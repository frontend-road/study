{"id":41440,"title":"10 |  递归：如何用三行代码找到“最终推荐人”？","content":"<p>推荐注册返佣金的这个功能我想你应该不陌生吧？现在很多App都有这个功能。这个功能中，用户A推荐用户B来注册，用户B又推荐了用户C来注册。我们可以说，用户C的“最终推荐人”为用户A，用户B的“最终推荐人”也为用户A，而用户A没有“最终推荐人”。</p><p>一般来说，我们会通过数据库来记录这种推荐关系。在数据库表中，我们可以记录两行数据，其中actor_id表示用户id，referrer_id表示推荐人id。</p><p><img src=\"https://static001.geekbang.org/resource/image/29/0e/2984d45578440e9a348144c70d124a0e.jpg?wh=1142*360\" alt=\"\"></p><p>基于这个背景，我的问题是，<strong><span class=\"orange\">给定一个用户ID，如何查找这个用户的“最终推荐人”？</span></strong> 带着这个问题，我们来学习今天的内容，递归（Recursion）！</p><h2>如何理解“递归”？</h2><p>从我自己学习数据结构和算法的经历来看，我个人觉得，有两个最难理解的知识点，一个是<strong>动态规划</strong>，另一个就是<strong>递归</strong>。</p><p>递归是一种应用非常广泛的算法（或者编程技巧）。之后我们要讲的很多数据结构和算法的编码实现都要用到递归，比如DFS深度优先搜索、前中后序二叉树遍历等等。所以，搞懂递归非常重要，否则，后面复杂一些的数据结构和算法学起来就会比较吃力。</p><p>不过，别看我说了这么多，递归本身可是一点儿都不“高冷”，咱们生活中就有很多用到递归的例子。</p><p>周末你带着女朋友去电影院看电影，女朋友问你，咱们现在坐在第几排啊？电影院里面太黑了，看不清，没法数，现在你怎么办？</p><!-- [[[read_end]]] --><p>别忘了你是程序员，这个可难不倒你，递归就开始排上用场了。于是你就问前面一排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到你前面的人告诉你他在哪一排，于是你就知道答案了。</p><p>这就是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。刚刚这个生活中的例子，我们用递推公式将它表示出来就是这样的：</p><pre><code>f(n)=f(n-1)+1 其中，f(1)=1\n</code></pre><p>f(n)表示你想知道自己在哪一排，f(n-1)表示前面一排所在的排数，f(1)=1表示第一排的人知道自己在第一排。有了这个递推公式，我们就可以很轻松地将它改为递归代码，如下：</p><pre><code>int f(int n) {\n  if (n == 1) return 1;\n  return f(n-1) + 1;\n}\n</code></pre><h2>递归需要满足的三个条件</h2><p>刚刚这个例子是非常典型的递归，那究竟什么样的问题可以用递归来解决呢？我总结了三个条件，只要同时满足以下三个条件，就可以用递归来解决。</p><p><strong>1.一个问题的解可以分解为几个子问题的解</strong></p><p>何为子问题？子问题就是数据规模更小的问题。比如，前面讲的电影院的例子，你要知道，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。</p><p><strong>2.这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</strong></p><p>比如电影院那个例子，你求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路，是一模一样的。</p><p><strong>3.存在递归终止条件</strong></p><p>把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。</p><p>还是电影院的例子，第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是f(1)=1，这就是递归的终止条件。</p><h2>如何编写递归代码？</h2><p>刚刚铺垫了这么多，现在我们来看，如何来写递归代码？我个人觉得，写递归代码最关键的是<strong>写出递推公式，找到终止条件</strong>，剩下将递推公式转化为代码就很简单了。</p><p>你先记住这个理论。我举一个例子，带你一步一步实现一个递归代码，帮你理解。</p><p>假如这里有n个台阶，每次你可以跨1个台阶或者2个台阶，请问走这n个台阶有多少种走法？如果有7个台阶，你可以2，2，2，1这样子上去，也可以1，2，1，1，2这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？</p><p>我们仔细想下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了1个台阶，另一类是第一步走了2个台阶。所以n个台阶的走法就等于先走1阶后，n-1个台阶的走法 加上先走2阶后，n-2个台阶的走法。用公式表示就是：</p><pre><code>f(n) = f(n-1)+f(n-2)\n</code></pre><p>有了递推公式，递归代码基本上就完成了一半。我们再来看下终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法。所以f(1)=1。这个递归终止条件足够吗？我们可以用n=2，n=3这样比较小的数试验一下。</p><p>n=2时，f(2)=f(1)+f(0)。如果递归终止条件只有一个f(1)=1，那f(2)就无法求解了。所以除了f(1)=1这一个递归终止条件外，还要有f(0)=1，表示走0个台阶有一种走法，不过这样子看起来就不符合正常的逻辑思维了。所以，我们可以把f(2)=2作为一种终止条件，表示走2个台阶，有两种走法，一步走完或者分两步来走。</p><p>所以，递归终止条件就是f(1)=1，f(2)=2。这个时候，你可以再拿n=3，n=4来验证一下，这个终止条件是否足够并且正确。</p><p>我们把递归终止条件和刚刚得到的递推公式放到一起就是这样的：</p><pre><code>f(1) = 1;\nf(2) = 2;\nf(n) = f(n-1)+f(n-2)\n</code></pre><p>有了这个公式，我们转化成递归代码就简单多了。最终的递归代码是这样的：</p><pre><code>int f(int n) {\n  if (n == 1) return 1;\n  if (n == 2) return 2;\n  return f(n-1) + f(n-2);\n}\n</code></pre><p>我总结一下，<strong><span class=\"orange\">写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码</span></strong>。</p><p>虽然我讲了这么多方法，但是作为初学者的你，现在是不是还是有种想不太清楚的感觉呢？实际上，我刚学递归的时候，也有这种感觉，这也是文章开头我说递归代码比较难理解的地方。</p><p>刚讲的电影院的例子，我们的递归调用只有一个分支，也就是说“一个问题只需要分解为一个子问题”，我们很容易能够想清楚“递”和“归”的每一个步骤，所以写起来、理解起来都不难。</p><p>但是，当我们面对的是一个问题要分解为多个子问题的情况，递归代码就没那么好理解了。</p><p>像我刚刚讲的第二个例子，人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。</p><p>计算机擅长做重复的事情，所以递归正合它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。</p><p>对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式应该是怎样的呢？</p><p>如果一个问题A可以分解为若干子问题B、C、D，你可以假设子问题B、C、D已经解决，在此基础上思考如何解决问题A。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</p><p>因此，<strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤</strong>。</p><h2>递归代码要警惕堆栈溢出</h2><p>在实际的软件开发中，编写递归代码时，我们会遇到很多问题，比如堆栈溢出。而堆栈溢出会造成系统性崩溃，后果会非常严重。为什么递归代码容易造成堆栈溢出呢？我们又该如何预防堆栈溢出呢？</p><p>我在“栈”那一节讲过，函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p><p>比如前面的讲到的电影院的例子，如果我们将系统栈或者JVM堆栈大小设置为1KB，在求解f(19999)时便会出现如下堆栈报错：</p><pre><code>Exception in thread &quot;main&quot; java.lang.StackOverflowError\n</code></pre><p>那么，如何避免出现堆栈溢出呢？</p><p>我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如1000）之后，我们就不继续往下再递归了，直接返回报错。还是电影院那个例子，我们可以改造成下面这样子，就可以避免堆栈溢出了。不过，我写的代码是伪代码，为了代码简洁，有些边界条件没有考虑，比如x&lt;=0。</p><pre><code>// 全局变量，表示递归的深度。\nint depth = 0;\n\nint f(int n) {\n  ++depth；\n  if (depth &gt; 1000) throw exception;\n  \n  if (n == 1) return 1;\n  return f(n-1) + 1;\n}\n</code></pre><p>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如10、50，就可以用这种方法，否则这种方法并不是很实用。</p><h2>递归代码要警惕重复计算</h2><p>除此之外，使用递归时还会出现重复计算的问题。刚才我讲的第二个递归代码的例子，如果我们把整个递归过程分解一下的话，那就是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/e7/bf/e7e778994e90265344f6ac9da39e01bf.jpg?wh=1142*837\" alt=\"\"></p><p>从图中，我们可以直观地看到，想要计算f(5)，需要先计算f(4)和f(3)，而计算f(4)还需要计算f(3)，因此，f(3)就被计算了很多次，这就是重复计算问题。</p><p>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的f(k)。当递归调用到f(k)时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。</p><p>按照上面的思路，我们来改造一下刚才的代码：</p><pre><code>public int f(int n) {\n  if (n == 1) return 1;\n  if (n == 2) return 2;\n  \n  // hasSolvedList可以理解成一个Map，key是n，value是f(n)\n  if (hasSolvedList.containsKey(n)) {\n    return hasSolvedList.get(n);\n  }\n  \n  int ret = f(n-1) + f(n-2);\n  hasSolvedList.put(n, ret);\n  return ret;\n}\n</code></pre><p>除了堆栈溢出、重复计算这两个常见的问题。递归代码还有很多别的问题。</p><p>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如我们前面讲到的电影院递归代码，空间复杂度并不是O(1)，而是O(n)。</p><h2>怎么将递归代码改写为非递归代码？</h2><p>我们刚说了，递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。</p><p>那我们是否可以把递归代码改写为非递归代码呢？比如刚才那个电影院的例子，我们抛开场景，只看f(x) =f(x-1)+1这个递推公式。我们这样改写看看：</p><pre><code>int f(int n) {\n  int ret = 1;\n  for (int i = 2; i &lt;= n; ++i) {\n    ret = ret + 1;\n  }\n  return ret;\n}\n</code></pre><p>同样，第二个例子也可以改为非递归的实现方式。</p><pre><code>int f(int n) {\n  if (n == 1) return 1;\n  if (n == 2) return 2;\n  \n  int ret = 0;\n  int pre = 2;\n  int prepre = 1;\n  for (int i = 3; i &lt;= n; ++i) {\n    ret = pre + prepre;\n    prepre = pre;\n    pre = ret;\n  }\n  return ret;\n}\n</code></pre><p>那是不是所有的递归代码都可以改为这种<strong>迭代循环</strong>的非递归写法呢？</p><p>笼统地讲，是的。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。</p><p>但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。</p><h2>解答开篇</h2><p>到此为止，递归相关的基础知识已经讲完了，咱们来看一下开篇的问题：如何找到“最终推荐人”？我的解决方案是这样的：</p><pre><code>long findRootReferrerId(long actorId) {\n  Long referrerId = select referrer_id from [table] where actor_id = actorId;\n  if (referrerId == null) return actorId;\n  return findRootReferrerId(referrerId);\n}\n</code></pre><p>是不是非常简洁？用三行代码就能搞定了，不过在实际项目中，上面的代码并不能工作，为什么呢？这里面有两个问题。</p><p>第一，如果递归很深，可能会有堆栈溢出的问题。</p><p>第二，如果数据库里存在脏数据，我们还需要处理由此产生的无限递归问题。比如demo环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果A的推荐人是B，B的推荐人是C，C的推荐人是A，这样就会发生死循环。</p><p>第一个问题，我前面已经解答过了，可以用限制递归深度来解决。第二个问题，也可以用限制递归深度来解决。不过，还有一个更高级的处理方法，就是自动检测A-B-C-A这种“环”的存在。如何来检测环的存在呢？这个我暂时不细说，你可以自己思考下，后面的章节我们还会讲。</p><h2>内容小结</h2><p>关于递归的知识，到这里就算全部讲完了。我来总结一下。</p><p>递归是一种非常高效、简洁的编码技巧。只要是满足“三个条件”的问题就可以通过递归代码来解决。</p><p>不过递归代码也比较难写、难理解。编写递归代码的关键就是不要把自己绕进去，正确姿势是写出递推公式，找出终止条件，然后再翻译成递归代码。</p><p>递归代码虽然简洁高效，但是，递归代码也有很多弊端。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码的时候，一定要控制好这些副作用。</p><h2>课后思考</h2><p>我们平时调试代码喜欢使用IDE的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，你有什么好的调试方法呢？</p><p>欢迎留言和我分享，我会第一时间给你反馈。</p>","neighbors":{"left":{"article_title":"09 | 队列：队列在线程池等有限资源池中的应用","id":41330},"right":{"article_title":"11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？","id":41802}},"comments":[{"had_liked":true,"id":31994,"user_name":"博金","can_delete":false,"product_type":"c1","uid":1173559,"ip_address":"","ucode":"86C2542E007E55","user_header":"https://static001.geekbang.org/account/avatar/00/11/e8/37/1ea4de97.jpg","comment_is_top":false,"comment_ctime":1539352389,"is_pvip":false,"replies":[{"id":"11595","content":"答案正确 大家可以把这一条顶上去","user_name":"作者回复","comment_id":31994,"uid":"1190123","ip_address":"","utype":1,"ctime":1539401629,"user_name_real":"gg"}],"discussion_count":26,"race_medal":0,"score":"11237173798725","product_id":100017301,"comment_content":"调试递归:<br>1.打印日志发现，递归值。<br>2.结合条件断点进行调试。","like_count":2617,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426601,"discussion_content":"答案正确 大家可以把这一条顶上去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539401629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1068326,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/26/44095eba.jpg","nickname":"贱贱的梦想","note":"","ucode":"A3F7AF23D193AF","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279763,"discussion_content":"秀，才知道有个条件断点","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1591411489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1243897,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/f9/f4ca4080.jpg","nickname":"高旭瑞","note":"","ucode":"284335282EE526","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264256,"discussion_content":"第一反应就是把值打印出来看看，我调试任何代码第一想法都是打印值看看。。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1589296295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75099,"discussion_content":"条件断点是个好东西","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1575722681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1664015,"avatar":"https://static001.geekbang.org/account/avatar/00/19/64/0f/12b1b224.jpg","nickname":"Mercury","note":"","ucode":"EE5ACA444C754C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":28333,"discussion_content":"能不能解释一下打印日志发现递归值👀","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1570691739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1655563,"avatar":"https://static001.geekbang.org/account/avatar/00/19/43/0b/25ff73e0.jpg","nickname":"许智鸿","note":"","ucode":"18E41503CC43C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1664015,"avatar":"https://static001.geekbang.org/account/avatar/00/19/64/0f/12b1b224.jpg","nickname":"Mercury","note":"","ucode":"EE5ACA444C754C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44044,"discussion_content":"我理解，简单的解释就是输出吧，每次递归的时候增加printf()，不知道这样理解对不对，但是这种方法很好用","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1572925466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":28333,"ip_address":""},"score":44044,"extra":""}]},{"author":{"id":1341031,"avatar":"","nickname":"OOO","note":"","ucode":"60BBF2C3CA7AEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370434,"discussion_content":"条件断点，真的学到了！谢谢 大佬","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619411430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1284647,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9a/27/4b81bce5.jpg","nickname":"笑","note":"","ucode":"C91EAFAB88E5AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319093,"discussion_content":"当然要用条件断点","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603941114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1608975,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8d/0f/52109316.jpg","nickname":"奋斗的小蜗牛","note":"","ucode":"268E01BD34C1AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221240,"discussion_content":"不懂啥是条件断点，百度一下懂了。看评论也能涨知识。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585993674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1b/a0/7c7d1b4a.jpg","nickname":"徐帅","note":"","ucode":"BDF904280E2330","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26953,"discussion_content":"太秀了，只想到第二个方法。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570625674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1655563,"avatar":"https://static001.geekbang.org/account/avatar/00/19/43/0b/25ff73e0.jpg","nickname":"许智鸿","note":"","ucode":"18E41503CC43C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1448864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1b/a0/7c7d1b4a.jpg","nickname":"徐帅","note":"","ucode":"BDF904280E2330","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44045,"discussion_content":"想问下，第二个方法是什么意思？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572925497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":26953,"ip_address":""},"score":44045,"extra":""},{"author":{"id":1078160,"avatar":"https://static001.geekbang.org/account/avatar/00/10/73/90/9118f46d.jpg","nickname":"chenhz","note":"","ucode":"485420EA3282D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1655563,"avatar":"https://static001.geekbang.org/account/avatar/00/19/43/0b/25ff73e0.jpg","nickname":"许智鸿","note":"","ucode":"18E41503CC43C2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66763,"discussion_content":"第二个方法描述比较精简，应该是“结合条件语句进行断点调试”","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575105345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":44045,"ip_address":""},"score":66763,"extra":""},{"author":{"id":1445106,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0c/f2/eff644f9.jpg","nickname":"Geek_f04d81","note":"","ucode":"ECD9F1BE0B2186","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1655563,"avatar":"https://static001.geekbang.org/account/avatar/00/19/43/0b/25ff73e0.jpg","nickname":"许智鸿","note":"","ucode":"18E41503CC43C2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303347,"discussion_content":"就是 给断点加上条件 符合条件才进入断点 但是用的多的还是打印","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599213739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":44045,"ip_address":""},"score":303347,"extra":""}]},{"author":{"id":1032345,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c0/99/259a412f.jpg","nickname":"Geeker","note":"","ucode":"9937127DE96D78","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7852,"discussion_content":"太秀了，本来想回答一下的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567691113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3202871,"avatar":"https://static001.geekbang.org/account/avatar/00/30/df/37/d715834f.jpg","nickname":"坡 Immortal","note":"","ucode":"2306E12D32D8F1","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591715,"discussion_content":"条件断点在vs怎么用？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666774800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1248375,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/77/d855bfb2.jpg","nickname":"Bupt_daydayup","note":"","ucode":"5E2BBE695288B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410908,"discussion_content":"还没用过&#34;条件断点&#34;，下次调试递归代码的时候注意学习一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635813749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2663781,"avatar":"","nickname":"叶成勇","note":"","ucode":"8D359ED202BE87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383512,"discussion_content":"条件短点试了一下，真的很nice，以后断点都不用逐个遍历了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626139287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2820632,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/0a/18/cdfd70ad.jpg","nickname":"LetMeCode","note":"","ucode":"AD6D729D42BB44","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2663781,"avatar":"","nickname":"叶成勇","note":"","ucode":"8D359ED202BE87","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414956,"discussion_content":"i==1是个布尔条件好用 但是怎么or判断。。我下意识写成sql了i==1 or i==2结果报错。这是java...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636944969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":383512,"ip_address":""},"score":414956,"extra":""}]},{"author":{"id":2617494,"avatar":"https://static001.geekbang.org/account/avatar/00/27/f0/96/cac3f00d.jpg","nickname":"风之恋","note":"","ucode":"C01DBEA69B10BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375659,"discussion_content":"请问Java eclipse怎么打印日志","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621787422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2343086,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c0/ae/e5e62510.jpg","nickname":"徐志超-Klaus","note":"","ucode":"CF26B39965F2A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331995,"discussion_content":"感谢你的第二条","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607042915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1848539,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/LqGZd83zp1y9fpbliaSgGh5qib5eGzU41xibTzib06ZAlaiaJibkJB89JuVEozCScUsVK90jpq7Na30AHDngQzI7YwiaA/132","nickname":"星朝","note":"","ucode":"DFCF2512D6DAE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305806,"discussion_content":"想到了第二种","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600089498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1916654,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/3e/ee/82c2ef12.jpg","nickname":"是海港呀","note":"","ucode":"32AD09DB7B1F3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216401,"discussion_content":"我想问下，递归和for循环的时间复杂度是一样的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585446250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1206787,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6a/03/cb597311.jpg","nickname":"远心","note":"","ucode":"1157202C315655","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1916654,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/3e/ee/82c2ef12.jpg","nickname":"是海港呀","note":"","ucode":"32AD09DB7B1F3B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294760,"discussion_content":"一样的，都是 O(n)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595990619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":216401,"ip_address":""},"score":294760,"extra":""}]},{"author":{"id":1088040,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9a/28/03613c22.jpg","nickname":"track6688","note":"","ucode":"0A9E893F8FD379","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189181,"discussion_content":"貌似不是递归，很多时候，我也是这样做的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582856549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1577856,"avatar":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","nickname":"L🚲🐱","note":"","ucode":"08A012739614DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50831,"discussion_content":"递归好抽象，看了三遍才看明白🙃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573778667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31850,"user_name":"刘強","can_delete":false,"product_type":"c1","uid":1035612,"ip_address":"","ucode":"B2E41BB894A727","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","comment_is_top":false,"comment_ctime":1539311111,"is_pvip":false,"discussion_count":39,"race_medal":0,"score":"3703801120263","product_id":100017301,"comment_content":"那个陷入思维误区的说法产生共鸣了，原来总以为自己脑容量不足，看来牛人也一样。","like_count":862,"discussions":[{"author":{"id":1243697,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/31/94adea35.jpg","nickname":"乐山","note":"","ucode":"C08D9C92A73536","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205649,"discussion_content":"实际上是因为脑内堆栈溢出","likes_number":68,"is_delete":false,"is_hidden":false,"ctime":1584328603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1809092,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9a/c4/7c49255a.jpg","nickname":"木对林三","note":"","ucode":"D31B48BB93D24B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1243697,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/31/94adea35.jpg","nickname":"乐山","note":"","ucode":"C08D9C92A73536","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215207,"discussion_content":"哈哈  而且做了一些很多重复运算","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1585301545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":205649,"ip_address":""},"score":215207,"extra":""},{"author":{"id":1178715,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fc/5b/4b92d745.jpg","nickname":"命中水","note":"","ucode":"2D4431A9CC67EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1243697,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/31/94adea35.jpg","nickname":"乐山","note":"","ucode":"C08D9C92A73536","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382272,"discussion_content":"被你逗笑了，牛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625494155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":205649,"ip_address":""},"score":382272,"extra":""}]},{"author":{"id":1154146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9c/62/f625b2bb.jpg","nickname":"酸葡萄","note":"","ucode":"9D059C4FB327C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":677,"discussion_content":"因为理解不了递归的详细流程，曾一度怀疑自己智商不适合做算法，现在跟自己和解了，：）","likes_number":53,"is_delete":false,"is_hidden":false,"ctime":1561952624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1717444,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/34/c4/08d9f349.jpg","nickname":"元","note":"","ucode":"4576E15018EEA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1154146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9c/62/f625b2bb.jpg","nickname":"酸葡萄","note":"","ucode":"9D059C4FB327C0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52956,"discussion_content":"对！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574098491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":677,"ip_address":""},"score":52956,"extra":""}]},{"author":{"id":1593762,"avatar":"https://static001.geekbang.org/account/avatar/00/18/51/a2/84e9efe2.jpg","nickname":"马祖晖","note":"","ucode":"7866916C8EF9DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58214,"discussion_content":"我因为这事还一直怀疑自己是弱智","likes_number":42,"is_delete":false,"is_hidden":false,"ctime":1574658899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132312,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","nickname":"o0oi1i","note":"","ucode":"D1F6AD4AAEAFBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240478,"discussion_content":"牛人意识到是陷入了思维误区而我们意识不到😭","likes_number":30,"is_delete":false,"is_hidden":false,"ctime":1587368041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1035612,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","nickname":"刘強","note":"","ucode":"B2E41BB894A727","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132312,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","nickname":"o0oi1i","note":"","ucode":"D1F6AD4AAEAFBE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240610,"discussion_content":"是了，这就是有人指点的好处。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587378965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":240478,"ip_address":""},"score":240610,"extra":""}]},{"author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261737,"discussion_content":"是的。终于能证明自己并不是真的傻了😄","likes_number":24,"is_delete":false,"is_hidden":false,"ctime":1589000439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1032345,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c0/99/259a412f.jpg","nickname":"Geeker","note":"","ucode":"9937127DE96D78","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7853,"discussion_content":"我的感受是：“学习技术，一定要抓大放小，逐步深入”","likes_number":21,"is_delete":false,"is_hidden":false,"ctime":1567691174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1633014,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ea/f6/47630b9f.jpg","nickname":"王琦","note":"","ucode":"A1D8D13B0B45C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10825,"discussion_content":"同样感受，怀疑自己智商不够 但又不愿意承认智商不够 更加想想明白；结果越想越糊涂","likes_number":18,"is_delete":false,"is_hidden":false,"ctime":1568311835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055859,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1c/73/223de7fd.jpg","nickname":"轰轰轰轰轰","note":"","ucode":"57CE765AAF1059","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":132387,"discussion_content":"同感！真的是对我来说全篇最动人的句子！拉下来发现很多同道中人！与自己和解！","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1578903482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1877814,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLHOZjqhVkWgXSFHWRFPm2n44xfGfWbz3niahKDw8F4iaQiblSIUanYg1VsEYgYlSJ3IWP7GWewPVNjg/132","nickname":"忘记了梦想","note":"","ucode":"A26C1B36566959","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1055859,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1c/73/223de7fd.jpg","nickname":"轰轰轰轰轰","note":"","ucode":"57CE765AAF1059","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212777,"discussion_content":"与自己和解，哈哈哈。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585014175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":132387,"ip_address":""},"score":212777,"extra":""}]},{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240454,"discussion_content":"想起了n年前老师教过的“汉诺塔”","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1587365515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1459806,"avatar":"https://static001.geekbang.org/account/avatar/00/16/46/5e/2da0d188.jpg","nickname":"Bifico","note":"","ucode":"AEA686D99F6652","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245739,"discussion_content":"这或许就是计算机思维，我们很难想象10后面10个0到到底有多大  但是计算机恰好可以。我们可以把苹果一切两半，但是无法想象切分50次的样子","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1587696475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2303268,"avatar":"https://static001.geekbang.org/account/avatar/00/23/25/24/6e9314c6.jpg","nickname":"Geek_zhang","note":"","ucode":"C5D727A37AA606","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323586,"discussion_content":"同感。现在猛然发现，这表达式高中的时候不就学过嘛，记得之前还有应用题就是列类似表达式求解。原来如此。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1604970988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1711363,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqiaEI7wXhKvaEfUbQOyMMXvHPwgOMlNO26wBNianWJTtibQwpDTDkmpJBlff2fHYwwbkEnMVB3ibuicIQ/132","nickname":"Jerry Wu","note":"","ucode":"85F9E5060A2A01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308804,"discussion_content":"10几层的数据规模已经相当可怕了，我觉得正常人应该在三层左右","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601086522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1801998,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/7f/0e/9659d08a.jpg","nickname":"交响","note":"","ucode":"113E777B59D4CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198241,"discussion_content":"加一，思考递归题时经常给自己绕糊涂","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583493038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2440848,"avatar":"https://static001.geekbang.org/account/avatar/00/25/3e/90/c86ec4ca.jpg","nickname":"XCF","note":"","ucode":"00A895B0B4CA3E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364519,"discussion_content":"对啊，就是这样，不是所有东西你都要一层一层全部理解透的，设定就是这样，最后反而把自己环进去了！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617507455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316937,"avatar":"https://static001.geekbang.org/account/avatar/00/14/18/49/b1d864e5.jpg","nickname":"Hinimix","note":"","ucode":"7994136C93BD89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236816,"discussion_content":"我写过好多递归了，但都是懵懵懂懂的，只是自我感觉是对的，原来真的不用细想啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587124553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1035612,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","nickname":"刘強","note":"","ucode":"B2E41BB894A727","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316937,"avatar":"https://static001.geekbang.org/account/avatar/00/14/18/49/b1d864e5.jpg","nickname":"Hinimix","note":"","ucode":"7994136C93BD89","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239349,"discussion_content":"是的，你只要知道你调用的这个函数能做什么就ok了，没必要再往下想了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587295533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":236816,"ip_address":""},"score":239349,"extra":""}]},{"author":{"id":1793911,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/yS2V9VvNbYpjsgDVd51Fh44GRaFoqY8AMGdpAKDnkYFnokcvwCmVCl8nib70jeCfI5IzQugPdBqjGfllHg0Eojg/132","nickname":"Geek_84bd08","note":"","ucode":"2B907ECB9CFB37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224550,"discussion_content":"原来大家都一样，我终于放心了哈哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586314840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1911733,"avatar":"","nickname":"且听风吟","note":"","ucode":"51549E28661CEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1793911,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/yS2V9VvNbYpjsgDVd51Fh44GRaFoqY8AMGdpAKDnkYFnokcvwCmVCl8nib70jeCfI5IzQugPdBqjGfllHg0Eojg/132","nickname":"Geek_84bd08","note":"","ucode":"2B907ECB9CFB37","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224772,"discussion_content":"看来大家都一样，我还以为自己是个傻子","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1586331286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":224550,"ip_address":""},"score":224772,"extra":""},{"author":{"id":2014573,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","nickname":"SharpBB","note":"","ucode":"D30C5B798B8E8C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1911733,"avatar":"","nickname":"且听风吟","note":"","ucode":"51549E28661CEF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281935,"discussion_content":"同感 越发觉得自己是猪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591844323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":224772,"ip_address":""},"score":281935,"extra":""}]},{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":173331,"discussion_content":"看到递归就会不自觉的用脑子想一层一层递归,每次最多10几层,就想的头炸了.不想了.哈哈!","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581848112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1035612,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","nickname":"刘強","note":"","ucode":"B2E41BB894A727","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":174054,"discussion_content":"哈哈，一般语言里的递归还是可以想想的。函数式语言里的递归，能搞死人。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581868346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":173331,"ip_address":""},"score":174054,"extra":""},{"author":{"id":1920722,"avatar":"","nickname":"Geek_crazycatmax","note":"","ucode":"5419044F6EA0E3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1035612,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","nickname":"刘強","note":"","ucode":"B2E41BB894A727","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213497,"discussion_content":"同感同感，高阶函数多套几层，脑子就溢出了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585099220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":174054,"ip_address":""},"score":213497,"extra":""},{"author":{"id":1911733,"avatar":"","nickname":"且听风吟","note":"","ucode":"51549E28661CEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":224773,"discussion_content":"牛批，我到第五层就吐了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586331320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":173331,"ip_address":""},"score":224773,"extra":""}]},{"author":{"id":2850617,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/7f/39/9fe8397c.jpg","nickname":"年轻人°","note":"","ucode":"3A2B6DABECD402","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554978,"discussion_content":"哈哈 每次递归都会把自己绕进去 , 一轮递归掉一根头发 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646707429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016749,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/83/ad/d3cb8dc5.jpg","nickname":"怪物猎人5.0","note":"","ucode":"3B29051AD1F477","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552958,"discussion_content":"人脑调试，你得换个内存条，哈哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645668075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1335112,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5f/48/6b871a71.jpg","nickname":"阿日日","note":"","ucode":"80C0BE4B04708E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400938,"discussion_content":"我也是，大学的时候学数据结构还找了个本子画汉罗塔，去理解。结果奔溃，没有学下去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633493151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2803405,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoIdvpZmFpm19dI5wjC4OFHMMu4qHyEJmMcso5AoX3IKdxcr3iaBzL0CxVXC69B3DibLoJ9KOVA7L9w/132","nickname":"Geek_ec1f24","note":"","ucode":"E0B4B6E855E74D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1335112,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5f/48/6b871a71.jpg","nickname":"阿日日","note":"","ucode":"80C0BE4B04708E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541966,"discussion_content":"做过同样的事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640614804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":400938,"ip_address":""},"score":541966,"extra":""}]},{"author":{"id":2223791,"avatar":"https://static001.geekbang.org/account/avatar/00/21/ee/af/bb84441d.jpg","nickname":"旗袍不开、怎么得胜？","note":"","ucode":"27351FE057C9A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392176,"discussion_content":"像汉诺塔问题，刚开始看了半天人都傻了。。\n后来才知道，递归细节不重要，重要的是过程和终止。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630889244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":132423,"discussion_content":"加一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578907273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1232210,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cd/52/a2478536.jpg","nickname":"敲键盘的人","note":"","ucode":"59AFFFE9DA5B4E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":131432,"discussion_content":"看来我们的大脑结构还是比较容易更大广度上的知识，对于更深的知识总是感觉心有余力不足。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578839881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359127,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqlqI5gE1MuPtKj6TgRBdoRnK2rKK3pGyVjkMia2431JVSgr0O4ScrqLoLe0T3mH8s6G04qtdk6zNg/132","nickname":"InfoQ_339e6b2a10f3","note":"","ucode":"B374F4812603FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":107789,"discussion_content":"加一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577607633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020637,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/dd/abb7bfe3.jpg","nickname":"realxz","note":"","ucode":"4B40FC3E89A2A9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76942,"discussion_content":"同感","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575870724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1733223,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/72/67/2921a72e.jpg","nickname":"兰多","note":"","ucode":"ABEE3B99088FDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74832,"discussion_content":"加一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575693106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":31790,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1539304605,"is_pvip":true,"replies":[{"id":"11476","content":"哈哈😄","user_name":"作者回复","comment_id":31790,"uid":"1190123","ip_address":"","utype":1,"ctime":1539310268,"user_name_real":"gg"}],"discussion_count":23,"race_medal":1,"score":"1749590994077","product_id":100017301,"comment_content":"哈哈，在电影院看是第几排，我直接看电影票，直接用索引找到了","like_count":407,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426508,"discussion_content":"哈哈😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539310268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1749095,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b0/67/80bba74a.jpg","nickname":"心定神明","note":"","ucode":"D3C15BD8DFA3F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204126,"discussion_content":"不是啊，不是因为天黑，找不到你坐的那一排在哪吗？","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1584114584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066276,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/24/bcf5fb99.jpg","nickname":"kOlapapa","note":"","ucode":"64640421EFFE23","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62086,"discussion_content":"秀 你坐下","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1574816662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1633316,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ec/24/6bceb24c.jpg","nickname":"孝孝孝孝孝康","note":"","ucode":"0B475582C30D25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368456,"discussion_content":"好家伙，面向用例编程。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1618718285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234281,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d5/69/d1f2f7c8.jpg","nickname":"罗洪州 IT","note":"","ucode":"3688313E7D010A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304399,"discussion_content":"我会问女朋友，女朋友不会就让她出去","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1599564913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1062997,"avatar":"https://static001.geekbang.org/account/avatar/00/10/38/55/a719a520.jpg","nickname":"Marshal丶","note":"","ucode":"15A3EB0F06E42C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1234281,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d5/69/d1f2f7c8.jpg","nickname":"罗洪州 IT","note":"","ucode":"3688313E7D010A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306718,"discussion_content":"我怀疑你没有女朋友","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600355032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304399,"ip_address":""},"score":306718,"extra":""}]},{"author":{"id":1234660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d6/e4/919022b0.jpg","nickname":"企鹅","note":"","ucode":"D36ACD640D97B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289934,"discussion_content":"可是现在的情况是：你知道自己是哪一排，但是太黑，看不清哪一排是你要的那一排。所以才引出老师说的询问的问题。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1594274568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234919,"avatar":"","nickname":"奥佛铎","note":"","ucode":"A1D544E5F22B7F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297838,"discussion_content":"座位上那么大字都看不见，电影票上小字更看不见了呀=。=","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597070229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1763208,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e7/88/c8b4ad9c.jpg","nickname":"没有昵称","note":"","ucode":"565783BDD01CE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210824,"discussion_content":"我只有知道第几排才能传入参数，传入参数后又计算出我在第几排","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1584779274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1486718,"avatar":"https://static001.geekbang.org/account/avatar/00/16/af/7e/1a1c57fe.jpg","nickname":"从小威武","note":"","ucode":"1593700F98DF40","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":22072,"discussion_content":"额  那还是不知道自己在哪一排😥","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1569574518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1448864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1b/a0/7c7d1b4a.jpg","nickname":"徐帅","note":"","ucode":"BDF904280E2330","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1486718,"avatar":"https://static001.geekbang.org/account/avatar/00/16/af/7e/1a1c57fe.jpg","nickname":"从小威武","note":"","ucode":"1593700F98DF40","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":26958,"discussion_content":"秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570625800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":22072,"ip_address":""},"score":26958,"extra":""}]},{"author":{"id":1120025,"avatar":"https://static001.geekbang.org/account/avatar/00/11/17/19/46fcde38.jpg","nickname":"yonyoupht","note":"","ucode":"9B3AC96150B8AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307229,"discussion_content":"秀儿","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600562031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1380312,"avatar":"https://static001.geekbang.org/account/avatar/00/15/0f/d8/9286b272.jpg","nickname":"leetcode","note":"","ucode":"3B8C3668A0DE74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224774,"discussion_content":"鬼才网友 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586331358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":132424,"discussion_content":"你坐下、","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578907290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2344034,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c4/62/269aae3f.jpg","nickname":"水月","note":"","ucode":"78FC68615016DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536753,"discussion_content":"以前去过这个电影院，直接查缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638861726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2028944,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/90/2caa07d0.jpg","nickname":"Geek8815","note":"","ucode":"D5102AFFA20E7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384955,"discussion_content":"陈独秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626832455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1459806,"avatar":"https://static001.geekbang.org/account/avatar/00/16/46/5e/2da0d188.jpg","nickname":"Bifico","note":"","ucode":"AEA686D99F6652","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245744,"discussion_content":"为什么我会选择从头往后数，因为数字有限，但是当数据无限的时候我立马放弃，我会问别人或者。。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587696551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1710042,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/17/da/5807a239.jpg","nickname":"ellen","note":"","ucode":"66A5BE083A8ADD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186528,"discussion_content":"时间复杂度O(1)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582688770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1338088,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6a/e8/4bb87c34.jpg","nickname":"月马穿关","note":"","ucode":"2CE20CA1EB827D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128495,"discussion_content":"这个网友不简单？！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578644197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179601,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/d1/28adb620.jpg","nickname":"蒙奇•D•273°","note":"","ucode":"5570919A507386","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104051,"discussion_content":"就你P","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577410459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1450371,"avatar":"https://static001.geekbang.org/account/avatar/00/16/21/83/53bbcfd9.jpg","nickname":"AL","note":"","ucode":"60FF57319D99AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86959,"discussion_content":"我也是，从文科转过来，经常掉进坑里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576634252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053084,"avatar":"https://static001.geekbang.org/account/avatar/00/10/11/9c/4fd6ebe0.jpg","nickname":"白了少年头","note":"","ucode":"A65E00E05B23BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21310,"discussion_content":"秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569465888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1564431,"avatar":"https://static001.geekbang.org/account/avatar/00/17/df/0f/0c483c62.jpg","nickname":"黑夜的骑士","note":"","ucode":"1351B67A3D2C3F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1984,"discussion_content":"用的是数组的思想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563161571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31881,"user_name":"姜威","can_delete":false,"product_type":"c1","uid":1244051,"ip_address":"","ucode":"C58EB9A5AD634D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg","comment_is_top":false,"comment_ctime":1539319487,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"1345864083135","product_id":100017301,"comment_content":"总结<br><br>一、什么是递归？<br><br>1.递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。<br>2.方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。<br>3.基本上，所有的递归问题都可以用递推公式来表示，比如<br>f(n) = f(n-1) + 1; <br>f(n) = f(n-1) + f(n-2);<br>f(n)=n*f(n-1);<br><br>二、为什么使用递归？递归的优缺点？<br><br>1.优点：代码的表达力很强，写起来简洁。<br>2.缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。<br><br>三、什么样的问题可以用递归解决呢？<br><br>一个问题只要同时满足以下3个条件，就可以用递归来解决：<br>1.问题的解可以分解为几个子问题的解。何为子问题？就是数据规模更小的问题。<br>2.问题与子问题，除了数据规模不同，求解思路完全一样<br>3.存在递归终止条件<br><br>四、如何实现递归？<br><br>1.递归代码编写<br>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。<br>2.递归代码理解<br>对于递归代码，若试图想清楚整个递和归的过程，实际上是进入了一个思维误区。<br>那该如何理解递归代码呢？如果一个问题A可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。<br>因此，理解递归代码，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。<br><br>五、递归常见问题及解决方案<br><br>1.警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。<br>2.警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。<br><br>六、如何将递归改写为非递归代码？<br><br>笼统的讲，所有的递归代码都可以改写为迭代循环的非递归写法。如何做？抽象出递推公式、初始值和边界条件，然后用迭代循环实现。","like_count":313,"discussions":[{"author":{"id":1754897,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/c7/11/ed02ee23.jpg","nickname":"小安a~🐯","note":"","ucode":"46861B89E281C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70649,"discussion_content":"每次都是你","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575374951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1643418,"avatar":"https://static001.geekbang.org/account/avatar/00/19/13/9a/eedb98f1.jpg","nickname":"柒","note":"","ucode":"171E98D28CC47A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19556,"discussion_content":"课代表终于出现了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1569206322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179601,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/d1/28adb620.jpg","nickname":"蒙奇•D•273°","note":"","ucode":"5570919A507386","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104057,"discussion_content":"总结的不错，不过递归的执行效率不高","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577410632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1520567,"avatar":"https://static001.geekbang.org/account/avatar/00/17/33/b7/966e8ac0.jpg","nickname":"ysir","note":"","ucode":"A25AF79EE1B63A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334530,"discussion_content":"这思维方式很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607871854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205697,"avatar":"https://static001.geekbang.org/account/avatar/00/12/65/c1/afcd981b.jpg","nickname":"程序员二师兄","note":"","ucode":"C9E3B5B3358BDF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280584,"discussion_content":"总结的很好，优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591574688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201101,"avatar":"https://static001.geekbang.org/account/avatar/00/12/53/cd/e344985b.jpg","nickname":"TopTop","note":"","ucode":"FFC8CAC662A83B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":248215,"discussion_content":"还是要自己总结下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587858578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65871,"discussion_content":"可以的，姜威 同学","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575032866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1350425,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9b/19/41dbba8c.jpg","nickname":"破晓","note":"","ucode":"1162E00FF08DF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43484,"discussion_content":"赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572877315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4400,"discussion_content":"谢谢！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565362023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31993,"user_name":"范柏柏","can_delete":false,"product_type":"c1","uid":1130596,"ip_address":"","ucode":"942D1784D42349","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/64/a4058693.jpg","comment_is_top":false,"comment_ctime":1539352342,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"955022092054","product_id":100017301,"comment_content":"希望老师多分享一些经典习题。比如链表那一章课后所说的，掌握这几道题就基本掌握了链表。","like_count":222,"discussions":[{"author":{"id":1677187,"avatar":"https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg","nickname":"Allen_","note":"","ucode":"CA5E00E4644CD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73209,"discussion_content":"自己leetcode上刷不就好了，老师领进门，修行靠个人","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1575555443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":32012,"user_name":"柠檬C","can_delete":false,"product_type":"c1","uid":1181505,"ip_address":"","ucode":"BC0EE704D952A4","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/41/2d477385.jpg","comment_is_top":false,"comment_ctime":1539358910,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"594244845758","product_id":100017301,"comment_content":"递归和数学归纳法非常像，所以可以利用数学归纳法的思路，先验证边界条件，再假设n-1的情况正确，思考n和n-1的关系写出递推公式","like_count":138,"discussions":[{"author":{"id":1062286,"avatar":"https://static001.geekbang.org/account/avatar/00/10/35/8e/529de449.jpg","nickname":"王睿","note":"","ucode":"E9F86285B4848C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23144,"discussion_content":"离开学校之后才发现高等数学是真的有用，大学本科就两门课最有用，一个是高等数学（包括线性代数与概率论），另外一个就是马克思政治与经济。分别是自然领域与人类社会的真理啊","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1569759930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1158349,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ac/cd/fda6374f.jpg","nickname":"Louis","note":"","ucode":"BC667839F17937","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1062286,"avatar":"https://static001.geekbang.org/account/avatar/00/10/35/8e/529de449.jpg","nickname":"王睿","note":"","ucode":"E9F86285B4848C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35447,"discussion_content":"数学归纳高中就学了啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571281174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":23144,"ip_address":""},"score":35447,"extra":""}]},{"author":{"id":2145095,"avatar":"https://static001.geekbang.org/account/avatar/00/20/bb/47/b60ae3eb.jpg","nickname":"你好，阳光","note":"","ucode":"1A2F487C57F7D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376487,"discussion_content":"递归是一种自顶向下的思路，和数学归纳法还是有一些区别，我觉得和根据递推方程迭代的思路更像。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622163501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1512738,"avatar":"https://static001.geekbang.org/account/avatar/00/17/15/22/4f836e60.jpg","nickname":"family~¥","note":"","ucode":"565B895476FBD2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573620,"discussion_content":"这个我很赞同。确实很像数学归纳法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653551541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055475,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","nickname":"iLeGeND","note":"","ucode":"4055A628A6E97C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551529,"discussion_content":"归纳法是递推吧？和递归相反","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645058424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298223,"discussion_content":"我感觉递归和数学归纳法还是不像的，数学归纳法并没有递和归的过程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597222064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162728,"discussion_content":"数学归纳还要证明n=1时是正确的，对应递归数终止条件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581003046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65854,"discussion_content":"em 上面的递归举例就是 高中数学的普通函数罢了。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575032138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31804,"user_name":"涛","can_delete":false,"product_type":"c1","uid":1245815,"ip_address":"","ucode":"555B9877F6AA4D","user_header":"https://static001.geekbang.org/account/avatar/00/13/02/77/f307372e.jpg","comment_is_top":false,"comment_ctime":1539305618,"is_pvip":false,"replies":[{"id":"11472","content":"👍","user_name":"作者回复","comment_id":31804,"uid":"1190123","ip_address":"","utype":1,"ctime":1539310128,"user_name_real":"gg"}],"discussion_count":3,"race_medal":0,"score":"478280675474","product_id":100017301,"comment_content":"终于在认知层面得到了提升，递归是什么，在我看来递归就是用栈的数据结构，加上一个简单的逻辑算法实现了业务功能。","like_count":111,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426513,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539310128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2267068,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ0QPgslVlxQ9NveDBskHopZXZiaGJEaqYGyEPkACeRQzRAOyCyYOibmIHRDacTfhh4F8M8ec0ibbF5w/132","nickname":"Geek_68ac2a","note":"","ucode":"8ED76443981410","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340094,"discussion_content":"递归应该是用栈这种数据结构的算法吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609902011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65855,"discussion_content":"后进先出，可以这么理解，大数n的func 用上面的n-1 n-2等来求解，其实就是 数学函数公式。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575032243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":31998,"user_name":"mj","can_delete":false,"product_type":"c1","uid":1251983,"ip_address":"","ucode":"A20AEAB7C6BCBA","user_header":"","comment_is_top":false,"comment_ctime":1539353512,"is_pvip":false,"replies":[{"id":"11596","content":"你理解的也对","user_name":"作者回复","comment_id":31998,"uid":"1190123","ip_address":"","utype":1,"ctime":1539401644,"user_name_real":"gg"}],"discussion_count":11,"race_medal":0,"score":"379496475560","product_id":100017301,"comment_content":"我对台阶问题的理解是:到达n阶只可能来自n-1和n-2,所以f(n)=f(n-1)+f(n-2)","like_count":88,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426603,"discussion_content":"你理解的也对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539401644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1206187,"avatar":"https://static001.geekbang.org/account/avatar/00/12/67/ab/fcf0cec4.jpg","nickname":"寒光","note":"","ucode":"061BE413595F21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218215,"discussion_content":"从最终的结果往前推，是最好理解的，点赞（｡ò ∀ ó｡）","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1585631227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1717444,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/34/c4/08d9f349.jpg","nickname":"元","note":"","ucode":"4576E15018EEA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52957,"discussion_content":"我记得书上这么讲解的","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1574098630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1140470,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/f6/d67377a4.jpg","nickname":"强","note":"","ucode":"468F2B19550A2D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4794,"discussion_content":"嗯，我也是这么理解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565744802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2069061,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/92/45/fd65c320.jpg","nickname":"十二","note":"","ucode":"465C1A14EDA261","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590942,"discussion_content":"你这个角度牛逼，茅塞顿开。是的，要么从 n-1个台阶上去， 要么从n-2个台阶上去。无他。牛逼牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666178949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1650748,"avatar":"https://static001.geekbang.org/account/avatar/00/19/30/3c/0668d6ae.jpg","nickname":"盘胧","note":"","ucode":"5386CC4C92ECC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384164,"discussion_content":"你这样才是比较好理解且正确的。 最后一步只有这两种情况的情况下，去考虑递归。老师那种，有一点点会让我们陷入误区~。 你就假设进行到了最后一步了有返回了，接下来该写啥代码就写啥。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626408003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2163901,"avatar":"","nickname":"livy","note":"","ucode":"04D639A75886E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318994,"discussion_content":"感谢，我就没理解这个，这个角度真不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603897310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2103645,"avatar":"","nickname":"DWong","note":"","ucode":"2E7F567C228EE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302494,"discussion_content":"争哥这种从下往上推 有点像动态规划 的思路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598935089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294558,"discussion_content":"这个思路瞬间点醒了我，赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595927622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1991279,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/62/6f/06d476f7.jpg","nickname":"Geek_Akara","note":"","ucode":"E86A5A9EEC8BFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265613,"discussion_content":"最后那个递归改写后是不是就是这个逻辑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589420711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65859,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575032365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31823,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1539307223,"is_pvip":false,"replies":[{"id":"11494","content":"你这种办法可行的 👍。实际情况 内存也不会耗太多","user_name":"作者回复","comment_id":31823,"uid":"1190123","ip_address":"","utype":1,"ctime":1539311129,"user_name_real":"gg"}],"discussion_count":15,"race_medal":0,"score":"366611527383","product_id":100017301,"comment_content":"检测环可以构造一个set集合或者散列表(下面都叫散列表吧，为了方便)。每次获取到上层推荐人就去散列表里先查，没有查到的话就加入，如果存在则表示存在环了。当然，每一次查询都是一个自己的散列表，不能共用。不过这样请求量大的话，会不会造成内存空间开辟太多？这里老师能帮忙解答一下吗？","like_count":85,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426524,"discussion_content":"你这种办法可行的 👍。实际情况 内存也不会耗太多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539311129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504776,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f6/08/ecf5d724.jpg","nickname":"Enthusiasm","note":"","ucode":"FEAA522C24A6D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269889,"discussion_content":"可以拿到A-B-C...的hash码,遍历时进行异或运算,靠异或值是否是0,如果出现&#34;环&#34;结构,那么异或值会变成0.","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1589958725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1504776,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f6/08/ecf5d724.jpg","nickname":"Enthusiasm","note":"","ucode":"FEAA522C24A6D5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312798,"discussion_content":"好办法。我只想到了散列表检查地址值。如果再要求，环节点在哪里？散列表和快慢指针好使。还有其他办法吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602819533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":269889,"ip_address":""},"score":312798,"extra":""},{"author":{"id":2626287,"avatar":"https://static001.geekbang.org/account/avatar/00/28/12/ef/cb0b57ec.jpg","nickname":"苏杭天下","note":"","ucode":"C6080021BA450F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1504776,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f6/08/ecf5d724.jpg","nickname":"Enthusiasm","note":"","ucode":"FEAA522C24A6D5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377226,"discussion_content":"如果是A^B^C^B^C这样的循环，异或也没法把A约了呀，出现不了0,总不能每次都遍历3个hash码吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622554398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":269889,"ip_address":""},"score":377226,"extra":""}]},{"author":{"id":1398853,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/45/721545cc.jpg","nickname":"成辉","note":"","ucode":"4E2DD20D989D57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545812,"discussion_content":"快慢指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642057250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1229631,"avatar":"","nickname":"Geek_20519a","note":"","ucode":"3D9EF44B9CACF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414544,"discussion_content":"我的想法也是用map存储，如果出现过，就说明存在环","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636809702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2712220,"avatar":"","nickname":"april","note":"","ucode":"9D83FD8B487C85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385503,"discussion_content":"除了不能是上层推荐人,还不能是最初被推荐人.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627101091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70136,"discussion_content":"一样的想法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575331419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1680692,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/OtshR2GDmbBcOG84Mp8aSgmp1Q1cPNI0yp6RRBH0vLViaV5paLQib2iaRj9NQ9xsibSM8WPpehr5Yel1aunyS1lVjA/132","nickname":"Geek_aee891","note":"","ucode":"523A95DA892963","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34335,"discussion_content":"就像检测链表是否有环的思路一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571193711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1680692,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/OtshR2GDmbBcOG84Mp8aSgmp1Q1cPNI0yp6RRBH0vLViaV5paLQib2iaRj9NQ9xsibSM8WPpehr5Yel1aunyS1lVjA/132","nickname":"Geek_aee891","note":"","ucode":"523A95DA892963","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63962,"discussion_content":"其实最好的方式还是在表里加一个字段，记录最终推荐人","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574926126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":34335,"ip_address":""},"score":63962,"extra":""},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1680692,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/OtshR2GDmbBcOG84Mp8aSgmp1Q1cPNI0yp6RRBH0vLViaV5paLQib2iaRj9NQ9xsibSM8WPpehr5Yel1aunyS1lVjA/132","nickname":"Geek_aee891","note":"","ucode":"523A95DA892963","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162735,"discussion_content":"可以的，两条sql，第一条查上层推荐人，第二条查上上层推荐人，死循环判断两个结果，其中一个结果为空则退出，无环；两个结果相等则退出，有环。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1581003398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":34335,"ip_address":""},"score":162735,"extra":""},{"author":{"id":1019961,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/39/abb7bfe3.jpg","nickname":"孙国林","note":"","ucode":"53C891890403C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189387,"discussion_content":"最终推荐人很可能是个动态的值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582875302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":63962,"ip_address":""},"score":189387,"extra":""}]}]},{"had_liked":false,"id":39705,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1542337821,"is_pvip":false,"discussion_count":11,"race_medal":0,"score":"220585669917","product_id":100017301,"comment_content":"关于走楼梯的思路解析：<br>1 走到第1级，有1种方法 ，直接走1<br><br>2 走到第2级，有2种方法 （1,1）（2）总共两种走法<br><br>3 走到第3级，有3种方法 （1,1,1）（1,2）（2,1）总共3种走法<br><br>4 走到第4级，有5种方法  （1,1,1,1）（1,1,2）（1,2,1）（2,1,1）（2,2） 总共5种<br><br>5 走到第5级，有8种方法   依次类推<br><br>以此类推，后面的总等于前面两级方法之和，现在使用递归和递推两种方法解决本问题","like_count":51,"discussions":[{"author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":241199,"discussion_content":"看完一直没懂第二种非递归方式的实现，现在我懂了啊哈哈，原来一二级爬楼梯就是斐波拉契数列，秒啊！","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1587396026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1748785,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/af/31/d3a75c95.jpg","nickname":"Geek_4437ed","note":"","ucode":"2DB9750F7A931C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":97181,"discussion_content":"这个意思是把规律总结出来然后用代码实现哈，我开始一直也没想明白，怎么能这么计算。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577107980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1284647,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9a/27/4b81bce5.jpg","nickname":"笑","note":"","ucode":"C91EAFAB88E5AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319096,"discussion_content":"牛逼！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603941366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1732780,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","nickname":"面向百度编程","note":"","ucode":"8FE04A019D71D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200781,"discussion_content":"我想知道，万一我没有这样去找规律呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583721597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238800,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e7/10/3ad7d556.jpg","nickname":"traveling","note":"","ucode":"A325458B2934C5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65287,"discussion_content":"开始一直不明白这个公式是怎么来的，感谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574993580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1711838,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/1e/de/cdee1780.jpg","nickname":"我是内存","note":"","ucode":"3D763D4F434D50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46560,"discussion_content":"为啥后面的走法是前面两级走法之和？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573181705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1248730,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0d/da/906dce6a.jpg","nickname":"sudo","note":"","ucode":"1936F782F914D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1711838,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/1e/de/cdee1780.jpg","nickname":"我是内存","note":"","ucode":"3D763D4F434D50","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53813,"discussion_content":"其实就是一个 斐波那契数列 你搜一下就知道了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574220916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":46560,"ip_address":""},"score":53813,"extra":""},{"author":{"id":1025093,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a4/45/3cb5cdc6.jpg","nickname":"拾迹","note":"","ucode":"38F367B77FF2D7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1711838,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/1e/de/cdee1780.jpg","nickname":"我是内存","note":"","ucode":"3D763D4F434D50","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":180677,"discussion_content":"因为一次只能走 1 步或者 2 步，所以最后肯定要么是走 1 步过来的，要么是走 2 步过来的。所以要走到 n，就是走到n-1或者n-2","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582298608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":46560,"ip_address":""},"score":180677,"extra":""},{"author":{"id":1244031,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fb/7f/5da88fb5.jpg","nickname":"小锅","note":"","ucode":"A1D46851246755","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1025093,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a4/45/3cb5cdc6.jpg","nickname":"拾迹","note":"","ucode":"38F367B77FF2D7","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":213203,"discussion_content":"这种思维可能有人一开始很难接受，但是仔细想一下，你如果要走到n个台阶，那你最后的方式是到n-1这个台阶，或到n-2这个台阶才有可能实现这么个过程，也就是说到第n-1个台阶的方法和到第n-2个台阶的所有方法都适用于到第n个台阶，哈哈哈～","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1585058979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":180677,"ip_address":""},"score":213203,"extra":""}]}]},{"had_liked":false,"id":31797,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1539305049,"is_pvip":true,"discussion_count":1,"race_medal":1,"score":"216287669849","product_id":100017301,"comment_content":"说的对的，每次写递归代码，或者看递归代码，都会不自觉的在大脑中复现整个递和归的过程","like_count":50,"discussions":[{"author":{"id":2915218,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/7b/92/ce884691.jpg","nickname":"云水禅心🌓","note":"","ucode":"1B0782009BC5B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551783,"discussion_content":"克服惯性思维，主动去总结规律","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645110273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":31772,"user_name":"Geek_8a2f3f","can_delete":false,"product_type":"c1","uid":1136829,"ip_address":"","ucode":"940BEE99DE158B","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/bd/bcc27593.jpg","comment_is_top":false,"comment_ctime":1539303365,"is_pvip":false,"replies":[{"id":"11484","content":"自己模拟一个栈 用非递归代码实现","user_name":"作者回复","comment_id":31772,"uid":"1190123","ip_address":"","utype":1,"ctime":1539310492,"user_name_real":"gg"}],"discussion_count":5,"race_medal":0,"score":"194812831685","product_id":100017301,"comment_content":"王老师，你好！说那个限制递归深度的做法只适合规模比较小的情况，那如果规模大了，怎么限制呢？","like_count":45,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426502,"discussion_content":"自己模拟一个栈 用非递归代码实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539310492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65862,"discussion_content":"循环迭代，不会栈溢出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575032494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3891,"discussion_content":"老师文稿中已有答案，采用迭代算法。迭代和递归","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564930049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2050135,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/48/57/f81acea8.jpg","nickname":"航","note":"","ucode":"FFAE304D6D4AD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288739,"discussion_content":"那老师不是说 这种递归改迭代的手法是“思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。”","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593855936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3891,"ip_address":""},"score":288739,"extra":""},{"author":{"id":2599641,"avatar":"","nickname":"Geek_180","note":"","ucode":"E92908F53640D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2050135,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/48/57/f81acea8.jpg","nickname":"航","note":"","ucode":"FFAE304D6D4AD6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377660,"discussion_content":"对的 我也想问这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622768223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":288739,"ip_address":""},"score":377660,"extra":""}]}]},{"had_liked":true,"id":31821,"user_name":"L","can_delete":false,"product_type":"c1","uid":1237556,"ip_address":"","ucode":"0BDC32D02DB267","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/34/0c2c1200.jpg","comment_is_top":false,"comment_ctime":1539307114,"is_pvip":false,"replies":[{"id":"11463","content":"是的 👍","user_name":"作者回复","comment_id":31821,"uid":"1190123","ip_address":"","utype":1,"ctime":1539309690,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"160453097066","product_id":100017301,"comment_content":"解答楼上的问题，数据规模较大的情况用循环，也就是老师讲的非递归代码","like_count":37,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426523,"discussion_content":"是的 👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539309690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31781,"user_name":"zl","can_delete":false,"product_type":"c1","uid":1122670,"ip_address":"","ucode":"53B414119349D0","user_header":"https://static001.geekbang.org/account/avatar/00/11/21/6e/c0b47405.jpg","comment_is_top":false,"comment_ctime":1539304152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"151863159512","product_id":100017301,"comment_content":"Debug不行就打日志","like_count":35},{"had_liked":false,"id":31739,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1539274428,"is_pvip":false,"replies":[{"id":"11495","content":"因为后面的内容会用到递归 而递归不依赖后面的内容 拓扑排序了解一下😄","user_name":"作者回复","comment_id":31739,"uid":"1190123","ip_address":"","utype":1,"ctime":1539311226,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"147568162492","product_id":100017301,"comment_content":"原以为老师会先讲完10个基本的数据结构再讲十种基本的算法。没想到老师会穿插着讲。冒昧的问下老师设计课程的思路。谢谢","like_count":34,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426487,"discussion_content":"因为后面的内容会用到递归 而递归不依赖后面的内容 拓扑排序了解一下😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539311226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":31783,"user_name":"mobo","can_delete":false,"product_type":"c1","uid":1243630,"ip_address":"","ucode":"195170E57B471B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/ee/1bbc2676.jpg","comment_is_top":false,"comment_ctime":1539304360,"is_pvip":false,"replies":[{"id":"11477","content":"github上艘wangzheng0822","user_name":"作者回复","comment_id":31783,"uid":"1190123","ip_address":"","utype":1,"ctime":1539310291,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"121798388648","product_id":100017301,"comment_content":"老师好，你的github地址可以发下吗？我在前面的章节没看到","like_count":28,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426506,"discussion_content":"github上艘wangzheng0822","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539310291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1716067,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/2f/63/7a048d46.jpg","nickname":"梨子苹果","note":"","ucode":"3666813FEE31D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53066,"discussion_content":"点赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574128560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":35021,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1105431,"ip_address":"","ucode":"B1F8AE3AD82C51","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg","comment_is_top":false,"comment_ctime":1540383259,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"113209532955","product_id":100017301,"comment_content":"我常用的办法是，打印一个树型结构的日志，每进入一层，深度加一然后打印深度，比如“--”，再接上值，换行，这样可以很清楚的看到信息","like_count":26,"discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162740,"discussion_content":"缩进","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581003575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35427,"user_name":"塘泥","can_delete":false,"product_type":"c1","uid":1236244,"ip_address":"","ucode":"14BBE1BED75A41","user_header":"https://static001.geekbang.org/account/avatar/00/12/dd/14/7d5799d1.jpg","comment_is_top":false,"comment_ctime":1540558707,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"108914741107","product_id":100017301,"comment_content":"尾递归的问题，想听听老师的讲解","like_count":25},{"had_liked":false,"id":31775,"user_name":"adapt","can_delete":false,"product_type":"c1","uid":1237547,"ip_address":"","ucode":"A26DA1AF84A785","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/2b/3483d165.jpg","comment_is_top":false,"comment_ctime":1539303547,"is_pvip":false,"replies":[{"id":"11482","content":"那例子就换成男朋友吧😄","user_name":"作者回复","comment_id":31775,"uid":"1190123","ip_address":"","utype":1,"ctime":1539310439,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"96028584059","product_id":100017301,"comment_content":"程序员哪来的女朋友😅😂","like_count":22,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426503,"discussion_content":"那例子就换成男朋友吧😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539310439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31752,"user_name":"风起","can_delete":false,"product_type":"c1","uid":1031600,"ip_address":"","ucode":"3DCEBF4D115081","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bd/b0/e587220b.jpg","comment_is_top":false,"comment_ctime":1539278072,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"87438623992","product_id":100017301,"comment_content":"调试递归就像写递归一样，<br>不要被每一步的细节所困，<br>重点在于确认递推关系与结束条件是否正确，<br>用条件断点着重调试最初两步与最终两步即可。","like_count":20},{"had_liked":false,"id":46630,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1543966609,"is_pvip":false,"replies":[{"id":"16663","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543973949,"ip_address":"","comment_id":46630,"utype":1}],"discussion_count":3,"race_medal":0,"score":"78853377937","product_id":100017301,"comment_content":"把该讲内容总结为几个问题, 大家复习的时候可以先尝试回答这些问题检查自己的掌握程度:<br>\t1. <br>递归需要满足的三个条件是什么?<br>\t2. <br>写好递推代码的关键着手点是什么? 如何避免被一层层的逻辑绕进去?<br>\t3. <br>写递推代码是如何避免堆栈溢出?<br>\t4. <br>写递推代码如何避免重复计算?<br><br>","like_count":18,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431495,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543973949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2832351,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/37/df/d49eab02.jpg","nickname":"拉布拉多、谁都能摸","note":"","ucode":"F4E4FDDFA0CCF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411495,"discussion_content":"可恨不能收藏评论，哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635941066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008016,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/61/90/de8c61a0.jpg","nickname":"dongge","note":"","ucode":"CEFE4D0CC42907","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9951,"discussion_content":"写的好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568250980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110853,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1562378550,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"65986887990","product_id":100017301,"comment_content":"“编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤”<br><br>看完这句话，整个世界都安静了，终于可以与自己和解了……","like_count":15,"discussions":[{"author":{"id":1490036,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/74/01e32a0d.jpg","nickname":"小肉仙","note":"","ucode":"1048D421CC5CC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":415063,"discussion_content":"同感","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636978424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1926508,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/65/6c/be97a3ae.jpg","nickname":"Geek_bb2310","note":"","ucode":"022885B257DEB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260050,"discussion_content":"嗯嗯\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588844185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31979,"user_name":"aof","can_delete":false,"product_type":"c1","uid":1062864,"ip_address":"","ucode":"5815D63C4926BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","comment_is_top":false,"comment_ctime":1539348173,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"61668890317","product_id":100017301,"comment_content":"检测环的答案其实老师已经在文章中的一个例子中讲过了，就是用一个数据结构把查询过的元素放到这个数据结构里面，新来的就先查这个数据结构里面有没有，有就返回，没有就放入到这个数据结构里面。","like_count":14,"discussions":[{"author":{"id":1744250,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9d/7a/fb762fea.jpg","nickname":"SkillIP","note":"","ucode":"60EAEB93EC6858","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218195,"discussion_content":"这样空间复杂度就比较高，可以用双指针，这样空间复杂度为O(1)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585629841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31939,"user_name":"微秒","can_delete":false,"product_type":"c1","uid":1249195,"ip_address":"","ucode":"65A2E8B565B191","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/ab/9748f40b.jpg","comment_is_top":false,"comment_ctime":1539334937,"is_pvip":false,"replies":[{"id":"11611","content":"你可以网上搜下斐波那契数列的代码实现","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539403492,"ip_address":"","comment_id":31939,"utype":1}],"discussion_count":4,"race_medal":0,"score":"61668877081","product_id":100017301,"comment_content":"不是很懂第二个例子非递归的实现方式是什么意思，可以讲的清楚一点吗？","like_count":14,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426573,"discussion_content":"你可以网上搜下斐波那契数列的代码实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539403492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1114093,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/ed/b2fc0e7c.jpg","nickname":"7","note":"","ucode":"10A6E57A027D42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232476,"discussion_content":"如果用n表示台阶的级数，a n表示走到第n级台阶时，所有可能不同的走法，容易得到：\n①当n=1时，显然只要1种跨法，即a1=1；\n②当n=2时，可以一步一级跨，也可以一步跨二级上楼，\n因此，共有2种不同的跨法，即a2=2；\n\n③当n=3时分两种情况讨论：\n如果第一步跨一个台阶，还剩下两级台阶，由②可知有a2=2种走法\n如果第一步跨二个台阶，还剩下一级台阶，由①可知有a1=1种走法\n\n④当n=4的时候，也分两种情况讨论：\n如果第一步跨一个台阶，还剩下三级台阶，由③可知有a3种走法\n如果第一步跨二个台阶，还剩下两级台阶，由②可知有a2种走法\n\n所以有以下公式\na3=a2+a1\n类推，有a4=a3+a2\na5=a4+a3\n.......\n根据规则就算出f(n) = f(n-1)+f(n-2)","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1586870854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1909502,"avatar":"","nickname":"晴空一鹤","note":"","ucode":"95940CDE56A2FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552133,"discussion_content":"递归是从n -&gt; 1的向下方向, 非递归就是从1 -&gt; n 的向上方向，将pre当作f(2), prepre当作f(1),向上推导","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645313986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1428043,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ca/4b/c1ace3aa.jpg","nickname":"蚝不鱿鱼","note":"","ucode":"5DB98E406F1D3E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249500,"discussion_content":"难道递归就是我分解当前问题的时候，发现可以用之前分解出来的子问题来直接解决就可以停在来了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587944772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33685,"user_name":"知易","can_delete":false,"product_type":"c1","uid":1246882,"ip_address":"","ucode":"BD3E3F0F0A40EF","user_header":"https://static001.geekbang.org/account/avatar/00/13/06/a2/350c4af0.jpg","comment_is_top":false,"comment_ctime":1539852973,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"53079460525","product_id":100017301,"comment_content":"还好开发基本不会遇到电影院这种问题，，不然写个函数发现入参就是递归最终值也是蛮尴尬的。。","like_count":12,"discussions":[{"author":{"id":1299347,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d3/93/c3fb8566.jpg","nickname":"ProcessIsTheKey","note":"","ucode":"BE02EFD75F7D98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552044,"discussion_content":"这个我也想了一会儿，但是电影院这个问题比较特殊，本例子中电影院的第一排的牌号默认为了排号1，而且直接相邻的后一排的排号是当前排排号+1.实际业务场景中，电影院的第一排的牌号可能是5，可能是-7，可能是B3，等等之类的，排号规则也不一定是+1；所以入参就是递归终值也是巧合了...不知道我理解的对不对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645253177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1026390,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a9/56/315c5be7.jpg","nickname":"青鸟","note":"","ucode":"A4818C5C0C688D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535950,"discussion_content":"没错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638616730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1617369,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/FqWrN8aNrlXEfo2YeDeCRuWMZ57VzsNC0aibkEIdiaNBdUVPjlBXrg9F4Eb8uMFYckuSgmXQ49vT6SHoicAjeEGdA/132","nickname":"Geek_558387","note":"","ucode":"2EA857EBC365B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3154,"discussion_content":"哈哈哈哈  说到点上了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564229408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32643,"user_name":"bro.","can_delete":false,"product_type":"c1","uid":1124948,"ip_address":"","ucode":"D65283CD869804","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/54/c9990105.jpg","comment_is_top":false,"comment_ctime":1539655949,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"53079263501","product_id":100017301,"comment_content":"判断环的思路,使用链表:判断是否有环:使用步长法判断: 思路,从起点开始分别以2x,1x速度出发两个指针,当遇到null停止,相遇点为null时说明没有环,如果相遇点不为null,说明有环,注意有两个地方:<br>1.首次相遇点速度为1的指针是进入环的第一圈,切记切记<br>      证明一下呗:  设 圆环总长为: R , 指针分别设置为 1, 2吧,当1指针首次进入圆环交点时,2指针在圆环位置为 x ,则 2-&gt;1 步长为 (R - x)<br>      此时开始走i步以后相遇则: (R - x) + i = 2i; (原来相距位置加上1走的距离等于 2倍的1走距离)<br>      则 i = R - x ; (X &lt;= R) 的,所以 i &lt; R (肯定在第一圈相遇)<br>     由上可得:<br>      在第一圈相遇的时候1走的距离为: 设 起始点至环入口位置为 L ,则 1路程为(L + i)<br>      2走的距离为 (L + nR + i) ,n为圈数<br>      则: (L + nR + i) = 2(L + i); (切记:n &gt;= 1  -&gt; 2比1先进圈)(2速度为1的2倍,1的总路程 * 2)<br>      即: L = nR - i = (n - 1)R + (R - i) ; (n &gt;= 1) 我们不管(n - 1)R,只是简单的绕圈数<br>      所以 L = R - i ; 而首次进入圈相遇的位置为 i ,整个圈长为 R ,<br>      所以当首次相遇的时候,重新以1为步长,一个以相交点为起始,一个以首节点开始,首次相遇点即为环的起始点;","like_count":12,"discussions":[{"author":{"id":2626287,"avatar":"https://static001.geekbang.org/account/avatar/00/28/12/ef/cb0b57ec.jpg","nickname":"苏杭天下","note":"","ucode":"C6080021BA450F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377231,"discussion_content":"感觉这里的相遇在上面递归代码里就是出现相同数字的意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622555438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2626287,"avatar":"https://static001.geekbang.org/account/avatar/00/28/12/ef/cb0b57ec.jpg","nickname":"苏杭天下","note":"","ucode":"C6080021BA450F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377229,"discussion_content":"大佬，请教一下。这种链表判断环的方法怎么跟上面的递归联系起来。尤其是咋代码实现，实在不会怎么把递归想象成环形链表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622555114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162762,"discussion_content":"佛洛依德法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581004072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114644,"user_name":"之城","can_delete":false,"product_type":"c1","uid":1252519,"ip_address":"","ucode":"12451253E366A2","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/a7/6a837523.jpg","comment_is_top":false,"comment_ctime":1563355744,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44513028704","product_id":100017301,"comment_content":"太高兴了，刚刚学完避免重复计算。通过hash map存以前计算过的结果。就想起来以前自己写的一个代码可能会重复计算，然后就去优化了一下，果真存在重复计算问题。终于学以致用了！感谢","like_count":10},{"had_liked":false,"id":35652,"user_name":"","can_delete":false,"product_type":"c1","uid":1119000,"ip_address":"","ucode":"B440EC07B93B7E","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/18/029a8804.jpg","comment_is_top":false,"comment_ctime":1540729813,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"44490402773","product_id":100017301,"comment_content":"走楼梯的问题用递推来写的话就是利用递归思想里面的“归”。<br>已知公式：f(n)=f(n-1)+f(n-2)<br>对公式按递推的方式来理解就是：走到当前台阶的走法数是当走到当前台阶前一个台阶的走法数加上走到当前台阶前两个台阶走法数。<br>已知f(1)=1；f(2)=2<br>f1=1;<br>f2=2;<br>ret = 0<br>for(int i=3;i&lt;n;i++)<br>{<br>    ret = f1 + f2;<br>    f1 = f2;<br>    f2 = ret;<br>}<br>return ret;<br><br>就像斐波那契数列一样。","like_count":10,"discussions":[{"author":{"id":1451006,"avatar":"https://static001.geekbang.org/account/avatar/00/16/23/fe/0c3b2613.jpg","nickname":"Hinker Liu","note":"","ucode":"CC50097B62B6DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":100589,"discussion_content":"通项公式和斐波那契数列是相同的，只是初始条件有点不同：1,1,2,3,5和1,2,3,5。如果设定第零步是1，就完全相同了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577271526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31836,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1539309309,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"44488982269","product_id":100017301,"comment_content":"## 界定问题能否用递归解决<br>1. 一个问题的解可以分解为几个子问题的解；<br>2. 这个问题与分解子问题的求解思路完全相同； <br>3. 存在终止条件<br><br>## 编写递归代码的技巧<br>1. 终止条件<br>2. 递推公式<br>3. 清理现场<br><br>编写递归的关键是思考终止条件，把问题抽象成一个递推公式，并信任它一定能帮我们完成任务，不用想一层层的调用关系，试图用人脑分解递归是反人类的，最多只能想两三层。<br><br>## 递归的缺点<br>递归会利用栈保存临时变量，如果递归过深，会造成栈溢出。解决方案是控制递归的深度。<br><br>递归要警惕重复计算，递归分解的子问题、子子问题可能存在相同的情况，如果都一一计算的话，就会发生重复计算。解决方案是使用散列表来保存结算结果，每次开始计算前检查散列表是否已经有结算结果。<br><br>笼统地讲，递归代码都能用迭代循环来替换。<br><br><br>免费加入知识星球「极客星球」讨论算法问题。<br>","like_count":10,"discussions":[{"author":{"id":1698258,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIx7FdRzUuQf4Fopr7DOXEHZyCFfH4GQViaqo7bymf1qaANcOvuEhHyTNwOOUFW7psxEeSQ5k9uXWw/132","nickname":"阿顺","note":"","ucode":"36F2AD6F980B11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37988,"discussion_content":"搜不到这个星球呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571710456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32210,"user_name":"秋天，不远了","can_delete":false,"product_type":"c1","uid":1238476,"ip_address":"","ucode":"C4FEA43BA69EBE","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/cc/49e74854.jpg","comment_is_top":false,"comment_ctime":1539484919,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31604255991","product_id":100017301,"comment_content":"哈哈，我就是文中说的那种人，写递归时要一步一步地想清楚，调试的时候用ide一步一步看清！！！","like_count":7},{"had_liked":false,"id":32032,"user_name":"晚风·和煦","can_delete":false,"product_type":"c1","uid":1236047,"ip_address":"","ucode":"0B1DB8F437A4B2","user_header":"","comment_is_top":false,"comment_ctime":1539393936,"is_pvip":false,"replies":[{"id":"11772","content":"这个话题有点大，不过我个人觉得语言都只是工具。学起来应该不难，重要的是多练、多实践、多做项目。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539530007,"ip_address":"","comment_id":32032,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31604165008","product_id":100017301,"comment_content":"老师您好，一名有过其他语言学习的学生，在您看来应该如何系统的学好一门语言。","like_count":7,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426617,"discussion_content":"这个话题有点大，不过我个人觉得语言都只是工具。学起来应该不难，重要的是多练、多实践、多做项目。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539530007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31827,"user_name":"Max","can_delete":false,"product_type":"c1","uid":1004825,"ip_address":"","ucode":"B0B928CF0D6AFF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/19/673d0a17.jpg","comment_is_top":false,"comment_ctime":1539307619,"is_pvip":false,"replies":[{"id":"11493","content":"f（n-1）和f（n-2）","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539310989,"ip_address":"","comment_id":31827,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31604078691","product_id":100017301,"comment_content":"pre和prepre代表的什么？","like_count":7,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426528,"discussion_content":"f（n-1）和f（n-2）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539310989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32097,"user_name":"崇拜","can_delete":false,"product_type":"c1","uid":1254953,"ip_address":"","ucode":"8EC2C04ACB638B","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/29/352d1ce6.jpg","comment_is_top":false,"comment_ctime":1539413793,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27309217569","product_id":100017301,"comment_content":"首先你得有一个女朋友才能解决看电影问题","like_count":6,"discussions":[{"author":{"id":1334015,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5a/ff/e89eb122.jpg","nickname":"LipLipLip","note":"","ucode":"6D5EC6B5BEC600","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369993,"discussion_content":"你是真的皮","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619242418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1926508,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/65/6c/be97a3ae.jpg","nickname":"Geek_bb2310","note":"","ucode":"022885B257DEB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260049,"discussion_content":"哈哈\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588844097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31841,"user_name":"Jessie","can_delete":false,"product_type":"c1","uid":1241378,"ip_address":"","ucode":"50FB29A445D371","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/22/d842d9c8.jpg","comment_is_top":false,"comment_ctime":1539310040,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"27309113816","product_id":100017301,"comment_content":"n=4,<br>f(n)=f(n-1)+f(n-2);<br>所以, <br>f(4)=f(3)+f(2)<br>     =f(2)+f(1)+f(2)<br>     =2+1+2=5<br>4个台阶，变5个台阶了，请问以上推理哪里出问题了？","like_count":6,"discussions":[{"author":{"id":1121003,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1a/eb/de2ccd58.jpg","nickname":"wxm","note":"","ucode":"82ABA5DFDF7142","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310,"discussion_content":"推理没问题，不过不是5个台阶，是5种走法","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1561442151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1909502,"avatar":"","nickname":"晴空一鹤","note":"","ucode":"95940CDE56A2FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552134,"discussion_content":"你这个疑问倒是解决了我的疑问，原来最开始我是把台阶数和走法数弄混了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645314323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1192932,"avatar":"https://static001.geekbang.org/account/avatar/00/12/33/e4/0d85d2bc.jpg","nickname":"Allany","note":"","ucode":"2181E93F708DC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38037,"discussion_content":"四个 台阶，五种走法  没毛病哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571715957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":96815,"user_name":"haha蟹","can_delete":false,"product_type":"c1","uid":1239445,"ip_address":"","ucode":"E833270AA83D1E","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/95/90bc14bd.jpg","comment_is_top":false,"comment_ctime":1558514002,"is_pvip":false,"replies":[{"id":"34670","content":"栈溢出，哈哈。如果非得扣字眼的话，堆栈溢出包含堆空间溢出、栈空间溢出。这里说的堆跟数据结构中的堆没啥关系，更多的是指内存空间。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1558568702,"ip_address":"","comment_id":96815,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23033350482","product_id":100017301,"comment_content":"小争哥不知道您还是否在关注这个课程的问题，我还是尝试问一下：<br>递归代码容易出现&quot;堆栈溢出&quot;，这个所谓的&quot;堆栈溢出&quot;就是StackOverflow，事实上就是&quot;栈溢出&quot;，和堆并没有什么关系是吗？我很困惑这里为什么翻译成&quot;堆栈溢出&quot;，而且很容易和我们数据结构里的堆混淆。可以给解释下吗以帮助我理清这里的概念。","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451024,"discussion_content":"栈溢出，哈哈。如果非得扣字眼的话，堆栈溢出包含堆空间溢出、栈空间溢出。这里说的堆跟数据结构中的堆没啥关系，更多的是指内存空间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558568702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35572,"user_name":"无星","can_delete":false,"product_type":"c1","uid":1248039,"ip_address":"","ucode":"F19F3F6D54EAC4","user_header":"https://static001.geekbang.org/account/avatar/00/13/0b/27/e67b238d.jpg","comment_is_top":false,"comment_ctime":1540682416,"is_pvip":false,"replies":[{"id":"12707","content":"哈哈 后面会讲的 ","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540777826,"ip_address":"","comment_id":35572,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23015518896","product_id":100017301,"comment_content":"动态规划？大事化小，小事化了","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427579,"discussion_content":"哈哈 后面会讲的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540777826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1667439,"avatar":"https://static001.geekbang.org/account/avatar/00/19/71/6f/07e1452a.jpg","nickname":"微尘","note":"","ucode":"F9CB2CEE9F19B9","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588443,"discussion_content":"递归+记忆化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663762355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32319,"user_name":"oldman","can_delete":false,"product_type":"c1","uid":1133711,"ip_address":"","ucode":"6BACE2832B4429","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/8f/a90b3969.jpg","comment_is_top":false,"comment_ctime":1539529204,"is_pvip":false,"replies":[{"id":"11884","content":"多看几遍 上网搜搜","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539615542,"ip_address":"","comment_id":32319,"utype":1}],"discussion_count":3,"race_medal":0,"score":"23014365684","product_id":100017301,"comment_content":"跨楼梯的例子好像并没有看懂","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426725,"discussion_content":"多看几遍 上网搜搜","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539615542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1322726,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2e/e6/10f59372.jpg","nickname":"Steven Dai","note":"","ucode":"833CA869D0B2A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5657,"discussion_content":"当你想上到第n阶台阶的时候，只有两种办法：你站在第n-1阶台阶上，一步上去；你站在第n-2阶台阶上一步上去。那你到达第n-1阶台阶有f(n-1)种方法，到达n-2阶台阶有f(n-2)种方法，所以f(n)=f(n-1)+f(n-2)","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1566406777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101465,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/99/4382727b.jpg","nickname":"sayid","note":"","ucode":"E40E0D86768DCA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301582,"discussion_content":"你站在第n-1阶台阶上，一步上去；你站在第n-2阶台阶上一步上去。这句看懂了；\n那你到达第n-1阶台阶有f(n-1)种方法，到达n-2阶台阶有f(n-2)种方法 这句没看懂；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598580565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31966,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1539344812,"is_pvip":false,"replies":[{"id":"11587","content":"在排序和树那两节课会讲两种递归代码的时间复杂度分析方法","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539401516,"ip_address":"","comment_id":31966,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23014181292","product_id":100017301,"comment_content":"老师，递归算法的时间复杂度，请给我们像前面章节那样分析分析。","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426584,"discussion_content":"在排序和树那两节课会讲两种递归代码的时间复杂度分析方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539401516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31862,"user_name":"汪木木","can_delete":false,"product_type":"c1","uid":1095399,"ip_address":"","ucode":"A2B1EFCBBB7387","user_header":"https://static001.geekbang.org/account/avatar/00/10/b6/e7/6d49e73f.jpg","comment_is_top":false,"comment_ctime":1539314268,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23014150748","product_id":100017301,"comment_content":"递推公式+边界条件","like_count":5},{"had_liked":false,"id":91899,"user_name":"Shawn","can_delete":false,"product_type":"c1","uid":1014729,"ip_address":"","ucode":"B95D7B54465DE4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/c9/75c9002e.jpg","comment_is_top":false,"comment_ctime":1557130524,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"18736999708","product_id":100017301,"comment_content":"没思考一次递归，发迹线都后移","like_count":4,"discussions":[{"author":{"id":2636178,"avatar":"https://static001.geekbang.org/account/avatar/00/28/39/92/88ed94f2.jpg","nickname":"YX","note":"","ucode":"CC108CCE845EAE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409784,"discussion_content":"清朝阿哥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635511217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1442605,"avatar":"https://static001.geekbang.org/account/avatar/00/16/03/2d/404627dc.jpg","nickname":"Anryg Zhun","note":"","ucode":"76DF8560BA9D14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209189,"discussion_content":"没事 去植个发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584618141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116188,"avatar":"https://static001.geekbang.org/account/avatar/00/11/08/1c/ef15e661.jpg","nickname":" 臣馟飞扬","note":"","ucode":"F2F882B7678055","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53054,"discussion_content":"扎心","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574127834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31950,"user_name":"leo","can_delete":false,"product_type":"c1","uid":1107385,"ip_address":"","ucode":"0A3D3508398328","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLhicDSmL4vicPF4mF9g5icORERwDSqZv5Guk0TyhiacuBsiaVxCdktI6oCrKzcycwFlpyL6Q1nDbvJZzA/132","comment_is_top":false,"comment_ctime":1539340743,"is_pvip":false,"replies":[{"id":"11585","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539401478,"ip_address":"","comment_id":31950,"utype":1}],"discussion_count":4,"race_medal":0,"score":"18719209927","product_id":100017301,"comment_content":"利用老师讲的方法分析下汉诺塔问题：<br>有a、b、c三个柱子，a柱子上从小到大码放n个盘子<br>要将盘子从a移动到c，依然从小到大码放<br>移动期间小盘子不能放到大盘子下面<br><br>1.问题拆分子问题<br>如果要将n个盘子从from柱借助assist柱移动到to柱，需要分三步<br>第一步：将第n个盘子上面的n-1个盘子（即n上面的盘子）从from柱子借助to柱移动到assist柱<br>第二步：将第n个盘子从from柱移动到to柱<br>第三步：将之前在assist柱子上面的n-1盘在从assist柱借助from柱移动到to柱<br><br>2.公式<br>move(n, from, to, assist)=<br>move(n-1, from, assist, to)<br>move n 从 from 到 to<br>move(n-1, assist, to, from)<br><br>3.终止条件<br>当只剩下一个盘子时，只需要将这个盘子从from柱移动到to柱<br><br>代码如下（Golang）：<br>func Hanoi(n uint) {<br>\tif n == 0 {<br>\t\treturn<br>\t}<br>\tmove(n, &quot;a&quot;, &quot;c&quot;, &quot;b&quot;)<br>}<br><br>func move(num uint, from, to, assist string) {<br>\tif num == 1 {<br>\t\tfmt.Printf(&quot;move %+v from %+v to %+v\\n&quot;, 1, from, to)<br>\t\treturn<br>\t}<br>\tmove(num-1, from, assist, to)<br>\tfmt.Printf(&quot;move %+v from %+v to %+v\\n&quot;, num, from, to)<br>\tmove(num-1, assist, to, from)<br>}","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426577,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539401478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2016408,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c4/98/9c7a1a23.jpg","nickname":"罗杰.菲の樂","note":"","ucode":"63590706846EEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":552560,"discussion_content":"def move(n: int, frm: str, buffer: str, to: str):\n    if n==1:\n        print(&#39;Move&#39;,n,&#39;from&#39;,frm,&#39;to&#39;,to)\n    else:\n        move(n-1,frm,to,buffer)\n        move(1,frm,buffer,to)\n        move(n-1,buffer,frm,to)\n\nmove(3, &#34;a&#34;, &#34;b&#34;, &#34;c&#34;)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645512235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":426577,"ip_address":""},"score":552560,"extra":""}]},{"author":{"id":2016408,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c4/98/9c7a1a23.jpg","nickname":"罗杰.菲の樂","note":"","ucode":"63590706846EEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552559,"discussion_content":"发一下pythoncode\ndef move(n: int, frm: str, buffer: str, to: str):\n    if n==1:\n        print(&#39;Move&#39;,n,&#39;from&#39;,frm,&#39;to&#39;,to)\n    else:\n        move(n-1,frm,to,buffer)\n        move(1,frm,buffer,to)\n        move(n-1,buffer,frm,to)\n\nmove(3, &#34;a&#34;, &#34;b&#34;, &#34;c&#34;)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645512228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1631982,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLDCC4yia65GicuukzgdZv34Zib2tXcfuBhkG3iaYBzJJRWQRPBLysR95WRD6RBibQfwHQvyDyP8fHAhkrA/132","nickname":"Geek_8a7668","note":"","ucode":"BBDBE125345CF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6245,"discussion_content":"太牛逼了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566809937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31909,"user_name":"靑城","can_delete":false,"product_type":"c1","uid":1242064,"ip_address":"","ucode":"ADE48AF334558B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f3/d0/8727aa8e.jpg","comment_is_top":false,"comment_ctime":1539327761,"is_pvip":false,"replies":[{"id":"11601","content":"正确","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539402318,"ip_address":"","comment_id":31909,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18719196945","product_id":100017301,"comment_content":"前面那个银行利息问题的，大概可以这样写递归？<br>#include&lt;iostream&gt;<br>using namespace std;<br>double money(double benjin,double rates,int year){<br>\tif(year&lt;1) return benjin;<br>\tbenjin=money(benjin,rates,year-1)*(1+rates);<br>\treturn benjin;<br>}<br>int main(){<br>\tdouble benjin=10;<br>\tdouble rates=0.5;<br>\tcout&lt;&lt;money(10,0.05,5);<br>\treturn 0;<br>} ","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426560,"discussion_content":"正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539402318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160238,"user_name":"Carlisle","can_delete":false,"product_type":"c1","uid":1701478,"ip_address":"","ucode":"B4625A7D9526BF","user_header":"https://static001.geekbang.org/account/avatar/00/19/f6/66/daba6e09.jpg","comment_is_top":false,"comment_ctime":1575897611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14460799499","product_id":100017301,"comment_content":"我更喜欢把递归结构分为4部分：<br>f(n){<br>&#47;&#47;终止条件<br>if(flag){<br>return finalResult;<br>}<br>&#47;&#47;递<br>temp = f(n-1);<br>&#47;&#47;实际处理<br>result = handle(temp);<br>&#47;&#47;归<br>return result;<br>}<br>老师讲解的时候直接 return handle(temp)，所以少了一步。当递归的处理步骤较多的话，这样会更清晰一些。上一节链表翻转的题目就可以用递归的方法试一下。","like_count":3},{"had_liked":false,"id":136546,"user_name":"厚积薄发","can_delete":false,"product_type":"c1","uid":1657999,"ip_address":"","ucode":"6FE711F65C8C66","user_header":"https://static001.geekbang.org/account/avatar/00/19/4c/8f/83eefcff.jpg","comment_is_top":false,"comment_ctime":1569468673,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14454370561","product_id":100017301,"comment_content":"难点：如何找到递推公式，看似大问题分解成小问题、找到终止条件，实践中还是有点难","like_count":3,"discussions":[{"author":{"id":1019809,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8f/a1/a7bd84e5.jpg","nickname":"Lee","note":"","ucode":"5D4223C38DD936","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":193164,"discussion_content":"同感 递推公式 有什么好的思路可以 找到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583132939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116188,"avatar":"https://static001.geekbang.org/account/avatar/00/11/08/1c/ef15e661.jpg","nickname":" 臣馟飞扬","note":"","ucode":"F2F882B7678055","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53047,"discussion_content":"是的，大道理都懂，但是还是感觉递归代码很难写啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574127413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99592,"user_name":"朱龙凯","can_delete":false,"product_type":"c1","uid":1554935,"ip_address":"","ucode":"C43E968179521B","user_header":"https://static001.geekbang.org/account/avatar/00/17/b9/f7/43311858.jpg","comment_is_top":false,"comment_ctime":1559264292,"is_pvip":false,"replies":[{"id":"35859","content":"你可以看下这篇文章：<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;Ki3WN2AJ5HhxxmaQ0lVh3Q","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559352455,"ip_address":"","comment_id":99592,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14444166180","product_id":100017301,"comment_content":"老师可否详细介绍一下如何将递归调用转化为非递归代码","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452181,"discussion_content":"你可以看下这篇文章：\nhttps://mp.weixin.qq.com/s/Ki3WN2AJ5HhxxmaQ0lVh3Q","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559352455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1815602,"avatar":"","nickname":"Geek_f00f16","note":"","ucode":"3ECF4A8A93BFCB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":574313,"discussion_content":"该文章已被删除","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653966767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":452181,"ip_address":""},"score":574313,"extra":""}]},{"author":{"id":1113864,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/08/7c18d8a4.jpg","nickname":"团","note":"","ucode":"D56ABBCE4E4D90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549522,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644052387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":62705,"user_name":"水手","can_delete":false,"product_type":"c1","uid":1336430,"ip_address":"","ucode":"536BB54E1E3617","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/6e/e5ecc1d2.jpg","comment_is_top":false,"comment_ctime":1548138586,"is_pvip":false,"replies":[{"id":"24181","content":"你写的是对的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550480120,"ip_address":"","comment_id":62705,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14433040474","product_id":100017301,"comment_content":"老师，我想问下“最终推荐人”的递推公式是啥？我想的是 f(actorId) = f(f(actorId)) ,终止条件是referrerId==null，感觉又不太对，麻烦老师指导一下，谢谢！","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437314,"discussion_content":"你写的是对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550480120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1064234,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3d/2a/16357640.jpg","nickname":"黄土高坡","note":"","ucode":"7018F0FAE464A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393358,"discussion_content":"我觉得这是最佳答案：\nf(actor) 表示 actor 的最终推荐人\n递推公式：f(actor) = f(referrer of actor)\n终止条件：referrer of an actor is nil","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631373552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54938,"user_name":"雍鹏亮","can_delete":false,"product_type":"c1","uid":1179992,"ip_address":"","ucode":"A7E394043295B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/01/58/98719136.jpg","comment_is_top":false,"comment_ctime":1545985416,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14430887304","product_id":100017301,"comment_content":"递归写起来很简单，看着代码理解起来也很简单，但是自己想简直难如上天！！！","like_count":3,"discussions":[{"author":{"id":2136879,"avatar":"https://static001.geekbang.org/account/avatar/00/20/9b/2f/6ac82d0a.jpg","nickname":"有人@我","note":"","ucode":"EDFB620F36E415","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353031,"discussion_content":"我想了1万次，掉了一万根头发。递归没学好，学会了植发","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614955206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33551,"user_name":"asnail","can_delete":false,"product_type":"c1","uid":1240695,"ip_address":"","ucode":"7E1F339CBFB8DD","user_header":"","comment_is_top":false,"comment_ctime":1539824801,"is_pvip":false,"replies":[{"id":"12094","content":"不会有了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539856401,"ip_address":"","comment_id":33551,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14424726689","product_id":100017301,"comment_content":"老师，将递归改为非递归没有了那么多的临时变量为什么还会有栈溢出风险？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426992,"discussion_content":"不会有了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539856401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31963,"user_name":"跬行","can_delete":false,"product_type":"c1","uid":1238874,"ip_address":"","ucode":"0BB846566571A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/5a/24ad29c8.jpg","comment_is_top":false,"comment_ctime":1539344218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14424246106","product_id":100017301,"comment_content":"递归调试 确实好难 每次都是日志输出 每一步的结果 看问题在哪里","like_count":3},{"had_liked":false,"id":241122,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1597196689,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10187131281","product_id":100017301,"comment_content":"代码中加一行判断，actorId 是否等于refererId，如果相等，就存在环，不等不存在。","like_count":2},{"had_liked":false,"id":147994,"user_name":"许智鸿","can_delete":false,"product_type":"c1","uid":1655563,"ip_address":"","ucode":"18E41503CC43C2","user_header":"https://static001.geekbang.org/account/avatar/00/19/43/0b/25ff73e0.jpg","comment_is_top":false,"comment_ctime":1572925385,"is_pvip":false,"replies":[{"id":"57066","content":"避免栈调用层次过深，栈溢出","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572948511,"ip_address":"","comment_id":147994,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10162859977","product_id":100017301,"comment_content":"老师，递归代码改为这种循环的非递归写法徒增了实现的复杂度但是为什么还要这样做呢？是不是因为解决了空间消耗，虽然时间消耗仍然没有变","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473365,"discussion_content":"避免栈调用层次过深，栈溢出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572948511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1655563,"avatar":"https://static001.geekbang.org/account/avatar/00/19/43/0b/25ff73e0.jpg","nickname":"许智鸿","note":"","ucode":"18E41503CC43C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44441,"discussion_content":"多谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572949257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146635,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1572590134,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"10162524726","product_id":100017301,"comment_content":"计算机擅长做重复的事情，所以递归正和它的胃口 &#47;&#47;和字是否错了, 应为合 \\smile","like_count":2,"discussions":[{"author":{"id":1079811,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7a/03/c9b43b21.jpg","nickname":"BewhY","note":"","ucode":"4BC26D47A79967","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":132147,"discussion_content":"纠结这个做什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578883785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1079811,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7a/03/c9b43b21.jpg","nickname":"BewhY","note":"","ucode":"4BC26D47A79967","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":135068,"discussion_content":"不干什么，只是评论一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579064636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":132147,"ip_address":""},"score":135068,"extra":""}]}]},{"had_liked":true,"id":124951,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1566025526,"is_pvip":false,"replies":[{"id":"47253","content":"👍，我那个例子一个f分解为一个f，所以递归深度就等于f被调用的次数。如果一个f分解为两个f的那种，比如斐波那契，就要求个max最大值，也就是你说的要在入参就放个变量了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1566775334,"ip_address":"","comment_id":124951,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10155960118","product_id":100017301,"comment_content":"老师，depth++，不是递归深度把，是统计的f(n)方法执行次数，递归深度如果要统计的话，就要在f(n)，方法中加入参了","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463374,"discussion_content":"👍，我那个例子一个f分解为一个f，所以递归深度就等于f被调用的次数。如果一个f分解为两个f的那种，比如斐波那契，就要求个max最大值，也就是你说的要在入参就放个变量了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566775334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39687,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1542335903,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10132270495","product_id":100017301,"comment_content":"老师，findRootReferrerId你这种递归方式效果不太好，数据量较大的时候，每次循环都要进行数据库的连接，这样不仅内存栈会溢出，还会导致数据库连接池耗尽。<br>","like_count":2,"discussions":[{"author":{"id":1322726,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2e/e6/10f59372.jpg","nickname":"Steven Dai","note":"","ucode":"833CA869D0B2A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5660,"discussion_content":"同样觉得，实际代码中并不会循环中查数据库。曾经做过的：\n1、（层次少）一次保存10个上级，查询一次可以获取10个上级，减少次数。但关系维护会比较麻烦。\n2、（层次多）直接数据库层次做，存储过程。\n多交流","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566407212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32169,"user_name":"斜月浮云","can_delete":false,"product_type":"c1","uid":1008933,"ip_address":"","ucode":"25CECBB175DA02","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/25/c6de04bc.jpg","comment_is_top":false,"comment_ctime":1539451705,"is_pvip":false,"replies":[{"id":"11756","content":"并不是所有递归代码都可以应用尾递归优化的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539528748,"ip_address":"","comment_id":32169,"utype":1}],"discussion_count":2,"race_medal":1,"score":"10129386297","product_id":100017301,"comment_content":"关于非递归徒增实现复杂度这点我有意见：1）非递归可共享变量空间，大幅度降低空间复杂度。2）解决堆栈溢出除了限制迭代次数外，首要考虑的应该是尾递归优化。望指正观点。","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426663,"discussion_content":"并不是所有递归代码都可以应用尾递归优化的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539528748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2102908,"avatar":"https://static001.geekbang.org/account/avatar/00/20/16/7c/80871d6a.jpg","nickname":"变革","note":"","ucode":"9D4DCCF90E6768","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344804,"discussion_content":"C语言编译器和ES6有实现尾递归优化，jvm没有实现尾递归优化","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611574805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31806,"user_name":"along","can_delete":false,"product_type":"c1","uid":1236054,"ip_address":"","ucode":"6855D571DD71AB","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/56/1a5b7e9f.jpg","comment_is_top":false,"comment_ctime":1539305829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10129240421","product_id":100017301,"comment_content":"最终推荐人避免出现死循环，可以用前面学的链表检测环的方式来实现","like_count":2},{"had_liked":false,"id":31774,"user_name":"DZuo","can_delete":false,"product_type":"c1","uid":1247240,"ip_address":"","ucode":"F23882BC1E307C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKKqibDZaXxicEUNWiap3fQX81H44ia7hJuVwTiaEFFsKzq8prW9evtpUibBYnd6E6xhF0Ox9SdYGyob7vA/132","comment_is_top":false,"comment_ctime":1539303516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10129238108","product_id":100017301,"comment_content":"在路上，想了想，短点打到结束语条件位置，向前调试","like_count":2},{"had_liked":false,"id":248253,"user_name":"WilliamVector","can_delete":false,"product_type":"c1","uid":1898112,"ip_address":"","ucode":"E0D3C3D4FCB7C9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/80/85ec2c2a.jpg","comment_is_top":false,"comment_ctime":1600081146,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5895048442","product_id":100017301,"comment_content":"【要点】<br>1、递归满足的三个条件<br>(1)一个问题的解可以分解为几个子问题的解。<br>(2)这个问题与分解后的子问题，除了数据规模不同，求解思路完全一样。<br>(3)存在递归终止条件。<br>2、如何写递归代码<br>(1)写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。<br>(2)不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。如果一个问题 A 可以分解为若干子问题 B、C、D，可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样理解起来就简单多了。<br>3、递归代码要警惕堆栈溢出<br>(1)函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。<br>(2)当递归深度非常大的时候，可以采用限定递归深度或者改用按照递推公式迭代循环(如果条件允许，尽量不借助栈)计算。<br>4、递归代码要警惕重复计算<br>(1)为了避免重复计算，可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回。<br>(2)在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。<br>5、改写递归代码为非递归代码<br>(1)递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。<br>(2)笼统的讲，所有的递归代码都可以改为迭代循环的写法。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。<br>【思考】<br>1、如何避免递归环？可以开一个Set，保存已经遍历过的元素，当遍历到某元素时，先查询Set中是否存在该元素，存在，则说明该元素已经遍历，递归路径存在环。<br>2、对于很深的递归代码，可以结合判断条件设置断点或者通过日志信息来跟踪调试，如果日志也太多，日志也可以结合判断条件来输出。","like_count":1},{"had_liked":false,"id":243130,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1597973695,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5892940991","product_id":100017301,"comment_content":"看到女朋友的例子我哭了。。。","like_count":1},{"had_liked":false,"id":241534,"user_name":"CptW","can_delete":false,"product_type":"c1","uid":2108743,"ip_address":"","ucode":"A3174302EBD4B2","user_header":"https://static001.geekbang.org/account/avatar/00/20/2d/47/6a5ab601.jpg","comment_is_top":false,"comment_ctime":1597327796,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5892295092","product_id":100017301,"comment_content":"做了 07、链表 的课后题，题目抽象为：检测单链表中环的存在","like_count":1},{"had_liked":false,"id":232946,"user_name":"耶low","can_delete":false,"product_type":"c1","uid":1992059,"ip_address":"","ucode":"4CCEB741583544","user_header":"https://static001.geekbang.org/account/avatar/00/1e/65/7b/058d17f3.jpg","comment_is_top":false,"comment_ctime":1594175541,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5889142837","product_id":100017301,"comment_content":"“编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。”，自己刷了200多题，递归遇到错误时还总是想着用大脑理清每一层的过程，然后找出错误，但实际上总是把自己绕进去了，还总是怀疑自己智商。早点看到这个专栏就好了，不管是入门还是查漏补缺都是极好的。","like_count":1},{"had_liked":false,"id":232782,"user_name":"GeekYanger","can_delete":false,"product_type":"c1","uid":2046036,"ip_address":"","ucode":"E674B7D25261CC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/sOuSC65kXWdWBAIIs6uXAD41Ed8Wo8tib81LLVOQJ2oK23TgPDy6x0PGmp7rXwLR3BHOicaKx1zib1DyfpCITK3dw/132","comment_is_top":false,"comment_ctime":1594116388,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5889083684","product_id":100017301,"comment_content":"看完您将解的递归，我首先非常同意您的结题方法，其中十分重要的就是找到递推公式，当初我理解到这里的时候不禁感叹数学的伟大，数学真的是所有理工科基础工具。其次，我想问一个问题，当初学习递归的时候看到所谓的“上递归”和“下递归”（我忘记专业词了），大概的意思就是“先调用递归函数再逻辑处理”和“先逻辑处理再调用递归函数”。<br>像您举的例子：<br>int f(int n) {<br>  if (n == 1) return 1;<br>  if (n == 2) return 2;<br>  return f(n-1) + f(n-2);<br>}<br><br>其实可以看成：<br>int f(int n) {<br>  if (n == 1) return 1;<br>  if (n == 2) return 2;<br>  int param1 = n-1;<br>  int param2 = n-2;<br>  return f(param1) + f(param2);<br>}<br>换言之，就是先算出的param1和param2，再调用递归函数，这就是后者（先逻辑处理再调用递归函数），再举个例子，像经典的汉诺塔递归解法：<br>{<br>递归调用；<br>挪动盘子（这里就是数据处理）<br>递归调用；<br>}<br>这就是“双递归”，我想问的是，什么时候先处理数据再调用递归，什么时候先调用递归再处理数据，这两个是有什么联系和区别的吗，或者有总结出什么特征和方法吗？","like_count":1},{"had_liked":false,"id":180503,"user_name":"拾迹","can_delete":false,"product_type":"c1","uid":1025093,"ip_address":"","ucode":"38F367B77FF2D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/45/3cb5cdc6.jpg","comment_is_top":false,"comment_ctime":1582298326,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5877265622","product_id":100017301,"comment_content":"递归可以理解为一个栈，不过平时存的都是数据，这次存的是一个个函数。这样的话，我还想到了管道模型，哈哈","like_count":1},{"had_liked":false,"id":151314,"user_name":" 臣馟飞扬","can_delete":false,"product_type":"c1","uid":1116188,"ip_address":"","ucode":"F2F882B7678055","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/1c/ef15e661.jpg","comment_is_top":false,"comment_ctime":1573698329,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5868665625","product_id":100017301,"comment_content":"给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br>示例：<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br><br>递归解法：<br>class Solution {<br>    &#47;&#47;递归做法<br>    int i;<br>    public ListNode removeNthFromEnd(ListNode head, int n) {<br>        if(head == null){<br>            i=0;<br>            return null;<br>        }<br>        head.next = removeNthFromEnd(head.next,n);<br>        i++;<br>        if(i==n) return head.next;<br>        return head;<br>     }<br>}<br><br>这种递归做法是怎么想到的呢？如何利用文章中的方法想到解题思路？一看到这种解法除了膜拜和感觉自己笨没别的想法了。。。","like_count":1,"discussions":[{"author":{"id":1437292,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ee/6c/246fa0d1.jpg","nickname":"Mr.差不多","note":"","ucode":"946555FCAE710B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53204,"discussion_content":"我觉得这里你可以想象成把一个一个节点放到栈里面，放完以后再从栈中一个一个取出，取出的时候进行计数。计数到是所传的N时就是要删除的节点了。  其实递归就是不断深入的栈结构。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574144573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147755,"user_name":"Crack","can_delete":false,"product_type":"c1","uid":1638828,"ip_address":"","ucode":"BA9573576069C2","user_header":"https://static001.geekbang.org/account/avatar/00/19/01/ac/0a84e410.jpg","comment_is_top":false,"comment_ctime":1572883783,"is_pvip":false,"replies":[{"id":"57064","content":"之前写的：<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;Ki3WN2AJ5HhxxmaQ0lVh3Q","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572948254,"ip_address":"","comment_id":147755,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5867851079","product_id":100017301,"comment_content":"讲讲尾递归优化","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473299,"discussion_content":"之前写的：\nhttps://mp.weixin.qq.com/s/Ki3WN2AJ5HhxxmaQ0lVh3Q","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572948254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1507430,"avatar":"https://static001.geekbang.org/account/avatar/00/17/00/66/508f9f40.jpg","nickname":"旧梦空城","note":"","ucode":"2B901C0CEE9701","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343448,"discussion_content":"该内容已被发布者删除","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611047705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113799,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1563158243,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5858125539","product_id":100017301,"comment_content":"算法_010<br># 作业<br>递归调试：<br>\t- 打印日志看递归值<br>\t- 结合条件断点调试<br>\t(@博金 同学的答案非常好)<br># 内容<br>1. 递归三条件<br>\t(1) 一个问题的解决可以分解为几个子问题的解<br>\t(2) 问题与子问题求解思路相同(只是数据规模不同)<br>\t(3) 存在终止条件<br>2. 处理步骤<br>\t- 写递推公式<br>\t- 找终止条件<br>3. 递归的理解误区：<br>\t从逻辑上和数学上能够证明方法正确即可，无需(其实是没有能力)在大脑中“执行”递归的全过程。<br>3. 利弊<br>\t利:<br>\t- 代码简洁，可读性高<br>\t弊:<br>\t- 堆栈溢出<br>\t- 重复计算<br>\t- 函数调用次数多(时间上，每次运行都要加上函数调用的时间)<br>\t- 空间复杂度高<br><br># 感想<br><br>递归是更符合人类逻辑和直觉的解决方案，但计算机的实现上，还是付出了很多资源。所以，在数据量大的时候，几乎不能使用。<br><br>如果让AI来寻找相关性，可能会以人完全看不懂的逻辑，同样正确地解决问题。","like_count":1},{"had_liked":false,"id":33827,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1060892,"ip_address":"","ucode":"B29CA98AC45F88","user_header":"https://static001.geekbang.org/account/avatar/00/10/30/1c/e160955d.jpg","comment_is_top":false,"comment_ctime":1539908687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834875983","product_id":100017301,"comment_content":"可以在合适的地方打印日志","like_count":1},{"had_liked":false,"id":33588,"user_name":"学习爱好者","can_delete":false,"product_type":"c1","uid":1236851,"ip_address":"","ucode":"F00A42CAB9912D","user_header":"","comment_is_top":false,"comment_ctime":1539829379,"is_pvip":false,"replies":[{"id":"12089","content":"是的。技巧比较不好总结呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539855266,"ip_address":"","comment_id":33588,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834796675","product_id":100017301,"comment_content":"王老师，递归转化为非递归时，我觉得除了时间复杂度问题没解决，其它三个问题空间复杂度，栈溢出，重复计算都解决了，是这样的吗？<br>还有一点，感觉转换的规律和技巧也不太详细，希望多讲解一下","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427007,"discussion_content":"是的。技巧比较不好总结呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539855266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33011,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1539739845,"is_pvip":false,"replies":[{"id":"12051","content":"你搜下斐波那契数列的代码实现","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539788449,"ip_address":"","comment_id":33011,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834707141","product_id":100017301,"comment_content":"pre和prepare  它们的含义是什么    这个程序是不是为了达到跟递归的相同的结果往上靠的    难道pre和prepare代表第一步走两步和走一步 ？  那么这个程序有点看不懂了。。。。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426924,"discussion_content":"你搜下斐波那契数列的代码实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539788449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32324,"user_name":"W_T","can_delete":false,"product_type":"c1","uid":1044071,"ip_address":"","ucode":"1A78F28537E138","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/67/c146c144.jpg","comment_is_top":false,"comment_ctime":1539530827,"is_pvip":false,"replies":[{"id":"11885","content":"你要是能很顺畅的写出递归代码 也没必要非得先写递推公式的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539615659,"ip_address":"","comment_id":32324,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834498123","product_id":100017301,"comment_content":"请问非数字计算的代码可以写递推公式么？比如用递归实现两个单向有序链表的合并。关键代码如下，想了半天，不知道递推公式应该怎么写。<br><br>public static SingleNode&lt;Integer&gt; mergeV2(SingleNode&lt;Integer&gt; nodeA, SingleNode&lt;Integer&gt; nodeB) {<br>        SingleNode&lt;Integer&gt; result;<br><br>        if (nodeA == null) {<br>            return nodeB;<br>        } else if (nodeB == null) {<br>            return nodeA;<br>        }<br><br>        &#47;&#47; 找出较小的节点<br>        if (compareNode(nodeA, nodeB) &lt;= 0) {<br>            result = nodeA;<br>            nodeA = nodeA.next;<br>        } else {<br>            result = nodeB;<br>            nodeB = nodeB.next;<br>        }<br><br>        result.next = mergeV2(nodeA, nodeB);<br>        return result;<br>    }","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426728,"discussion_content":"你要是能很顺畅的写出递归代码 也没必要非得先写递推公式的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539615659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32189,"user_name":"Amari","can_delete":false,"product_type":"c1","uid":1244207,"ip_address":"","ucode":"FC151DC397368C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epuvKVmiaiaYDRKN04xn2RzFR5OSBOlLNMJ8B2JQRmb4tGRCSUgC3TAREia6ny3iaBwbhgDEjico76njYw/132","comment_is_top":false,"comment_ctime":1539480812,"is_pvip":false,"replies":[{"id":"11753","content":"前一排的排数加一就是后一排的排数","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539528607,"ip_address":"","comment_id":32189,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834448108","product_id":100017301,"comment_content":"int f(int n) {<br>  if (n == 1) return 1;<br>  return f(n-1) + 1;<br>}<br>老师，f(n-1)表示前一排，那再加1是啥意思，没懂，求解释","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426670,"discussion_content":"前一排的排数加一就是后一排的排数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539528607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32133,"user_name":"前进前进","can_delete":false,"product_type":"c1","uid":1251872,"ip_address":"","ucode":"645735A90C500B","user_header":"","comment_is_top":false,"comment_ctime":1539428291,"is_pvip":false,"replies":[{"id":"11762","content":"不会了 不好意思","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539529176,"ip_address":"","comment_id":32133,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834395587","product_id":100017301,"comment_content":"老师后续会讲尾递归？尾递归能减少空间复杂度，避免堆栈溢出。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426647,"discussion_content":"不会了 不好意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539529176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31964,"user_name":"跬行","can_delete":false,"product_type":"c1","uid":1238874,"ip_address":"","ucode":"0BB846566571A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/5a/24ad29c8.jpg","comment_is_top":false,"comment_ctime":1539344219,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834311515","product_id":100017301,"comment_content":"递归调试 确实好难 每次都是日志输出 每一步的结果 看问题在哪里","like_count":1},{"had_liked":false,"id":31913,"user_name":"杨智晓 ✟","can_delete":false,"product_type":"c1","uid":1024263,"ip_address":"","ucode":"E3B56F4A38F63D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/07/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1539328543,"is_pvip":false,"replies":[{"id":"11600","content":"嗯嗯","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539402250,"ip_address":"","comment_id":31913,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834295839","product_id":100017301,"comment_content":"典型的递归例子是求阶乘吧f(n)=n*f(n-1)","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426562,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539402250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31903,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1539326264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834293560","product_id":100017301,"comment_content":"1. 关于环形推荐人那个问题我又想到了判断链表环的,快慢指针法 每次查询分两步比如都从A开始 下步操作中 快的查C的推荐人慢的查B的推荐人 如果某一次查的人相同 比如都是A或者B或者C即为有环<br><br>2. 我觉得还有一种办法 叫最终推荐人法，即我们每一次查询的时候都记录下当前查找的人比如A 做一个映射map[A] = ?, 推荐人为B 则map[A] = B, 如果B还有推荐人C 我们更新map[A] = C 如果没有推荐人了 清空map，如果C还有推荐人则继续更新map[A] = ?,再每一次查询完了过后我们验证key是否等于value 则可得出是否有环，这方法的复杂度比上面方法要好多的多就是O(1),如果要查B则映射map[b] = ?以此类推<br><br>补充一下：<br>只检查A有点牵强，我思考过后又觉得 比如我最开始检查A 先map[A] = ?,如果得到A的推荐人B 则再做map[B] = ?，保留map[A] = ?,再接下来的检查推荐人过程中map[A] map[B] 都要更新value,并且每一个映射都要检查key是否等于value则可以得出是否有环，这次应该考虑周全了 ","like_count":1},{"had_liked":false,"id":31814,"user_name":"Egos","can_delete":false,"product_type":"c1","uid":1071143,"ip_address":"","ucode":"9F0055B140E935","user_header":"https://static001.geekbang.org/account/avatar/00/10/58/27/1188e017.jpg","comment_is_top":false,"comment_ctime":1539306618,"is_pvip":false,"replies":[{"id":"11465","content":"后面会讲两种分析方法 在排序和树两节课中","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539309773,"ip_address":"","comment_id":31814,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834273914","product_id":100017301,"comment_content":"递归时间复杂度觉得比较复杂","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426520,"discussion_content":"后面会讲两种分析方法 在排序和树两节课中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539309773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31813,"user_name":"哲人之石","can_delete":false,"product_type":"c1","uid":1240451,"ip_address":"","ucode":"3B81132D9FD66E","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/83/2257b0eb.jpg","comment_is_top":false,"comment_ctime":1539306607,"is_pvip":false,"replies":[{"id":"11469","content":"好像有点不对 先写递推公式吧 然后再写代码 你写的那个有点不是规整的递推公式","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539309933,"ip_address":"","comment_id":31813,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834273903","product_id":100017301,"comment_content":"定期存款利息计算可以用递归吗？<br>首先找到递推公式是：benjin =本金+本金*利率，<br>其次退出条件是：存5年<br>Int fuli(int benjin, int year, double lilv):<br>        Benjin=benjin+benjin*lilv<br>        Year=year-1<br>        If (year &lt; 5){<br>            Return fuli(bebjin,year,lilv)<br>    }else{<br>            Return benjin<br>    }<br>我这个程序写的对吗？而且感觉很复杂，请老师指导？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426519,"discussion_content":"好像有点不对 先写递推公式吧 然后再写代码 你写的那个有点不是规整的递推公式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539309933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360314,"user_name":"码狐","can_delete":false,"product_type":"c1","uid":1234879,"ip_address":"新加坡","ucode":"A4666D3AF30D6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/bf/9d8984b7.jpg","comment_is_top":false,"comment_ctime":1666424267,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1666424267","product_id":100017301,"comment_content":"递归还是建议打印日志来定位<br>1. 递归的深度 -&gt; 通过空格符的数量更加直观<br>2. 打印对应的结果","like_count":0},{"had_liked":false,"id":359564,"user_name":"泥鳅儿","can_delete":false,"product_type":"c1","uid":1323000,"ip_address":"辽宁","ucode":"26B47C8FC67615","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ojfRyNRvy1x3Mia0nssz6CNPHrHXwPPmibvds1URgoHQuKXrGiaxrEbsT6sAvuK4N4AOicySh8S9iaWcOLjteOl6Kgg/132","comment_is_top":false,"comment_ctime":1665646938,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665646938","product_id":100017301,"comment_content":"老师，你好 我在实际项目开发中，经常会用那三行代码来解决寻找最终推荐人的问题，那具体该怎么优化或实现才能最优呢，还是说实际遇到这种问题还是先不用递归的方式实现？","like_count":0},{"had_liked":false,"id":359331,"user_name":"🐻","can_delete":false,"product_type":"c1","uid":1043072,"ip_address":"北京","ucode":"534EDAD496A0E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/80/8759e4c1.jpg","comment_is_top":false,"comment_ctime":1665450019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665450019","product_id":100017301,"comment_content":"print 适合于调试代码<br><br>gdb debug 适合于阅读代码","like_count":0},{"had_liked":false,"id":358346,"user_name":"111","can_delete":false,"product_type":"c1","uid":3109487,"ip_address":"北京","ucode":"D6E8E83A118A3E","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/6f/44c10658.jpg","comment_is_top":false,"comment_ctime":1664239416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664239416","product_id":100017301,"comment_content":"总结：<br>1. 递归就是问题分解化<br>2. 适合递归的问题：<br>  1. 可以分解<br>  2. 子问题实现逻辑一致<br>  3. 有终止条件<br>3. 不要去将递归细节在大脑中实现","like_count":0},{"had_liked":false,"id":355685,"user_name":"蒋慕平","can_delete":false,"product_type":"c1","uid":2302901,"ip_address":"重庆","ucode":"57B8FF7F00C042","user_header":"https://static001.geekbang.org/account/avatar/00/23/23/b5/639a12ec.jpg","comment_is_top":false,"comment_ctime":1661651886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661651886","product_id":100017301,"comment_content":"递归-难点<br>- f(n)= f(n-1)+1<br>1. 一个问题可以分解为几个子问题<br>2. 这个问题与子问题，除数据规模不同，解题方法同样。<br>3. 存在递归终止条件<br>4. 找出递归公式<br>- 警惕堆栈溢出<br>- 避免重复计算","like_count":0},{"had_liked":false,"id":352706,"user_name":"陈斌","can_delete":false,"product_type":"c1","uid":1149402,"ip_address":"","ucode":"AD6933D125C930","user_header":"https://static001.geekbang.org/account/avatar/00/11/89/da/136cdca6.jpg","comment_is_top":false,"comment_ctime":1658891493,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658891493","product_id":100017301,"comment_content":"递归的中间计算过程要避免缓慢的io操作，比如推荐人循环查数据库，层级越多交易就越慢。有些时候需要空间换时间，排序查出来再进行循环处理。","like_count":0},{"had_liked":false,"id":347398,"user_name":"Vivion","can_delete":false,"product_type":"c1","uid":1242310,"ip_address":"","ucode":"C62C4F46B8EB4D","user_header":"https://static001.geekbang.org/account/avatar/00/12/f4/c6/aed9e44a.jpg","comment_is_top":false,"comment_ctime":1653989597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653989597","product_id":100017301,"comment_content":"如何来检测环的存在呢？<br>判断是否与访问过的元素重复即可，如 HashSet","like_count":0},{"had_liked":false,"id":346478,"user_name":"lzai9tian","can_delete":false,"product_type":"c1","uid":2678249,"ip_address":"","ucode":"2AAB4EE6DB66E0","user_header":"https://static001.geekbang.org/account/avatar/00/28/dd/e9/25c127bd.jpg","comment_is_top":false,"comment_ctime":1653190465,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1653190465","product_id":100017301,"comment_content":"递归是一个有去有回的过程，去即是递，归即是回，递的目的是寻找答案，归是携带了寻找到的结果","like_count":0},{"had_liked":false,"id":346247,"user_name":"凯林","can_delete":false,"product_type":"c1","uid":2874237,"ip_address":"","ucode":"20A1024A7ECE17","user_header":"https://static001.geekbang.org/account/avatar/00/2b/db/7d/a3510ae3.jpg","comment_is_top":false,"comment_ctime":1652943799,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652943799","product_id":100017301,"comment_content":"如何知道n-1和n-2的两种里面有没有重复的呢？","like_count":0},{"had_liked":false,"id":344827,"user_name":"Geek_小小萌新","can_delete":false,"product_type":"c1","uid":2880603,"ip_address":"","ucode":"51A2FA527B0857","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIUXWqIBiadT4KFB3rochOHnHSGrAtDQ3GJOrVWqibpaxWrNJIOe7UwgK7O7OLanJcpEibDq9BnjARiag/132","comment_is_top":false,"comment_ctime":1651812928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651812928","product_id":100017301,"comment_content":"第一次学习递归这一节很多知识点都不理解，后来对于不理解的知识点就只能背下来。等学到后面的章节再回来看递归这节内容，发现之前不理解的知识点竟然能弄懂了，但是对于真正掌握和运用这些知识点还是要做题。","like_count":0},{"had_liked":false,"id":341880,"user_name":"zhexiaozi90","can_delete":false,"product_type":"c1","uid":1699904,"ip_address":"","ucode":"C324C71E408560","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/biaG5gpYHkH2TpiaqgQ9iaAl1n4oKyNO25TPC9WAm6XuMxmiaRRbc5oMn5DABibjgIrvGQzIeAj7ZTziaIcFibYaA8yUA/132","comment_is_top":false,"comment_ctime":1649899152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649899152","product_id":100017301,"comment_content":"解决栈溢出：依然借助递归思想。可以引入一个人工链表栈 和 一个长度为1的map。比如递归深度有999，但系统函数调用栈最多能容纳100个。 当递归深度到达100时，如果没有得到结果，就把当前深度入链表栈，递归返回，重新开始递归之前深度-1。当有结果返回时，把最近一次递归的深度和结果写入map，并删除map中之前的键值对，然后链表栈出栈，继续递归。","like_count":0},{"had_liked":false,"id":339448,"user_name":"李琦","can_delete":false,"product_type":"c1","uid":2362871,"ip_address":"","ucode":"40A05E652E8C43","user_header":"https://static001.geekbang.org/account/avatar/00/24/0d/f7/fb595257.jpg","comment_is_top":false,"comment_ctime":1648109029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648109029","product_id":100017301,"comment_content":"初学者可以练习 力扣509. 斐波那契数 ","like_count":0},{"had_liked":false,"id":337830,"user_name":"知行","can_delete":false,"product_type":"c1","uid":1802022,"ip_address":"","ucode":"5AC8CBCC0AD48B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7f/26/c5127e9a.jpg","comment_is_top":false,"comment_ctime":1647081700,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647081700","product_id":100017301,"comment_content":"递归调试方法：1.加上限制递归的深度或者降低数据规模：比如：计算n=10000，只调试n=20；2、打印进入方法的递归值，递归计算出来的值","like_count":0},{"had_liked":false,"id":337546,"user_name":"后乐","can_delete":false,"product_type":"c1","uid":1264163,"ip_address":"","ucode":"058A631CA1A56B","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/23/74bf8518.jpg","comment_is_top":false,"comment_ctime":1646885183,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1646885183","product_id":100017301,"comment_content":"是否学习：✅<br>学习日期：2022&#47;03&#47;10","like_count":0},{"had_liked":false,"id":337315,"user_name":"Geek_sz","can_delete":false,"product_type":"c1","uid":2449060,"ip_address":"","ucode":"72E86D7D6554CF","user_header":"https://static001.geekbang.org/account/avatar/00/25/5e/a4/d48b8298.jpg","comment_is_top":false,"comment_ctime":1646750646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646750646","product_id":100017301,"comment_content":"文中座位排数和走楼梯的例子，递归改成非递归空间复杂度降低了呀","like_count":0},{"had_liked":false,"id":337230,"user_name":"201202077","can_delete":false,"product_type":"c1","uid":2881261,"ip_address":"","ucode":"2FB173EB6A9A2E","user_header":"","comment_is_top":false,"comment_ctime":1646708027,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646708027","product_id":100017301,"comment_content":"需要额外添加递归深度计数辅助调试","like_count":0},{"had_liked":false,"id":336307,"user_name":"Today","can_delete":false,"product_type":"c1","uid":1235000,"ip_address":"","ucode":"4FA397F0BD8C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/38/41027bda.jpg","comment_is_top":false,"comment_ctime":1646059865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646059865","product_id":100017301,"comment_content":"1. 递归的本质就是把一个问题分解成若干个相同解决思路的子问题，递归必须要有终止条件不能无限递归 <br>2. 只要满足三个条件的问题就可以使用递归来解决<br>3. 要出递归代码的关键是先分解问题，写出递推公式和终止条件，再转换成代码<br>4. 递归要警惕两个问题： 栈溢出； 重复计算<br>6. 借助迭代循环来把递归代码转为非递归代码","like_count":0},{"had_liked":false,"id":335079,"user_name":"晴空一鹤","can_delete":false,"product_type":"c1","uid":1909502,"ip_address":"","ucode":"95940CDE56A2FC","user_header":"","comment_is_top":false,"comment_ctime":1645313627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645313627","product_id":100017301,"comment_content":"台阶问题一开始想不清楚为什么是f(n-1)+f(n-2) ,看了评论大受启发，就是如果想到n阶台阶的话，只可能先到n-1阶，或者n-2阶，到了之后再到n阶的方法就是唯一了。如果到达n-1阶的方法个数是f(n-1),到n-2阶的方法个数是f(n-2),那么到达n阶总的方法数就是f(n-1) + f(n-2)。","like_count":0},{"had_liked":false,"id":331974,"user_name":"lixin","can_delete":false,"product_type":"c1","uid":1512599,"ip_address":"","ucode":"94D99DAFB6C929","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/88nXicqmkJWm3IXVfPfGQSk8SKIBVKjuC4qhzaCkf5Ud88uvKgS4Vf5AzCJ1uaFO0gpPnxdh4CowfhpxV1kSbXw/132","comment_is_top":false,"comment_ctime":1642930020,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642930020","product_id":100017301,"comment_content":"爬楼梯的，每步可以爬1阶或2阶， 递归公式为什么写为：<br>f(1) = 1;f(2) = 2;f(n) = f(n-1)+f(n-2) 两者的和？这个想法是怎么来的？","like_count":0},{"had_liked":false,"id":330443,"user_name":"Jack","can_delete":false,"product_type":"c1","uid":1450366,"ip_address":"","ucode":"A0956D2467A8C6","user_header":"https://static001.geekbang.org/account/avatar/00/16/21/7e/12c77eaa.jpg","comment_is_top":false,"comment_ctime":1641978878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641978878","product_id":100017301,"comment_content":"登录n个台阶的方法分成两个子问题，一个登上n-1个台阶后，只有一种方法，另一个是登上n-2个台阶后，还有两个台阶<br>f(n) = f(n-1) + 1   前提是 n&gt;1<br>f(n) = f(n-2) + 2   前提是 n&gt;2<br>后面不知道怎么递推了？<br>","like_count":0},{"had_liked":false,"id":325258,"user_name":"okda","can_delete":false,"product_type":"c1","uid":1266931,"ip_address":"","ucode":"A38D34B0E29CE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/54/f3/2495dade.jpg","comment_is_top":false,"comment_ctime":1638881877,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638881877","product_id":100017301,"comment_content":"f(n)=1*f(n-1)+1*f(n-2)，前面的两个1分别表示走一步和走两步两类走法。","like_count":0},{"had_liked":false,"id":325190,"user_name":"任锋","can_delete":false,"product_type":"c1","uid":1086592,"ip_address":"","ucode":"8C32C85A61C426","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/80/70e483f6.jpg","comment_is_top":false,"comment_ctime":1638858176,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638858176","product_id":100017301,"comment_content":"是不是可以将查询出来的数据扔到一个散列表，key是推荐人id，value是1， 如果查询出来的数据，在散列表中能够找到就是代表有环的出现呢？如果存在，则退出，最终推荐人就是上一个查询的人的ID，<br>比如 A的推荐人是B， B 的推荐人是 C， C的推荐人是 B， 那么久有环的产生，最终推荐人是C没有问题吧？","like_count":0},{"had_liked":false,"id":323887,"user_name":"Tina","can_delete":false,"product_type":"c1","uid":2851354,"ip_address":"","ucode":"8D6D9F6E3D0A99","user_header":"https://static001.geekbang.org/account/avatar/00/2b/82/1a/30676c2e.jpg","comment_is_top":false,"comment_ctime":1638195784,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638195784","product_id":100017301,"comment_content":"递归高效简介，但是不要把自己绕进去，也要注意栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码的时候，一定要控制好这些副作用。","like_count":0},{"had_liked":false,"id":319788,"user_name":"拉布拉多、谁都能摸","can_delete":false,"product_type":"c1","uid":2832351,"ip_address":"","ucode":"F4E4FDDFA0CCF4","user_header":"https://static001.geekbang.org/account/avatar/00/2b/37/df/d49eab02.jpg","comment_is_top":false,"comment_ctime":1635940633,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635940633","product_id":100017301,"comment_content":"记录一下自己刚开始时的困惑，希望可以帮到跟我一样有点懵的小伙伴。<br>就是在递归使用了栈的数据模型这里有点糊涂了，原因是想岔了把最里面执行的方法结束时return结果的步骤想成了直接返回到递归的最外层，事实上在递归最里面的方法结束时return的结果仍然是沿着这个循环的“自我调用“出来的，这也就是说递归的最后一次方法是第一个return从栈弹出的。","like_count":0},{"had_liked":false,"id":319282,"user_name":"Geek_1d4382","can_delete":false,"product_type":"c1","uid":2826799,"ip_address":"","ucode":"D6C0105FDD01B8","user_header":"","comment_is_top":false,"comment_ctime":1635732045,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635732045","product_id":100017301,"comment_content":"递归:写出递推公式，给出终止条件，不要思考具体实现过程<br>问题:堆栈溢出，重复计算<br>解决方案:控制大小，散列表存贮重复计算的东西","like_count":0},{"had_liked":false,"id":316627,"user_name":"付伟","can_delete":false,"product_type":"c1","uid":1397649,"ip_address":"","ucode":"97DC8054E30D97","user_header":"https://static001.geekbang.org/account/avatar/00/15/53/91/5a160371.jpg","comment_is_top":false,"comment_ctime":1634461206,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634461206","product_id":100017301,"comment_content":"递归真的很容易陷入思维误区，至今都只能写很简单的递归，能避开就避开了。<br>递归需要只要同时满足以下三个条件，这三个条件需要手写下来才好理解，实在不行也是for循环搞定也不是不行。","like_count":0},{"had_liked":false,"id":314271,"user_name":"俯瞰风景.","can_delete":false,"product_type":"c1","uid":1044166,"ip_address":"","ucode":"A6DB68B7B84AEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/c6/bebcbcf0.jpg","comment_is_top":false,"comment_ctime":1632925985,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632925985","product_id":100017301,"comment_content":"可以用递归方法解决的问题的特征是：<br>  1、大问题可以分解为子问题<br>  2、子问题和大问题本身的解法一致<br>  3、解法有终止条件<br><br>所有的递归代码都可以改为这种迭代循环的非递归写法。<br>  因为递归解决问题的方式中就使用了循环，大问题不断拆解为子问题是循环，大问题的解是所有子问题解的算术运算结果，那么就可以用变量来存放子问题的解，然后不断循环运算，最终得到大问题的解。循环迭代是正推求解，递归迭代是逆推求解。","like_count":0},{"had_liked":false,"id":312175,"user_name":"卡拉卡拉啦卡","can_delete":false,"product_type":"c1","uid":2264131,"ip_address":"","ucode":"C89528DDF4B379","user_header":"https://static001.geekbang.org/account/avatar/00/22/8c/43/c41e985b.jpg","comment_is_top":false,"comment_ctime":1631672845,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631672845","product_id":100017301,"comment_content":"满足递归的三个条件:<br>1. 问题可以分为几个子问题<br>2. 问题和子问题之间除了数据规模不一样, 其解决方法都是一样的<br>3. 存在终止条件","like_count":0},{"had_liked":false,"id":310231,"user_name":"放飞心情","can_delete":false,"product_type":"c1","uid":1244845,"ip_address":"","ucode":"75A2192D91D86C","user_header":"https://static001.geekbang.org/account/avatar/00/12/fe/ad/7fa85a7d.jpg","comment_is_top":false,"comment_ctime":1630562584,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630562584","product_id":100017301,"comment_content":"二刷再来，爬楼梯的另一种方案，<br>f(n)=f(n-1)+1;<br>f(n)=f(n-2)+2;<br>当n &lt;=0 时递归终止，n ==0 时，方案可行<br>    int count = 0;<br>    private void f(int n) {<br>        if (n &lt;= 0) {<br>            if (n == 0) {<br>                count++;<br>            }<br>            return;<br>        }<br>        f(n - 2);<br>        f(n - 1);<br>    }","like_count":0},{"had_liked":false,"id":309661,"user_name":"陈启航","can_delete":false,"product_type":"c1","uid":2177436,"ip_address":"","ucode":"89246B9BFD3269","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLC4IhKmJDYdWhQms3dmZqJ5YMDGTlPa1o52DnKSErYjsqfc6iaRJrBDZpx0RqQx7eZAED797kiaV6aw/132","comment_is_top":false,"comment_ctime":1630293677,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1630293677","product_id":100017301,"comment_content":"断点可以打条件变量, 在一定条件下停住.<br><br>","like_count":0},{"had_liked":false,"id":308703,"user_name":"魏汉武","can_delete":false,"product_type":"c1","uid":2154488,"ip_address":"","ucode":"D65B21B01202D4","user_header":"https://static001.geekbang.org/account/avatar/00/20/df/f8/e17f8ab5.jpg","comment_is_top":false,"comment_ctime":1629763378,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629763378","product_id":100017301,"comment_content":"使用递归的前提条件<br>1. 一个问题的解可以分解为几个子问题的解<br>2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样<br>3. 存在递归终止条件","like_count":0},{"had_liked":false,"id":308433,"user_name":"李叶","can_delete":false,"product_type":"c1","uid":1470449,"ip_address":"","ucode":"41B33FA8526E48","user_header":"https://static001.geekbang.org/account/avatar/00/16/6f/f1/35f9f16f.jpg","comment_is_top":false,"comment_ctime":1629618949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629618949","product_id":100017301,"comment_content":"递归是借用虚拟机栈实现的，注意边界条件防止死循环，递归深度防止堆栈溢出。递归算法的核心：问题拆解，确定结束条件","like_count":0},{"had_liked":false,"id":308311,"user_name":"侯恩训","can_delete":false,"product_type":"c1","uid":1162376,"ip_address":"","ucode":"F4DC47EECA0F00","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/88/fbb6022e.jpg","comment_is_top":false,"comment_ctime":1629529701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629529701","product_id":100017301,"comment_content":"总结 <br>递归是一种编程技巧<br>递归满足的三个条件<br>1. 一个问题可以转换成规模更小的子问题<br>2. 子问题和之前的问题除了数据规模，其解决方案都一样<br>3. 存在递归终止条件<br><br>递归的问题<br>1. 栈溢出<br>2. 存在重复计算<br>3. 空间占用较高<br><br>可以把一个递归问题转换成一个非递归问题<br><br>思考题<br>条件断点 ","like_count":0},{"had_liked":false,"id":306317,"user_name":"Geek5350","can_delete":false,"product_type":"c1","uid":2028947,"ip_address":"","ucode":"6EB4553707C357","user_header":"","comment_is_top":false,"comment_ctime":1628493454,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628493454","product_id":100017301,"comment_content":"对于第二题，假设100个台阶，已经知道到达99台阶和98台阶的走法了，也很难想到，到达100个台阶是99台阶走法 + 98台阶走法。一般想到是到达99台阶走法 + 1","like_count":0},{"had_liked":false,"id":306027,"user_name":"Geek_a0acbb","can_delete":false,"product_type":"c1","uid":2727756,"ip_address":"","ucode":"B3832953DAF52D","user_header":"","comment_is_top":false,"comment_ctime":1628307213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628307213","product_id":100017301,"comment_content":"翻译成动态规划的问题","like_count":0},{"had_liked":false,"id":303751,"user_name":"王兴","can_delete":false,"product_type":"c1","uid":2625677,"ip_address":"","ucode":"3EF1AC47EE7C78","user_header":"https://static001.geekbang.org/account/avatar/00/28/10/8d/abf02c56.jpg","comment_is_top":false,"comment_ctime":1626961613,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626961613","product_id":100017301,"comment_content":"1. 结束条件<br>2.执行方法<br>3.调用递归  <br><br>尽量约束递归，防止溢出<br>减少重复计算","like_count":0},{"had_liked":false,"id":303713,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1626940585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626940585","product_id":100017301,"comment_content":"很多IDE包括gdb都支持条件断点，可以使用这种方式来进行调试","like_count":0},{"had_liked":false,"id":302710,"user_name":"Yongtao","can_delete":false,"product_type":"c1","uid":2324603,"ip_address":"","ucode":"248BE5661D6532","user_header":"https://static001.geekbang.org/account/avatar/00/23/78/7b/09defb8d.jpg","comment_is_top":false,"comment_ctime":1626342694,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626342694","product_id":100017301,"comment_content":"递归需要满足的三个条件：<br>- 1. 一个问题的解可以分解为几个子问题的解；<br>- 2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样；<br>- 3. 存在递归终止条件。<br><br>重点：<br>递归公式。<br><br>缺点:<br>堆栈溢出、重复计算、函数调用耗时多、空间复杂度高。","like_count":0},{"had_liked":false,"id":302592,"user_name":"Benson_Geek","can_delete":false,"product_type":"c1","uid":1519415,"ip_address":"","ucode":"D95B5C2BA09961","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/dr34H3hOMVsibL0XV1iaBWFiaTnYssX8sNjmJDpiaBUVv2X39nFzDjNpe288cKkZfH3P9sVRxZ1lzYZEcRR3vJNYtA/132","comment_is_top":false,"comment_ctime":1626274434,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626274434","product_id":100017301,"comment_content":"只能靠多做让脑子习惯那种思维。没有啥捷径。","like_count":0},{"had_liked":false,"id":301904,"user_name":"阿甘","can_delete":false,"product_type":"c1","uid":1057843,"ip_address":"","ucode":"BC93175B70E05D","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/33/bcf37f50.jpg","comment_is_top":false,"comment_ctime":1625969140,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1625969140","product_id":100017301,"comment_content":"爬楼梯这个其实看递归公司就是一个简单的斐波那契数列。大家还可以思考一下另一个关于爬楼梯的有趣的问题，就是有 n 级楼梯，一次可以爬 [1, 2, 5] 格楼梯，问最少需要爬多少格楼梯？这个题目其实跟后面的换零钱是一样的思路。","like_count":0},{"had_liked":false,"id":301800,"user_name":"灰灰灰灰灰灰灰帽子","can_delete":false,"product_type":"c1","uid":1388563,"ip_address":"","ucode":"EA9E46444D0CB1","user_header":"https://static001.geekbang.org/account/avatar/00/15/30/13/13d43e3a.jpg","comment_is_top":false,"comment_ctime":1625889267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625889267","product_id":100017301,"comment_content":"条件断点太香了","like_count":0},{"had_liked":false,"id":301150,"user_name":"红尘","can_delete":false,"product_type":"c1","uid":1445504,"ip_address":"","ucode":"CCCD5736755DF5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/gVfU7icdia3o5ZNaHjaWAdgkSYIpU1rdhIlVYiahYCvRlDZu2K6oPSvVobNjzwZbUaiayQcKjicZ44WjfWJCj5xdlPA/132","comment_is_top":false,"comment_ctime":1625554089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625554089","product_id":100017301,"comment_content":"递归有利有弊，利的是递归代码的表达力强，写起来简洁，而弊就是空间复杂度高，有堆栈溢出的风险，存在重读计算，过多的函数调用会耗时比较多的问题<br>递归的分解过程为两步，去的过程叫做递，回来的过程叫做归，基本上，所有的递归问题都可以通过递归的公式来标识，<br>递归需要满足的三个条件<br>1：一个问题的解可以分成几个子问题的解<br>2：这个问题与分解之后的子问题除了数据规模相同，求解思路完全一样<br>3：存在递归的终止条件<br>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递归公式，然后再推敲出终止条件，最后将递归公式和终止条件翻译成代码。<br>学习递归的方式，不用在脑子里循环，一层一层的往下调，然后再一层一层的返回，试图搞清楚计算机每一步都是怎么执行的，这样很容易被绕进去，我们只需要注意递归公式和终止条件就可以解决。<br>递归要警惕堆栈溢出：递归调用的栈溢出，就是函数调用的栈溢出。避免堆栈溢出就是递归调用超过一定深度之后，我们就不继续往下再递归了，直接返回报错。<br>递归代码要警惕重复计算，可以创建一个map用来存放递归中计算得到的值。<br>递归的一步步计算，拆分出来，往往会形成一个树的形式。<br>递归代码的调试最好的方式，就是每次递归进入函数就直接打log，看计算的方式，或者debug这样一步一步的计算","like_count":0},{"had_liked":false,"id":299325,"user_name":"阿杜","can_delete":false,"product_type":"c1","uid":1674685,"ip_address":"","ucode":"3A64AEA4CCFED0","user_header":"https://static001.geekbang.org/account/avatar/00/19/8d/bd/abf3b445.jpg","comment_is_top":false,"comment_ctime":1624583051,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624583051","product_id":100017301,"comment_content":"递归环的检测：<br>第一种方法：用散列表保存递归结果，然后每次递归计算完结果查看散列表是否存在相同值，存在说明有环，这种查询时间复杂度O(1)，但不知道环的具体形态；<br>第二种方法：用链表保存递归结果，然后每次递归计算完结果遍历链表是否存在相同值，存在说明有环，这种查询时间复杂度O(n)，但知道环的具体形态；","like_count":0},{"had_liked":false,"id":299324,"user_name":"阿杜","can_delete":false,"product_type":"c1","uid":1674685,"ip_address":"","ucode":"3A64AEA4CCFED0","user_header":"https://static001.geekbang.org/account/avatar/00/19/8d/bd/abf3b445.jpg","comment_is_top":false,"comment_ctime":1624582671,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624582671","product_id":100017301,"comment_content":"递归使用单步调试容易把自己绕进去，可以在递归函数中打印调试日志，打印每一层递归深度、计算结果等调试信息，然后运行递归代码用notepad工具分析日志。","like_count":0},{"had_liked":false,"id":297774,"user_name":"ABC简简单单","can_delete":false,"product_type":"c1","uid":2657478,"ip_address":"","ucode":"C4A2ECF0F0AA1E","user_header":"https://static001.geekbang.org/account/avatar/00/28/8c/c6/f5a0cf08.jpg","comment_is_top":false,"comment_ctime":1623770620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623770620","product_id":100017301,"comment_content":"问题：如何将递归转为迭代。如何避免递归的重复计算（可以利用hash来记录计算过的值）。如何编写递归代码。如何避免递归造成的内存泄漏（限制深度）<br>","like_count":0},{"had_liked":false,"id":297385,"user_name":"Geek_ff0a91","can_delete":false,"product_type":"c1","uid":2655902,"ip_address":"","ucode":"1E602093C3D583","user_header":"","comment_is_top":false,"comment_ctime":1623492479,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623492479","product_id":100017301,"comment_content":"我一直都想不清楚一层层调用的细节，我一直以为自己智商捉急。","like_count":0},{"had_liked":false,"id":297375,"user_name":"海崖","can_delete":false,"product_type":"c1","uid":2552745,"ip_address":"","ucode":"9D42E0B0D30A56","user_header":"https://static001.geekbang.org/account/avatar/00/26/f3/a9/bb9d8450.jpg","comment_is_top":false,"comment_ctime":1623489908,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623489908","product_id":100017301,"comment_content":"叮~打卡","like_count":0},{"had_liked":false,"id":296114,"user_name":"Geek_180","can_delete":false,"product_type":"c1","uid":2599641,"ip_address":"","ucode":"E92908F53640D3","user_header":"","comment_is_top":false,"comment_ctime":1622768612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622768612","product_id":100017301,"comment_content":"所有的递归代码都可以改为这种迭代循环的非递归写法<br>迭代循环，除了代码复杂点，我觉得解决了堆栈溢出的问题  因为里面的变量在重复使用；<br>也解决了重复计算的问题<br><br>这样理解有问题吗","like_count":0},{"had_liked":false,"id":295671,"user_name":"Jiyea","can_delete":false,"product_type":"c1","uid":1245445,"ip_address":"","ucode":"B70847279D76E6","user_header":"https://static001.geekbang.org/account/avatar/00/13/01/05/b26aa5c5.jpg","comment_is_top":false,"comment_ctime":1622539774,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622539774","product_id":100017301,"comment_content":"电影院查自己是哪一排这个例子不知道该怎么理解：<br><br>int f(int n) {<br>  if (n == 1) return 1;<br>  return f(n-1) + 1;<br>}<br>这个函数的意义不是应该算出最终自己在哪一排么，参数n在场景中没有对应啊，想要算出一个值，n就必须要有具体值啊，这个参数n是什么呢？","like_count":0},{"had_liked":false,"id":295511,"user_name":"袁景松","can_delete":false,"product_type":"c1","uid":2406978,"ip_address":"","ucode":"05F108082D5B27","user_header":"https://static001.geekbang.org/account/avatar/00/24/ba/42/4b6518a3.jpg","comment_is_top":false,"comment_ctime":1622456343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622456343","product_id":100017301,"comment_content":"那第一次有第三种走法（3个台阶）<br>是不是就是f(n) = f(n-1)+f(n-2)+f(n-3);","like_count":0},{"had_liked":false,"id":295146,"user_name":"dreamcasher","can_delete":false,"product_type":"c1","uid":2046980,"ip_address":"","ucode":"2AE26895FC191A","user_header":"https://static001.geekbang.org/account/avatar/00/1f/3c/04/398d2157.jpg","comment_is_top":false,"comment_ctime":1622271088,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622271088","product_id":100017301,"comment_content":"调式递归：<br>1、打印递归值<br>2、条件断点调试","like_count":0},{"had_liked":false,"id":292596,"user_name":"郑思雨","can_delete":false,"product_type":"c1","uid":1474579,"ip_address":"","ucode":"F1F4B08FC94E7D","user_header":"https://static001.geekbang.org/account/avatar/00/16/80/13/df2a0ced.jpg","comment_is_top":false,"comment_ctime":1620889072,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620889072","product_id":100017301,"comment_content":"打印代码：<br>public int f(int n) {<br>        if (n == 1) return 1;<br>        if (n == 2) return 2;<br>        int n_1 = f(n - 1);<br>        System.out.println(&quot;f(n-1=&quot; + (n - 1) + &quot;)=&quot; + n_1);<br>        int n_2 = f(n - 2);<br>        System.out.println(&quot;f(n-2=&quot; + (n - 2) + &quot;)=&quot; + n_2);<br>        int m = n_1 + n_2;<br>        System.out.println(&quot;f(n-1) + f(n-2) = &quot; + m);<br>        return m;<br>    }","like_count":0},{"had_liked":false,"id":291553,"user_name":"青阳","can_delete":false,"product_type":"c1","uid":2139807,"ip_address":"","ucode":"3591D366BAB0B9","user_header":"https://static001.geekbang.org/account/avatar/00/20/a6/9f/3c60fffd.jpg","comment_is_top":false,"comment_ctime":1620359031,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1620359031","product_id":100017301,"comment_content":"上台阶也可以这么理解，最后一步只能是上一个台阶或者上两个台阶，若最后一步是上一个台阶，有f(n-1)种，若最后一步上两个台阶，有f(n-2)种","like_count":0},{"had_liked":false,"id":291400,"user_name":"马志远","can_delete":false,"product_type":"c1","uid":1480892,"ip_address":"","ucode":"AAD8875343E5FC","user_header":"https://static001.geekbang.org/account/avatar/00/16/98/bc/6d5affd3.jpg","comment_is_top":false,"comment_ctime":1620271498,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620271498","product_id":100017301,"comment_content":"## 10 | 递归：如何用三行代码找到“最终推荐人”？<br>### ==1.如何理解“递归”？==  <br>递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。  <br>递的过程=函数持续求解的过程=入栈 归的过程=return持续返回的过程=出栈<br>### ==2.什么情况下使用递归==  <br>1. 一个问题的解可以分解为几个子问题的解  <br>2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样  <br>3. 存在递归终止条件  <br><br>### ==3.递归如何写==  <br>写出递推公式，找到终止条件  <br>递归公式可以根据前几种条件进行总结  <br>### ==4.递归产生问题==  <br>1. 递归代码要警惕堆栈溢出  <br>2. 递归代码要警惕重复计算","like_count":0},{"had_liked":false,"id":290852,"user_name":"萧云","can_delete":false,"product_type":"c1","uid":1573173,"ip_address":"","ucode":"482FCC4A81120D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM5Kwia5yViaSzkS7ibg06wibYRh0ibfpuva5iaqialmwIGyjYicmxIplhvEv58jiaCuQqasTbQQsiabvzTGvibbA/132","comment_is_top":false,"comment_ctime":1619781153,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619781153","product_id":100017301,"comment_content":"可以增加一下尾递归相关的知识","like_count":0},{"had_liked":false,"id":290702,"user_name":"lxj","can_delete":false,"product_type":"c1","uid":1541351,"ip_address":"","ucode":"8A1AC16A9E09C9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BQaJmDRTUXyNIzH6SwM27kXQibyDUlJ3vibiaIUmRe9j1I4K5fLDnOf6Uicibj2gBsSeWA4zKoUMN803oFD4gAHuiblA/132","comment_is_top":false,"comment_ctime":1619692754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619692754","product_id":100017301,"comment_content":"老师，不好意思我现在才看到。我感觉递归和动态规划好像啊，动态规划的解题思路是：<br>1、找到base case<br>2、找到状态值<br>3、找到选择项<br>4、写出dp函数<br>其中，第一步和第四步和递归类似，然后动态规划也会出现重复计算问题，堆栈过深等","like_count":0},{"had_liked":false,"id":290605,"user_name":"李锋雨（力天）","can_delete":false,"product_type":"c1","uid":1522071,"ip_address":"","ucode":"44E3350F44563B","user_header":"https://static001.geekbang.org/account/avatar/00/17/39/97/1bf1240f.jpg","comment_is_top":false,"comment_ctime":1619658282,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619658282","product_id":100017301,"comment_content":"编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。--------王争老师终于解惑我多年的疑问，指出了我的问题，感觉终于找到知音了，很多资料讲的挺好，不知道我的困惑，导致长时间苦闷","like_count":0},{"had_liked":false,"id":289806,"user_name":"yang","can_delete":false,"product_type":"c1","uid":1940562,"ip_address":"","ucode":"67C86E09BA6E4B","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9c/52/dc770378.jpg","comment_is_top":false,"comment_ctime":1619181598,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619181598","product_id":100017301,"comment_content":"上学时候做作业时用递归在matlab上实现了dfs. 调试的话，好像就是用了print吧，或者用一个全局计数器计下来递规次数。调试时先从小一点的数开始。","like_count":0},{"had_liked":false,"id":289351,"user_name":"Geek_bethel","can_delete":false,"product_type":"c1","uid":2541943,"ip_address":"","ucode":"C6313699A95B02","user_header":"https://static001.geekbang.org/account/avatar/00/26/c9/77/bf372419.jpg","comment_is_top":false,"comment_ctime":1618986824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618986824","product_id":100017301,"comment_content":"递归 与 递推公式<br>基本上，所有的递归问题都可以用递推公式来表示。<br>写递归代码最关键的是写出递推公式，找到终止条件，剩下将递推公式转化为代码就很简单了。<br><br>只要同时满足以下三个条件，就可以用递归来解决：<br>1. 一个问题的解可以分解为几个子问题的解<br>子问题就是数据规模更小的问题。<br>2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样<br>3. 存在递归终止条件<br><br>递归代码要警惕堆栈溢出<br>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。<br>系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。<br><br>递归代码要警惕重复计算<br>为了避免重复计算，我们可以通过一个数据结构(比如散列表)来保存已经求解过的f(k)。<br>当递归调用到f(k)时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。<br><br>除了这两个常见的问题，递归代码还有很多别的问题：<br>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。<br>在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。<br><br>递归有利有弊，利是递归代码的表达力很强，写起来非常简洁;<br>而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。<br>所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。","like_count":0},{"had_liked":false,"id":288714,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1618636843,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618636843","product_id":100017301,"comment_content":"一般调试递归方法可以使用断点、日志的方式来分析。也可以在递归方法内部增加目标值判断条件使断点停到值位置来进行单步分析。","like_count":0},{"had_liked":false,"id":288423,"user_name":"张知信","can_delete":false,"product_type":"c1","uid":2144474,"ip_address":"","ucode":"7C896BB3214B3D","user_header":"https://static001.geekbang.org/account/avatar/00/20/b8/da/42284f64.jpg","comment_is_top":false,"comment_ctime":1618465219,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618465219","product_id":100017301,"comment_content":"什么是递归？函数调用自己，递归是一种编程方法。<br>递归需要满足的三个条件？1.问题的解可以拆分为几个子问题的解；2.这个问题与子问题的求解方法相同；3.存在递归终止条件。<br>如何编写递归代码？写出递推公式，找出终止条件。<br>如何看懂递归代码？不要试图分解递归的每个步骤，而是直接把子问题视为已解决。<br>递归代码警惕堆栈溢出；递归代码警惕重复计算。<br>使用栈可以将自顶向下的递归代码修改为非递归代码，但是这种修改没有必要。<br>递归代码调试？1.打印日志打印递归值；2.结合条件断点调试。","like_count":0},{"had_liked":false,"id":287798,"user_name":"imeteors","can_delete":false,"product_type":"c1","uid":1504435,"ip_address":"","ucode":"D1765B12B71A48","user_header":"https://static001.geekbang.org/account/avatar/00/16/f4/b3/071b69d1.jpg","comment_is_top":false,"comment_ctime":1618152520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618152520","product_id":100017301,"comment_content":"王老师，没有讲如何分析递归的时间复杂度","like_count":0},{"had_liked":false,"id":287797,"user_name":"imeteors","can_delete":false,"product_type":"c1","uid":1504435,"ip_address":"","ucode":"D1765B12B71A48","user_header":"https://static001.geekbang.org/account/avatar/00/16/f4/b3/071b69d1.jpg","comment_is_top":false,"comment_ctime":1618152442,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618152442","product_id":100017301,"comment_content":"如果递归栈过大造成溢出，是否可以采用尾递归的方式？","like_count":0},{"had_liked":false,"id":286707,"user_name":"赵爽","can_delete":false,"product_type":"c1","uid":2400026,"ip_address":"","ucode":"C96C83F65E0917","user_header":"","comment_is_top":false,"comment_ctime":1617518732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617518732","product_id":100017301,"comment_content":"还记得当年那个青涩的我面试被问到迭代的时候，一脸懵逼，虽然后来看了些相关内容，但是现在写一篇，让我受益匪浅，感悟很深","like_count":0},{"had_liked":false,"id":285883,"user_name":"Vonct","can_delete":false,"product_type":"c1","uid":2524479,"ip_address":"","ucode":"4511797597786D","user_header":"https://static001.geekbang.org/account/avatar/00/26/85/3f/e77a6e4c.jpg","comment_is_top":false,"comment_ctime":1617065004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617065004","product_id":100017301,"comment_content":"老师我想问一下，是不是递归中return的都是同一个数据（在return表达式中没有加减等运算时） 就像例子中的return函数的调用","like_count":0},{"had_liked":false,"id":284605,"user_name":"志凡","can_delete":false,"product_type":"c1","uid":1045919,"ip_address":"","ucode":"00BABEC130C3EC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/9f/854ed833.jpg","comment_is_top":false,"comment_ctime":1616384457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616384457","product_id":100017301,"comment_content":"盗梦空间里的梦中梦是递归","like_count":0},{"had_liked":false,"id":284119,"user_name":"Jefitar","can_delete":false,"product_type":"c1","uid":1370659,"ip_address":"","ucode":"D7ED9F32ADA5B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/ea/23/508f71e3.jpg","comment_is_top":false,"comment_ctime":1616070808,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616070808","product_id":100017301,"comment_content":"老师的课真的能让人豁然开朗！","like_count":0},{"had_liked":false,"id":283843,"user_name":"coco","can_delete":false,"product_type":"c1","uid":1052821,"ip_address":"","ucode":"7BC3AB84E8434E","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/95/17a9a042.jpg","comment_is_top":false,"comment_ctime":1615954137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615954137","product_id":100017301,"comment_content":"1，不要试图用人脑去分解递归的每个步骤<br>2，递归可以分解为多个子问题，而非单个","like_count":0},{"had_liked":false,"id":283572,"user_name":"凌波漫步","can_delete":false,"product_type":"c1","uid":1567545,"ip_address":"","ucode":"4CDAABBFB491E8","user_header":"https://static001.geekbang.org/account/avatar/00/17/eb/39/5c13ed3b.jpg","comment_is_top":false,"comment_ctime":1615821497,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615821497","product_id":100017301,"comment_content":"爬楼梯：<br>int f(int n)  { <br>    if (n &lt;= 2)  return n; <br>    int pre = 2; <br>    int prepre = 1; <br>    for (int i = 3; i &lt;= n; ++i)  { <br>        int ret = pre + prepre; <br>        prepre = pre; <br>        pre = ret; <br>     } <br>     return pre;<br>}","like_count":0},{"had_liked":false,"id":283124,"user_name":"〈😐ノ","can_delete":false,"product_type":"c1","uid":1581352,"ip_address":"","ucode":"A4EBDCE5EF943A","user_header":"https://static001.geekbang.org/account/avatar/00/18/21/28/4c13599a.jpg","comment_is_top":false,"comment_ctime":1615559250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615559250","product_id":100017301,"comment_content":"1.栈溢出  f(n)  n非常大,把栈撑爆了<br>2.计算冗余  , 下楼梯,一步两步的问题,  f(5) 分解 f(4) f(3)    f(4) 分解 f(3) f(2),    f(3)算了两次, 可以通过结果收集来避免. <br>3.深度优先.","like_count":0},{"had_liked":false,"id":283055,"user_name":"Kyle(","can_delete":false,"product_type":"c1","uid":1640978,"ip_address":"","ucode":"0C14C4C086CAA9","user_header":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","comment_is_top":false,"comment_ctime":1615532158,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615532158","product_id":100017301,"comment_content":"上面的例子其实就是斐波那契数列（不懂的去搜一下），或者你自己在本子上画一下就知道了，第一阶有1种走法，第二阶有2种走法，第三阶有3种走法，第四阶有5种走法，第五阶有8种走法，这个走法的规律正好符合斐波那契数列1(这个1在此例子省略了)、1、2、3、5、8、13、21....不管哪个数都是前两个数的和，那么想象每个数下面都有一个类似数组一样的下标，那么第n个数就等于第n-1位置的数加上第n-2位置的数也就是F(n) = F(n-1) + F(n-2)，你学废了吗？懂的话请点赞~","like_count":0},{"had_liked":false,"id":280506,"user_name":"Geek_c6d818","can_delete":false,"product_type":"c1","uid":2447241,"ip_address":"","ucode":"C75D88DD4B6D88","user_header":"http://thirdwx.qlogo.cn/mmopen/uqaRIfRCAhKNfTrkGONA9TRs4ibOgPROmdSAf3lwHsPxehgbnrRxiahiaiaCXLzWmF7a0asAueMDDUBkftJAxHzmSXjzJ93ze81c/132","comment_is_top":false,"comment_ctime":1614237629,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614237629","product_id":100017301,"comment_content":"递归需要满足的三个条件：<br>  1、一个问题的解可以分解为几个子问题的解<br>  2、这个问题纯属分解之后的子问题，除了数据规模不同，求解思路完全一样<br>  3、存在递归种植条件<br><br>如何编写递归代码？<br>  写出递推公式，找到终止条件。<br>  关键是，只要遇到递归，我们就把他抽象成一个地推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。<br><br>注意点：<br>  1、递归代码要警惕堆栈溢出<br>  2、递归代码要警惕重复计算","like_count":0},{"had_liked":false,"id":280498,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1614235943,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1614235943","product_id":100017301,"comment_content":"茶艺师学编程<br><br>当时在学递归的时候，老师是这样警告的：<br><br>1、找到“最大公约数”，交给电脑完成<br><br>2、不要人肉递归，不要人肉递归，不要人肉递归","like_count":0},{"had_liked":false,"id":280255,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1614144193,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614144193","product_id":100017301,"comment_content":"递归：(时间复杂度是O(2^n))<br>1.例子：计算电影院自己的座位，问前排，前排问前排，问到第一排，再每排返回结果给后排。<br>递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。<br>用递推公式来表示递归问题：f(n)=f(n-1)+1 其中，f(1)=1。<br>f(n)表示自己在哪一排，f(n-1) 表示前面一排所在的排数，f(1)=1 表示第一排的人知道自己在第一排。<br><br>2.递归需要满足条件<br>1).一个问题的解可以分解为几个子问题的解。（“自己在哪一排”的问题，可分解为“前一排的人在哪一排”这样一个子问题）<br>2).这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。（你求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路一样）<br>3).存在递归终止条件。（第一排的人不需要再继续询问任何人，就知道自己在哪一排）<br><br>3.如何编写递归代码？<br>找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。<br>如果一个问题 A 可以分解为若干子问题 B、C、D，可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。<br>而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题等。<br>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。<br><br>4.递归代码要警惕堆栈溢出<br>如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。<br>可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，就不继续往下再递归了，直接返回报错。<br>最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法。<br><br>5.递归代码要警惕重复计算<br>可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。<br><br>6.将递归代码改为非递归代码(可以避免栈调用层次过深，栈溢出)<br>所有的递归代码都可以改为这种迭代循环的非递归写法<br>因为递归本身就是借助栈来实现的，如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。<br>这种思路实际上是将递归改为了“手动”递归，本质并没有变，徒增了实现的复杂度。<br>例子：假如这里有n个台阶，每次可以跨1个台阶或2个台阶，请问走这n个台阶有多少种走法？<br>递推公式：f(n) = f(n-1)+f(n-2)<br>终止条件：f(1)=1，f(2)=2<br>递归代码：<br>int f(int n) {<br>\tif (n == 1) return 1; if (n == 2) return 2; <br>\treturn f(n-1) + f(n-2);<br>}<br>非递归代码：pre和prepre代表f（n-1）和f（n-2）<br>int f(int n) { <br>\tif (n == 1) return 1; if (n == 2) return 2; <br>\tint ret = 0; int pre = 2; int prepre = 1; <br>\tfor (int i = 3; i &lt;= n; ++i) { <br>\t\tret = pre + prepre; prepre = pre; pre = ret; <br>\t} <br>\treturn ret;<br>}<br>关于走楼梯的思路解析：（评论：落叶飞逝的恋）<br>1 走到第1级，有1种方法 ，直接走1<br>2 走到第2级，有2种方法（1,1）（2）总共两种走法<br>3 走到第3级，有3种方法（1,1,1）（1,2）（2,1）总共3种走法<br>4 走到第4级，有5种方法（1,1,1,1）（1,1,2）（1,2,1）（2,1,1）（2,2） 总共5种<br>5 走到第5级，有8种方法<br>以此类推，后面的总等于前面两级方法之和（斐波那契数列）<br><br>7.递归弊端<br>堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码的时候，一定要控制好这些副作用。<br>堆栈溢出(StackOverflow-栈溢出)包含堆空间溢出、栈空间溢出。这里说的堆跟数据结构中的堆没啥关系，更多的是指内存空间。<br>尾递归也并不能完全避免堆栈溢出<br><br>8.对于递归代码，有什么好的代码调试方法吗？（评论：博金）<br>1).打印日志发现，递归值。<br>2).结合条件断点进行调试。<br><br>感谢老师及各位小伙伴！","like_count":0},{"had_liked":false,"id":280127,"user_name":"LIFE l=new LIFE()","can_delete":false,"product_type":"c1","uid":2446981,"ip_address":"","ucode":"729BACA3B7FD42","user_header":"https://static001.geekbang.org/account/avatar/00/25/56/85/6da913fa.jpg","comment_is_top":false,"comment_ctime":1614088979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614088979","product_id":100017301,"comment_content":"找出解决单次问题的公式，然后找出递归结束的条件，调用就完事了，千万别一层层往里面想","like_count":0},{"had_liked":false,"id":278931,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1356978,"ip_address":"","ucode":"E78B1F15BC10F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcLjatV3GHdibZXCTIgL1X2A7jpByIeLH3Zyia8KXdT4JRcicmVSgq5ekRHCFCFenMqicsAwaWYibHkTw/132","comment_is_top":false,"comment_ctime":1613464151,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613464151","product_id":100017301,"comment_content":"这么看来，递归和动态规划也有相似的地方。都是把大问题分解为小问题，给出初始条件，找出转化方程。不同之处可能是动态规划更多用在求最优解问题上，同时会做剪枝合并相同操作等。","like_count":0},{"had_liked":false,"id":277337,"user_name":"进化菌","can_delete":false,"product_type":"c1","uid":1276861,"ip_address":"","ucode":"B30A5F78BB4171","user_header":"https://static001.geekbang.org/account/avatar/00/13/7b/bd/ccb37425.jpg","comment_is_top":false,"comment_ctime":1612362744,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1612362744","product_id":100017301,"comment_content":"之前对递归比较困惑的时候，确实有想了解它执行的每一步，结果越绕进去越发觉自己脑子混乱，甚至怀疑自己智力有问题。听老师这么一分析，似乎看开了许多，感谢~","like_count":0},{"had_liked":false,"id":276736,"user_name":"Geek_4b3c96","can_delete":false,"product_type":"c1","uid":2360934,"ip_address":"","ucode":"E50466CF68E531","user_header":"","comment_is_top":false,"comment_ctime":1612096616,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612096616","product_id":100017301,"comment_content":"常用的是条件控制 比如 conter==n？ 或者其他条件满足 在分支里下断","like_count":0},{"had_liked":false,"id":275406,"user_name":"变革","can_delete":false,"product_type":"c1","uid":2102908,"ip_address":"","ucode":"9D4DCCF90E6768","user_header":"https://static001.geekbang.org/account/avatar/00/20/16/7c/80871d6a.jpg","comment_is_top":false,"comment_ctime":1611506403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611506403","product_id":100017301,"comment_content":"电影院坐第几排的例子把我看懵了，入参n就是排数吧，入参等于结果，这个例子岂不是没有意义？","like_count":0},{"had_liked":false,"id":273424,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1356978,"ip_address":"","ucode":"E78B1F15BC10F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcLjatV3GHdibZXCTIgL1X2A7jpByIeLH3Zyia8KXdT4JRcicmVSgq5ekRHCFCFenMqicsAwaWYibHkTw/132","comment_is_top":false,"comment_ctime":1610593763,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610593763","product_id":100017301,"comment_content":"去的过程叫递，回来的过程叫归，原来命名由此而来。递归的关键点在于写出递归公式和找出结束条件。在评论中学习到了条件断点的调试方式，很有用！","like_count":0},{"had_liked":false,"id":271448,"user_name":"rainforest派","can_delete":false,"product_type":"c1","uid":2387448,"ip_address":"","ucode":"D684D70BD4D913","user_header":"https://static001.geekbang.org/account/avatar/00/24/6d/f8/c91e6cd1.jpg","comment_is_top":false,"comment_ctime":1609644971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609644971","product_id":100017301,"comment_content":"假设子问题已解决，只考虑问题与子问题之间的关系即可，屏蔽递归细节。忽略层层的细节，大概就是递归的优雅之处吧！","like_count":0},{"had_liked":false,"id":270645,"user_name":"林肯","can_delete":false,"product_type":"c1","uid":1008582,"ip_address":"","ucode":"D2C97220230DE5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/c6/d6ea3df3.jpg","comment_is_top":false,"comment_ctime":1609206036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609206036","product_id":100017301,"comment_content":"老师这个查找最终上级的例子仅作为示例，实际上我们一般不会这样用，试想如果一个用户有1000个上级推荐人则需要查数据库1000次，这个显然不能接受；工程上一般会采用空间换时间的思路：新增一个字段记录用户的所有直系上级，这样查询一次数据库即可","like_count":0},{"had_liked":false,"id":268884,"user_name":"bowen","can_delete":false,"product_type":"c1","uid":1073569,"ip_address":"","ucode":"B0979D12090C7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/a1/f2ddc098.jpg","comment_is_top":false,"comment_ctime":1608388042,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608388042","product_id":100017301,"comment_content":"递归代码调试如果直接使用断点不太现实，可以使用打印日志或条件断点的方式","like_count":0},{"had_liked":false,"id":268883,"user_name":"bowen","can_delete":false,"product_type":"c1","uid":1073569,"ip_address":"","ucode":"B0979D12090C7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/a1/f2ddc098.jpg","comment_is_top":false,"comment_ctime":1608387893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608387893","product_id":100017301,"comment_content":"递归有三步，第一步，看问题能到否分解为一个或多个小问题，这些问题除了数据规模解决方法完全一样。第二步，找到分解问题的规律，找出递推公式。第三步，判断终止递归的条件。<br>递归的坑，第一可能会造成堆栈溢出，也就是递归深度过深，可以使用限制最大递归深度来解决，第二可能有重复计算，可以用散列表存下已经计算过的值，然后遇到的时候直接调用","like_count":0},{"had_liked":false,"id":268172,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1608089592,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608089592","product_id":100017301,"comment_content":"1、不要人肉递归，要把我与子问题直接的处理逻辑，解决了与子问题的逻辑处理，下面的全是与子问题的逻辑处理关系，这样就解决了递归问题。2、递归问题带来的重复需要我们保存记录从而提供性能","like_count":0},{"had_liked":false,"id":267853,"user_name":"慕高迪","can_delete":false,"product_type":"c1","uid":1448126,"ip_address":"","ucode":"EB1CB5EA4E3A90","user_header":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","comment_is_top":false,"comment_ctime":1607952991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607952991","product_id":100017301,"comment_content":"总结：<br>1. 什么是递归？（what）<br><br>递归分为“递”和“归”两个方面，所谓的递就是一层层的传递，而归就是一层层的返回。是解决问题的一种思维方式。<br><br>2. 为什么要用递归？（why）<br><br>在解决某些问题时，母问题可以通过拆解成执行逻辑相同的子问题，这些子问题又可以拆解成更小的子问题，直到拆解到可以求值的地步。在进行反推得到母问题的结果。<br>在这种场景下，递归更加适用。使用递归算法，只需关注将母的问题拆解为子问题的过程，并假设这些子问题都已经解决了后，这些子问题又该如何解决母问题。而对于子问题的继续拆解，由于执行逻辑都是<br>相同的，可以不用思考。这种方式大大简化了实现问题的复杂程度。<br><br>3.什么情况下用递归？（when）<br><br>通过上面的总结，可以看到，要想使用递归，需要具备以下两个条件：<br>（1）要解决的问题能够拆解为逻辑相同的子问题，只是问题的规模不一样而已<br>（2）递归不能无限的进行下去，需要存在一个终点。达到终点时需要反推得到大规模问题的结果<br><br>4. 如何应用递归？（how）<br><br>要写好递归代码，最最关键的是：找到问题拆解的规律，并写好递归公式和找到终止条件。再去写递归代码就很简单了。<br><br>5. 递归的误区<br><br>在使用递归时，存在如下几个误区：<br><br>（1）使用递归不是没有代价的，由于递归每一层都会调用函数，而函数的调用需要函数调用栈来存储临时变量，这个函数调用栈大小是有限制的，用一点就少一点，而且它往往比较小，如果递归的深度较高，可能<br>导致的结果就是这个函数调用栈满了，从而导致程序出现：堆栈溢出异常。<br><br>（2）在有些问题的拆解过程中，涉及到拆解后的子问题重复计算，浪费计算资源的问题。<br><br> 针对第一种，我们可以限制递归的深度，达到了设置的阈值，就终止程序；而第二个问题的解决，我们可以采用hash表存储已经计算过的子问题，当需要再次计算该子问题时，从hash表中直接拿到结果即可。","like_count":0},{"had_liked":false,"id":267068,"user_name":"锅侠","can_delete":false,"product_type":"c1","uid":2090232,"ip_address":"","ucode":"2F7856BEF55301","user_header":"https://static001.geekbang.org/account/avatar/00/1f/e4/f8/80374742.jpg","comment_is_top":false,"comment_ctime":1607587689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607587689","product_id":100017301,"comment_content":"第二个例子也可以改为非递归的实现方式。 这块代码看得有点蒙蔽👀。。。","like_count":0},{"had_liked":false,"id":266697,"user_name":"geekymv","can_delete":false,"product_type":"c1","uid":1075950,"ip_address":"","ucode":"B119ACE47B8C0C","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJTywPCdTDoRAaLBN20JfD50dQPic0B3OeUgYMHA3x7ptvF3iaCRTqrNZsF3Cz8TCibcwSsCichdOiallQ/0","comment_is_top":false,"comment_ctime":1607441885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607441885","product_id":100017301,"comment_content":"从一个故事开始讲递归 https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;TWgjnmlx0d62hv7ZUk-R7A","like_count":0},{"had_liked":false,"id":266253,"user_name":"一剑","can_delete":false,"product_type":"c1","uid":1907159,"ip_address":"","ucode":"8B52B85C223F02","user_header":"https://static001.geekbang.org/account/avatar/00/1d/19/d7/324b6ae1.jpg","comment_is_top":false,"comment_ctime":1607258655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607258655","product_id":100017301,"comment_content":"递归算法实际上是一种分而治之的方法，它把复杂问题分解为简单问题来求解。对于某些复杂问题(例如hanio塔问题)，递归算法是一种自然且合乎逻辑的解决问题的方式，但是递归算法的执行效率通常比较差。因此，在求解某些问题时，常采用递归算法来分析问题，用非递归算法来求解问题；另外，有些程序设计语言不支持递归，这就需要把递归算法转换为非递归算法。","like_count":0},{"had_liked":false,"id":266090,"user_name":"saodiseng","can_delete":false,"product_type":"c1","uid":1277474,"ip_address":"","ucode":"04445D96A4F6CA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJxNpWRCIaJib5txN8crwmlLTJBcAz77XOR7ib44FaDqdhhIr7WMJupwnC0nWY7ZtQwcEEB9YkQQQPw/132","comment_is_top":false,"comment_ctime":1607162974,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607162974","product_id":100017301,"comment_content":"n步台阶问题为什么要第一步一个台阶和第一步两个台阶这样分类😂","like_count":0},{"had_liked":false,"id":264465,"user_name":"YUAN元","can_delete":false,"product_type":"c1","uid":2278571,"ip_address":"","ucode":"3E61E785BAA7AB","user_header":"https://static001.geekbang.org/account/avatar/00/22/c4/ab/49f21c62.jpg","comment_is_top":false,"comment_ctime":1606471655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606471655","product_id":100017301,"comment_content":"环的问题可以通过Set集合判断解决。","like_count":0},{"had_liked":false,"id":260281,"user_name":"Z7k","can_delete":false,"product_type":"c1","uid":1238680,"ip_address":"","ucode":"39373D7A6E6EE1","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/98/5853eb73.jpg","comment_is_top":false,"comment_ctime":1604975920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604975920","product_id":100017301,"comment_content":"打断点单步调试，查看数据走向","like_count":0},{"had_liked":false,"id":258521,"user_name":"挥手自兹去，萧萧班马鸣","can_delete":false,"product_type":"c1","uid":1751818,"ip_address":"","ucode":"AE3A2187AC1A30","user_header":"https://static001.geekbang.org/account/avatar/00/1a/bb/0a/f9d81f3e.jpg","comment_is_top":false,"comment_ctime":1604472979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604472979","product_id":100017301,"comment_content":"递归要注意重复计算和递归深度。","like_count":0},{"had_liked":false,"id":258446,"user_name":"没有你你你你称","can_delete":false,"product_type":"c1","uid":1178918,"ip_address":"","ucode":"D5DCE19719DE5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/26/409c8a78.jpg","comment_is_top":false,"comment_ctime":1604449453,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1604449453","product_id":100017301,"comment_content":"从文章看，递归的好处就是代码简洁，可是在可读性（易理解）和性能上都下降了，递归有它的必要吗？","like_count":0,"discussions":[{"author":{"id":1238680,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e6/98/5853eb73.jpg","nickname":"Z7k","note":"","ucode":"39373D7A6E6EE1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323622,"discussion_content":"开发效率高，代码简洁，在对性能要求较低的时候，挺好噻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604976044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257299,"user_name":"吃茫茫","can_delete":false,"product_type":"c1","uid":2122304,"ip_address":"","ucode":"D9781EDA5CC825","user_header":"https://static001.geekbang.org/account/avatar/00/20/62/40/faf9a818.jpg","comment_is_top":false,"comment_ctime":1603932901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603932901","product_id":100017301,"comment_content":"递归自动检测“环”的问题，我认为定义一个全局变量，比如 Java 中的 Set，然后每一次递归的时候，把递归的值插入进去，如果插入失败了，则证明行成“环”了，此时抛出错误","like_count":0},{"had_liked":false,"id":256956,"user_name":"gerry pang","can_delete":false,"product_type":"c1","uid":1068169,"ip_address":"","ucode":"54BD1D8DE1DBBF","user_header":"https://static001.geekbang.org/account/avatar/00/10/4c/89/e698c0a9.jpg","comment_is_top":false,"comment_ctime":1603795604,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603795604","product_id":100017301,"comment_content":"老师，我写递归的时候什么时候新开一个函数，什么时候用原函数在拿不准，请问您在写的时候有什么准则吗？","like_count":0},{"had_liked":false,"id":252984,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1602554459,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602554459","product_id":100017301,"comment_content":"思考题解答：我一般使用 IDE 控制台打印的方式来解决。","like_count":0},{"had_liked":false,"id":252254,"user_name":"Fy","can_delete":false,"product_type":"c1","uid":2213304,"ip_address":"","ucode":"4F4C0617A79083","user_header":"https://static001.geekbang.org/account/avatar/00/21/c5/b8/481d8a64.jpg","comment_is_top":false,"comment_ctime":1602214482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602214482","product_id":100017301,"comment_content":"递归用电影院那个例子太棒了。<br>检测环的话就用一个visited set，如果出现过就说明在环里了","like_count":0},{"had_liked":false,"id":250686,"user_name":"衬衫的价格是19美元","can_delete":false,"product_type":"c1","uid":1397631,"ip_address":"","ucode":"655F925451F772","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","comment_is_top":false,"comment_ctime":1601196050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601196050","product_id":100017301,"comment_content":"推荐人这个该有一个很大的问题，如果记录数量非常多，达到几十亿条记录这样的规模，甚至都无法一次性加载到内存中，这时要如何处理呢","like_count":0},{"had_liked":false,"id":249198,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1797622,"ip_address":"","ucode":"A76DD12FFBA1EF","user_header":"https://static001.geekbang.org/account/avatar/00/1b/6d/f6/183a831e.jpg","comment_is_top":false,"comment_ctime":1600499950,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600499950","product_id":100017301,"comment_content":"加debug条件，找到需要打断点的那一层<br>增加调试代码，例如出现死循环时，需要找到哪一层开始死循环的","like_count":0},{"had_liked":false,"id":248431,"user_name":"蹲脚麻~","can_delete":false,"product_type":"c1","uid":1556876,"ip_address":"","ucode":"9048137880C66D","user_header":"https://static001.geekbang.org/account/avatar/00/17/c1/8c/19856665.jpg","comment_is_top":false,"comment_ctime":1600161763,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600161763","product_id":100017301,"comment_content":"不知道有没有人和我一样有这样的困惑，我想了好久才说服自己。<br>按照倒叙的思路，大家总结的是：到达N=到达N-1+到达N-2;<br>但是我的想法是：到达N=到达N-1时再走一步，或者到达N-2的时候再走两步或（一步+一步（这种情况会和前面的N-1情况重合））。<br>所以我一直以为：到达N =（ 到达N-1的情况+上一个台阶 ）+（到达N-2的情况+上两个台阶）。<br>即：f(n) = f(n-1)+1+f(n-2)+1;<br>后来我才发觉我纠结在了上台阶的个数上了，题目的意思是求到达台阶的方式数量，而到达N-1个台阶和到达N-2个台阶时都只会有一种方式到达N台阶。<br>所以：到达N =（ 到达N-1的情况 ）+（到达N-2的情况）。","like_count":0},{"had_liked":false,"id":245874,"user_name":"Geek_a43198","can_delete":false,"product_type":"c1","uid":2155962,"ip_address":"","ucode":"EAACF51688E165","user_header":"","comment_is_top":false,"comment_ctime":1599099720,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599099720","product_id":100017301,"comment_content":"递归感觉是自顶向下的思路，循环自底向上的思路。不知道理解的对不对","like_count":0},{"had_liked":false,"id":245447,"user_name":"怕什么，抱紧我","can_delete":false,"product_type":"c1","uid":1318633,"ip_address":"","ucode":"CBCEA76E9EF33B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/e9/dcc63d8f.jpg","comment_is_top":false,"comment_ctime":1598946597,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1598946597","product_id":100017301,"comment_content":"重复计算没看懂，从根结点到叶子结点算一种走法，虽然同时出现多个f（3），但是总体的走法是不一样的，何来的重复计算，望告知","like_count":0},{"had_liked":false,"id":245378,"user_name":"剑影梦残","can_delete":false,"product_type":"c1","uid":1284481,"ip_address":"","ucode":"A5C5DAA49F6996","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/XSnxM4uP67mVu7ZtPxWqUIvFH15pibGt1rFd34EiblN6NFfgKEKBuibLlI1kUjOIfbY56icwBibn6MmXzSEXm7AHicdQ/132","comment_is_top":false,"comment_ctime":1598927826,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598927826","product_id":100017301,"comment_content":"1.检测环 使用字典，添加一个的时候就加入。如果当前值已经在字典，那就是代码出现过   2.使用打印日志查看递归是否符合预期","like_count":0},{"had_liked":false,"id":241714,"user_name":"Co🥥chO","can_delete":false,"product_type":"c1","uid":2116626,"ip_address":"","ucode":"8699B3332A622B","user_header":"https://static001.geekbang.org/account/avatar/00/20/4c/12/76fc82b6.jpg","comment_is_top":false,"comment_ctime":1597398586,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597398586","product_id":100017301,"comment_content":"条件允许的话，有时候可以用尾递归解决堆栈溢出的情况","like_count":0},{"had_liked":false,"id":239090,"user_name":"陈琦","can_delete":false,"product_type":"c1","uid":1607864,"ip_address":"","ucode":"48F974137EF0BE","user_header":"https://static001.geekbang.org/account/avatar/00/18/88/b8/7527da95.jpg","comment_is_top":false,"comment_ctime":1596433448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596433448","product_id":100017301,"comment_content":"思考递归题时经常给自己绕糊涂","like_count":0},{"had_liked":false,"id":237945,"user_name":"星星滴蓝天","can_delete":false,"product_type":"c1","uid":1465990,"ip_address":"","ucode":"2F2F56F93AD828","user_header":"https://static001.geekbang.org/account/avatar/00/16/5e/86/40877404.jpg","comment_is_top":false,"comment_ctime":1596011533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596011533","product_id":100017301,"comment_content":"idea是可以的，idea的Frames里面的栈帧显示的很详细，debug的时候能详细看到过程","like_count":0},{"had_liked":false,"id":237869,"user_name":"远心","can_delete":false,"product_type":"c1","uid":1206787,"ip_address":"","ucode":"1157202C315655","user_header":"https://static001.geekbang.org/account/avatar/00/12/6a/03/cb597311.jpg","comment_is_top":false,"comment_ctime":1595990020,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595990020","product_id":100017301,"comment_content":"文章中两个将「递归代码」改造成「迭代循环代码」的例子，空间复杂度从 O(n) 降为了 O(1)，但是时间复杂度不变，仍然是 O(1)。从这个角度看，还是有些好处的。","like_count":0},{"had_liked":false,"id":237560,"user_name":"朱小倩","can_delete":false,"product_type":"c1","uid":2068474,"ip_address":"","ucode":"0684CFC388ABDD","user_header":"","comment_is_top":false,"comment_ctime":1595863387,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595863387","product_id":100017301,"comment_content":"用一个全局变量限制递归深度，解决方案还是很不靠谱的，因为抛出一个exception，还不是没有得到结果，只是相对安全的不让系统崩溃。","like_count":0},{"had_liked":false,"id":236830,"user_name":"陈琦","can_delete":false,"product_type":"c1","uid":1607864,"ip_address":"","ucode":"48F974137EF0BE","user_header":"https://static001.geekbang.org/account/avatar/00/18/88/b8/7527da95.jpg","comment_is_top":false,"comment_ctime":1595559402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595559402","product_id":100017301,"comment_content":"[下面的话怎么理解]<br>将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。","like_count":0},{"had_liked":false,"id":236072,"user_name":"Wizard","can_delete":false,"product_type":"c1","uid":1916084,"ip_address":"","ucode":"EEC2AC00BBED06","user_header":"https://static001.geekbang.org/account/avatar/00/1d/3c/b4/60e20977.jpg","comment_is_top":false,"comment_ctime":1595303553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595303553","product_id":100017301,"comment_content":"tail recursion也是一種可以消除堆棧溢出的方法，透過直接回傳函數回傳（等於是連續回傳兩次），省去在棧中新增回傳位置，優化空間複雜度。","like_count":0},{"had_liked":false,"id":235257,"user_name":"逍遥朱雀","can_delete":false,"product_type":"c1","uid":1236152,"ip_address":"","ucode":"E91DF893862A84","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/b8/eb53e0a8.jpg","comment_is_top":false,"comment_ctime":1594953075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594953075","product_id":100017301,"comment_content":"package com.leyb.demo.controller;<br><br>import java.util.HashMap;<br>import java.util.Map;<br>&#47;**<br> * 最终推荐人简单实现（递归），有问题还请指教<br> * @author Administrator<br> *<br> *&#47;<br>public class Demo1 {<br>\t<br>\tstatic Map&lt;String,String&gt; map = new HashMap&lt;String, String&gt;();<br>\t\t<br>\t<br>\tpublic static String getpc(String id,int count) throws Exception {<br>\t\tif(count &gt; 10) {<br>\t\t\tthrow new Exception();<br>\t\t}<br>\t\tString pId = map.get(id);<br>\t\tif (pId == null) return id;<br>\t\t++ count;<br>\t\treturn getpc(pId,count);<br>\t}<br>\t<br>\tpublic static void main(String[] args) throws Exception {<br>\t\tmap.put(&quot;A&quot;, &quot;B&quot;);<br>\t\tmap.put(&quot;B&quot;, &quot;C&quot;);<br>\t\tmap.put(&quot;C&quot;, &quot;D&quot;);<br>\t\tmap.put(&quot;D&quot;, &quot;A&quot;);<br>\t\tString id = &quot;B&quot;;<br>\t\tint count = 0;<br>\t\tString r = getpc(id,count);<br>\t\tSystem.out.println(r);<br>\t}<br><br>}<br>","like_count":0},{"had_liked":false,"id":232953,"user_name":"Smile @ Life","can_delete":false,"product_type":"c1","uid":1293907,"ip_address":"","ucode":"320EDAD5A8BE56","user_header":"https://static001.geekbang.org/account/avatar/00/13/be/53/eda4b622.jpg","comment_is_top":false,"comment_ctime":1594176987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594176987","product_id":100017301,"comment_content":"可以用条件断点进行调试","like_count":0},{"had_liked":false,"id":232573,"user_name":"GeekYanger","can_delete":false,"product_type":"c1","uid":2046036,"ip_address":"","ucode":"E674B7D25261CC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/sOuSC65kXWdWBAIIs6uXAD41Ed8Wo8tib81LLVOQJ2oK23TgPDy6x0PGmp7rXwLR3BHOicaKx1zib1DyfpCITK3dw/132","comment_is_top":false,"comment_ctime":1594041810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594041810","product_id":100017301,"comment_content":"程序员的两道坎，完全理解递归 和 完全理解一个编译器","like_count":0},{"had_liked":false,"id":232148,"user_name":"delete is create","can_delete":false,"product_type":"c1","uid":1147979,"ip_address":"","ucode":"A8C751219A7746","user_header":"https://static001.geekbang.org/account/avatar/00/11/84/4b/e4738ba8.jpg","comment_is_top":false,"comment_ctime":1593872052,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593872052","product_id":100017301,"comment_content":"递归查询很可能查询好多次吧  有点类似n+1查询库  但是一次都查出来  又可能出现OOM问题  生产环境下如何处理？","like_count":0},{"had_liked":false,"id":232106,"user_name":"航","can_delete":false,"product_type":"c1","uid":2050135,"ip_address":"","ucode":"FFAE304D6D4AD6","user_header":"https://static001.geekbang.org/account/avatar/00/1f/48/57/f81acea8.jpg","comment_is_top":false,"comment_ctime":1593856055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593856055","product_id":100017301,"comment_content":"老师老师一个问题，我看到评论说如果可以说用迭代取代递归来解决堆栈问题，但是你在文章中不是说<br>用迭代取代递归的“思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。”吗？我想就这里你能解释一下怎么回事？评论里面个个都是大神，我只是小菜鸟啊","like_count":0},{"had_liked":false,"id":231713,"user_name":"无为而立","can_delete":false,"product_type":"c1","uid":2003887,"ip_address":"","ucode":"A74526BF43A077","user_header":"https://static001.geekbang.org/account/avatar/00/1e/93/af/54e2a654.jpg","comment_is_top":false,"comment_ctime":1593756712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593756712","product_id":100017301,"comment_content":"我一般都是打印日志，看递归","like_count":0},{"had_liked":false,"id":231513,"user_name":"憎爱不关心","can_delete":false,"product_type":"c1","uid":1133580,"ip_address":"","ucode":"A868ACB200C798","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/0c/ada45f25.jpg","comment_is_top":false,"comment_ctime":1593695024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593695024","product_id":100017301,"comment_content":"1.检测环，和检测已计算出的值一样，用map保存检测过的值。<br>2.给归值加打印","like_count":0},{"had_liked":false,"id":231472,"user_name":"LostGeneration","can_delete":false,"product_type":"c1","uid":1700504,"ip_address":"","ucode":"3DC1536ACCE985","user_header":"https://static001.geekbang.org/account/avatar/00/19/f2/98/150f51db.jpg","comment_is_top":false,"comment_ctime":1593682407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593682407","product_id":100017301,"comment_content":"换个角度想，递归求解也可以理解为倒推！所谓的递归终止条件实际就是问题求解的最后一步操作。我们无法一下就知道答案。但是我们能确定事件最后一刻发生的事，这样我们便能推断出最后一刻的前一刻发生了什么，一直推到开始。在代码上就表现为函数所传参数为参数的初始值，函数体第一步要做的事就是判断参数值是否是最终条件，如若不是参数递减再次调用，直到达到最终条件。","like_count":0},{"had_liked":false,"id":231189,"user_name":"﹏﹏那年一路向北","can_delete":false,"product_type":"c1","uid":1283457,"ip_address":"","ucode":"78DC51F9C50360","user_header":"https://static001.geekbang.org/account/avatar/00/13/95/81/ca409eb1.jpg","comment_is_top":false,"comment_ctime":1593604976,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1593604976","product_id":100017301,"comment_content":"递归这个真真切切搞死我了。一直想弄明白怎么去具体实现，但一次次失败。折磨了大概两天左右，想到了画树状图的方式、结合日志打印进入递归值和输出递归值、瞬间明了。小争的课程真的是一步步引导，刚刚明白递归的顺序含义、接着就告知注意重复、果然用空间换取时间、1999的递归瞬间完成、给大佬点赞","like_count":0},{"had_liked":false,"id":230666,"user_name":"zzZ","can_delete":false,"product_type":"c1","uid":1008191,"ip_address":"","ucode":"C450B79E495168","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/3f/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1593444520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593444520","product_id":100017301,"comment_content":"改成非递归的那段代码是不是就是动态规划，动态规划和递归思路好像","like_count":0},{"had_liked":false,"id":230410,"user_name":"罗樱罂","can_delete":false,"product_type":"c1","uid":2045997,"ip_address":"","ucode":"9072E79E625ED1","user_header":"https://static001.geekbang.org/account/avatar/00/1f/38/2d/f3c6493e.jpg","comment_is_top":false,"comment_ctime":1593365788,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593365788","product_id":100017301,"comment_content":"请问一下老师，递归方程的时间与空间复杂度要看应用的实例才能确定是吗？","like_count":0},{"had_liked":false,"id":229080,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1592893024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592893024","product_id":100017301,"comment_content":"递归顶多自己脑子递归俩次，然后就在往下递归了，脑子装不下，那种感觉很难受，习惯就好","like_count":0},{"had_liked":false,"id":227084,"user_name":"极客学子","can_delete":false,"product_type":"c1","uid":1149510,"ip_address":"","ucode":"40051597564EB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/46/71747b18.jpg","comment_is_top":false,"comment_ctime":1592278499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592278499","product_id":100017301,"comment_content":"1.可以通过打印 log 来跟踪执行步骤；<br>2.通过条件断点来进行调试，即可以定位到递归的某一步才开始断点调试，省略中间的繁琐递归过程","like_count":0},{"had_liked":false,"id":227062,"user_name":"Geek_dd8b2b","can_delete":false,"product_type":"c1","uid":1988075,"ip_address":"","ucode":"CBEF7C39075A96","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJX4ZU53F8hBHicctluqK6Ef3U0ib40bq1vFyAvqV0wu3GaPuWbj967OdMT7k0gl3OMxsfopvbk9veQ/132","comment_is_top":false,"comment_ctime":1592273696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592273696","product_id":100017301,"comment_content":"当你在第n台阶时，向下走到台阶0，那么此时你只有两种走法，向下走一步，或者向下走两步。走一步之后的走法就是由f（n-1）决定的，若是走两步下去，就在n-2这个台阶，那么剩下来的走法就是由f（n-2）决定的。所以你在n台阶时候，总共就是走一步和走两步之后的走法之和。所以f（n）=f（n-1）+f（n-2）","like_count":0},{"had_liked":false,"id":226633,"user_name":"sam","can_delete":false,"product_type":"c1","uid":1000417,"ip_address":"","ucode":"8D48F4B9045947","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/e1/b7be5560.jpg","comment_is_top":false,"comment_ctime":1592162404,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592162404","product_id":100017301,"comment_content":"学完这课，我怎么感觉递归很简单了…理解起来也没那么难","like_count":0},{"had_liked":false,"id":226455,"user_name":"JayceMei","can_delete":false,"product_type":"c1","uid":1586248,"ip_address":"","ucode":"95643F7EF2D4B3","user_header":"https://static001.geekbang.org/account/avatar/00/18/34/48/970fd29f.jpg","comment_is_top":false,"comment_ctime":1592108594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592108594","product_id":100017301,"comment_content":"递归是 自顶向下 求解， 遇到重复计算时， 使用备忘录 减少不必要的计算耗时<br>非递归 是自底向上 求解， 就是动态规划了","like_count":0},{"had_liked":false,"id":225919,"user_name":"Geek_849f9f","can_delete":false,"product_type":"c1","uid":2027473,"ip_address":"","ucode":"67601F35A91999","user_header":"","comment_is_top":false,"comment_ctime":1591889107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591889107","product_id":100017301,"comment_content":"递归最重要的是找到A问题分解成子问题A、B、C的规律以及终止条件","like_count":0},{"had_liked":false,"id":224402,"user_name":"七月","can_delete":false,"product_type":"c1","uid":1988043,"ip_address":"","ucode":"876EE5EAEC9DC4","user_header":"https://static001.geekbang.org/account/avatar/00/1e/55/cb/9c23f47d.jpg","comment_is_top":false,"comment_ctime":1591369810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591369810","product_id":100017301,"comment_content":"打印设置断点，是不是有递归值;<br>发现斐波那契数列 用递归方法。","like_count":0},{"had_liked":false,"id":222032,"user_name":"Geek_69cfd7","can_delete":false,"product_type":"c1","uid":2007777,"ip_address":"","ucode":"BFC4B586FA65F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/orTaVwTib3ribTl5wibBQPniclzNVJMXCDw4ic4P2Q3A6MBEyuqg5AY46o4SPmIKm8vgIqnUzzqbEhIfQRQBtY7q6JQ/132","comment_is_top":false,"comment_ctime":1590659378,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1590659378","product_id":100017301,"comment_content":"检测环就是检测查询的数据是否在之前的栈内曾经被查出过，用散列表保存以前的数据进行contains判断","like_count":0},{"had_liked":false,"id":220348,"user_name":"Geek_py hang","can_delete":false,"product_type":"c1","uid":1915167,"ip_address":"","ucode":"E1DABF14C9176B","user_header":"https://static001.geekbang.org/account/avatar/00/1d/39/1f/579ae900.jpg","comment_is_top":false,"comment_ctime":1590225419,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590225419","product_id":100017301,"comment_content":"父子同模式循环","like_count":0},{"had_liked":false,"id":219125,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1589950450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589950450","product_id":100017301,"comment_content":"递归适用场景:  大问题可以划分为小问题，大小问题的处理方法一致，有跳出递归的边界。<br><br>递归的缺点:  递归太多容易栈溢出，空间复杂度是O(n),重复计算多等","like_count":0},{"had_liked":false,"id":218914,"user_name":"guan0078","can_delete":false,"product_type":"c1","uid":1090467,"ip_address":"","ucode":"53B15FF3752A40","user_header":"https://static001.geekbang.org/account/avatar/00/10/a3/a3/804fb3e9.jpg","comment_is_top":false,"comment_ctime":1589897714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589897714","product_id":100017301,"comment_content":"可以在递归中打日志。或者增加容易出错情况的assertion判断","like_count":0},{"had_liked":false,"id":217685,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1589587794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589587794","product_id":100017301,"comment_content":"递归适用场景: 问题能拆分小问题，且拆分的问题求解思路一样，存在递归终止条件。<br>实现递归时，主要是思考递归公式，然后再思考终止条件。<br>递归存在太多的方法调用，空间复杂度高，容易引起栈溢出，而且时间复杂度是2n","like_count":0},{"had_liked":false,"id":217618,"user_name":"iris","can_delete":false,"product_type":"c1","uid":1986106,"ip_address":"","ucode":"8D54D1DBEA6F64","user_header":"https://static001.geekbang.org/account/avatar/00/1e/4e/3a/1932100c.jpg","comment_is_top":false,"comment_ctime":1589549056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589549056","product_id":100017301,"comment_content":"1、递归的核心有两个：递归公式+递归终止条件。<br>2、递归产生的问题1:重复计算，用散列表将每个计算出来的值存起来，每次计算新值去比较一下。<br>问题2:堆栈益处，用一个全局变量来控制递归的深度，但这种方法实用性比较低，一般不知道深度或者一边递归一边计算也耗时过大。<br>3、了解到过多的函数调用回耗时较多，以前没有这个概念今天知道了<br>4、递归都可以改也成非递归，但递归底层实现也是这样的，所以必要性不高。<br>","like_count":0},{"had_liked":false,"id":217102,"user_name":"Geek_Akara","can_delete":false,"product_type":"c1","uid":1991279,"ip_address":"","ucode":"E86A5A9EEC8BFF","user_header":"https://static001.geekbang.org/account/avatar/00/1e/62/6f/06d476f7.jpg","comment_is_top":false,"comment_ctime":1589420625,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589420625","product_id":100017301,"comment_content":"检测环可以用Floyd环检测算法（快慢指针）跟散列表（存储所有直进行对比），可以解决LeetCode 202 Happy Number 的问题。","like_count":0},{"had_liked":false,"id":216879,"user_name":"jllzc","can_delete":false,"product_type":"c1","uid":1243326,"ip_address":"","ucode":"D7DC42E59587E0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/GEsrR5BvcKoiaFEdmhNz17cJNB9esY5VpUgeP5IEPwCwiaDKW2ubt50ibjm5kZN4AIM16piaG8wRSfg3oQUrkenY9g/132","comment_is_top":false,"comment_ctime":1589361482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589361482","product_id":100017301,"comment_content":"学递归的好处，<br>女朋友说：我明天也爱你。<br>不会递归：只有今天和明天爱我？<br>会递归：爱我永远","like_count":0},{"had_liked":false,"id":214714,"user_name":"Geek_5dcf01","can_delete":false,"product_type":"c1","uid":1742078,"ip_address":"","ucode":"C5B01399CFC950","user_header":"https://wx.qlogo.cn/mmopen/vi_32/w9qKgqGnYczWDJtiawlW1NLmoIltqhuEyDf7Tze74wQtQthFaxF4tqBNTKCuJ4r6zVAGBm6qc1sdKJL0LBeAH6w/132","comment_is_top":false,"comment_ctime":1588808081,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588808081","product_id":100017301,"comment_content":"跳台阶问题，从n到1涉及到n－1，n－2……重复计算，而从1到n会避免这种情况，1到n的每个值只计算了一次。","like_count":0},{"had_liked":false,"id":213816,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1588567478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588567478","product_id":100017301,"comment_content":"分解子问题，写出递推公式，分析递归的终止条件，其实每一个子问题的结果都是终止条件的值，例如，当我走第10个楼梯时，摆在我面前的只有两种走法，要么迈出两步，要么迈出一步，即f(2)或f(1)，当然，前提是剩余的楼梯大于等于2，我感觉递归对于我来说，写递推公式这个环节有点困难，可能是我数学基础太差的缘故。","like_count":0},{"had_liked":false,"id":213425,"user_name":"Geek_ac7784","can_delete":false,"product_type":"c1","uid":1981613,"ip_address":"","ucode":"62F0E5E6D6F4BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","comment_is_top":false,"comment_ctime":1588410510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588410510","product_id":100017301,"comment_content":"学习感悟：<br>1. 递归的字面理解：递就是将子问题传递给小弟，归就是小弟把小问题的结果带回来，然后自己把子问题结合起来。<br>2. 递归容易陷入不断向深处思考的误区，解决办法是想象直接分解成的几个小问题已经解决了，只需要考虑这几个直接的小问题和主问题这一步之间的关系就行。<br>3. 递归函数的写法：想好递归函数和终止条件。<br>4. 递归容易产生的问题：<br>    堆栈溢出：全局变量表示递归深度<br>    问题重复：利用哈希表来存储已经解决的问题<br>    脏数据形成环：后面再说<br>5. 递归改写：理论上都可以改写成循环的方式(文章中没有写出具体方法)，但是改写不一定好，徒增写代码的难度。<br>6. 可以用递归解决的问题：<br>    1. 问题可以划分为几个子问题的和<br>    2. 子问题除了数据规模，与主问题没有任何区别<br>    3. 存在递归终止条件<br>7. 递归调试(转载其他人问题)：<br>    1. 打印日志<br>    2. 条件断点着重调试最初几部和最后几步即可","like_count":0},{"had_liked":false,"id":213423,"user_name":"不需往后看","can_delete":false,"product_type":"c1","uid":1015410,"ip_address":"","ucode":"33EB4793C67B72","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/72/3aeca403.jpg","comment_is_top":false,"comment_ctime":1588410367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588410367","product_id":100017301,"comment_content":"老师你好，连看了几篇文章，非常受用，感谢分享。补充个问题，查找推荐人 这个解决思路还存在一个问题，会导致触发多个 查询 sql。","like_count":0},{"had_liked":false,"id":213353,"user_name":"Net Scotte","can_delete":false,"product_type":"c1","uid":1283297,"ip_address":"","ucode":"83DFAA31D487A3","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/e1/f3f0015d.jpg","comment_is_top":false,"comment_ctime":1588392199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588392199","product_id":100017301,"comment_content":"递归算法尽量使用尾递归，让递归调用只发生在函数尾部，这样编译器会做优化，从而避免堆栈溢出问题","like_count":0},{"had_liked":false,"id":212878,"user_name":"请叫我和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1588230735,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1588230735","product_id":100017301,"comment_content":"## 什么样的适合递归<br><br>1. 一个问题的解可以分解为几个子问题的解<br>2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样<br>3. 存在递归终止条件<br><br>## 如何写出递归的代码<br><br>1. 找到子问题之间的关系——&gt;递归公式<br>2. 递归问题的结束条件——&gt;终止条件<br><br>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码<br><br>## 如何理解递归<br><br>思维误区：把递归的每一层都去搞明白，去推敲，把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。<br><br>正确思维：如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，<br><br>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。<br><br>## 递归代码要注意的问题<br><br>1. 递归层次过多引起堆栈溢出<br>   - 解决办法：当递归层次在肉眼可见的很小情况下，可以写一个全局depth的变量记录深度，当深度 &gt; 多少的时候直接做处理<br>2. 警惕重复计算<br>   - 简单例子，爬楼梯那个问题<br><br>## 递归改非递归<br>","like_count":0},{"had_liked":false,"id":210288,"user_name":"默默","can_delete":false,"product_type":"c1","uid":1006635,"ip_address":"","ucode":"AF798B9D327F24","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/2b/8b771383.jpg","comment_is_top":false,"comment_ctime":1587714546,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587714546","product_id":100017301,"comment_content":"递归的调试，个人觉得ide调试还是最有效的。不过调试有技巧，在递归函数终止的地方打断点，查看一层一层回调的过程，只调试归的过程，不调试递的过程。","like_count":0},{"had_liked":false,"id":210236,"user_name":"完美坚持","can_delete":false,"product_type":"c1","uid":1919541,"ip_address":"","ucode":"AE0261D8DDEF64","user_header":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","comment_is_top":false,"comment_ctime":1587703237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587703237","product_id":100017301,"comment_content":"递归的缺点：<br><br>1.容易堆栈溢出：函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。<br>解决，设置堆栈深度。<br>1.1大量的函数调用，不仅有可观的时间成本，保存递归调用的现场数据，空间复杂度相对可能较高。<br>2.除此之外，使用递归时还会出现重复计算的问题。解决办法，用一个小本本(散列表)来记录已经计算出的值。<br><br>用非递归的方式写递归：<br>警惕一种思路，手工实现栈——这对于我们理解递归依赖的底层栈结构是有帮助的，但是实际开发中，这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。","like_count":0},{"had_liked":false,"id":208674,"user_name":"海之蓝","can_delete":false,"product_type":"c1","uid":1257821,"ip_address":"","ucode":"7C994B7797533E","user_header":"https://static001.geekbang.org/account/avatar/00/13/31/5d/a416ac29.jpg","comment_is_top":false,"comment_ctime":1587398606,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587398606","product_id":100017301,"comment_content":"学习递归：1、首先将大问题分解为多个小问题，大问题与小问题的解决思路是一致的，只不过他们的数量级有差别；2、找到终止条件；3、写出递推公式。","like_count":0},{"had_liked":false,"id":208671,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1587397862,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1587397862","product_id":100017301,"comment_content":"对于递归，我一直感觉是比较反人类直觉的，但是如果从分解子问题、递推公式以及递归终止条件去考虑，似乎递归反而是相对容易的（当然，时间复杂度不一定最优）。我以前似乎就是按照平铺直叙的方式去看递归，结果搞得自己被绕了进去，然后“脑栈溢出”。<br><br>上楼梯问题最后变成了斐波那切数列数列，文章里面讲解的挺清楚的。<br><br>我感觉堆栈溢出是属于递归法的固有缺陷，似乎是因为在重复调用的时候需要存储每次调用的参数，空间复杂度比较高；而重复计算，应该是递归本身特点，而且大部分情况下，应该是可以优化的。<br><br>将递归改为非递归没有什么好处么？改为非递归后，至少能够避免堆栈溢出，空间复杂度和时间复杂度应该也会有所优化。<br><br>对于课后思考题，如果是调试递归代码，那我只能加输入语句，把每次递归的参数都打印出来看看了。","like_count":0},{"had_liked":false,"id":208405,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1587351626,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587351626","product_id":100017301,"comment_content":"60天攻克算法打卡行动第8天<br><br>学习内容 : 递归：如何用三行代码找到“最终推荐人”？<br><br>递归代码难理解，写起来也很复杂。掌握下面5个问题，我们就能通过这三步：分解大问题、写出递推公式、找出终止条件，掌握递归，解决复杂问题。<br><br>1.如何理解“递归”<br>去的过程叫递，回来的过程叫归。<br>2.递归需要满足的三个条件<br>-&gt;一个问题的解可以分解为几个子问题的解；-&gt;这个问题与分解的子问题，除了数据规模不同，求解思路完全一样\t -&gt;存在递归终止条件，不可能一直循环下去<br>3.如何编写递归代码<br>找到大化小的规律，写出递推公式，推敲终止条件，最后翻译成代码。<br>4.编写递归代码时的常见问题：堆栈溢出、重复计算<br>调用层次很深，一直压入栈，就会又堆栈溢出的风险。分解后的小分支总会依赖于前面的分支计算，所以一开始的首分支就会重复计算多次。<br>5.怎么将递归代码改写为非递归代码<br>利用递归表达力很强，写起来代码简洁；弊端是空间复杂度高，有堆栈溢出的风险，存在重复计算，过多的函数调用会耗时较多等问题。所有递归都可以转换为非递归的写法，但并未解决递归的几个问题。<br><br>对于递归调试，可以在代码中加上日志打印，这次进来的是由谁进来的，也就是前驱后继的形式作为debug跟踪。","like_count":0},{"had_liked":false,"id":208388,"user_name":"russellyue","can_delete":false,"product_type":"c1","uid":1541894,"ip_address":"","ucode":"0758ACF772F9C1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epIMwPE6FwsicZ6bjhu7ZpWLnoib8G76sA1XL8y5W8GxqfQEjBub6g57E60mzjWzrA6icMRw1QT5CpyA/132","comment_is_top":false,"comment_ctime":1587348427,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587348427","product_id":100017301,"comment_content":"总结：去的过程叫“递”，回来的过程叫“归”。什么样的问题可以用递归来解决？一个问题可以被分解为多个子问题；子问题除了数据规模的差别，跟原问题没有任何区别；有终止条件；如何写出递归代码？写出递推公式，找出递归终止条件。为什么人脑难以理解含有多个分支的递归过程？当递归的深度够深时，我们的脑袋里依然想要演算一层一层往下调，然后再一层一层返回的过程。我们的人脑其实不太擅长这种过程的演算，所以试图去想清楚递归的每个递和归的过程其实是陷入了一种思维误区。正确的做法是，我们脑子里应该假设子问题已经解决的情况下，如何去解决父问题。这其实类似于api调用，我们假设api是工作的，基于这个api我们去解决问题。应用递归需要警惕的几个问题：警惕堆栈溢出，在JavaScript中，每一次调用一次函数，就会把函数的执行环境压入调用栈中，只有在函数返回时，执行环境才会被清除。递归的深度太深，就会导致调用栈溢出。如何避免调用堆栈溢出，可以限制递归的最大深度，如果超过最大深度，那么就抛出错误。递归代码警惕重复运算，可以将运算结果保存到散列表中从而减少重复的计算；时间和空间成本的增加，在JavaScript中，调用一个函数时，需要创建一个执行环境，并将其压入调用栈中。这个过程本身就需要一定的时间。当然，增加的执行环境也增加了空间成本。","like_count":0},{"had_liked":false,"id":207882,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1587204852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587204852","product_id":100017301,"comment_content":"走台阶的问题应该倒推分析吧。假设这n阶台阶总共走了x步，总共走法等于前1步走法之和相加。前一步可能是n-1也可能是n-2。以此类推得出递推公示f(n) = f(n-1) + f(n-2)","like_count":0},{"had_liked":false,"id":207757,"user_name":"爱吃胡萝卜","can_delete":false,"product_type":"c1","uid":1459413,"ip_address":"","ucode":"35FCF84D1E04C5","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/d5/ca522e83.jpg","comment_is_top":false,"comment_ctime":1587175029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587175029","product_id":100017301,"comment_content":"调试递归的话 ，可以使用条件断点，查看关键位置的代码是否正确","like_count":0},{"had_liked":false,"id":206197,"user_name":"梅端","can_delete":false,"product_type":"c1","uid":1525335,"ip_address":"","ucode":"FEC08731457770","user_header":"https://static001.geekbang.org/account/avatar/00/17/46/57/fe38a6db.jpg","comment_is_top":false,"comment_ctime":1586822600,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586822600","product_id":100017301,"comment_content":"对递归和递归求解有了更深入的了解，算法学习打卡第三天，继续加油。","like_count":0},{"had_liked":false,"id":205985,"user_name":"遇见","can_delete":false,"product_type":"c1","uid":1624590,"ip_address":"","ucode":"FAF53CD4C28494","user_header":"https://static001.geekbang.org/account/avatar/00/18/ca/0e/5009c5ff.jpg","comment_is_top":false,"comment_ctime":1586768206,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586768206","product_id":100017301,"comment_content":"主要要把当前递归值打印出来，就能知道到底是递归到几次层的时候出的问题。","like_count":0},{"had_liked":false,"id":205616,"user_name":"yoummg","can_delete":false,"product_type":"c1","uid":1067856,"ip_address":"","ucode":"1B809CFDD7A508","user_header":"https://static001.geekbang.org/account/avatar/00/10/4b/50/fdecd51a.jpg","comment_is_top":false,"comment_ctime":1586686448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586686448","product_id":100017301,"comment_content":"使用递归，明确三个条件：1.问题可以拆分成几个小问题 2. 问题拆分成小问题，除了数据规模，解决问题思路没变 3.存在递归终止条件<br><br>明确使用递归的缺点：栈溢出，重复值计算等<br><br>写出递归的关键是，不要试图一步一步拆解递归的过程，而是可以抽象写出递推公式。","like_count":0},{"had_liked":false,"id":205304,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1586589207,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586589207","product_id":100017301,"comment_content":"分层，一层一层思考，聚焦在当前层，而不是同时思考所有层。","like_count":0},{"had_liked":false,"id":202833,"user_name":"201201177","can_delete":false,"product_type":"c1","uid":1901015,"ip_address":"","ucode":"8E2C0DB7A4D3D4","user_header":"","comment_is_top":false,"comment_ctime":1586074971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586074971","product_id":100017301,"comment_content":"递归的调试方式，根据输入条件打断点。","like_count":0},{"had_liked":false,"id":201741,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1585831072,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585831072","product_id":100017301,"comment_content":"&lt;?php<br>$haveStep = [];<br>function f($n) {<br>\tglobal $haveStep;<br>\tif ($n &lt; 1) {<br>\t\techo &quot;输入数据不合法&quot;;<br>\t}<br>\tif ($n==1) return 1;<br>\tif ($n==2) return 2;<br>\tif (!empty($haveStep[$n])) return $haveStep[$n];<br>\t<br>\t$ret = f($n-1) + f($n-2);<br>\t$haveStep[$n] = $ret;<br>\treturn $ret;<br>}<br><br>echo f(3);<br>echo &#39;&lt;br&gt;&#39;;<br>echo f(4);","like_count":0},{"had_liked":false,"id":200655,"user_name":"SkillIP","can_delete":false,"product_type":"c1","uid":1744250,"ip_address":"","ucode":"60EAEB93EC6858","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/7a/fb762fea.jpg","comment_is_top":false,"comment_ctime":1585629769,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585629769","product_id":100017301,"comment_content":"可以用双指针检测环","like_count":0},{"had_liked":false,"id":200600,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1585622815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585622815","product_id":100017301,"comment_content":"调试递归:+1<br>1.打印日志发现，递归值。<br>2.结合条件断点进行调试","like_count":0},{"had_liked":false,"id":200075,"user_name":"yezi","can_delete":false,"product_type":"c1","uid":1935780,"ip_address":"","ucode":"B2E5CC51D37C44","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/AiaYGqeT5oDEUaRq2vVLOIesrnPwJH3VfN8tb3CZlAbxW9QYo6TfPqUS8c4ibAyibsn1955GK3EOJsjFFKXRbSYvA/132","comment_is_top":false,"comment_ctime":1585539988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585539988","product_id":100017301,"comment_content":"设置边界值，进行测试","like_count":0},{"had_liked":false,"id":194425,"user_name":"小锅","can_delete":false,"product_type":"c1","uid":1244031,"ip_address":"","ucode":"A1D46851246755","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/7f/5da88fb5.jpg","comment_is_top":false,"comment_ctime":1585059410,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585059410","product_id":100017301,"comment_content":"台阶那个我一开始用的列举的方式，因为思维一开始没转变过来，后续思考了一下。大概思路是这样的：你如果要走到n个台阶，那你最后的方式是到n-1这个台阶，或到n-2这个台阶才有能实现到第n个台阶这么个过程，也就是说到第n-1个台阶的方法和到第n-2个台阶的方法都适用于到第n个台阶，那到第n个台阶的方法就有到第n-1个台阶和第n-2个台阶的方法的总合。不知道这样理解对不，可能是我胡说八道的吧，哈哈哈～","like_count":0},{"had_liked":false,"id":194391,"user_name":"SteelHuaSheng","can_delete":false,"product_type":"c1","uid":1396126,"ip_address":"","ucode":"BC8127FC5207FC","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/9e/04ec08bf.jpg","comment_is_top":false,"comment_ctime":1585057334,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585057334","product_id":100017301,"comment_content":"把递归改成迭代循环是自己骗自己吗？","like_count":0},{"had_liked":false,"id":194371,"user_name":"SteelHuaSheng","can_delete":false,"product_type":"c1","uid":1396126,"ip_address":"","ucode":"BC8127FC5207FC","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/9e/04ec08bf.jpg","comment_is_top":false,"comment_ctime":1585055195,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585055195","product_id":100017301,"comment_content":"我们仔细想下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了 1 个台阶，另一类是第一步走了 2 个台阶。所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 加上先走 2 阶后，n-2 个台阶的走法。用公式表示就是：<br><br>这个我理解的有点迷糊，这什么脑回路？<br>这是正着想吗？<br>我先走1步，然后走剩下的？<br>或者我先走2步，然后走剩下的？<br>正着想，我想不通。。。阿西吧。。。<br><br>我觉得倒着想比较好想：<br>我要么从n-1级台阶跨1步上来<br>要么从n-2级台阶跨2步上来","like_count":0},{"had_liked":false,"id":192000,"user_name":"獨自去遠方","can_delete":false,"product_type":"c1","uid":1503941,"ip_address":"","ucode":"E246B33F397441","user_header":"https://static001.geekbang.org/account/avatar/00/16/f2/c5/2a441c27.jpg","comment_is_top":false,"comment_ctime":1584809263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584809263","product_id":100017301,"comment_content":"递归<br>\t三个条件<br>\t\t1.问题的解可以分为子问题的解<br>\t\t2.问题分解之后的子问题，求解思路一致<br>\t\t3.存在终止条件<br>\t如何编写代码<br>\t\t写出递推公式<br>\t\t找到终止条件<br><br>\t警惕<br>\t\t堆栈溢出<br>\t\t重复计算<br>\t\t\t存储计算过的值","like_count":0},{"had_liked":false,"id":191181,"user_name":"X  W  z","can_delete":false,"product_type":"c1","uid":1235441,"ip_address":"","ucode":"915BA1CF6090F7","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/f1/a00711f8.jpg","comment_is_top":false,"comment_ctime":1584752807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584752807","product_id":100017301,"comment_content":"例子“电影院询问我在第几排”，好像有点悖论的意思哈。不知道我是不是，疫情期间没事干，想歪了。<br>n是啥。若是=问的人？=问的人的排数？。那计算的意义呢，嘻嘻。现在中我知道“到我停止+1”：<br>1、程序如果知道了我在哪，那不正是我想要的结果？。<br>2、程序不知道我在哪，“归”什么时候停止呢。<br>这个例子中的，n应该就是想要的结果？，输入=结果？","like_count":0},{"had_liked":false,"id":191175,"user_name":"雨落千木的时节","can_delete":false,"product_type":"c1","uid":1796430,"ip_address":"","ucode":"A268063299F0D6","user_header":"https://static001.geekbang.org/account/avatar/00/1b/69/4e/7ef7604b.jpg","comment_is_top":false,"comment_ctime":1584752619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584752619","product_id":100017301,"comment_content":"递归和动态规划真的是太难了，每次都写不好","like_count":0},{"had_liked":false,"id":190721,"user_name":"Evan","can_delete":false,"product_type":"c1","uid":1344281,"ip_address":"","ucode":"B877ABD0CF4661","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/19/0a3fe8c1.jpg","comment_is_top":false,"comment_ctime":1584686982,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1584686982","product_id":100017301,"comment_content":"递归  三个条件， 递和归分析，另外详细分解问题，从易入手的得解决问题","like_count":0},{"had_liked":false,"id":190604,"user_name":"o0oi1i","can_delete":false,"product_type":"c1","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1584672014,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584672014","product_id":100017301,"comment_content":"打卡10","like_count":0},{"had_liked":false,"id":188754,"user_name":"Louis","can_delete":false,"product_type":"c1","uid":1710046,"ip_address":"","ucode":"9A8A67FE6A1BF6","user_header":"https://static001.geekbang.org/account/avatar/00/1a/17/de/36000c5a.jpg","comment_is_top":false,"comment_ctime":1584411926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584411926","product_id":100017301,"comment_content":"哈哈哈，找递推公式是关键。","like_count":0},{"had_liked":false,"id":188278,"user_name":"极客雷","can_delete":false,"product_type":"c1","uid":1041465,"ip_address":"","ucode":"0DBAC4CB9C7BCD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e4/39/a06ade33.jpg","comment_is_top":false,"comment_ctime":1584334387,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584334387","product_id":100017301,"comment_content":"数学要学的好","like_count":0},{"had_liked":false,"id":187579,"user_name":"zouz","can_delete":false,"product_type":"c1","uid":1172368,"ip_address":"","ucode":"EBC8E9DD8EB0B0","user_header":"https://static001.geekbang.org/account/avatar/00/11/e3/90/84eb5682.jpg","comment_is_top":false,"comment_ctime":1584162587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584162587","product_id":100017301,"comment_content":"走阶梯那个，为什么是不是用排列组合中的乘法原理，到现在都没有想明白。","like_count":0},{"had_liked":false,"id":186837,"user_name":"james","can_delete":false,"product_type":"c1","uid":1232771,"ip_address":"","ucode":"AC42035106E5B9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/yyibGRYCArsUNBfCAEAibua09Yb9D5AdO8TkCmXymhAepibqmlz0hzg06ggBLxyvXicnjqFVGr7zYF0rQoZ0aXCBAg/132","comment_is_top":false,"comment_ctime":1583936446,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1583936446","product_id":100017301,"comment_content":"总结<br><br>一、什么是递归？<br><br>1.递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。<br>2.方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。<br>3.基本上，所有的递归问题都可以用递推公式来表示，比如<br>f(n) = f(n-1) + 1;<br>f(n) = f(n-1) + f(n-2);<br>f(n)=n*f(n-1);<br><br>二、为什么使用递归？递归的优缺点？<br><br>1.优点：代码的表达力很强，写起来简洁。<br>2.缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。<br><br>三、什么样的问题可以用递归解决呢？<br><br>一个问题只要同时满足以下3个条件，就可以用递归来解决：<br>1.问题的解可以分解为几个子问题的解。何为子问题？就是数据规模更小的问题。<br>2.问题与子问题，除了数据规模不同，求解思路完全一样<br>3.存在递归终止条件<br><br>四、如何实现递归？<br><br>1.递归代码编写<br>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。<br>2.递归代码理解<br>对于递归代码，若试图想清楚整个递和归的过程，实际上是进入了一个思维误区。<br>那该如何理解递归代码呢？如果一个问题A可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。<br>因此，理解递归代码，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。<br><br>五、递归常见问题及解决方案<br><br>1.警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。<br>2.警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。<br><br>六、如何将递归改写为非递归代码？<br><br>笼统的讲，所有的递归代码都可以改写为迭代循环的非递归写法。如何做？抽象出递推公式、初始值和边界条件，然后用迭代循环实现。","like_count":0},{"had_liked":false,"id":185996,"user_name":"谭方敏","can_delete":false,"product_type":"c1","uid":1710960,"ip_address":"","ucode":"728DC7ECB7C902","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1b/70/547042ee.jpg","comment_is_top":false,"comment_ctime":1583740173,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583740173","product_id":100017301,"comment_content":"递归满足3个条件：<br>1）一个问题的解可以分解为几个子问题的解。<br>2）这个问题与分解之后的子问题，除了数据过不同，求解思路完全一样。<br>3）存在递归终止条件。<br><br>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，<br>最后将递推公式和终止条件翻译成代码。<br><br>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公司，不用想一层层的调用关系，不要试图用人脑去了解递归的每个步骤。<br><br>递归代码要警惕堆栈溢出<br>递归代码要注意重复计算<br><br>递归代码可以修改为非递归代码，迭代代码<br><br>递归代码调试一般有二种办法：<br>1）静态代码检查法，阅读代码<br>2）打印日志法，主要针对递推公式。<br><br>实在不行的话，就改成非递归的吧。这样就相对而言比较好调试了。<br>","like_count":0},{"had_liked":false,"id":185898,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1583721900,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583721900","product_id":100017301,"comment_content":"可以这样理解嘛，第一次走可能是一步可能是两步，如果是走1 就剩下(n-1)个台阶，那么(n-1)个台阶里面就也是走一步或走两步的问题 ，如果是走2 就剩（n-2）个台阶，那个剩下的n-2个台阶里面也是走一步或者走两步的问题，既然所有子问题都是走一步或者走两步，合起来就是 f(n) = f(n-1)+f(n-2)","like_count":0},{"had_liked":false,"id":184162,"user_name":"雷刚","can_delete":false,"product_type":"c1","uid":1655725,"ip_address":"","ucode":"115FE2BE1AAB61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132","comment_is_top":false,"comment_ctime":1583240810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583240810","product_id":100017301,"comment_content":"之前读Spring源码时，看到好多递归算法都传递一个HashMap作参数，其实也是动态规则，将中间计算结果缓存起来，避免重复计算。不过看递归算法确实很烧脑，总想着在脑子里模拟出递归的过程，结果就把自己绕进去了。","like_count":0},{"had_liked":false,"id":183145,"user_name":"Eternal","can_delete":false,"product_type":"c1","uid":1188023,"ip_address":"","ucode":"EA6FE7CC98F740","user_header":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","comment_is_top":false,"comment_ctime":1582961445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582961445","product_id":100017301,"comment_content":"递归调试：<br>1.使用小规模的用例<br>2.打印每次递归的上下文和参数，出错了可以知道执行到哪儿断了<br>","like_count":0},{"had_liked":false,"id":182751,"user_name":"肖大妞","can_delete":false,"product_type":"c1","uid":1426644,"ip_address":"","ucode":"2AD2F8684FDCF8","user_header":"https://static001.geekbang.org/account/avatar/00/15/c4/d4/5c8fb1cb.jpg","comment_is_top":false,"comment_ctime":1582860074,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582860074","product_id":100017301,"comment_content":"递归的实现是找到递推公式，然后根据BCD，寻找如何解决A的方法，但是我觉得好多问题的难点在于，脑子里根本没有把这个问题分解成规模更小的两个问题的思路，我们的思路是逆向的，我们会先找看看最小的怎么解决，然后往上寻找解决更大规模的问题的规律，而不是直接利用小规模问题的答案","like_count":0},{"had_liked":false,"id":180504,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1582298357,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582298357","product_id":100017301,"comment_content":"对于思考题 虽然自己平时写过递归 但是还没有碰到递归比较深的例子 不过现在IDE都比较智能，可以打断点写表达式 当表达式满足的时候在进入断点 想深入递归就写好表达式 等满足表达式自然就进入了 然后进行调试","like_count":0},{"had_liked":false,"id":180501,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1582298202,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582298202","product_id":100017301,"comment_content":"对于爬楼梯的例子f(n)=f(n-1)+f(n-2)这个是不是2阶线性差分方程？通项是不是:当n=1 f(n)=1 当n=2 f(n)=2 当n&gt;=3 f(n)=2^n-1 - 2^n-3","like_count":0},{"had_liked":false,"id":178509,"user_name":"兰柯","can_delete":false,"product_type":"c1","uid":1850499,"ip_address":"","ucode":"6D7230B3CE8722","user_header":"https://static001.geekbang.org/account/avatar/00/1c/3c/83/93e7af9e.jpg","comment_is_top":false,"comment_ctime":1581730198,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581730198","product_id":100017301,"comment_content":"我感觉递归转非递归空间复杂度降了吧老师。","like_count":0},{"had_liked":false,"id":177843,"user_name":"一只独立特行的猪","can_delete":false,"product_type":"c1","uid":1473358,"ip_address":"","ucode":"52263607CCBE6F","user_header":"https://static001.geekbang.org/account/avatar/00/16/7b/4e/73a9deec.jpg","comment_is_top":false,"comment_ctime":1581513779,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581513779","product_id":100017301,"comment_content":"以前自己也尝试过一层一层的分析递归代码，最后都把自己搞得云里雾里的。看了老师的总结豁然开朗，我们把问题A拆成几个问题后，就假设这几个问题已经解决了，屏蔽掉后面的递归细节，保证递归公司正确，确保终止条件对，这样就容易多了。","like_count":0},{"had_liked":false,"id":177835,"user_name":"王jojo","can_delete":false,"product_type":"c1","uid":1812840,"ip_address":"","ucode":"1ABE7FA2614F86","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","comment_is_top":false,"comment_ctime":1581512699,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581512699","product_id":100017301,"comment_content":"1. 写出好的递归, 最关键的一步是发现规律和找到终止的条件<br>2. 递归带来的问题, 空间复杂度上升, 重复计算(可以用散列表解决),堆栈溢出<br><br>递归改写成非递归可以一定程度上避免上述问题么?我看了原文发现好像没有说这个问题, 只是说&quot;手动&quot;创造栈和递归是一个效果","like_count":0},{"had_liked":false,"id":176080,"user_name":"谢真","can_delete":false,"product_type":"c1","uid":1124650,"ip_address":"","ucode":"8C3402DE107C9F","user_header":"https://static001.geekbang.org/account/avatar/00/11/29/2a/9079f152.jpg","comment_is_top":false,"comment_ctime":1580952441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580952441","product_id":100017301,"comment_content":"学到了递归防止重复计算的小技巧。","like_count":0},{"had_liked":false,"id":172086,"user_name":"莫奈","can_delete":false,"product_type":"c1","uid":1644960,"ip_address":"","ucode":"A1E1DDFD0AEBED","user_header":"https://static001.geekbang.org/account/avatar/00/19/19/a0/84f95280.jpg","comment_is_top":false,"comment_ctime":1579085907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579085907","product_id":100017301,"comment_content":"递归学了，女朋友在哪里领？","like_count":0},{"had_liked":false,"id":171092,"user_name":"板栗","can_delete":false,"product_type":"c1","uid":1239741,"ip_address":"","ucode":"35B8B2CB2E0214","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/bd/aba4b2c9.jpg","comment_is_top":false,"comment_ctime":1578843169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578843169","product_id":100017301,"comment_content":"<br>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。<br>递归分为两部分思考<br>1.重复执行的部分：任务可以被分解成N次思路相同,规模不同的问题的循环，然后在分解循环中每次执行问题为若干个子问题进行分别考虑，但是要避免重复计算的问题。<br>2.终止条件：递归循环在什么条件下应该停止,防止无限递归照成的堆栈溢出等<br><br>递归调试 可以直接打印操日志查看递归值。在结合边界条件（终止条件）打断点进行调试","like_count":0},{"had_liked":false,"id":170929,"user_name":"周敏","can_delete":false,"product_type":"c1","uid":1691553,"ip_address":"","ucode":"114D2441221F89","user_header":"https://static001.geekbang.org/account/avatar/00/19/cf/a1/dd10944c.jpg","comment_is_top":false,"comment_ctime":1578766972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578766972","product_id":100017301,"comment_content":"限制递归深度实际上也并没有解决调用该递归的问题吧，无非就是说不能用这个递归算法了","like_count":0},{"had_liked":false,"id":170766,"user_name":"Vicent🍀","can_delete":false,"product_type":"c1","uid":1589894,"ip_address":"","ucode":"70AEA72A0B6F0E","user_header":"https://static001.geekbang.org/account/avatar/00/18/42/86/6b2e81ba.jpg","comment_is_top":false,"comment_ctime":1578709212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578709212","product_id":100017301,"comment_content":"想请教一下，关于走台阶，如果不进行计算优化，f(n) = (fn-1)+f(n-2) 的计算复杂度是多少呢？我开始计算有迭代情况，算法复杂度相当于遍历自身的值为O(2n次方)，但计算了一下，比指数级的要低。具体不知道怎么求这种形式的算法复杂度","like_count":0},{"had_liked":false,"id":170290,"user_name":"liyghting","can_delete":false,"product_type":"c1","uid":1108970,"ip_address":"","ucode":"439794ECEEFD26","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/ea/7d00f657.jpg","comment_is_top":false,"comment_ctime":1578562356,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1578562356","product_id":100017301,"comment_content":"环的检测是不是可以用ThreadLocal来传递，判断","like_count":0,"discussions":[{"author":{"id":1926508,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/65/6c/be97a3ae.jpg","nickname":"Geek_bb2310","note":"","ucode":"022885B257DEB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260051,"discussion_content":"用哈希表\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588844257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170287,"user_name":"Luke","can_delete":false,"product_type":"c1","uid":1203115,"ip_address":"","ucode":"16DC5BD899CCE5","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/ab/aac30656.jpg","comment_is_top":false,"comment_ctime":1578560804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578560804","product_id":100017301,"comment_content":"https:&#47;&#47;www.cnblogs.com&#47;fivestudy&#47;p&#47;11855853.html 爬楼梯的问题可以结合这篇文章理解：<br>问题拆解，找到问题之间的具体联系<br>状态定义<br>递推方程推导<br>实现","like_count":0},{"had_liked":false,"id":170263,"user_name":"liyghting","can_delete":false,"product_type":"c1","uid":1108970,"ip_address":"","ucode":"439794ECEEFD26","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/ea/7d00f657.jpg","comment_is_top":false,"comment_ctime":1578558382,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578558382","product_id":100017301,"comment_content":"递归（Recursion）是一种应用广泛的算法（或者编程技巧），比如应用在DFS深度优先查询，前中后序二叉树遍历，给一个用户id查询最终推荐人（注册返佣金）等等.<br>什么样的问题可以用递归？<br>1.一个问题的解可以分解成几个子问题的解<br>2.这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样<br>3.存在递归终止条件<br><br>怎么写递归代码？<br>举例，推导写出递归公式，找到终止条件。关键在于找到如何将大问题分解为小问题的规律，并且基于此推导出递归公式，然后推敲出终止条件，最后将递归公式和终止条件翻译成代码。<br><br>警惕思维误区？不要在脑海中试图想清楚整个递和归求解过程，正确的思维误区是怎样的呢？<br>如果问题A可分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决，在此基础上思考如何解决问题A。而且，只需要思考问题A与子问题B、C、D两层之间的关系即可，不用一层一层下去<br>思考子问题与子子问题，子子问题和子子子问题的关系。这样子来思维就简单多了。<br><br>递归代码需要注意的地方<br>1.警惕堆栈溢出，解决方法，限制递归调用的最大深度<br>2.警惕重复计算，解决办法，用散列表比如Map来缓存计算结果<br>3.警惕死循环，如A-&gt;B-C-A，自动检查环的存在<br><br><br>空间复杂度较高<br><br><br><br>","like_count":0},{"had_liked":false,"id":167406,"user_name":"卖火柴的托儿索","can_delete":false,"product_type":"c1","uid":1451295,"ip_address":"","ucode":"A9C7412E75DA82","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/1f/8e304ec0.jpg","comment_is_top":false,"comment_ctime":1577785155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577785155","product_id":100017301,"comment_content":"老师，您好，关于：A-B-C-A问题会在后面的哪一节讲到？我对这个更高级的方法比较好奇","like_count":0},{"had_liked":false,"id":167157,"user_name":"Dana","can_delete":false,"product_type":"c1","uid":1241142,"ip_address":"","ucode":"FE94F5E3987DBA","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/36/020428c7.jpg","comment_is_top":false,"comment_ctime":1577701308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577701308","product_id":100017301,"comment_content":"PHP  代码 <br><br>function goStep($n)<br>{<br>    if ($n == 1) return 1;<br>    if ($n == 2) return 2;<br>    return goStep($n - 1) + goStep($n - 2);<br>}<br><br><br>&#47;&#47; 优化<br>function doStep($n, &amp;$hasSolved = [])<br>{<br>    if ($n == 1) return 1;<br>    if ($n == 2) return 2;<br><br>    if (isset($hasSolved[$n])) {<br>        return $hasSolved[$n];<br>    }<br><br>    $ret = doStep($n - 1, $hasSolved) + doStep($n - 2, $hasSolved);<br>    $hasSolved[$n] = $ret;<br>    return $ret;<br>}","like_count":0},{"had_liked":false,"id":165693,"user_name":"耀","can_delete":false,"product_type":"c1","uid":1634462,"ip_address":"","ucode":"3692BEC242A399","user_header":"https://static001.geekbang.org/account/avatar/00/18/f0/9e/cf6570f7.jpg","comment_is_top":false,"comment_ctime":1577283662,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577283662","product_id":100017301,"comment_content":"每次学习，总会有新的收获。我有不少使用递归的经验，因为面试的原因也看过不少递归方面的代码，做过OJ题目，但是我防止栈溢出，以及转化为循环，这些都有接触过，但是避免重复计算，这点倒是从来没有考虑过。重学算法课程，能够意识到自己以前一直忽略的东西就是我最大的收获。","like_count":0},{"had_liked":false,"id":164878,"user_name":"smiler","can_delete":false,"product_type":"c1","uid":1090136,"ip_address":"","ucode":"B10D1DDEA74165","user_header":"https://static001.geekbang.org/account/avatar/00/10/a2/58/066b8005.jpg","comment_is_top":false,"comment_ctime":1577103978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577103978","product_id":100017301,"comment_content":"递归算法的时间复杂度怎么分析？","like_count":0},{"had_liked":false,"id":164556,"user_name":"Sid","can_delete":false,"product_type":"c1","uid":1115041,"ip_address":"","ucode":"0461B574B2736B","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/a1/e6a0f60b.jpg","comment_is_top":false,"comment_ctime":1577026516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577026516","product_id":100017301,"comment_content":"使用idea的小伙伴们，debug时可以在debugger窗口-frame窗口看到函数调用栈（包含入参、临时变量等），递归调用也会显示出当前的递归层级","like_count":0},{"had_liked":false,"id":164551,"user_name":"Sid","can_delete":false,"product_type":"c1","uid":1115041,"ip_address":"","ucode":"0461B574B2736B","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/a1/e6a0f60b.jpg","comment_is_top":false,"comment_ctime":1577026352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577026352","product_id":100017301,"comment_content":"递归和普通的函数调用是一样的，比如aa()-&gt;bb()-&gt;cc()-&gt;dd(), 只不过aa() bb() cc() dd() 除了入参外，实现的逻辑完全一样，所以只保留一个aa（），把 bb() cc() dd() 全部换成aa（），就成了自己调用自己，也叫递归。函数调用栈和方法之间的互相调用也是一样的。","like_count":0},{"had_liked":false,"id":164110,"user_name":"艾尔欧唯伊","can_delete":false,"product_type":"c1","uid":1139716,"ip_address":"","ucode":"5BD50691342461","user_header":"https://static001.geekbang.org/account/avatar/00/11/64/04/18875529.jpg","comment_is_top":false,"comment_ctime":1576885756,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576885756","product_id":100017301,"comment_content":"感觉循环更难写...","like_count":0},{"had_liked":false,"id":162750,"user_name":"万历十五年","can_delete":false,"product_type":"c1","uid":1122150,"ip_address":"","ucode":"3D8CF5DF847AE8","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg","comment_is_top":false,"comment_ctime":1576584595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576584595","product_id":100017301,"comment_content":"判断是否有环：递归方法的参数中加一个set的引用，每得到一个推荐人就查询set里是否有此值，若无就加入，若有就是环。","like_count":0},{"had_liked":false,"id":160671,"user_name":"猫切切切切切","can_delete":false,"product_type":"c1","uid":1075033,"ip_address":"","ucode":"F350BA1B7FFDC4","user_header":"https://static001.geekbang.org/account/avatar/00/10/67/59/017b5726.jpg","comment_is_top":false,"comment_ctime":1576013772,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576013772","product_id":100017301,"comment_content":"调试递归代码，平时比较常用：<br>1. 打印递归值进行观察调试<br>2. 在递归值满足某个条件的位置放置断点调试<br>3. 如果没有现成的上述条件，则临时在代码中添加","like_count":0},{"had_liked":false,"id":160158,"user_name":"好名字可以让你的朋友更容易妒忌你","can_delete":false,"product_type":"c1","uid":1206110,"ip_address":"","ucode":"4EDC3F5BC49602","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/5e/fa980906.jpg","comment_is_top":false,"comment_ctime":1575882407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575882407","product_id":100017301,"comment_content":"我用js 实现的台阶题，受启发加入了缓存，性能极大的提升。<br>function taijie(n) {<br>  const cache = {}<br>  return function fib(n) {<br>    if (n === 1) return 1<br>    if (n === 2) return 2<br>    if (cache[n]) {<br>      return cache[n]<br>    }<br><br>    let one = fib(n - 1)<br>      , two = fib(n - 2)<br>      , result = one + two<br>    ;<br>    cache[n] = result<br>    return result<br>  }(n)<br>}<br><br>console.log(<br>  taijie(100)    &#47;&#47; 573147844013817200000<br>);<br>","like_count":0},{"had_liked":false,"id":159509,"user_name":"技术修行者","can_delete":false,"product_type":"c1","uid":1013147,"ip_address":"","ucode":"28CA41A1214D6B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/9b/611e74ab.jpg","comment_is_top":false,"comment_ctime":1575641704,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1575641704","product_id":100017301,"comment_content":"思维导图：https:&#47;&#47;mubu.com&#47;doc&#47;9Dx0eSgvkw<br>递归属于典型的理论简单但实现复杂的算法，经常练习，熟能生巧。","like_count":0},{"had_liked":false,"id":159368,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1575607366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575607366","product_id":100017301,"comment_content":"递归类似于图节点的可达性，从一个节点出发，只要每次遍历离基本节点近了一步，递归都能结束。","like_count":0},{"had_liked":false,"id":159185,"user_name":"Allen_","can_delete":false,"product_type":"c1","uid":1677187,"ip_address":"","ucode":"CA5E00E4644CD5","user_header":"https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg","comment_is_top":false,"comment_ctime":1575555339,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575555339","product_id":100017301,"comment_content":"把字问题的值打印出来，我也不知道怎么用断点，但是每次靠这个都能找到bug","like_count":0},{"had_liked":false,"id":158895,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1575472183,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575472183","product_id":100017301,"comment_content":"        （1）递归是一种应用非常广泛的算法。<br>\t（2）递归求解问的过程可分解为：去的过程叫“递”，回来的过程叫“归”<br>\t（3）递归需要满足的三个条件：<br>\t\t1，一个问题的解可以分解为几个子问题的解<br>\t\t\t所谓子问题，是数据规模更小的问题<br>\t\t2，这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样<br>\t\t3，存在递归终止条件<br>\t\t\t把问题分解为子问题，把子问题在分解为子问题，一层一层分解下去，不能存在无限循环，要有终止条件。<br>\t（4）编写递归代码：<br>\t\t写递归代码最关键的是：写出地推公式，找到终止条件。<br>\t（5）递归的思考方式：<br>\t\t如果一个问题A可以分解为若干子问题B，C，D，我们可以假设子问题B，C，D已经解决，在此基础上思考如何解决问题A。<br>\t\t而且，我们只需要思考问题A与子问题B，C，D两层之间的关系即可，不需要一层一层的往下思考子问题与子子问题的关系。<br>\t\t关键：只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。<br>\t（6）递归代码要警惕堆栈溢出<br>\t\t原因：a，函数调用会使用栈来保存临时变量，没调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。<br>\t\t\tb, 系统栈或虚拟机栈空间一般都不大。如递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。<br><br>\t解决：限制递归的最大深度。<br>\t（7）递归代码要警惕重复计算<br>\t\t解决：为了避免重复计算，可以通过一个数据结构（如散列表）来保存已经求解过的f(k)。当递归调用到f(k)时，先看下是否已经求解过，若已经求解过，则直接从散列表中取值返回。<br>\t（8）递归的其他问题：<br>\t\t在时间效率上，递归代码里多了很多函数调用，当调用函数数量较大时，就要消耗大量的时间。<br>\t\t在空间复杂度上，递归调用一次就会在内存栈中保存一次栈帧，所以在分析递归代码空间复杂度时，也考虑这部分的开销。<br>\t（9）我们可以通过使用迭代循环的方式改写递归代码。<br>\t因为递归本身是就是借助栈来实现的，只不过使用的是系统或虚拟机的本身提供，我们没有感知到。<br>\t我们可以自己在内存堆上实现栈，手动模拟入栈出栈过程，将任何递归代码改写成不是递归代码的样子。<br>","like_count":0},{"had_liked":false,"id":158659,"user_name":"leejunhui","can_delete":false,"product_type":"c1","uid":1188627,"ip_address":"","ucode":"A957C0034B9F4D","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/13/6ba35b43.jpg","comment_is_top":false,"comment_ctime":1575428719,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575428719","product_id":100017301,"comment_content":"最近在看一本关于LLDB调试的书，里面有一个例子就是使用LLDB工具来调试XCode，通过设置 [NSView hitTest:] 的断点来观察Xcode界面响应情况，其实这个方法本质也是去递归查询被点击视图的所有子视图，在调试的时候需要每次执行 continue 来进入到下一层递归调用中。","like_count":0},{"had_liked":false,"id":158602,"user_name":"SteveYang","can_delete":false,"product_type":"c1","uid":1754829,"ip_address":"","ucode":"C42BCA4F40A9EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCbnOvEatUN4ysE2cl6zJNoAJVXXuQVhicQ1jxh6Z2Towrmmc1I6PndaicuQQ0RyyJPyJQicv4tSib9Q/132","comment_is_top":false,"comment_ctime":1575421676,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575421676","product_id":100017301,"comment_content":"递归调试和循环遍历调试一样都是不好单步调试，一般都是采用条件断点或者打印日志。","like_count":0},{"had_liked":false,"id":158490,"user_name":"BroHorizon_gr","can_delete":false,"product_type":"c1","uid":1362857,"ip_address":"","ucode":"B05488C0073135","user_header":"https://static001.geekbang.org/account/avatar/00/14/cb/a9/2dbaddb2.jpg","comment_is_top":false,"comment_ctime":1575382927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575382927","product_id":100017301,"comment_content":"没有女朋友和我一起看电影，所以此题无解。","like_count":0},{"had_liked":false,"id":158022,"user_name":"晨风破晓","can_delete":false,"product_type":"c1","uid":1321464,"ip_address":"","ucode":"F2BC46428A97B5","user_header":"https://static001.geekbang.org/account/avatar/00/14/29/f8/561c5be1.jpg","comment_is_top":false,"comment_ctime":1575299175,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575299175","product_id":100017301,"comment_content":"递归：可以将一个问题划分为多个小问题，且这些小问题跟原始问题除了数据规模不一样解题思路一样无变化，最后能找到递归终止条件。<br>如何写出递归代码：由一个问题划分多个小问题时进而得到递推公式，再推敲终止条件，最后翻译成代码。<br>递归存在的问题：<br>容易造成堆栈溢出：可限制递归层次不要太深<br>中间值的重复计算：用散列表保存已经求解过的值，<br>时间复杂度和空间复杂度的成本都较高","like_count":0},{"had_liked":false,"id":157973,"user_name":"big智慧","can_delete":false,"product_type":"c1","uid":1202616,"ip_address":"","ucode":"272C32E19EAE1A","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/b8/2a4624c3.jpg","comment_is_top":false,"comment_ctime":1575291870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575291870","product_id":100017301,"comment_content":"打开Day8：<br>1、日期：<br>* 2019年12月2日<br><br>2、是什么：<br>* 递归是一种编程的技巧，满足问题可拆分，子问题的处理逻辑除数据规模外均相同，有递归的终止条件。<br><br>3、为什么：<br>* 递归的代码非常的简洁 ；<br>* 处理重复子问题的场景，非常高效 。 <br>4、怎么用：<br>* 实现步骤：写出递归公式，找出终止条件，将公式和条件翻译成代码 ；<br>* 注意问题：注意堆栈溢出，警惕重复计算，避免脏数据等导致的无限递归 。 <br>5、递归在工作中类似的场景：<br>* 递归就像管理工作，一层层分管，如果层级太多信息会严重失真，如果传递的信息错误会造成很多的无用功，如果工作分配的边界不清晰会有很多重复工作。其实就是递归中的重复计算、脏数据等常见的异常问题。 <br><br>6、关注点：<br>* 边界、信息确认","like_count":0},{"had_liked":false,"id":157830,"user_name":"小K","can_delete":false,"product_type":"c1","uid":1739011,"ip_address":"","ucode":"DA39D5CC847BEE","user_header":"https://static001.geekbang.org/account/avatar/00/1a/89/03/8498c7d5.jpg","comment_is_top":false,"comment_ctime":1575267186,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575267186","product_id":100017301,"comment_content":"电影院座位的递归函数是不是有问题？参数是n？都知道n了，还需要算吗？","like_count":0},{"had_liked":false,"id":157812,"user_name":"testerman","can_delete":false,"product_type":"c1","uid":1473556,"ip_address":"","ucode":"8DDC62262FA5DE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoDbVIx6bXBFTCDtBUPXzIJzEiaSCfjP7wRA95dGIAGJRnOCutFcIRFkEaUqrEF2fE0HJ1WaFsKn8w/132","comment_is_top":false,"comment_ctime":1575263682,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575263682","product_id":100017301,"comment_content":"子问题均是重复计算，且不是终止条件，是否就出现了递归环？","like_count":0},{"had_liked":false,"id":157760,"user_name":"冲","can_delete":false,"product_type":"c1","uid":1149914,"ip_address":"","ucode":"4191C8A4DF3840","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIk46cor5XVFTPZbPOnb7pViabgy450pobo46hRHFQz5nR5ocYRKIzC8vShic36vwa553H4Vj50x5wA/132","comment_is_top":false,"comment_ctime":1575256134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575256134","product_id":100017301,"comment_content":"😂看来大家都一样啊，之前会一直随着递归脑子跟着一步一步走下去，原来是思维误区","like_count":0},{"had_liked":false,"id":157751,"user_name":"克","can_delete":false,"product_type":"c1","uid":1069206,"ip_address":"","ucode":"6DDFBB05E0F4E9","user_header":"https://static001.geekbang.org/account/avatar/00/10/50/96/18612c89.jpg","comment_is_top":false,"comment_ctime":1575255453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575255453","product_id":100017301,"comment_content":"虽然递归存在一些问题，而且理论上所有的递归算法都可以以非递归的形式编写，但是思考递归解法的过程有助于我们理解问题的本质，从而找到写出普通迭代解法的头绪。递归的思想是最重要的！而递归的模型是数学归纳法。","like_count":0},{"had_liked":false,"id":157705,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1575249037,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1575249037","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":157702,"user_name":"莫问流年","can_delete":false,"product_type":"c1","uid":1249663,"ip_address":"","ucode":"23140E031AED4B","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/7f/80d56c1c.jpg","comment_is_top":false,"comment_ctime":1575248743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575248743","product_id":100017301,"comment_content":"递归调试技巧：1.日志打印 2.条件断点","like_count":0},{"had_liked":false,"id":157675,"user_name":"刘丶小备","can_delete":false,"product_type":"c1","uid":1102106,"ip_address":"","ucode":"F4D5EF592B7030","user_header":"https://static001.geekbang.org/account/avatar/00/10/d1/1a/3564c9da.jpg","comment_is_top":false,"comment_ctime":1575246126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575246126","product_id":100017301,"comment_content":"可以打印log日志来进行递归调试","like_count":0},{"had_liked":false,"id":157320,"user_name":"31415","can_delete":false,"product_type":"c1","uid":1227263,"ip_address":"","ucode":"35DFB1B33DEF04","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ3SytQ7GRwY9BzY6eiaib6DldfYibialbMRfVYdoR39dg5LxJOkdIc2JGMCYIgKmv5OUyolrFIqgsD0g/132","comment_is_top":false,"comment_ctime":1575108606,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575108606","product_id":100017301,"comment_content":"感觉递归的弊端是非常严重的问题。是不是说在在工作中，递归只是种思维方式和解题思路。落实成代码还是要转换为非递归的方式？","like_count":0},{"had_liked":false,"id":157311,"user_name":"大海","can_delete":false,"product_type":"c1","uid":1001446,"ip_address":"","ucode":"20913D0265971B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/e6/67b0b711.jpg","comment_is_top":false,"comment_ctime":1575106311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575106311","product_id":100017301,"comment_content":"递归的调试方法，我想到的是在指定的次数达日志进行调试","like_count":0},{"had_liked":false,"id":157108,"user_name":"Swing","can_delete":false,"product_type":"c1","uid":1330065,"ip_address":"","ucode":"55FCA9ECEFBBEB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","comment_is_top":false,"comment_ctime":1575033027,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575033027","product_id":100017301,"comment_content":"想到一个递归思想的应用场景：网络请求的拦 截器，也是后进先出LIFO的思想","like_count":0},{"had_liked":false,"id":157038,"user_name":"毛启圣","can_delete":false,"product_type":"c1","uid":1330056,"ip_address":"","ucode":"233DA95ED28C11","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/88/272b4562.jpg","comment_is_top":false,"comment_ctime":1575016505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575016505","product_id":100017301,"comment_content":"log日志<br>或者先断点终止条件<br>非终止条件 使用 条件断点","like_count":0},{"had_liked":false,"id":156969,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1575004621,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575004621","product_id":100017301,"comment_content":"递归终于明白了，听完豁然开朗，需要考虑的问题也就了解了，多谢","like_count":0},{"had_liked":false,"id":155785,"user_name":"赵炯","can_delete":false,"product_type":"c1","uid":1005135,"ip_address":"","ucode":"64A1F4E5531C13","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/4f/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1574756539,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574756539","product_id":100017301,"comment_content":"难的不是写递归的算法，而是如何把递归的算法改成正常的算法。。。。","like_count":0},{"had_liked":false,"id":153819,"user_name":"马志远","can_delete":false,"product_type":"c1","uid":1480892,"ip_address":"","ucode":"AAD8875343E5FC","user_header":"https://static001.geekbang.org/account/avatar/00/16/98/bc/6d5affd3.jpg","comment_is_top":false,"comment_ctime":1574311710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574311710","product_id":100017301,"comment_content":"递归详解-典型递归介绍<br><br>http:&#47;&#47;chenqx.github.io&#47;2014&#47;09&#47;29&#47;Algorithm-Recursive-Programming&#47;<br><br>1.如何理解“递归”？(什么是递归)<br><br>去的过程叫“递”，回来的过程叫“归”f(n)=f(n-1)+1<br><br>备注:去的过程入栈的过程,回来的过程出栈<br><br>2.递归需要满足的三个条件(递归的特点)<br><br>2.1. 一个问题的解可以分解为几个子问题的解<br><br>2.2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样<br><br>2.3. 存在递归终止条件<br><br>3.如何编写递归代码？(怎样实现递归)<br><br>3.1写出递推公式，找到终止条件<br><br>归纳:写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码<br><br>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤<br><br>4.注意点(递归弊端)<br><br>递归代码要警惕堆栈溢出<br><br>递归代码要警惕重复计算<br><br>都可以将递归使用循环+栈实现","like_count":0},{"had_liked":false,"id":152943,"user_name":"梨子苹果","can_delete":false,"product_type":"c1","uid":1716067,"ip_address":"","ucode":"3666813FEE31D3","user_header":"https://static001.geekbang.org/account/avatar/00/1a/2f/63/7a048d46.jpg","comment_is_top":false,"comment_ctime":1574128099,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574128099","product_id":100017301,"comment_content":"#<br>int f(int n) {<br>  if (n == 1) return 1;<br>  if (n == 2) return 2;<br>  <br>  int ret = 0;<br>  int pre = 2;<br>  int prepre = 1;<br>  for (int i = 3; i &lt;= n; ++i) {<br>    ret = pre + prepre;<br>    prepre = pre;<br>    pre = ret;<br>  }<br>  return ret;<br>}<br><br>说下这个展开过程吧，可以这样想，到第一个台阶，就只有一种走法，到第二个台阶只能有两种走法，到三个台阶，那只能从第一个台阶一步过来(如果是走两步过来就和之前到第二级台阶的一种方法重复了)，或者从第二个台阶一步过来，所以是2+1=3，如果是第四个台阶，只能从第三个台阶一步过来，或者第二个台阶一步过来，所以是之前的3+2=5，依次序类推，","like_count":0},{"had_liked":false,"id":151848,"user_name":"握不住手中沙","can_delete":false,"product_type":"c1","uid":1097132,"ip_address":"","ucode":"F194E47C4D42C9","user_header":"https://static001.geekbang.org/account/avatar/00/10/bd/ac/49494ed8.jpg","comment_is_top":false,"comment_ctime":1573799825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573799825","product_id":100017301,"comment_content":"思考题：<br>调试递归可以通过打印日志的方式，将递归值和递归深度给打印出来，可直观表现出递归运行状况","like_count":0},{"had_liked":false,"id":149832,"user_name":"Mr.Fu","can_delete":false,"product_type":"c1","uid":1613254,"ip_address":"","ucode":"F1E4304C5CDE52","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/c6/a72db706.jpg","comment_is_top":false,"comment_ctime":1573396929,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573396929","product_id":100017301,"comment_content":"一.What-什么是递归？递归要满足的三个条件：<br>一个问题可以分解成几个子问题的解：比如前面讲的电影院的例子，你要知道“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。<br>这个问题和分解成的子问题，除了属于规模不同，求解思路完全一样：求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路是一样的。<br>存在终止递归条件：第一排的人不需要再继续询问任何人就知道自己在哪一排<br><br>二.How-如何编写递归代码：<br>写出递推公式：找到如何将大问题分解为小问题的规律，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。<br>找到终止条件：尝试边缘终止条件<br>把递推公式和终止条件转换成代码<br><br>三.写递归代码要注意的问题：<br>空间复杂度(堆栈溢出)：限制递归调用的最大深度<br>时间复杂度(函数调用耗时多)：递归越深，时间越久<br>重负计算：f(n)=f(n-1)+f(n-2)，f(4)=f(3)+f(2),f(3)=f(2)+f(1)，f(2)不要计算两次，散列表存储已经计算过的值<br><br>N.例子<br>最终推荐人：用户 A 推荐用户 B 来注册，用户 B 又推荐了用户 C 来注册。我们可以说，用户 C 的“最终推荐人”为用户 A，用户 B 的“最终推荐人”也为用户 A，而用户 A 没有“最终推荐人”。<br>看电影第几排：问前面一排的人他是第几排，只要在他的数字上加一就知道自己在哪一排了。但是前面的人也看不清，所以他也问他前面的人。就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到前面的人告诉你他在哪一排，于是你就知道答案了；这就是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。","like_count":0,"discussions":[{"author":{"id":1480892,"avatar":"https://static001.geekbang.org/account/avatar/00/16/98/bc/6d5affd3.jpg","nickname":"马志远","note":"","ucode":"AAD8875343E5FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54734,"discussion_content":"喜欢你这个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574311742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149255,"user_name":"mandy","can_delete":false,"product_type":"c1","uid":1711964,"ip_address":"","ucode":"C58CE4593EFBAB","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1f/5c/2c9edfe3.jpg","comment_is_top":false,"comment_ctime":1573179627,"is_pvip":false,"replies":[{"id":"57637","content":"这里说的手动递归，并非指改成for循环的方式。手动递归是自己模拟函数栈，那个非常复杂，我抽空写个文章讲下。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1573425026,"ip_address":"","comment_id":149255,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573179627","product_id":100017301,"comment_content":"&quot;但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度&quot;,这句话没有太理解，递归改成for循环方式，可以降低空间复杂度和重复计算问题吧，还请老师帮忙解惑，谢谢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473794,"discussion_content":"这里说的手动递归，并非指改成for循环的方式。手动递归是自己模拟函数栈，那个非常复杂，我抽空写个文章讲下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573425026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146843,"user_name":"Geek_6240d7","can_delete":false,"product_type":"c1","uid":1701798,"ip_address":"","ucode":"4A60F1712F7C96","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUcSLVV6ia3d2V6aic2fb9XcbDYP5iajibGSoRmfEVk0EhIc25UeFN5Sb3EMmFoUsl3n8zfTyq7E3tKQ/132","comment_is_top":false,"comment_ctime":1572673590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572673590","product_id":100017301,"comment_content":"f(n)=f(n-1)+f(n-2)的非递归方式的证明参考斐波那契数列的证明","like_count":0},{"had_liked":false,"id":146633,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1572589907,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1572589907","product_id":100017301,"comment_content":"斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）","like_count":0},{"had_liked":false,"id":145142,"user_name":"不破楼兰终不还","can_delete":false,"product_type":"c1","uid":1145867,"ip_address":"","ucode":"F06EEF04552A90","user_header":"https://static001.geekbang.org/account/avatar/00/11/7c/0b/2b5e5da5.jpg","comment_is_top":false,"comment_ctime":1572223560,"is_pvip":false,"replies":[{"id":"55967","content":"差不多😂","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572228605,"ip_address":"","comment_id":145142,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1572223560","product_id":100017301,"comment_content":"递归递归，写代码时却是现有归的条件，再往下递。这样理解没问题吧？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472261,"discussion_content":"差不多😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572228605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1145867,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7c/0b/2b5e5da5.jpg","nickname":"不破楼兰终不还","note":"","ucode":"F06EEF04552A90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43389,"discussion_content":"不对，还是先递再归。方法总要在外层先被调用的😭","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572871383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144933,"user_name":"时光之刃","can_delete":false,"product_type":"c1","uid":1083381,"ip_address":"","ucode":"0F15CAD70BDDC3","user_header":"https://static001.geekbang.org/account/avatar/00/10/87/f5/c6d1ffed.jpg","comment_is_top":false,"comment_ctime":1572103465,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1572103465","product_id":100017301,"comment_content":"牛人，由浅入深，通俗易懂","like_count":0},{"had_liked":false,"id":144897,"user_name":"Mango","can_delete":false,"product_type":"c1","uid":1515101,"ip_address":"","ucode":"D34F0424F4F742","user_header":"https://static001.geekbang.org/account/avatar/00/17/1e/5d/62fdc917.jpg","comment_is_top":false,"comment_ctime":1572083700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572083700","product_id":100017301,"comment_content":"什么时候用递归？<br><br>求解有限和或者积的时候，比如若干种类纸币不限张，求解凑成25块(指定和)有几种方案。<br><br>为什么这种情况时候使用递归？<br><br>因为递归过程自动生成、保存了大量临时变量。就好像上帝视角玩迷宫游戏，我们从出口逆推，中间遇到一个岔口，就保存成分支，只要最终能找到入口，那么这些分支就是有效的。递归过程中的栈帧其实就已经自动帮我们保存了这些临时变量，比如上面说的找到了迷宫的入口，下一步就是打印有效路径，那么由于栈帧已经自动保存了每个节点信息，那么直接&quot;归&quot;输出即可。","like_count":0},{"had_liked":false,"id":144479,"user_name":"wend","can_delete":false,"product_type":"c1","uid":1014096,"ip_address":"","ucode":"45EE220931FE91","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJyzUm3M4HMj0wXv8Pr34OhOiaFJjFMSjVKnaJoOWR9Uo1T4RBI4MYtguolJgOwb6eKsAUOq4MGlrw/132","comment_is_top":false,"comment_ctime":1571933874,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571933874","product_id":100017301,"comment_content":"调试递归，Android中的触摸事件就是递归，<br>平时一般使用3种方式调试:<br>1 看代码，从逻辑分析<br>2 打日志，方便全局分析<br>3 条件断点，看看异常时的现场","like_count":0},{"had_liked":false,"id":141208,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1571129348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571129348","product_id":100017301,"comment_content":"文中爬楼梯的问题就是求斐波那契数列的第n+1项。","like_count":0},{"had_liked":false,"id":141142,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1571122616,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571122616","product_id":100017301,"comment_content":"递归有点像到一个目的地取东西，每次都向目的地靠近一步，这是递的过程，如果检查到目的地已经到达，取好东西进入归过程，一步一步回到原点。这里的关键有两步：每次都能确定向目的地迈进一步，步长不会减少；其次，要能轻易确定是否目的地已经到达。","like_count":0},{"had_liked":false,"id":140883,"user_name":"stg609","can_delete":false,"product_type":"c1","uid":1073025,"ip_address":"","ucode":"FB70A75A891BB8","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/81/1c614f4a.jpg","comment_is_top":false,"comment_ctime":1571067009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571067009","product_id":100017301,"comment_content":"最大的收获就是以后写递归一定要注意可能存在的两个问题1.堆栈溢出(通过限制深度解决)，2.重复调用(，可通过把调用过的放到一个数据结构中，每次调用先比对)","like_count":0},{"had_liked":false,"id":138964,"user_name":"Geek_a7fa46","can_delete":false,"product_type":"c1","uid":1437749,"ip_address":"","ucode":"73387D21767789","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRyUPicEMqGsQlkDXiaJrAMNCtHOaMjsp2Dcxcx797k2onzfdb82Zpb3KHZLqaICKOl4ohOV6In2mQ/132","comment_is_top":false,"comment_ctime":1570519625,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570519625","product_id":100017301,"comment_content":"可以根据父子节点在数据库层做递归查询","like_count":0},{"had_liked":false,"id":138416,"user_name":"stonyjerry","can_delete":false,"product_type":"c1","uid":1686515,"ip_address":"","ucode":"DD1C0C7C619E0B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJEWMeroibyjVVcXlf81C7WicDAfUv01jVnwDUooHk5zDU51zbLPsYnAAa2icz1ySSQab2bxQqzD5xEg/132","comment_is_top":false,"comment_ctime":1570222672,"is_pvip":false,"replies":[{"id":"53598","content":"看看后面的动态规划那一章节吧  两者没太大关系呢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570580124,"ip_address":"","comment_id":138416,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570222672","product_id":100017301,"comment_content":"可以再说一下递归和动态规划的区别么？还是没有特别能够区分两者区别哎！谢谢！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469515,"discussion_content":"看看后面的动态规划那一章节吧  两者没太大关系呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570580124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138360,"user_name":"Geek_b617bf","can_delete":false,"product_type":"c1","uid":1220552,"ip_address":"","ucode":"9BAFC3B184B1D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9f/c8/0318c83e.jpg","comment_is_top":false,"comment_ctime":1570178059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570178059","product_id":100017301,"comment_content":"递归的思想跟高中时候学习的数学归纳法比较像.   <br>如果按照计算机运行的顺序去理解递归比较难,大概是因为人脑容易stackoverflow吧哈哈.<br> 数学归纳法<br>　　数学上证明与自然数n有关的命题的一种方法。必须包括两步：(1)验证当n取第一个自然数值n=n1(n1=1，2或其他常数)时，命题正确；(2)假设当n取某一自然数k时命题正确，以此推出当n=k+1时这个命题也正确。从而就可断定命题对于从n1开始的所有自然数都成立。<br>设计递归的时候可以仿照这个思路,从递归的退出条件开始,先设计出基本的函数f(n),再推理出f(n)和f(n+1)的关系,这样比较符合人的思维习惯.<br>例如求阶乘n!=n*n-1*n-2....*2*1  可以先确定递归的退出条件为n=1,也就是归纳的起始条件.   然后当f(n)成立时,f(n+1)=(n+1)*n*...*2*1=(n+1)f(n)  也成立   那么f(n)=n*f(n-1)  再结合上面的退出条件递归函数就设计出来了 ","like_count":0},{"had_liked":false,"id":138278,"user_name":"雨无尽时","can_delete":false,"product_type":"c1","uid":1298995,"ip_address":"","ucode":"2BF137791408A7","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLUPzlts4GoyqvmvW8qXicQNBnFlNQGElSmC4DMBAVhu62uOf649xEKaWLYBsd6qDV3090wG7wGn6Q/132","comment_is_top":false,"comment_ctime":1570151152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570151152","product_id":100017301,"comment_content":"条件断点","like_count":0},{"had_liked":false,"id":138168,"user_name":"俊哥","can_delete":false,"product_type":"c1","uid":1678451,"ip_address":"","ucode":"C5548F817D97B0","user_header":"https://static001.geekbang.org/account/avatar/00/19/9c/73/4d23e4f2.jpg","comment_is_top":false,"comment_ctime":1570073834,"is_pvip":false,"replies":[{"id":"53632","content":"嗯嗯，你理解的也没太大问题。不过，我说的手动模拟递归还跟你理解的不大一样。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570582778,"ip_address":"","comment_id":138168,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570073834","product_id":100017301,"comment_content":"但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。<br><br>老师，个人认为改为非递归方式是可以优化空间复杂度的，比如你讲的例子，如果采用是用非递归方式，无论递归多少次，递归部分只需要使用pre、prepre和ret三个临时变量，不会随递归次数增长。<br>而使用递归方式，则相当于每次递归都压栈3个临时变量。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469420,"discussion_content":"嗯嗯，你理解的也没太大问题。不过，我说的手动模拟递归还跟你理解的不大一样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570582778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134891,"user_name":"leeyunt","can_delete":false,"product_type":"c1","uid":1462087,"ip_address":"","ucode":"6AFA868EE84982","user_header":"https://static001.geekbang.org/account/avatar/00/16/4f/47/5dd73cd4.jpg","comment_is_top":false,"comment_ctime":1568947554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568947554","product_id":100017301,"comment_content":"方法或者函数调用自身的方法称为递归调用，调用即称为递，返回即称为归。<br>递归是一种应用非常广泛的算法。比如DFS深度优先搜索、前中后序二叉树遍历。<br>去的过程叫“递”，回来的过程叫“归”。基本上所以的递归问题都可以用递归公式来表示。<br>f(n) = f(n-1) + 1 其中，f(1)=1<br>Int f(int n) {<br>    If (n == 1) return 1;<br>    return f(n-1) +1;<br>}<br>使用递归算法需要满足的三个条件<br>1、一个问题的解可以分解为几个子问题的解<br>2、这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样<br>3、存在递归终止条件<br>写递归代码最关键的是写出递推公式，找到终止条件。<br>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。<br>* 递归代码要警惕堆栈溢出<br>* 递归代码要警惕重复计算<br>避免重复计算可以通过散列表来保存已经求解过的f(k)。<br>递归的优缺点：<br>优点：代码的表达力很强，写起来简单。<br>缺点：空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会消耗较多的问题。<br>","like_count":0},{"had_liked":false,"id":133940,"user_name":"呲牙胡椒粉","can_delete":false,"product_type":"c1","uid":1664037,"ip_address":"","ucode":"19FB66081748AC","user_header":"https://static001.geekbang.org/account/avatar/00/19/64/25/996931a3.jpg","comment_is_top":false,"comment_ctime":1568703386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568703386","product_id":100017301,"comment_content":"第二个例子的非递归实现好像是动态规划的感觉","like_count":0},{"had_liked":false,"id":132897,"user_name":"Zer0","can_delete":false,"product_type":"c1","uid":1042801,"ip_address":"","ucode":"CC754786CFEB4C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e9/71/40b04914.jpg","comment_is_top":false,"comment_ctime":1568265306,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1568265306","product_id":100017301,"comment_content":"在一个嵌入式的平台写过一个项目，有个函数就是用递归写的，平台上栈空间不够，程序挂掉了，查了好久才怀疑是递归太深了，之后就再没用过递归了，能循环就循环。","like_count":0,"discussions":[{"author":{"id":1188710,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/66/413c0bb5.jpg","nickname":"LDxy","note":"","ucode":"956432CE7B7761","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12515,"discussion_content":"嵌入式平台上尽量避免递归吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568540184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132532,"user_name":"胡永","can_delete":false,"product_type":"c1","uid":1200543,"ip_address":"","ucode":"6C8BA1E0BED9C0","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/9f/1840385e.jpg","comment_is_top":false,"comment_ctime":1568162809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568162809","product_id":100017301,"comment_content":"递归代码的三个条件：有边界，可分解，需要注意栈溢出，死循环；子问题是总问题的重复，写递归的方法是写出公式","like_count":0},{"had_liked":false,"id":132530,"user_name":"胡永","can_delete":false,"product_type":"c1","uid":1200543,"ip_address":"","ucode":"6C8BA1E0BED9C0","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/9f/1840385e.jpg","comment_is_top":false,"comment_ctime":1568162665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568162665","product_id":100017301,"comment_content":"递归代码的实现思路我在那些容易把最绕晕的问题也是这样操作的，显示手写出来，大问题分解小问题，然后从一般再到抽象就搞定了","like_count":0},{"had_liked":false,"id":129906,"user_name":"Geek_019531","can_delete":false,"product_type":"c1","uid":1563214,"ip_address":"","ucode":"90C29D69B5E4D1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJyNJCibCAUoZHib55TsCUBGFk5HosAB7ShvlmhJZIXEiaH7yyq184ibia0u0bnfrmdqWLHt1CjeXM4Hicg/132","comment_is_top":false,"comment_ctime":1567323940,"is_pvip":false,"replies":[{"id":"48494","content":"求解的问题重复和提高效率  两者有冲突吗？还有其他问题，能具体讲下吗？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1567378990,"ip_address":"","comment_id":129906,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567323940","product_id":100017301,"comment_content":"我怎么越看到后面越糊涂，避免重复计算是说求解的问题重复计算了，还是为了提高代码效率去避免重复计算，感觉绕进去了。还有其他的问题，没讲我就感觉疑问更多了。。。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465709,"discussion_content":"求解的问题重复和提高效率  两者有冲突吗？还有其他问题，能具体讲下吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567378990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127906,"user_name":"Geek_8a7668","can_delete":false,"product_type":"c1","uid":1631982,"ip_address":"","ucode":"BBDBE125345CF7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLDCC4yia65GicuukzgdZv34Zib2tXcfuBhkG3iaYBzJJRWQRPBLysR95WRD6RBibQfwHQvyDyP8fHAhkrA/132","comment_is_top":false,"comment_ctime":1566807203,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1566807203","product_id":100017301,"comment_content":"看了两遍，还是不会写出汉诺塔递归代码","like_count":0,"discussions":[{"author":{"id":1116188,"avatar":"https://static001.geekbang.org/account/avatar/00/11/08/1c/ef15e661.jpg","nickname":" 臣馟飞扬","note":"","ucode":"F2F882B7678055","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53052,"discussion_content":"一看就会，一写就废","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574127675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125893,"user_name":"冰风落叶","can_delete":false,"product_type":"c1","uid":1128059,"ip_address":"","ucode":"E4DE480B95A17D","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/7b/3788ca13.jpg","comment_is_top":false,"comment_ctime":1566269059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566269059","product_id":100017301,"comment_content":"知识点总结：<br><br>一、判断是否可以递归：<br>1. 主问题是否可以拆分成子问题<br>2. 子问题解决思路是否和主问题一致<br>3. 是否存在终止条件<br><br>二、递归问题的解决思路：<br>1. 找出大问题分解成小问题的规律<br>2. 写出递推公示<br>3. 找到终止条件<br>注意：找出一层关系即可，不要试图用人脑去分解递归的每个步骤<br><br>三、递归代码要注意：<br>1. 警惕堆栈溢出，函数调用会用栈保存临时变量，等函数返回时才会出栈，所以一直递归的话就会一直入栈，就会有堆栈溢出的风险<br>2. 避免重复计算，可以利用散列表保存已有的结果，每次递归是先看是否已存在结果，不存在在进行计算","like_count":0},{"had_liked":false,"id":125397,"user_name":"花儿与少年","can_delete":false,"product_type":"c1","uid":1046304,"ip_address":"","ucode":"E2D685737E4F1B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/20/e2dfa9c2.jpg","comment_is_top":false,"comment_ctime":1566179168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566179168","product_id":100017301,"comment_content":"疑问: 电影院的例子能说明递归过程，但是不适合用来 演示递推公示吧，因为具体到这个例子，知道了n就知道了结果，还需要递归来计算吗","like_count":0},{"had_liked":false,"id":124937,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1566023404,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1566023404","product_id":100017301,"comment_content":"之前讲的数据结构，自己看过源码都很好理解，看了递归这一节，我觉得这节课值了，为了打开了递归的新大门，老师就是老师","like_count":0,"discussions":[{"author":{"id":1116188,"avatar":"https://static001.geekbang.org/account/avatar/00/11/08/1c/ef15e661.jpg","nickname":" 臣馟飞扬","note":"","ucode":"F2F882B7678055","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53053,"discussion_content":"先写几个递归题再说，看懂了但是依然是不会写的飘过~~~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574127727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124553,"user_name":"looper","can_delete":false,"product_type":"c1","uid":1238396,"ip_address":"","ucode":"DA4BCE83836C04","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/7c/2a5a418b.jpg","comment_is_top":false,"comment_ctime":1565919821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565919821","product_id":100017301,"comment_content":"打卡，第三天，已经学习完基本的数据结构：数组，链表，队列，并能实现课程里面出现的算法了，感觉收获不少，尤其是对平时不太注意的编程逻辑细节，感谢","like_count":0},{"had_liked":false,"id":124339,"user_name":"热心网友","can_delete":false,"product_type":"c1","uid":1329547,"ip_address":"","ucode":"8779205D59C409","user_header":"https://static001.geekbang.org/account/avatar/00/14/49/8b/844e70df.jpg","comment_is_top":false,"comment_ctime":1565862471,"is_pvip":false,"replies":[{"id":"45679","content":"😁，那只是一个例子","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565906917,"ip_address":"","comment_id":124339,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565862471","product_id":100017301,"comment_content":"老师你好，第几排这个例子，递归函数的入参不就是第几排吗，既然参数已知。。。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463123,"discussion_content":"😁，那只是一个例子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565906917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122418,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1565362321,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565362321","product_id":100017301,"comment_content":"对于如何判断是不是成环，其实可以用快慢指针，总会相遇！","like_count":0},{"had_liked":false,"id":122086,"user_name":"1620","can_delete":false,"product_type":"c1","uid":1104310,"ip_address":"","ucode":"C9222A5CE4723C","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/b6/4c498c17.jpg","comment_is_top":false,"comment_ctime":1565281768,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565281768","product_id":100017301,"comment_content":"两行代码 😂<br><br>int f(int n) {<br>  if (n == 1 || n==2）return n；<br>  return f(n-1) + f(n-2);<br>}<br>","like_count":0},{"had_liked":false,"id":121706,"user_name":"王木公","can_delete":false,"product_type":"c1","uid":1014550,"ip_address":"","ucode":"F049AEBFA0338D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/16/ca250e8c.jpg","comment_is_top":false,"comment_ctime":1565187945,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565187945","product_id":100017301,"comment_content":"iOS开发中，Xcode支持给断点加过滤条件，只有满足条件的断点才会触发程序停止，再进行单步调试","like_count":0},{"had_liked":false,"id":121290,"user_name":"未来的胡先森","can_delete":false,"product_type":"c1","uid":1234682,"ip_address":"","ucode":"AFF193AC0E2E6C","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/fa/1f5bf642.jpg","comment_is_top":false,"comment_ctime":1565094915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565094915","product_id":100017301,"comment_content":"生活中常见的递归例子「报数」，后者在前者的数上+1.","like_count":0},{"had_liked":false,"id":121002,"user_name":"丰富","can_delete":false,"product_type":"c1","uid":1017611,"ip_address":"","ucode":"8FF798DC1418C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/0b/6a4cf978.jpg","comment_is_top":false,"comment_ctime":1565048945,"is_pvip":false,"replies":[{"id":"44731","content":"看我写的这篇文章：还有程序员天真地以为”尾递归“真的可以避免堆栈溢出！<br><br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;Ki3WN2AJ5HhxxmaQ0lVh3Q","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565219364,"ip_address":"","comment_id":121002,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565048945","product_id":100017301,"comment_content":"建议老师把尾递归这种方式也讲一下","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461569,"discussion_content":"看我写的这篇文章：还有程序员天真地以为”尾递归“真的可以避免堆栈溢出！\n\nhttps://mp.weixin.qq.com/s/Ki3WN2AJ5HhxxmaQ0lVh3Q","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565219364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118012,"user_name":"赵小洛","can_delete":false,"product_type":"c1","uid":1592232,"ip_address":"","ucode":"A326C12B1A1ABA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/a8/14b8a860.jpg","comment_is_top":false,"comment_ctime":1564212605,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564212605","product_id":100017301,"comment_content":"恰好遇到了  也是反佣金的项目","like_count":0},{"had_liked":false,"id":116736,"user_name":"Cooper","can_delete":false,"product_type":"c1","uid":1607867,"ip_address":"","ucode":"D940921B53F1DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/88/bb/f569045d.jpg","comment_is_top":false,"comment_ctime":1563897892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563897892","product_id":100017301,"comment_content":"select * from [table] where referrer_id is null and actor_id = actorId;","like_count":0},{"had_liked":false,"id":114843,"user_name":"逻各斯与努斯","can_delete":false,"product_type":"c1","uid":1476477,"ip_address":"","ucode":"148F124E649B0F","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/7d/5b331647.jpg","comment_is_top":false,"comment_ctime":1563415395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563415395","product_id":100017301,"comment_content":"这个环怎么检测啊？？","like_count":0},{"had_liked":false,"id":114164,"user_name":"Leo","can_delete":false,"product_type":"c1","uid":1217896,"ip_address":"","ucode":"947C5785A7EDF1","user_header":"https://static001.geekbang.org/account/avatar/00/12/95/68/41546e8a.jpg","comment_is_top":false,"comment_ctime":1563244535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563244535","product_id":100017301,"comment_content":"写出递推公式，找出终止条件，打卡","like_count":0},{"had_liked":false,"id":113162,"user_name":"joker","can_delete":false,"product_type":"c1","uid":1161345,"ip_address":"","ucode":"C60D7748D13D2C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL2J0zpE8HiccMmFS45yllWHq7icwMeHQomhxDeGU1sZEqSw4VEOkIG1jiawrrzmA4yHdoJ7roHukOAQ/132","comment_is_top":false,"comment_ctime":1562905615,"is_pvip":false,"replies":[{"id":"41287","content":"后面讲分治的时候讲到了<br>","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562976923,"ip_address":"","comment_id":113162,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562905615","product_id":100017301,"comment_content":"想请教一下，递归和分治算法有什么区别？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458086,"discussion_content":"后面讲分治的时候讲到了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562976923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112316,"user_name":"逍遥","can_delete":false,"product_type":"c1","uid":1070213,"ip_address":"","ucode":"95C583EF780159","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/85/081804f7.jpg","comment_is_top":false,"comment_ctime":1562719657,"is_pvip":false,"replies":[{"id":"40900","content":"你还是认真看下文章吧 都有讲到的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562739253,"ip_address":"","comment_id":112316,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562719657","product_id":100017301,"comment_content":"还是不太明白什么时候该用递归，既然递归有那你多缺点，而且都是没法完全解决的，比如限制递归深度这条，如果我数据就是那么多，不能限制怎么办？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457671,"discussion_content":"你还是认真看下文章吧 都有讲到的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562739253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111062,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1562461751,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562461751","product_id":100017301,"comment_content":"递归代码的调试，我一般用条件断点，来定位需要调试的例子。","like_count":0},{"had_liked":false,"id":111061,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1562461632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562461632","product_id":100017301,"comment_content":"我个人倾向于少用递归代码，但是递归对于分析问题非常有价值，毕竟少考虑了循环变量，只要找到一个规模较小的等价问题和平凡基本例子即可。在递归关系明确的情况下，很多时候转化成循环代码还是直观的，例如文中的爬楼梯问题。也有一些递归代码不太容易转成循环代码，例如快速排序，这时候用递归代码也无妨，只要对最大数据量做足够的测试。","like_count":0},{"had_liked":false,"id":109114,"user_name":"Joiner","can_delete":false,"product_type":"c1","uid":1071941,"ip_address":"","ucode":"7F67D4C325E71F","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/45/5dc5437e.jpg","comment_is_top":false,"comment_ctime":1561964644,"is_pvip":false,"replies":[{"id":"39585","content":"1. C语言里没有异常，但是可以直接返回错误码error code<br>2. 你可以搜下dfs的非递归实现，算是一个例子","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562024900,"ip_address":"","comment_id":109114,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1561964644","product_id":100017301,"comment_content":"老师，那个用Java的异常防止递归层次太深的代码，如果用C语言来实现，是不是会更复杂，毕竟C语言中没有现成的语句。<br>还有，文章使用非递归时说的「自己在内存堆上实现栈，手动模拟入栈、出栈过程」，不太明白怎么实现栈？怎么模拟入栈、出栈？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456249,"discussion_content":"1. C语言里没有异常，但是可以直接返回错误码error code\n2. 你可以搜下dfs的非递归实现，算是一个例子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562024900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1071941,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5b/45/5dc5437e.jpg","nickname":"Joiner","note":"","ucode":"7F67D4C325E71F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3912,"discussion_content":"返回错误码，有点担心这个错误码会影响真正的返回值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564972020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107194,"user_name":"aoxiaojun","can_delete":false,"product_type":"c1","uid":1393481,"ip_address":"","ucode":"2526DD2FEC2CDE","user_header":"https://static001.geekbang.org/account/avatar/00/15/43/49/cfe534c2.jpg","comment_is_top":false,"comment_ctime":1561477503,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561477503","product_id":100017301,"comment_content":"利：更强的表现方式，代码简洁<br>弊：堆栈溢出风险<br>","like_count":0},{"had_liked":false,"id":106736,"user_name":"申鹏飞","can_delete":false,"product_type":"c1","uid":1331464,"ip_address":"","ucode":"429211A63F6314","user_header":"https://static001.geekbang.org/account/avatar/00/14/51/08/0460f6eb.jpg","comment_is_top":false,"comment_ctime":1561381450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561381450","product_id":100017301,"comment_content":"递归的本质是栈的应用，递是入栈，归是出栈，用自身调用代表了N次调用，看起来像是一种调用信息的丢失。","like_count":0},{"had_liked":false,"id":106140,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1561186670,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561186670","product_id":100017301,"comment_content":"递归的三个核心条件：<br>1.问题的解可以被拆分成几个子问题的解<br>2.问题和分解后的子问题，除了数据规模不同，求解思路完全相同<br>3.存在递归终止条件<br>写递归代码的关键：找到大问题分解成小问题的规律，并基于此写出递推公式，再推敲出终止条件，最后将两者翻译成代码（能找出这样的小问题；并假设该小问题已被解决）<br>递归代码需要谨防的问题和解决思路：<br>1.调用过深导致栈溢出--&gt;改为循环结构；在堆中自维护栈；采用尾递归<br>2.重复计算--&gt;动态规划<br>递归在经典算法中的应用：快速排序；归并排序；二叉树遍历；DFS;BFS；并查集查找root<br>递归的调试方法：<br>1.打印堆栈日志<br>2.结合条件断点","like_count":0},{"had_liked":false,"id":104594,"user_name":"时光剪影","can_delete":false,"product_type":"c1","uid":1093159,"ip_address":"","ucode":"CC6F24C30AE3E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/ae/27/3dfcc699.jpg","comment_is_top":false,"comment_ctime":1560780757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560780757","product_id":100017301,"comment_content":"递归：寻找初始化的值称为递，通过初始化计算出最终值称为归；<br><br>判断是否可以使用递归：<br>问题可以分解成若干个子问题的解<br>问题与分解之后的子问题解法思路一致<br>存在递归终止条件<br><br>操作：<br>写出递归公式+找出终止条件+ 翻译出代码<br><br>存在问题：<br>堆栈溢出(设置递归深度）重复计算(用map存储已经计算出来的值）、函数调用耗时、空间复杂度高","like_count":0},{"had_liked":false,"id":100445,"user_name":"花脸猫","can_delete":false,"product_type":"c1","uid":1519651,"ip_address":"","ucode":"FC36052CD22618","user_header":"https://static001.geekbang.org/account/avatar/00/17/30/23/e1454937.jpg","comment_is_top":false,"comment_ctime":1559556948,"is_pvip":false,"replies":[{"id":"36258","content":"是的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559611563,"ip_address":"","comment_id":100445,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559556948","product_id":100017301,"comment_content":"代码不是很精，看老师写的那个代码，意思就是不停的调用本身的方法来造循环？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452553,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559611563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98783,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1559094504,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1559094504","product_id":100017301,"comment_content":"f(1) = 1;f(2) = 2;<br><br>台阶递归: <br>这里的f(1)= 1 代表剩下1个台阶, 有几种走法,  1种.<br>这里的f(2)=2 代表剩下2个台阶, 有几种走法,  2种( 一次一个台阶, 一次2个台阶).","like_count":0},{"had_liked":false,"id":98484,"user_name":"福布斯第一","can_delete":false,"product_type":"c1","uid":1244851,"ip_address":"","ucode":"6DA11E1E6819F2","user_header":"https://static001.geekbang.org/account/avatar/00/12/fe/b3/964eb5ac.jpg","comment_is_top":false,"comment_ctime":1559009449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559009449","product_id":100017301,"comment_content":"也许牛人只是谦虚😒","like_count":0},{"had_liked":false,"id":96805,"user_name":"名曰蓝兮","can_delete":false,"product_type":"c1","uid":1461809,"ip_address":"","ucode":"90E1873682991F","user_header":"https://static001.geekbang.org/account/avatar/00/16/4e/31/3a7e74c1.jpg","comment_is_top":false,"comment_ctime":1558511646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558511646","product_id":100017301,"comment_content":"条件断点","like_count":0},{"had_liked":false,"id":92214,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1557202573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557202573","product_id":100017301,"comment_content":"在方法体中记录一些标示，每次调试进来的就是当前的信息。","like_count":0},{"had_liked":false,"id":89818,"user_name":"陛下","can_delete":false,"product_type":"c1","uid":1502609,"ip_address":"","ucode":"0EE22B4A1904F6","user_header":"https://static001.geekbang.org/account/avatar/00/16/ed/91/5dece756.jpg","comment_is_top":false,"comment_ctime":1556272314,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556272314","product_id":100017301,"comment_content":"输出日志，把想要调试的值都输出到日志文件；<br>上面检查死循环，我想到用集合先存储每次计算出来的值，如果发现计算的值已经存在在集合中，就说明死循环了，个人的一点浅见；","like_count":0},{"had_liked":false,"id":88756,"user_name":"若风","can_delete":false,"product_type":"c1","uid":1450599,"ip_address":"","ucode":"149CA826B3E357","user_header":"https://static001.geekbang.org/account/avatar/00/16/22/67/f073b7f9.jpg","comment_is_top":false,"comment_ctime":1555993425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555993425","product_id":100017301,"comment_content":"f(n)=f(n-1)+1 f(1)=1 让我想起了通项公式f(n)=n","like_count":0},{"had_liked":false,"id":87478,"user_name":"犇","can_delete":false,"product_type":"c1","uid":1241705,"ip_address":"","ucode":"CCA66C9BF3EBAB","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/69/a925db7a.jpg","comment_is_top":false,"comment_ctime":1555604446,"is_pvip":false,"replies":[{"id":"31491","content":"有点那个意思。加油，这次别放弃了，坚持学完，肯定有收获。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555639255,"ip_address":"","comment_id":87478,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555604446","product_id":100017301,"comment_content":"老师，我觉得，递归的思想是不是跟数学归纳法的思想是一致的？时隔一年再次拿起了这个专栏🤔","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447474,"discussion_content":"有点那个意思。加油，这次别放弃了，坚持学完，肯定有收获。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555639255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86812,"user_name":"大大大侠饶命","can_delete":false,"product_type":"c1","uid":1253975,"ip_address":"","ucode":"9C59655D514AA2","user_header":"https://static001.geekbang.org/account/avatar/00/13/22/57/0ecc24e8.jpg","comment_is_top":false,"comment_ctime":1555463542,"is_pvip":false,"replies":[{"id":"31219","content":"f(n) = f(n-1) + f(n-2) + f(n-3)","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555468884,"ip_address":"","comment_id":86812,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555463542","product_id":100017301,"comment_content":"老师，我想问7个台阶的那个问题，假如说可以走1步，2步，，或者3步，是什么个公式呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447187,"discussion_content":"f(n) = f(n-1) + f(n-2) + f(n-3)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555468884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86691,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1555426667,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1555426667","product_id":100017301,"comment_content":"1.防止死循环可以用bitmap<br>2.调试时可以用if附加条件,在条件内加断点。","like_count":0},{"had_liked":false,"id":85439,"user_name":"寻找大卫","can_delete":false,"product_type":"c1","uid":1336941,"ip_address":"","ucode":"9F80960AA9E51C","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/6d/71d98c9f.jpg","comment_is_top":false,"comment_ctime":1555060518,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1555060518","product_id":100017301,"comment_content":"看到一半就来留言了，把递归讲的明明白白太赞了","like_count":0,"discussions":[{"author":{"id":1116188,"avatar":"https://static001.geekbang.org/account/avatar/00/11/08/1c/ef15e661.jpg","nickname":" 臣馟飞扬","note":"","ucode":"F2F882B7678055","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53055,"discussion_content":"看了这么多理论，依然写不好递归代码，扎心啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574127871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85324,"user_name":"ywk","can_delete":false,"product_type":"c1","uid":1474458,"ip_address":"","ucode":"23F96551D2E9D1","user_header":"https://static001.geekbang.org/account/avatar/00/16/7f/9a/f6e6bd64.jpg","comment_is_top":false,"comment_ctime":1555037032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555037032","product_id":100017301,"comment_content":"步数的例子是少了一阶的斐波那契[Fibonacci]数列吧","like_count":0},{"had_liked":false,"id":84432,"user_name":"yshnb!","can_delete":false,"product_type":"c1","uid":1488301,"ip_address":"","ucode":"E93A9132532492","user_header":"https://static001.geekbang.org/account/avatar/00/16/b5/ad/587a45dc.jpg","comment_is_top":false,"comment_ctime":1554861351,"is_pvip":false,"replies":[{"id":"30465","content":"有点那个意思","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554938812,"ip_address":"","comment_id":84432,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554861351","product_id":100017301,"comment_content":"递归是不是都用到了分治的思想呢<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446356,"discussion_content":"有点那个意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554938812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84298,"user_name":"J²","can_delete":false,"product_type":"c1","uid":1082365,"ip_address":"","ucode":"13C3F52946725F","user_header":"https://static001.geekbang.org/account/avatar/00/10/83/fd/94bf3f4b.jpg","comment_is_top":false,"comment_ctime":1554822082,"is_pvip":false,"replies":[{"id":"30467","content":"后面有讲到的 别急","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554938874,"ip_address":"","comment_id":84298,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554822082","product_id":100017301,"comment_content":"递归算法的时间复杂度怎么分析呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446308,"discussion_content":"后面有讲到的 别急","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554938874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83138,"user_name":"木木","can_delete":false,"product_type":"c1","uid":1411645,"ip_address":"","ucode":"BF590964828F8C","user_header":"https://static001.geekbang.org/account/avatar/00/15/8a/3d/5f29e927.jpg","comment_is_top":false,"comment_ctime":1554434809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554434809","product_id":100017301,"comment_content":"4.5<br>递归，数据结构中最难理解的可能就是动态规划和递归了，但递归生活中很常用，出去的叫&quot;递&quot;，回来的叫&quot;归&quot;，所有递归都能写出数学表达式<br>1.递归的三个条件<br>分支:一个问题的解分成几个子问题的解，规模依次递减<br>分支关系:规模依次递减的问题，他们求解思路完全相同<br>终止条件:规模依次递减，就一定存在终止条件，即最小边界<br>注:由此可见，递归是从n规模倒推回去的，设n规模时解方法为f(n)，规模递减之后n-1&#47;n-2但求解思路一样，所以他们解方法肯定一样f(n-2)或者f(n-1)<br>2.代码编写<br>难点:写出递归公式，找出终止条件<br>如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？如果有 7 个台阶，那如何用编程求得总共有多少种走法呢？<br>解:<br>a.递归式子<br>从规模n开始，设解方法为f(n)，由于到n规模前一次操作的规模是n-1或n-2，他们求解方法完全一样f(n-1)或f(n-2)，每次操作，都是如此，求总共和，故两者想加f(n)=f(n-1)+f(n-2)<br>b.终止条件<br>当最后一次递归操作(逆序)，等价最开始的一次操作(顺序)，走到台阶1(n=1)或台阶2(n=2)，对应走法为1，2(走到台阶2:2次1步&#47;1次2步共两种)，解方法为f(1)=1，f(2)=2<br>c.警惕堆栈溢出<br>解决办法限制最大递归深度(也就是执行次数)，计数器解决，但这个不好用，不知道当前栈空间，计算也很难，所以10&#47;50次可以考虑，超出最好不用<br>&#47;&#47; 全局变量，表示递归的深度。<br>int depth = 0;<br><br>int f(int n) {<br>  ++depth；<br>  if (depth &gt; 1000) throw exception;<br>  <br>  if (n == 1) return 1;<br>  return f(n-1) + 1;<br>}<br><br>d.警惕重复计算<br>解决办法，另辟空间储存已求得的解，每次递归式子执行前，先判定是否已经存在，存在直接返回结果，不用再算<br>public int f(int n) {<br>  if (n == 1) return 1;<br>  if (n == 2) return 2;<br>  <br>  &#47;&#47; hasSolvedList 可以理解成一个 Map，key 是 n，value 是 f(n)<br>  if (hasSolvedList.containsKey(n)) {<br>    return hasSovledList.get(n);<br>  }<br><br>  int ret = f(n-1) + f(n-2);<br>  hasSovledList.put(n, ret);<br>  return ret;<br>}<br>3.非递归实现<br>只是模拟递归实现过程，迭代循环过程，本质没有变，徒增了复杂度<br>4.递归代码的调试<br>单步追踪已经无法解决，打印日志发现递归值，结合条件断点调试<br>5.递归性能<br>递归代码虽然简洁高效，但是，递归代码也有很多弊端。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码的时候，一定要控制好这些副作用。<br>6.递归注意事项<br>递归只有一个分支时，很容易理解每一个步骤，但是递归有多个分支，如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A，再找分支关系(数学语言:求递归式子)","like_count":0},{"had_liked":false,"id":80086,"user_name":"高健宇","can_delete":false,"product_type":"c1","uid":1396745,"ip_address":"","ucode":"6A7E90CEE248AD","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/09/57be9ecf.jpg","comment_is_top":false,"comment_ctime":1553603446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553603446","product_id":100017301,"comment_content":"如果推荐人存在表里面，数据库支持这种查询sql.","like_count":0},{"had_liked":false,"id":78688,"user_name":"莫问流年","can_delete":false,"product_type":"c1","uid":1249663,"ip_address":"","ucode":"23140E031AED4B","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/7f/80d56c1c.jpg","comment_is_top":false,"comment_ctime":1553218300,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553218300","product_id":100017301,"comment_content":"递归调试技巧：<br>1. 打印日志<br>2. 条件调试","like_count":0},{"had_liked":false,"id":75949,"user_name":"疾风狂草","can_delete":false,"product_type":"c1","uid":1283489,"ip_address":"","ucode":"05F899725048BC","user_header":"","comment_is_top":false,"comment_ctime":1552496544,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552496544","product_id":100017301,"comment_content":"老师，请教一下，排除人工模拟栈的话，有没有具体场景是只能用递归实现的。因为听到一个大牛说，所有递归都可以写成非递归的形式，效率高风险低。我查了一下我所知道的递归场景，没找到特例。","like_count":0},{"had_liked":false,"id":75865,"user_name":"鹅鹅鹅","can_delete":false,"product_type":"c1","uid":1348721,"ip_address":"","ucode":"C6372567C83738","user_header":"https://static001.geekbang.org/account/avatar/00/14/94/71/e8ec9843.jpg","comment_is_top":false,"comment_ctime":1552484654,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552484654","product_id":100017301,"comment_content":"老师后面有没有高阶的课程啊，就是更多的涉及到数学推理的课程","like_count":0},{"had_liked":false,"id":74086,"user_name":"locke.wei","can_delete":false,"product_type":"c1","uid":1351535,"ip_address":"","ucode":"58C70AC52A0C84","user_header":"https://static001.geekbang.org/account/avatar/00/14/9f/6f/aee1732a.jpg","comment_is_top":false,"comment_ctime":1552101165,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552101165","product_id":100017301,"comment_content":"尾调用可以解决空间复杂度问题","like_count":0},{"had_liked":false,"id":72421,"user_name":"cserbo","can_delete":false,"product_type":"c1","uid":1240958,"ip_address":"","ucode":"C8D1A83A675CA0","user_header":"https://static001.geekbang.org/account/avatar/00/12/ef/7e/ecea53d2.jpg","comment_is_top":false,"comment_ctime":1551621964,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551621964","product_id":100017301,"comment_content":"调试递归到底是怎么调试的，可否说的更详细些，留言中说的打印日志的方法，不理解是什么意思","like_count":0},{"had_liked":false,"id":72087,"user_name":"左手画圈~","can_delete":false,"product_type":"c1","uid":1339710,"ip_address":"","ucode":"CD6C66C8510EAF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/C4Qhy5XHSe7nXRF3dicfic4VB0eA3HxGcX9cT7kcaibztP29xHHcODK5Hu05ZqxWbe4AHUUicF4Q767TViafETbib59A/132","comment_is_top":false,"comment_ctime":1551516923,"is_pvip":false,"replies":[{"id":"26269","content":"哈哈，你说的对！请看后面的“总结课”那一节，我有讲到这个问题的解决思路。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551666106,"ip_address":"","comment_id":72087,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551516923","product_id":100017301,"comment_content":"老师 递归查询的时候，如果层级较深，耗时不就太长了吗，数据库的连接和数据接收都是通过网络的，一旦涉及网络，单次耗时就是个不定值","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441454,"discussion_content":"哈哈，你说的对！请看后面的“总结课”那一节，我有讲到这个问题的解决思路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551666106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71842,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1551449352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551449352","product_id":100017301,"comment_content":"打日志调试😁","like_count":0},{"had_liked":false,"id":69945,"user_name":"chouyarn","can_delete":false,"product_type":"c1","uid":1008038,"ip_address":"","ucode":"DCD4D450784192","user_header":"https://static001.geekbang.org/account/avatar/00/0f/61/a6/9adb0bf2.jpg","comment_is_top":false,"comment_ctime":1550913157,"is_pvip":false,"replies":[{"id":"25053","content":"嗯嗯 是的，抱歉。有些内容是没有涉及。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551060899,"ip_address":"","comment_id":69945,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550913157","product_id":100017301,"comment_content":"二刷，但老师没讲尾递归相关的知识呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440369,"discussion_content":"嗯嗯 是的，抱歉。有些内容是没有涉及。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551060899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68180,"user_name":"康斯坦丁","can_delete":false,"product_type":"c1","uid":1368096,"ip_address":"","ucode":"C130E800E8D5C9","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/20/003190c1.jpg","comment_is_top":false,"comment_ctime":1550454536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550454536","product_id":100017301,"comment_content":"条件调试","like_count":0},{"had_liked":false,"id":67587,"user_name":"陈鹏","can_delete":false,"product_type":"c1","uid":1387243,"ip_address":"","ucode":"C672C13C17A0E6","user_header":"https://static001.geekbang.org/account/avatar/00/15/2a/eb/2931dc71.jpg","comment_is_top":false,"comment_ctime":1550202520,"is_pvip":true,"replies":[{"id":"25407","content":"深度是50吧，你可以自己画一画","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551232899,"ip_address":"","comment_id":67587,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550202520","product_id":100017301,"comment_content":"老师针对第二道题：如果传入参数为50层阶梯,那么递归深度是多少？怎么计算的","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439264,"discussion_content":"深度是50吧，你可以自己画一画","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551232899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66928,"user_name":"Aaron","can_delete":false,"product_type":"c1","uid":1067913,"ip_address":"","ucode":"441614DAEAF8D0","user_header":"https://static001.geekbang.org/account/avatar/00/10/4b/89/a65d1a3f.jpg","comment_is_top":false,"comment_ctime":1550043512,"is_pvip":false,"replies":[{"id":"24640","content":"没写错呢。有些actor是没有推荐人的，自己注册的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550728291,"ip_address":"","comment_id":66928,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550043512","product_id":100017301,"comment_content":"推荐人那个 demo 第二行 是不是写错了 应该是 where referenceid = actorId 吧?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438980,"discussion_content":"没写错呢。有些actor是没有推荐人的，自己注册的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550728291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65754,"user_name":"Pre-Y","can_delete":false,"product_type":"c1","uid":1396900,"ip_address":"","ucode":"A13D13A37F3ABC","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/a4/8d2e454b.jpg","comment_is_top":false,"comment_ctime":1549624138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549624138","product_id":100017301,"comment_content":"今日份的打卡。<br>想到递归就想到数学归纳法，想到数学归纳法就想起了老师曾经要求的解题格式😂<br>1.证明当n＝1时命题成立<br>2.假设n＝m时命题成立，那么可以推导出在n＝m+1时命题成立。<br>","like_count":0},{"had_liked":false,"id":64737,"user_name":"晓龙","can_delete":false,"product_type":"c1","uid":1004576,"ip_address":"","ucode":"78CDCEBD183D3A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/20/93c79f7c.jpg","comment_is_top":false,"comment_ctime":1548897145,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548897145","product_id":100017301,"comment_content":"防止重复计算（key value记录）<br>递归终止条件<br>死循环（a-b-c-a）","like_count":0},{"had_liked":false,"id":64650,"user_name":"镞砺括羽","can_delete":false,"product_type":"c1","uid":1309089,"ip_address":"","ucode":"EC4CD773CA06EA","user_header":"https://static001.geekbang.org/account/avatar/00/13/f9/a1/0396e1fb.jpg","comment_is_top":false,"comment_ctime":1548842532,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548842532","product_id":100017301,"comment_content":"和作者说的一样，我遇到递归时总是想把每一步都想清楚，然后就觉得自己脑容量不够，智力有问题了","like_count":0},{"had_liked":false,"id":63858,"user_name":"Cheng少、Ian","can_delete":false,"product_type":"c1","uid":1364152,"ip_address":"","ucode":"7D781695F8D737","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/b8/5c1a1930.jpg","comment_is_top":false,"comment_ctime":1548560674,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548560674","product_id":100017301,"comment_content":"有一些编译器支持尾递归自动优化，可以解决栈溢出的问题","like_count":0},{"had_liked":false,"id":63371,"user_name":"安南寸暖🤕","can_delete":false,"product_type":"c1","uid":1387564,"ip_address":"","ucode":"9E8036B99E3F16","user_header":"https://static001.geekbang.org/account/avatar/00/15/2c/2c/77f80dfc.jpg","comment_is_top":false,"comment_ctime":1548334927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548334927","product_id":100017301,"comment_content":"像这个问题我觉的 是不是可以用队列 三个数的队列就是实现了呢  感觉很非彼那切数列很想啊 3 = 2 + 1  只要我们有了最后的值，前面第一个的值就可以不要了呀。","like_count":0},{"had_liked":false,"id":61733,"user_name":"杨家荣","can_delete":false,"product_type":"c1","uid":1259241,"ip_address":"","ucode":"3DA65396C7F002","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/g1icQRbcv1QvJ5U8Cqk0ZqMH5PcMTXcZ8TpS5utE4SUzHcnJA3FYGelHykpzTfDh55ehE8JO9Zg9VGSJW7Wxibxw/132","comment_is_top":false,"comment_ctime":1547784248,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547784248","product_id":100017301,"comment_content":"斐波那契数列经典算法","like_count":0},{"had_liked":false,"id":61536,"user_name":"好吃二师兄","can_delete":false,"product_type":"c1","uid":1242173,"ip_address":"","ucode":"A367B52BC79199","user_header":"https://static001.geekbang.org/account/avatar/00/12/f4/3d/ec3d6348.jpg","comment_is_top":false,"comment_ctime":1547717314,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547717314","product_id":100017301,"comment_content":"阶梯那个，求出所有的走法<br>    private static int step(int n, String steps){<br>        if(n == 1){<br>            System.out.println(&quot;路径：&quot; + steps + &quot;1&quot;);<br>            return 1;<br>        }<br>        if(n == 2){<br>            System.out.println(&quot;路径：&quot; + steps + &quot;2&quot;);<br>            System.out.println(&quot;路径：&quot; + steps + &quot;1,&quot; + &quot;1&quot;);<br>            return 2;<br>        }<br>        int a = step(n - 1, steps + &quot;1,&quot;);<br>        int b = step(n - 2, steps + &quot;2,&quot;);<br>        return a + b;<br>    }","like_count":0},{"had_liked":false,"id":58102,"user_name":"Chok Wah","can_delete":false,"product_type":"c1","uid":1147040,"ip_address":"","ucode":"4DD3D6E978BA36","user_header":"https://static001.geekbang.org/account/avatar/00/11/80/a0/26a8d76b.jpg","comment_is_top":false,"comment_ctime":1546997815,"is_pvip":false,"replies":[{"id":"20921","content":"压栈的并不仅仅是临时变量","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546999557,"ip_address":"","comment_id":58102,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546997815","product_id":100017301,"comment_content":"有个疑问，写了死循环的函数也会堆栈溢出。并没有创建临时变量，如void donothing { donothing (）}。是不是因为函数里的内容就是一个栈，不断自己调用自己就是不断把自己入栈，导致溢出？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435905,"discussion_content":"压栈的并不仅仅是临时变量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546999557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57598,"user_name":"泉","can_delete":false,"product_type":"c1","uid":1099760,"ip_address":"","ucode":"914709BE802A8D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/f0/aa2e0749.jpg","comment_is_top":false,"comment_ctime":1546845341,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1546845341","product_id":100017301,"comment_content":"递归条件:1.一个问题可以分为一个或者多个子问题；2.原问题和子问题除了数据规模不同，解决方法一样；3.存在终止条件。<br>递归可能有栈溢出，重复计算的问题。","like_count":0},{"had_liked":false,"id":57592,"user_name":"陌上人 .","can_delete":false,"product_type":"c1","uid":1207075,"ip_address":"","ucode":"02D0044843172B","user_header":"https://static001.geekbang.org/account/avatar/00/12/6b/23/73f18275.jpg","comment_is_top":false,"comment_ctime":1546843611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546843611","product_id":100017301,"comment_content":"检测环是否存在,可将每次的结果压入一个数组,查询完成之后之后再检测数组中这个推荐人ID是否存在,存在且不为nul的话就证明环的存在<br>不知道这个办法是否可行","like_count":0},{"had_liked":false,"id":56969,"user_name":"永旭","can_delete":false,"product_type":"c1","uid":1068819,"ip_address":"","ucode":"C9C74BE32C8F46","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/13/5197f8d2.jpg","comment_is_top":false,"comment_ctime":1546589400,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546589400","product_id":100017301,"comment_content":"上楼梯每个步骤java 实现的,感觉跟递推公式实现的不一样啊 .<br>public static int[] stepArray = {1,2}; &#47;&#47; 步伐种类<br>&#47;**<br>     * @param ladder 指定台阶数<br>     * @param result 结果<br>     *&#47;<br>    public static void getStep(int ladder, ArrayList&lt;Integer&gt; result) {<br>        &#47;&#47; 正好到达指定台阶<br>        if (ladder == 0) {<br>            System.out.println(result);<br>            return;<br>        }<br>        &#47;&#47; 超过指定台阶<br>        else if (ladder &lt; 0) {<br>            return;<br>        } else {<br>            for (int step : stepArray) {<br>                ArrayList&lt;Integer&gt; subResult = (ArrayList&lt;Integer&gt;) result.clone();<br>                subResult.add(step);<br>                getStep(ladder - step,subResult);<br>            }<br>        }<br>    }<br>-------------<br>        int ladder = 7;<br>        getStep(ladder, new ArrayList&lt;Integer&gt;());","like_count":0},{"had_liked":false,"id":54952,"user_name":"雍鹏亮","can_delete":false,"product_type":"c1","uid":1179992,"ip_address":"","ucode":"A7E394043295B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/01/58/98719136.jpg","comment_is_top":false,"comment_ctime":1545987661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545987661","product_id":100017301,"comment_content":"循环是人类思维，递归是上帝思维。","like_count":0},{"had_liked":false,"id":53288,"user_name":"CathyLin","can_delete":false,"product_type":"c1","uid":1240546,"ip_address":"","ucode":"F7CDFF5E1A235F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/e2/0e1c6c5a.jpg","comment_is_top":false,"comment_ctime":1545622645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545622645","product_id":100017301,"comment_content":"思考题：<br>如果递归深度较大，我一般会选择打印出来结果。然后大致的根据打印出来的结果看一下是不是编写的时候思路出现了问题。因为有结果输出，所以看起来会比较方便。<br>(update: 看了评论区大牛的说法，是叫打印日志= =）<br><br>想法：<br>1）在递归重复计算那里，还有一个思路就是：一开始全都标记为 -1，那么如果不是 -1，说明是已经计算过了的，那么就直接返回。<br>2）学到了，递归果然不能一步一步去思考，要不然会把自己也给绕进去。真的！！！只要把握好递归式和结束条件就可以了！！！<br><br>笔记<br>递归需要满足的三个条件<br>1）一个问题的解可以分解为几个子问题的解 - 子问题就是数据规模更小的问题<br>2）这个问题与分解之后的问题，除了数据规模不一样，求解的思路还是一样的<br>3）存在递归终止条件<br><br>如何编写递归代码<br>最重要的是写出递推公式，找出终止条件就可以了。<br>然后将递归公式转化成代码就很简单了。<br><br>正确理解递归代码的思路<br>对于递归代码，如果试图去理解每个递和归的过程，那么会陷入一种思维误区，也会产生理解障碍。<br><br>正确的理解方式是：<br>如果一个问题 A 可以分解为若干子问题 B, C, D。你可以假设子问题 B, C, D 已经解决，然后在此基础上思考怎样解决 A。<br>而且，我们只需要思考 A 与 B, C, D 之间的关系就可以了。不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，然后理解起来就简单多了。<br><br>\t• 编写递归代码的关键是：只要遇到递归，我们就把它抽象为一个递归公式，不用想一层层的调用关系。不要试图用人脑去分解递归的每个步骤。<br><br>递归代码要警惕堆栈溢出<br>因为函数调用会使用栈来保存临时变量，每调用一个函数，都会将相应的临时变量作为栈帧压入到内存栈中，直到函数结束才出栈。但是系统栈 &#47; 虚拟机栈内存空间不是很大，如果递归调用层次很深的话，就会一直压入栈，那么就会有堆栈溢出的风险。<br><br>如何避免？<br>设置递归调用的最大深度来限制溢出。<br>但是并不能完全解决问题，因为当前最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。<br><br>递归代码要警惕重复计算<br>1）用散列表来标记是否之前已经求过，如果求过那么就直接返回。<br>2）或者一开始全都标记为 -1，那么如果不是 -1，说明是已经计算过了的。<br><br>递归在空间复杂度上，因为递归调用一次就会在内存栈中保存一次数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。<br><br>递归本身就是借助于栈来实现的，所以一般来说递归式都可以改变为迭代式。<br><br>对于比较浅的递归式，我们可以使用单步追踪的方法来调试。但是对于层次比较深的，可以通过打印日志的方式来 debug。","like_count":0},{"had_liked":false,"id":53080,"user_name":"于林杰","can_delete":false,"product_type":"c1","uid":1252868,"ip_address":"","ucode":"5CD4AFD506D50B","user_header":"https://static001.geekbang.org/account/avatar/00/13/1e/04/a7d57e9f.jpg","comment_is_top":false,"comment_ctime":1545580161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545580161","product_id":100017301,"comment_content":"既然递归这么耗资源，为什么使用还那么广泛。","like_count":0},{"had_liked":false,"id":52102,"user_name":"caicongyang","can_delete":false,"product_type":"c1","uid":1009447,"ip_address":"","ucode":"B1984736E7C0C2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/27/bca407e1.jpg","comment_is_top":false,"comment_ctime":1545310170,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545310170","product_id":100017301,"comment_content":"没看懂非递推的写法，希望老师能有注释","like_count":0},{"had_liked":false,"id":51808,"user_name":"银河号","can_delete":false,"product_type":"c1","uid":1318813,"ip_address":"","ucode":"0E53DCCE2D48B0","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83ericM7MZkvFKae8K9EKjukiaGZnNxecd4Yicol4fPV1eM0puaZXOEJD2wJ0XJfe63og1Dibr0Wa1Tph9w/132","comment_is_top":false,"comment_ctime":1545265924,"is_pvip":false,"replies":[{"id":"18781","content":"会有压力。不过如果递归不深的话 也是ok的。这样要具体看了。也不好一概而论","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545271154,"ip_address":"","comment_id":51808,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1545265924","product_id":100017301,"comment_content":"老师，递归查询数据库难道不会对数据库的产生很大压力吗，我只知道循环查询是这样的，不知道递归会不会？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433628,"discussion_content":"会有压力。不过如果递归不深的话 也是ok的。这样要具体看了。也不好一概而论","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545271154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1077060,"avatar":"https://static001.geekbang.org/account/avatar/00/10/6f/44/5e9fe724.jpg","nickname":"高高兴兴","note":"","ucode":"426B2CB242F89C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202845,"discussion_content":"老师，我购买的课程怎么不能看了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583970459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51655,"user_name":"睡痴儿😑","can_delete":false,"product_type":"c1","uid":1187204,"ip_address":"","ucode":"750EF858EF2042","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/84/d0ec0064.jpg","comment_is_top":false,"comment_ctime":1545218437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545218437","product_id":100017301,"comment_content":"输入输出值的方式来判断。","like_count":0},{"had_liked":false,"id":51379,"user_name":"左瞳","can_delete":false,"product_type":"c1","uid":1206589,"ip_address":"","ucode":"B262A3E99C8605","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/3d/3cfb9b87.jpg","comment_is_top":false,"comment_ctime":1545179869,"is_pvip":false,"replies":[{"id":"18545","content":"这个要具体看了 有些代码不好写成非递归的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545184421,"ip_address":"","comment_id":51379,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545179869","product_id":100017301,"comment_content":"是否在我们开发中应该避免写递归？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433434,"discussion_content":"这个要具体看了 有些代码不好写成非递归的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545184421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50399,"user_name":"金咩咩","can_delete":false,"product_type":"c1","uid":1150607,"ip_address":"","ucode":"7F328A5F98EAC6","user_header":"https://static001.geekbang.org/account/avatar/00/11/8e/8f/517c89a9.jpg","comment_is_top":false,"comment_ctime":1544966709,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544966709","product_id":100017301,"comment_content":"老师能不能分享下把递归改写成循环的思路？","like_count":0},{"had_liked":false,"id":48401,"user_name":"jiaobuchongจุ๊บ","can_delete":false,"product_type":"c1","uid":1118938,"ip_address":"","ucode":"0AEE4E579DC3A2","user_header":"https://static001.geekbang.org/account/avatar/00/11/12/da/a3ea305f.jpg","comment_is_top":false,"comment_ctime":1544436104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544436104","product_id":100017301,"comment_content":"   private static long f(int n) {<br>        System.out.println(n);<br>        if (n == 1) {<br>            return 1L;<br>        }<br>        if (n == 2) {<br>            return 2L;<br>        }<br>        return f(n - 1) + f(n - 2);<br>    }<br>测试了下，当 n 比较大时，比如是 50 或 100，比用循环迭代计算慢了很多，差距挺大的","like_count":0},{"had_liked":false,"id":48276,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1544409843,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544409843","product_id":100017301,"comment_content":"这个应该是属于算法的范畴<br><br>来历：<br>特点：表达力强，代码简洁；空间复杂度高、堆栈溢出，重复计算，过多的函数调用<br>1、有递推公式，有终止条件<br>迭代循环<br><br>适合解决的问题：<br>实际应用：<br>问答：没有想到好的办法，又看评论了，说打印log","like_count":0},{"had_liked":false,"id":48119,"user_name":"匆匆","can_delete":false,"product_type":"c1","uid":1333414,"ip_address":"","ucode":"4DB39C6CD5743B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/H8NxrljQXliccaT5fjdXJQYS3ou3Z9ykAuKw6EgicicEA9L4jQLz3h85P0odgDSaK0cA9oTyUKibbiagdNvnHuuV5mQ/132","comment_is_top":false,"comment_ctime":1544361192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544361192","product_id":100017301,"comment_content":"关于递归 <br><br>递归分两个过程，一个是“递”，一个是“归”，分别代表层层深入和层层返回值的过程。<br><br>递归需要满足三个条件：1、一个问题的解可以分解成几个过程的解。2、分解后的子问题同父问题的求解思路一样。3、存在终止条件（归的条件）<br><br>如何写递归：1、写出递归公式。2、找到终止条件。<br><br>写递归代码的关键：遇到递归就把他想抽象成一个递归公式。不用去想一层一层的调用关系，不要试图用人脑去分解递归的每个步骤。<br><br>警惕堆栈溢出：因为函数调用会使用栈来保存临时变量。每调用一个函数就会将临时变量封装为栈帧压入内存栈，函数执行完在返回出栈。所以当递归层数太多时可能会造成堆栈溢出。\t如何避免：限制最大深度；其他。<br><br>警惕重复计算：（我认为）当递归公式里有多个条件判断时可能会在不同条件分支里出现重复计算。解决：通过数据结构保存已经求过的解。（哈希）<br>","like_count":0},{"had_liked":false,"id":47745,"user_name":"Kian.Lee","can_delete":false,"product_type":"c1","uid":1086568,"ip_address":"","ucode":"3FB08A00F2DFD7","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/68/56794ea3.jpg","comment_is_top":false,"comment_ctime":1544190228,"is_pvip":false,"discussion_count":0,"race_medal":5,"score":"1544190228","product_id":100017301,"comment_content":"现在有些语言（比如Lua、ES6）有“尾调用”优化和“尾递归”优化，在这些语言中使用尾递归不会造成栈溢出。<br>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，直接用内层函数的调用帧取代外层函数的即可。<br>尾递归的实现往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。","like_count":0},{"had_liked":false,"id":46629,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1543966577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543966577","product_id":100017301,"comment_content":"思考题: 可以首先把递归条件理解清楚用debug的condition和evaluate expression功能去判断递归的入口条件和终止条件是否符合预期, 然后可以忽略掉中间的步骤, 这样自己应该就不会乱掉.","like_count":0},{"had_liked":false,"id":46338,"user_name":"王鸿运","can_delete":false,"product_type":"c1","uid":1068577,"ip_address":"","ucode":"14AF7B485D29A1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/21/700586eb.jpg","comment_is_top":false,"comment_ctime":1543903344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543903344","product_id":100017301,"comment_content":"防止递归堆栈太深导致溢出可以进行两种方式优化:<br>1.当达到一定深度时，修改成非递归算法，比如快排算法，当递归深度达到一定次数，对于子集采用堆排<br>2.优化成尾递归算法，因为尾递归方式，回归阶段不需要任何操作，所以可以直接覆盖栈桢，也就也会有堆栈溢出问题了<br><br>工作以后单步调试基本不用了，只要调试还是code review+log+经验<br>通过崩溃堆栈，减少定位范围，通过日志打印输出流，通过概率出线或者必现根据经验判断原因，如果是函数退出崩溃，大概率内存操作越界了（越界导致内存分配元数据被改，内存释放崩溃）<br>另外，查看线上日志（程序日志，系统日志，nginx日志等）找到出线问题的输入，来重现问题也更能方便定位","like_count":0},{"had_liked":false,"id":46238,"user_name":"王鸿运","can_delete":false,"product_type":"c1","uid":1068577,"ip_address":"","ucode":"14AF7B485D29A1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/21/700586eb.jpg","comment_is_top":false,"comment_ctime":1543887741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543887741","product_id":100017301,"comment_content":"为了防止递归堆栈溢出 可以优化成尾递归方式<br>实际工作中，最主要的调试方式还是打印日志流啊<br>当然了，工作中能不用递归就不用递归，代码移植到盒子，tv上，堆栈溢出会让你崩溃的","like_count":0},{"had_liked":false,"id":45781,"user_name":"coco","can_delete":false,"product_type":"c1","uid":1310547,"ip_address":"","ucode":"23D28C1C237494","user_header":"https://static001.geekbang.org/account/avatar/00/13/ff/53/dfaff7e3.jpg","comment_is_top":false,"comment_ctime":1543795886,"is_pvip":false,"replies":[{"id":"16353","content":"如果要求性能比较高 可以离线计算 然后保存在数据库中","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543801448,"ip_address":"","comment_id":45781,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543795886","product_id":100017301,"comment_content":"作为算法入门者和两年的开发经历，想请教一下，开篇的问题中，使用递归查询最终推荐人，或者查找一个人所有辐射推荐的人，是不是会一遍一遍的查数据库，在实际开发中就是这样做的吗，有没有更好的办法，从查询速度和系统性能两方面考虑，比较好的做法是什么样呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431208,"discussion_content":"如果要求性能比较高 可以离线计算 然后保存在数据库中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543801448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45617,"user_name":"Aitozi","can_delete":false,"product_type":"c1","uid":1118091,"ip_address":"","ucode":"B8096312BAD560","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/8b/25d118be.jpg","comment_is_top":false,"comment_ctime":1543724873,"is_pvip":false,"replies":[{"id":"16361","content":"可以调大jvm栈的大小","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543801998,"ip_address":"","comment_id":45617,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543724873","product_id":100017301,"comment_content":"那如果递归的深度比较深，超过jvm的限制，是就不能采用直接递归的方式解决问题了吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431122,"discussion_content":"可以调大jvm栈的大小","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543801998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45435,"user_name":"krugle","can_delete":false,"product_type":"c1","uid":1045770,"ip_address":"","ucode":"60A7D9189C01BE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/0a/077b9922.jpg","comment_is_top":false,"comment_ctime":1543640608,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543640608","product_id":100017301,"comment_content":"java 我测试几十亿次递归一秒钟,比c还快，java是怎么优化的呢","like_count":0},{"had_liked":false,"id":44545,"user_name":"喜欢你的笑","can_delete":false,"product_type":"c1","uid":1076836,"ip_address":"","ucode":"DC9867EA2D4D97","user_header":"https://static001.geekbang.org/account/avatar/00/10/6e/64/9b000b4f.jpg","comment_is_top":false,"comment_ctime":1543456175,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543456175","product_id":100017301,"comment_content":"1、用递归的方法查找是时间换空间。<br>2、抛开本节内容不谈，我觉得是否可以用并查集的思想及空间换时间的思想，增加一列最终推荐人，这样查询最终推荐人时间复杂度在$O(1)$。","like_count":0},{"had_liked":false,"id":42994,"user_name":"Geek_987169","can_delete":false,"product_type":"c1","uid":1180853,"ip_address":"","ucode":"4B2955A044805D","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/b5/8bc4790b.jpg","comment_is_top":false,"comment_ctime":1543132148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543132148","product_id":100017301,"comment_content":"五星好评✨✨✨✨✨已送达！","like_count":0},{"had_liked":false,"id":42872,"user_name":"李坤","can_delete":false,"product_type":"c1","uid":1316193,"ip_address":"","ucode":"D05334A45B2B7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/15/61/ebbf6a33.jpg","comment_is_top":false,"comment_ctime":1543067622,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543067622","product_id":100017301,"comment_content":"判断是否存在环，可以在求解一个子问题开始时用散列表来进行标记，求解完成后清除标记。如果在某一次子问题求解过程中发现当前正在求解的子问题存在于散列表中，那么就说明存在环。","like_count":0},{"had_liked":false,"id":42736,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1543030048,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543030048","product_id":100017301,"comment_content":"Leetcode 698. Partition to K Equal Sum Subsets<br>Given an array of integers nums and a positive integer k, find whether it&#39;s possible to divide this array into k non-empty subsets whose sums are all equal.<br><br>Example 1:<br>Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4<br>Output: True<br>Explanation: It&#39;s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.<br><br>老师能不能讲一下这道题，看了一下网上的资料，但是都不太理解","like_count":0},{"had_liked":false,"id":42020,"user_name":"邓志国","can_delete":false,"product_type":"c1","uid":1043844,"ip_address":"","ucode":"380AE67ED7B9D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/84/0b8e2d25.jpg","comment_is_top":false,"comment_ctime":1542893412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542893412","product_id":100017301,"comment_content":"栈的问题，如果符合尾递归优化，是可以不溢出的","like_count":0},{"had_liked":false,"id":41558,"user_name":"Flash","can_delete":false,"product_type":"c1","uid":1236163,"ip_address":"","ucode":"E285075C9E0B02","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/c3/e4ba51d5.jpg","comment_is_top":false,"comment_ctime":1542805714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542805714","product_id":100017301,"comment_content":"如何自动检测( A-B-C-A )“环”的存在：结合避免递归重复计算的思路,利用Map,在将结果put之前检查map中是否已经存在，代码如下：<br>f (n) {<br>...<br>int ret = f(n-1) + f(n-2)；<br>if (hasSolvedList.containsKey(n）{<br>    throw Exception(&quot;..&quot;);<br>}<br>hasSovledList.put(n, ret);<br>return ret;<br>}<br>","like_count":0},{"had_liked":false,"id":39351,"user_name":"蓝色理想","can_delete":false,"product_type":"c1","uid":1015043,"ip_address":"","ucode":"43C8D83DC19A17","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/03/4e71c307.jpg","comment_is_top":false,"comment_ctime":1542252168,"is_pvip":false,"replies":[{"id":"14108","content":"递归和分治我的理解就是一个是编程技巧 一个是指导思想<br><br>拓扑排序可以的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542280123,"ip_address":"","comment_id":39351,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542252168","product_id":100017301,"comment_content":"递归和分治的思想是不是在于条件2不一样，及需要求解思路不一样？<br>另外环形问题的求解我怎么想到了图的数据结构，拓扑排序什么的？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429022,"discussion_content":"递归和分治我的理解就是一个是编程技巧 一个是指导思想\n\n拓扑排序可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542280123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37824,"user_name":"Neo_Zhang","can_delete":false,"product_type":"c1","uid":1175689,"ip_address":"","ucode":"92FFEFE7905AE9","user_header":"https://static001.geekbang.org/account/avatar/00/11/f0/89/25899406.jpg","comment_is_top":false,"comment_ctime":1541739431,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541739431","product_id":100017301,"comment_content":"之前做题时总是对递归这块似懂非懂，学习上总是存在偏差，现在算是明白了．^_^","like_count":0},{"had_liked":false,"id":37448,"user_name":"Ahikaka","can_delete":false,"product_type":"c1","uid":1045146,"ip_address":"","ucode":"B3A678567E40A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/vhOPEib27xAuTycN0eQekLzsCe9zwcTTcrOb98cIfpgibgcweZBDN38tIicABibuZBwah9jnGVr02H2Zjuue1fLfEQ/132","comment_is_top":false,"comment_ctime":1541591957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541591957","product_id":100017301,"comment_content":"动态规划和流计算是不是由异曲同工之妙？","like_count":0},{"had_liked":false,"id":37256,"user_name":"小老鼠","can_delete":false,"product_type":"c1","uid":1257460,"ip_address":"","ucode":"C663A0C863A515","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/f4/2dede51a.jpg","comment_is_top":false,"comment_ctime":1541508891,"is_pvip":false,"replies":[{"id":"13462","content":"有些代码写成非递归很难的 比如二叉树的遍历 递归还是非递归 看情况来选择","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541642674,"ip_address":"","comment_id":37256,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541508891","product_id":100017301,"comment_content":"记得我上学时老师建议我们所有递归代码都用顺环非递归方式来实现。由于已经过去二十多年了，忘了为什么了，老师这个有必要吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428264,"discussion_content":"有些代码写成非递归很难的 比如二叉树的遍历 递归还是非递归 看情况来选择","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541642674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36560,"user_name":"djane","can_delete":false,"product_type":"c1","uid":1249032,"ip_address":"","ucode":"5315AA246AFDD8","user_header":"","comment_is_top":false,"comment_ctime":1541150170,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541150170","product_id":100017301,"comment_content":"【笔记】<br>一、如何理解“递归”？<br>1、递归是一种非常高效、简洁的编码技巧，应用非常广泛的算法。比如 DFS 深度优先搜索、前中后序二叉树遍历等等很多数据结构和算法的编码实现都要用到递归。<br>2、递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。<br>3、基本上，所有的递归问题都可以用递推公式来表示。<br>     比如：f(n) = f(n-1) + 1;<br>               f(n) = f(n-1) + f(n-2);<br>               f(n)=n*f(n-1)。<br><br>二、递归需要满足的三个条件<br>以下三个条件只要同时满足，就可以用递归来解决。<br>1、一个问题的解可以分解为几个子问题的解<br>2、这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样<br>3、存在递归终止条件<br><br>三、如何编写递归代码？<br>1、递归代码的编写<br>写出递推公式，找到终止条件，剩下将递推公式转化为代码就很简单了。<br>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。<br>2、递归代码的理解<br>对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式应该是怎样的呢？<br>如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。<br>因此，编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。<br><br>四、递归代码要警惕堆栈溢出<br>1、为什么递归代码容易造成堆栈溢出呢？<br>在“栈”那一节讲过，函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。<br>2、如何避免出现堆栈溢出呢？<br>可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错。还是电影院那个例子，我们可以改造成下面这样子，就可以避免堆栈溢出了。不过，这里的代码是伪代码，为了代码简洁，有些边界条件没有考虑，比如 x&lt;=0。<br>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。<br><br>五、递归代码要警惕重复计算<br>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。<br><br>六、怎么将递归代码改写为非递归代码？<br>递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。<br>笼统地讲，递归代码都能用迭代循环的非递归写法来替换。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。<br>但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。<br><br>七、如何找到“最终推荐人”？<br>第一，如果递归很深，可能会有堆栈溢出的问题。<br>第二，如果数据库里存在脏数据，我们还需要处理由此产生的无限递归问题。比如demo环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果 A 的推荐人是 B，B 的推荐人是 C，C 的推荐人是 A，这样就会发生死循环。<br><br>【思考】<br>一、我们平时调试代码喜欢使用 IDE 的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，你有什么好的调试方法呢？<br>1、打印日志发现，递归值。<br>2、结合条件断点进行调试。","like_count":0},{"had_liked":false,"id":36559,"user_name":"Jeff","can_delete":false,"product_type":"c1","uid":1238705,"ip_address":"","ucode":"0CE581F252934A","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/b1/23942ff3.jpg","comment_is_top":false,"comment_ctime":1541150040,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541150040","product_id":100017301,"comment_content":"可以，原来高手也和我一样陷入误区，对递归不再那么恐慌","like_count":0},{"had_liked":false,"id":36398,"user_name":"葱头","can_delete":false,"product_type":"c1","uid":1123106,"ip_address":"","ucode":"87644C72ED5A71","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83errNia6OxtRGohu6L9NtxWzibicbEa0Fce80cwMHLic8QRM2eyliazZ9tUOsHmFLHyjWctsauMylbjvQCw/132","comment_is_top":false,"comment_ctime":1541080489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541080489","product_id":100017301,"comment_content":"老师，想问一下，文中提到所有的递归代码都可以改为这种迭代循环的非递归写法。但记得汉诺塔问题只有递归求解的方式，这个应该不能改成迭代循环吧?","like_count":0},{"had_liked":false,"id":35594,"user_name":"樱桃子77","can_delete":false,"product_type":"c1","uid":1260146,"ip_address":"","ucode":"676894101A6652","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJicwphCoQ0S1DaibWNarUJq3DrGOeADY02AreVbKCLkm0PWJmZR0f1rMrrXDRzOwLCmIQbqeibQ4uHQ/132","comment_is_top":false,"comment_ctime":1540698340,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1540698340","product_id":100017301,"comment_content":"这节课讲的很不错 ","like_count":0},{"had_liked":false,"id":35294,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1105431,"ip_address":"","ucode":"B1F8AE3AD82C51","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg","comment_is_top":false,"comment_ctime":1540512369,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540512369","product_id":100017301,"comment_content":"老师，我在做递推公式的时候，遇到一个问题，我不知道这个递推公式怎么写了，麻烦您指导下，<br><br>我的问题是这样子的，给定一个目录，求目录及所有子目录下文件的个数？<br>","like_count":0},{"had_liked":false,"id":35261,"user_name":"宋晓明","can_delete":false,"product_type":"c1","uid":1146507,"ip_address":"","ucode":"DC866DCE2FBA9E","user_header":"https://static001.geekbang.org/account/avatar/00/11/7e/8b/3cc461b3.jpg","comment_is_top":false,"comment_ctime":1540479687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540479687","product_id":100017301,"comment_content":"n个台阶的那个例子是我年初的face++面试题，很遗憾，当时都蒙圈了","like_count":0},{"had_liked":false,"id":35232,"user_name":"ForzaJuve","can_delete":false,"product_type":"c1","uid":1047302,"ip_address":"","ucode":"E090D83AE78EE6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/06/0e6b6365.jpg","comment_is_top":false,"comment_ctime":1540470710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540470710","product_id":100017301,"comment_content":"递归原理是计算机自顶向上的思维方式。它的好处是每一层循环使用的方法相同，因此原理简单，能够把复杂的大问题化解为简单的步骤。比如你坐在电影院的哪一排呢？太黑你可以问你前排，你前排再问他前排直到循环到第一排，最终回传得到答案。<br>f(n)=f(n-1)+1 其中，f(1)=1<br><br>但递归要有一个正确的结束条件，不然将陷入死循环。比如你在40岁的年纪自己不在学习提升努力做事情，把自己的理想愿望都让下一代去实现，说我这辈子就这样了，这就会陷入一代代的死循环。<br><br>写递归代码前先写递推公式<br>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最终结合翻译成代码。<br><br>只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。<br><br>写递归代码要注意堆栈溢出和重复计算的问题<br>递归代码都可以翻译成相应的迭代代码，但很多场景递归代码更好理解，递推公式，数学公式的翻译","like_count":0},{"had_liked":false,"id":35192,"user_name":"dovefi","can_delete":false,"product_type":"c1","uid":1007670,"ip_address":"","ucode":"9F8C59F095B187","user_header":"https://static001.geekbang.org/account/avatar/00/0f/60/36/1848c2b7.jpg","comment_is_top":false,"comment_ctime":1540453587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540453587","product_id":100017301,"comment_content":"基本上，每一节都讲到了痛点上！！！","like_count":0},{"had_liked":false,"id":35062,"user_name":"favorlm","can_delete":false,"product_type":"c1","uid":1120997,"ip_address":"","ucode":"CFD52127AA6E1D","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/e5/6899701e.jpg","comment_is_top":false,"comment_ctime":1540392470,"is_pvip":false,"replies":[{"id":"12584","content":"是的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540517182,"ip_address":"","comment_id":35062,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540392470","product_id":100017301,"comment_content":"我感觉递归就是比动态规划简单","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427431,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540517182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34969,"user_name":"xavier","can_delete":false,"product_type":"c1","uid":1243128,"ip_address":"","ucode":"2F7918EA37ED9F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f7/f8/3c0a6854.jpg","comment_is_top":false,"comment_ctime":1540372775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540372775","product_id":100017301,"comment_content":"第一次见把递归讲解得这么通俗易懂，例子很形象啊。<br>递归调试可以借助printf函数，打印相关变量数据。","like_count":0},{"had_liked":false,"id":34711,"user_name":"洗净铅华呈素姿","can_delete":false,"product_type":"c1","uid":1238901,"ip_address":"","ucode":"F35C833682797A","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/75/16da2d1c.jpg","comment_is_top":false,"comment_ctime":1540264972,"is_pvip":false,"replies":[{"id":"12384","content":"嗯 如果这样讲的话 例子确实有点不妥","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540292529,"ip_address":"","comment_id":34711,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540264972","product_id":100017301,"comment_content":"老师，我是你昨天夜里11:22回答的。我可能表述的意思不完整。<br><br>我觉得我应该问，这个 int n 参数的意义，是什么？如果填所在的排数，那我既然知道自己所在的排数，为什么还要用它解决问题？如果填的不是所在的排数，那么填什么？<br><br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427306,"discussion_content":"嗯 如果这样讲的话 例子确实有点不妥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540292529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34694,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1540259878,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1540259878","product_id":100017301,"comment_content":"还是 使用循环迭代模拟 递归的代码问题   <br>前者的空间复杂度时 O1 还是 O(n)呢 个人觉得时O1 ","like_count":0},{"had_liked":false,"id":34684,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1540258957,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1540258957","product_id":100017301,"comment_content":"老师关于使用迭代循环模拟递归代码的地方有一个疑问<br>一个for循环实现的递归 和 很多的函数入栈出栈操作   是不是前者效率会高点，开销少点。","like_count":0},{"had_liked":false,"id":34486,"user_name":"洗净铅华呈素姿","can_delete":false,"product_type":"c1","uid":1238901,"ip_address":"","ucode":"F35C833682797A","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/75/16da2d1c.jpg","comment_is_top":false,"comment_ctime":1540186739,"is_pvip":false,"replies":[{"id":"12309","content":"比如f（5）。f（6）","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540221765,"ip_address":"","comment_id":34486,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540186739","product_id":100017301,"comment_content":"老师，麻烦问下，这个f(int n),在调用这个函数的时候，参数应该怎么填？<br><br>int f(int n) {<br>  if (n == 1) return 1;<br>  return f(n-1) + 1;<br>}","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427224,"discussion_content":"比如f（5）。f（6）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540221765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34393,"user_name":"光","can_delete":false,"product_type":"c1","uid":1108110,"ip_address":"","ucode":"52EBDCABA633E8","user_header":"https://static001.geekbang.org/account/avatar/00/10/e8/8e/197ee632.jpg","comment_is_top":false,"comment_ctime":1540141380,"is_pvip":false,"replies":[{"id":"12265","content":"可以这么理解","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540173295,"ip_address":"","comment_id":34393,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540141380","product_id":100017301,"comment_content":"王争老师我看到网上有些说函数自己调用自己就是递归，是这样吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427195,"discussion_content":"可以这么理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540173295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34366,"user_name":"李靖峰","can_delete":false,"product_type":"c1","uid":1139247,"ip_address":"","ucode":"AA4DE3E91A1FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/2f/6fe8ee9e.jpg","comment_is_top":false,"comment_ctime":1540130877,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540130877","product_id":100017301,"comment_content":"分叉递归学到了","like_count":0},{"had_liked":false,"id":34364,"user_name":"kakasi","can_delete":false,"product_type":"c1","uid":1237297,"ip_address":"","ucode":"64F357E6A08CA5","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/31/eb103bdc.jpg","comment_is_top":false,"comment_ctime":1540127544,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540127544","product_id":100017301,"comment_content":"递归条件: 一个问题能分解成几个子问题。子问题除了数据规模，求解方式相同。有终止条件。<br><br>递归缺陷: 函数调用栈溢出（可以用过限制调用次数），重复计算，时间空间复杂度高。<br><br>一般可以先写出递归的公式，说实话这就是考验数学思维，然后再考虑如何用非递归实现（理论上手动模拟栈一定能实现）。","like_count":0},{"had_liked":false,"id":34357,"user_name":"行走着的宋公子","can_delete":false,"product_type":"c1","uid":1002416,"ip_address":"","ucode":"3FA47B1580A327","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/b0/2ae78627.jpg","comment_is_top":false,"comment_ctime":1540124286,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540124286","product_id":100017301,"comment_content":"调试递归代码思路：<br>1 不要陷入每个递归当中<br>2 用数据验证终止条件 =&gt; 终止条件是否正确<br>3 跟踪两次递归  =&gt; 大问题可否拆解为子问题","like_count":0},{"had_liked":false,"id":34321,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1540108017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540108017","product_id":100017301,"comment_content":"关于如何检测环的存在，和用散列表来规避重复计算有点类似：<br>利用散列表来保存已经查找到的推荐人 id ，每查询一次后，先判断散列表中是否已经存在推荐人 id 。","like_count":0},{"had_liked":false,"id":34099,"user_name":"花生","can_delete":false,"product_type":"c1","uid":1252241,"ip_address":"","ucode":"93A097D5129495","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/91/66f0d38a.jpg","comment_is_top":false,"comment_ctime":1540001577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540001577","product_id":100017301,"comment_content":"递归总能让我联想到中学学的 数学归纳法。","like_count":0},{"had_liked":false,"id":33701,"user_name":"linxs~","can_delete":false,"product_type":"c1","uid":1226540,"ip_address":"","ucode":"3CBF1F5A2C2745","user_header":"https://static001.geekbang.org/account/avatar/00/12/b7/2c/cc7e1f04.jpg","comment_is_top":false,"comment_ctime":1539856768,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539856768","product_id":100017301,"comment_content":"经过尾递归优化的递归代码，空间复杂度可以达到0（1），那么和用非递归的代码相比，谁的速度更快？ 是非递归的方式更快么","like_count":0},{"had_liked":false,"id":33617,"user_name":"叶子扬","can_delete":false,"product_type":"c1","uid":1207351,"ip_address":"","ucode":"BA63BFC4ACDC07","user_header":"https://static001.geekbang.org/account/avatar/00/12/6c/37/90c73f45.jpg","comment_is_top":false,"comment_ctime":1539836763,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539836763","product_id":100017301,"comment_content":"希望老师多分享一些经典习题。比如链表那一章课后所说的，掌握这几道题就基本掌握了链表","like_count":0},{"had_liked":false,"id":32824,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1539699635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539699635","product_id":100017301,"comment_content":"递归误区:人脑试图想清楚递归的每一层，但这是不容易的，你会被绕进去；正确的方式是，只需要考虑当前层和下一层之间的关系，而不需要考虑下一层和下下一层。","like_count":0},{"had_liked":false,"id":32716,"user_name":"山野刁民","can_delete":false,"product_type":"c1","uid":1191795,"ip_address":"","ucode":"3371E25F6AEFBC","user_header":"https://static001.geekbang.org/account/avatar/00/12/2f/73/00a56a7d.jpg","comment_is_top":false,"comment_ctime":1539676846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539676846","product_id":100017301,"comment_content":"之前说链表的反转，当时是用递归实现的：<br>reverse(x, pre){<br>        if(x.next != null) reverse(x.next, x);<br>        x.next = pre;<br>        pre.next = null;<br>}<br>之前是按照物理意义来理解，即递归是利用程序调用栈和栈内临时局部变量来做循环。<br>现在看了老师的总结，逻辑上的理解思路，更一般的形式，更适合复杂逻辑","like_count":0},{"had_liked":false,"id":32680,"user_name":"siegfried","can_delete":false,"product_type":"c1","uid":1007931,"ip_address":"","ucode":"31673819DD2605","user_header":"https://static001.geekbang.org/account/avatar/00/0f/61/3b/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1539662112,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539662112","product_id":100017301,"comment_content":"无限递归问题，脏数据问题，递归深度限制","like_count":0},{"had_liked":false,"id":32677,"user_name":"siegfried","can_delete":false,"product_type":"c1","uid":1007931,"ip_address":"","ucode":"31673819DD2605","user_header":"https://static001.geekbang.org/account/avatar/00/0f/61/3b/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1539661948,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539661948","product_id":100017301,"comment_content":"需要注意。内存栈，空间复杂度，堆栈溢出，重复计算。","like_count":0},{"had_liked":false,"id":32644,"user_name":"徐章宁","can_delete":false,"product_type":"c1","uid":1175391,"ip_address":"","ucode":"9122F0F39CDF6A","user_header":"https://static001.geekbang.org/account/avatar/00/11/ef/5f/449a59ab.jpg","comment_is_top":false,"comment_ctime":1539655956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539655956","product_id":100017301,"comment_content":"将递归写成循环的形式，确实没有大的不同，有没有在什么情况会是必须的呢？","like_count":0},{"had_liked":false,"id":32638,"user_name":"程序员大天地","can_delete":false,"product_type":"c1","uid":1249001,"ip_address":"","ucode":"7A21F15FEE2D5B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg","comment_is_top":false,"comment_ctime":1539655246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539655246","product_id":100017301,"comment_content":"学习了。看了很多留言，有一点要强调下，上面留言里面讨论的怎么判断A-B-C-A环的，可以用散列表或者其他的数据结构保存已经查询过的ID，但是这个数据结构不能共用！","like_count":0},{"had_liked":false,"id":32422,"user_name":"在下令狐冲","can_delete":false,"product_type":"c1","uid":1178651,"ip_address":"","ucode":"6228893CCF8C09","user_header":"https://static001.geekbang.org/account/avatar/00/11/fc/1b/7fa5823c.jpg","comment_is_top":false,"comment_ctime":1539568138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539568138","product_id":100017301,"comment_content":"这个时候我拿出手机打开闪光灯看座位号~~~~~","like_count":0},{"had_liked":false,"id":32351,"user_name":"刘志国","can_delete":false,"product_type":"c1","uid":1262033,"ip_address":"","ucode":"197F686B995DA2","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/d1/e6698285.jpg","comment_is_top":false,"comment_ctime":1539553617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539553617","product_id":100017301,"comment_content":"递归，如何检测环？","like_count":0},{"had_liked":false,"id":32334,"user_name":"黑桃K","can_delete":false,"product_type":"c1","uid":1234939,"ip_address":"","ucode":"1439F7F46B4982","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/fb/384ef0a1.jpg","comment_is_top":false,"comment_ctime":1539534260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539534260","product_id":100017301,"comment_content":"思考题：<br>打印日志，查看递归值<br>结合条件断点调试<br>总结：<br>递归三要素，分解，公式（大小问题思路一样），终止条件。<br>堆栈溢出问题，可以通过递归深度控制<br>重复计算问题，可以通过如散列表记录数据<br>递归改写为非递归，徒增复杂度<br>还有可能有脏数据，需要递归时检测环<br>递归空间复杂度较高","like_count":0},{"had_liked":false,"id":32306,"user_name":"Keep-Moving","can_delete":false,"product_type":"c1","uid":1182631,"ip_address":"","ucode":"76F33C06E07A27","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/a7/6ef32187.jpg","comment_is_top":false,"comment_ctime":1539521540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539521540","product_id":100017301,"comment_content":"递归需要满足的三个条件<br>1. 一个问题的解可以分解为几个子问题的解<br>2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样<br>3. 存在递归终止条件","like_count":0},{"had_liked":false,"id":32287,"user_name":"每天学英语的小沈","can_delete":false,"product_type":"c1","uid":1024179,"ip_address":"","ucode":"C58FA38D8272FA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/b3/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1539512038,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539512038","product_id":100017301,"comment_content":"动态规划和递归感觉还是蛮像的，动态规划的状态转移方程和递归的求解子问题的方式，思想核心是一致的，感觉","like_count":0},{"had_liked":false,"id":32286,"user_name":"每天学英语的小沈","can_delete":false,"product_type":"c1","uid":1024179,"ip_address":"","ucode":"C58FA38D8272FA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/b3/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1539511916,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539511916","product_id":100017301,"comment_content":"递归代码调试，在关键层级打log验证正确性。","like_count":0},{"had_liked":false,"id":32246,"user_name":"肖小强","can_delete":false,"product_type":"c1","uid":1245065,"ip_address":"","ucode":"A929A8D1DAD3C4","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/89/32e3f682.jpg","comment_is_top":false,"comment_ctime":1539495754,"is_pvip":false,"replies":[{"id":"11746","content":"是的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539528178,"ip_address":"","comment_id":32246,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539495754","product_id":100017301,"comment_content":"老师，那个电影票递归的空间复杂度是O(n),如果用尾递归的话，就是O(1)吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426696,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539528178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32167,"user_name":"斜月浮云","can_delete":false,"product_type":"c1","uid":1008933,"ip_address":"","ucode":"25CECBB175DA02","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/25/c6de04bc.jpg","comment_is_top":false,"comment_ctime":1539451297,"is_pvip":false,"replies":[{"id":"11757","content":"我后面不是写了一个避免重复计算的版本和非递归的版本嘛","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539528822,"ip_address":"","comment_id":32167,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1539451297","product_id":100017301,"comment_content":"像楼梯那种，拆分到多个子问题的迭代算法，都是O（2^n）的时间复杂度，在真实场景中很难落实吧？感觉看到这种思路都会直接使用近视的估算算法了。王老师在现实实践中怎么解决这类问题？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426662,"discussion_content":"我后面不是写了一个避免重复计算的版本和非递归的版本嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539528822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32165,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":false,"comment_ctime":1539449585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539449585","product_id":100017301,"comment_content":"Re Jessie:<br>----<br>n=4,<br>f(n)=f(n-1)+f(n-2);<br>所以, <br>f(4)=f(3)+f(2)<br>=f(2)+f(1)+f(2)<br>=2+1+2=5<br>4个台阶，变5个台阶了，请问以上推理哪里出问题了？<br>----<br><br>不是4个台阶变5个台阶，是4个台阶有5种下法。","like_count":0},{"had_liked":false,"id":32158,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1539442765,"is_pvip":false,"replies":[{"id":"11760","content":"p指针指向q<br>p的next指针指向q","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539528946,"ip_address":"","comment_id":32158,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539442765","product_id":100017301,"comment_content":"两个节点之间赋值，p=q和p-next=q有什么区别，一直没没分清","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426657,"discussion_content":"p指针指向q\np的next指针指向q","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539528946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32155,"user_name":"wean","can_delete":false,"product_type":"c1","uid":1239735,"ip_address":"","ucode":"3E069F95C25EAD","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/b7/1f7316e6.jpg","comment_is_top":false,"comment_ctime":1539440928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539440928","product_id":100017301,"comment_content":"调试递归代码的方式，同样适合调试循环轮次很高的情况","like_count":0},{"had_liked":false,"id":32153,"user_name":"周平","can_delete":false,"product_type":"c1","uid":1259488,"ip_address":"","ucode":"4954DC474C4FDF","user_header":"https://static001.geekbang.org/account/avatar/00/13/37/e0/23f288ae.jpg","comment_is_top":false,"comment_ctime":1539438599,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539438599","product_id":100017301,"comment_content":"递归的错误思路是，在脑中把递归展开。 <br>正确的应该是， 找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。<br>递归的错误的思维方式，还需要多多练习才行。 <br>老师有没有一些递归的题，供我们练习一下啊？","like_count":0},{"had_liked":false,"id":32149,"user_name":"insist","can_delete":false,"product_type":"c1","uid":1054536,"ip_address":"","ucode":"1EE2800A900BA7","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/48/3ab39c86.jpg","comment_is_top":false,"comment_ctime":1539437471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539437471","product_id":100017301,"comment_content":"递归是一种将大问题分解为小问题的编程技巧，优点是代码简洁，容易理解；缺点是如果递归层次过多，容易导致堆栈溢出，可能存在重复计算问题，空间复杂度也比较大。写递归代码思路：将大问题分解为数据规模小一些，但处理逻辑一致的小问题，接着推导出递推公式，推导出终止条件，最后翻译成代码。<br>这次课对递归有了新的理解，分为递和归两个步骤。就像坐公交，从后面上时候，让前一个人把公交卡递过去刷一下，刷完了再原路归回来。","like_count":0},{"had_liked":false,"id":32132,"user_name":"阳仔","can_delete":false,"product_type":"c1","uid":1046920,"ip_address":"","ucode":"79F73D85EDF3E2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg","comment_is_top":false,"comment_ctime":1539428041,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539428041","product_id":100017301,"comment_content":"学习反馈：<br>递归是计算机算法里广泛使用的一种算法。它的实现代码简洁，但理解“递归”需要下点功夫。<br>递归算法需要满足的三个条件：<br>1、规模大的问题可以分解为规模较小的问题；<br>2、规模大的问题与规模较小问题的求解方式是一样的；<br>3、要有终止条件。<br>如何写一个递归算法：<br>关键点是将大规模问题分解成小规模问题，推导出递推公式，并找到终止条件，最后把递推公式和终止条件翻译成代码。<br>递归算法需要注意的问题：<br>1、栈溢出<br>由于递归算法是基于计算机内部的函数调用栈的数据结构，每调用一次函数，就执行入栈操作，函数返回时才执行出栈操作，因此当函数调用层次太多，就有可能发生栈溢出的问题。<br>如何避免栈溢出<br>在递归代码中使用最大深度变量来控制。这种方式不是特别好，因为要知道计算机栈的深度，也使得编码复杂度变高。<br>2、避免重复计算<br>这个问题可以使用散列表来缓存已经计算过的值来解决。<br>3、其他问题<br>时间复杂度和空间复杂度都会有很高的开销<br>递归算法是一种简洁有效的编码思想，但是递归算法也有缺点，空间和时间复杂度都比较大。一般递归代码都可以写成迭代循环的形式。因此在实际编码中，选择递归或者迭代需要具体问题具体分析<br><br>","like_count":0},{"had_liked":false,"id":32130,"user_name":"天若有情天亦老","can_delete":false,"product_type":"c1","uid":1172029,"ip_address":"","ucode":"57F0B7D524C0CF","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/3d/9a52946b.jpg","comment_is_top":false,"comment_ctime":1539426852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539426852","product_id":100017301,"comment_content":"费布那齐汤 就是递归的思想","like_count":0},{"had_liked":false,"id":32128,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1539425032,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539425032","product_id":100017301,"comment_content":"好留言不能做笔记，只能临时记一下了……<br><br>调试递归:<br>1.打印日志发现，递归值。<br>2.结合条件断点进行调试。","like_count":0},{"had_liked":false,"id":32121,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1238703,"ip_address":"","ucode":"C5EB025A9D1301","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/af/e94ef6d8.jpg","comment_is_top":false,"comment_ctime":1539423085,"is_pvip":false,"replies":[{"id":"11764","content":"y==1那个终止条件可以省略吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539529340,"ip_address":"","comment_id":32121,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539423085","product_id":100017301,"comment_content":"老师，看到有同学通过递归计算定期存款，我试着写了一下，麻烦老师看看。<br>......<br>定期存款利息计算可以用递归吗？<br>首先找到递推公式是：benjin =本金+本金*利率，<br>其次退出条件是：存5年<br>Int fuli(int benjin, int year, double lilv):<br>Benjin=benjin+benjin*lilv<br>Year=year-1<br>If (year &lt; 5){<br>Return fuli(bebjin,year,lilv)<br>}else{<br>Return benjin<br>}<br>我这个程序写的对吗？而且感觉很复杂，请老师指导？<br>......<br>以上是那位同学的留言，下面是我写的：<br>假如在银行定存一笔钱，一年以上每年固定利率为lilv，根据所存年数计算存息和（存款和利息总和）<br>首先找到递推公式是：存息 = 本金 * (1+利率)<br>                             f(n) = f(n-1)*(1+lilv)<br>终止条件有两个，1.定存不到一年，f(0) = 本金;2.定存只有一年，(1) = 本金 * (1+利率)<br>把递归终止条件和刚刚得到的递推公式放到一起就是这样的：<br>double f(int y){<br>     if(y == 0) return 本金；<br>     if(y == 1) return 本金* (1+lilv)；<br>     return f(y-1)*(1+lilv)；<br>}<br>老师，这样分析对吗？<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426643,"discussion_content":"y==1那个终止条件可以省略吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539529340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32114,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1238703,"ip_address":"","ucode":"C5EB025A9D1301","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/af/e94ef6d8.jpg","comment_is_top":false,"comment_ctime":1539419489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539419489","product_id":100017301,"comment_content":"如何来检测环的存在呢？<br>可否用前面学的“栈”存储结构，每次入栈时，判断栈里是否有这个元素存在，例如：A-B-C-A，当A再次入栈时，栈内存中已存在元素A，说明此时递归是一个环,栈顶的A就是最终推荐人；或者用队列为存储结构，当A再次入队时，A-B-C-A，队列头部的A就是最终推荐人。<br>老师，这种分析思路对吗？","like_count":0},{"had_liked":false,"id":32112,"user_name":"无名","can_delete":false,"product_type":"c1","uid":1123325,"ip_address":"","ucode":"CA7CB9727EF235","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/fd/1397930a.jpg","comment_is_top":false,"comment_ctime":1539419174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539419174","product_id":100017301,"comment_content":"最终推荐人有环的情况可以用递归的深度超过表记录的总长度的方法解决，感觉。","like_count":0},{"had_liked":false,"id":32111,"user_name":"liangjf","can_delete":false,"product_type":"c1","uid":1058812,"ip_address":"","ucode":"681A6CCF098F55","user_header":"https://static001.geekbang.org/account/avatar/00/10/27/fc/b8d83d56.jpg","comment_is_top":false,"comment_ctime":1539418362,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539418362","product_id":100017301,"comment_content":"数据规模小结果正确，而数据规模大结果出错。面对递归这种 公式固定的算法，出错的原因应该是系统相关的吧，栈溢出，切换时保存现场出错，内存换页等原因吧？","like_count":0},{"had_liked":false,"id":32110,"user_name":"nil","can_delete":false,"product_type":"c1","uid":1122630,"ip_address":"","ucode":"9A1685AB329469","user_header":"https://static001.geekbang.org/account/avatar/00/11/21/46/1ae4b6e9.jpg","comment_is_top":false,"comment_ctime":1539418322,"is_pvip":false,"replies":[{"id":"11766","content":"不能全部解决 要看具体情况","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539529407,"ip_address":"","comment_id":32110,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539418322","product_id":100017301,"comment_content":"想问老师，尾递归的方式是否能解决递归的堆栈溢出的问题","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426640,"discussion_content":"不能全部解决 要看具体情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539529407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32108,"user_name":"liangjf","can_delete":false,"product_type":"c1","uid":1058812,"ip_address":"","ucode":"681A6CCF098F55","user_header":"https://static001.geekbang.org/account/avatar/00/10/27/fc/b8d83d56.jpg","comment_is_top":false,"comment_ctime":1539417984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539417984","product_id":100017301,"comment_content":"看完觉得顿悟了，之前是用人脑模拟递归，现在看来是不合适的。<br><br>而应该像调试递归那样，人脑给定条件限定，&quot;断点&quot;调试模拟最初的一两步，和最终的一两步。","like_count":0},{"had_liked":false,"id":32100,"user_name":"Zhangwh","can_delete":false,"product_type":"c1","uid":1244001,"ip_address":"","ucode":"49CDE4BCFC2534","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/61/c84a45be.jpg","comment_is_top":false,"comment_ctime":1539415030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539415030","product_id":100017301,"comment_content":"之前都没做笔记，但是这一篇写的实在是很动人，不自觉的就记下一些老师的经验总结，来加深理解","like_count":0},{"had_liked":false,"id":32093,"user_name":"@","can_delete":false,"product_type":"c1","uid":1249561,"ip_address":"","ucode":"EC3932BC1E9137","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/19/e9b052dd.jpg","comment_is_top":false,"comment_ctime":1539412566,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539412566","product_id":100017301,"comment_content":"老师那个递归调试的两个方法，没看懂，能详细的解释一下吗？比如：如火热结合条件断点？这里的条件断点指的是什么？打印日志，是将递归值都打印出来吗？这样如果堆栈溢出还能打印出来吗？会不会编译的时候程序直接报错？我是小白，有时间请详细解释一波","like_count":0},{"had_liked":false,"id":32088,"user_name":".小、挂念","can_delete":false,"product_type":"c1","uid":1249258,"ip_address":"","ucode":"8A10CD13A0FF86","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/ea/3d4bf856.jpg","comment_is_top":false,"comment_ctime":1539411603,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539411603","product_id":100017301,"comment_content":"看了老师的文章，就想着把前几天弄的那个菜单树换成用递归去实现。代码是简洁了，但极易死循环，调适起来也不是很容易","like_count":0},{"had_liked":false,"id":32082,"user_name":"DDT","can_delete":false,"product_type":"c1","uid":1246042,"ip_address":"","ucode":"2E64C1982BEFCE","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/5a/6db83ec3.jpg","comment_is_top":false,"comment_ctime":1539408214,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539408214","product_id":100017301,"comment_content":"我觉得现在老师已经把我从思维误区里面带出来了 我现在是怎么把一个大问题分成几个小问题的时候 会卡壳...","like_count":0},{"had_liked":false,"id":32073,"user_name":"TryTs","can_delete":false,"product_type":"c1","uid":1036276,"ip_address":"","ucode":"1DD1E974D461A1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/f4/26b95f0b.jpg","comment_is_top":false,"comment_ctime":1539404575,"is_pvip":false,"replies":[{"id":"11770","content":"联系的话，我觉得数据结构和算法是基础吧，可以通过数据结构和算法训练一下思维。是否要很强的编程能力，这个我不好下定论，起码应该不差吧。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539529805,"ip_address":"","comment_id":32073,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539404575","product_id":100017301,"comment_content":"老师，我想请教一下，你觉得机器学习与传统的数据结构算法这些有什么联系吗？如果我想学机器学习是否需要很强的编程能力？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426626,"discussion_content":"联系的话，我觉得数据结构和算法是基础吧，可以通过数据结构和算法训练一下思维。是否要很强的编程能力，这个我不好下定论，起码应该不差吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539529805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32072,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1539403250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539403250","product_id":100017301,"comment_content":"用之前讲的链表来检测环😁","like_count":0},{"had_liked":false,"id":32065,"user_name":"Marnie","can_delete":false,"product_type":"c1","uid":1001912,"ip_address":"","ucode":"ECF9B22574F868","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/b8/fb19aa6a.jpg","comment_is_top":false,"comment_ctime":1539400513,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539400513","product_id":100017301,"comment_content":"递归步骤：<br>1.大问题拆成小问题<br>2.找到终止条件<br>3.写代码<br><br>递归算法的空间复杂度为n，很容易内存溢出。解决方法是将已经算出结果的存起来，下次直接用。","like_count":0},{"had_liked":false,"id":32038,"user_name":"中山浪子","can_delete":false,"product_type":"c1","uid":1055296,"ip_address":"","ucode":"25D0F8462473D3","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","comment_is_top":false,"comment_ctime":1539394536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539394536","product_id":100017301,"comment_content":"之前写递归时候就是陷入了层层递归的计算误区、结果把自己陷进去了，老师这篇文章，颇有醍醐灌顶的感觉","like_count":0},{"had_liked":false,"id":32025,"user_name":"Realm","can_delete":false,"product_type":"c1","uid":1081299,"ip_address":"","ucode":"30CBEBE619D1A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/7f/d3/b5896293.jpg","comment_is_top":false,"comment_ctime":1539392245,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539392245","product_id":100017301,"comment_content":"<br>n=4,<br>f(n)=f(n-1)+f(n-2);<br>所以, <br>f(4)=f(3)+f(2)<br>=f(2)+f(1)+f(2)<br>=2+1+2=5<br>4个台阶，变5个台阶了，请问以上推理哪里出问题了？<br><br>这里最后的结果是步数，不是台阶数，其实结果是一个1 2 3 5 8...肥波拉切","like_count":0},{"had_liked":false,"id":32024,"user_name":"Jimbol","can_delete":false,"product_type":"c1","uid":1178008,"ip_address":"","ucode":"8D9190B3B3E08B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/98/95b13446.jpg","comment_is_top":false,"comment_ctime":1539392023,"is_pvip":false,"replies":[{"id":"11773","content":"稍微没怎么看懂你写的呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539530110,"ip_address":"","comment_id":32024,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539392023","product_id":100017301,"comment_content":"老师我还有个问题，就是在所有操作递归调用本函数之前和在递归调用本函数之后的思维方式是不是不太一样呢？比如用递归处理链表反转和递归处理斐波那契数列","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426615,"discussion_content":"稍微没怎么看懂你写的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539530110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32010,"user_name":"ADkun","can_delete":false,"product_type":"c1","uid":1236725,"ip_address":"","ucode":"09A4A03FFF610E","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/f5/a9054651.jpg","comment_is_top":false,"comment_ctime":1539358781,"is_pvip":false,"replies":[{"id":"11598","content":"我下周添加些注释，让编辑再重新更新下代码吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539401671,"ip_address":"","comment_id":32010,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539358781","product_id":100017301,"comment_content":"老师，将第二个递归算法改成非递归的那段代码不太明白，可否注释一下？每个变量分别表示什么？循环里面操作的意义？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426608,"discussion_content":"我下周添加些注释，让编辑再重新更新下代码吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539401671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32007,"user_name":"snakorse","can_delete":false,"product_type":"c1","uid":1064887,"ip_address":"","ucode":"0AD727E1F16993","user_header":"https://static001.geekbang.org/account/avatar/00/10/3f/b7/0d8b5431.jpg","comment_is_top":false,"comment_ctime":1539358444,"is_pvip":false,"replies":[{"id":"11597","content":"尾递归也并不能完全避免堆栈溢出的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539401659,"ip_address":"","comment_id":32007,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539358444","product_id":100017301,"comment_content":"部分编译器支持对尾递归的堆栈优化，可以避免堆栈溢出","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426607,"discussion_content":"尾递归也并不能完全避免堆栈溢出的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539401659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31952,"user_name":"Jimbol","can_delete":false,"product_type":"c1","uid":1178008,"ip_address":"","ucode":"8D9190B3B3E08B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/98/95b13446.jpg","comment_is_top":false,"comment_ctime":1539341010,"is_pvip":false,"replies":[{"id":"11586","content":"有时候这样子还不够能定位到问题","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539401504,"ip_address":"","comment_id":31952,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539341010","product_id":100017301,"comment_content":"在debug的时候不要过多关注具体的局部变量，重点关注递归函数的返回值，这样可以吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426579,"discussion_content":"有时候这样子还不够能定位到问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539401504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31948,"user_name":"Geek_d5ff62","can_delete":false,"product_type":"c1","uid":1241138,"ip_address":"","ucode":"D804ADC9C01B45","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/32/7fc85b26.jpg","comment_is_top":false,"comment_ctime":1539338493,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539338493","product_id":100017301,"comment_content":"终于把困惑已久的知识点补上了，不过还是需要多看几遍仔细琢磨其精髓，再加上多加练习才能深刻领悟，希望老师可以多加一些练习题的内容，感谢。","like_count":0},{"had_liked":false,"id":31943,"user_name":"勤劳的小胖子-libo","can_delete":false,"product_type":"c1","uid":1158344,"ip_address":"","ucode":"5BB20CD5A56568","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/c8/4b1c0d40.jpg","comment_is_top":false,"comment_ctime":1539335842,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539335842","product_id":100017301,"comment_content":"大爱，对于递归原来不应想着展开，会被绕进去。多谢🙏，解决多年来的毛病。<br><br>课后问题，可以试着断点，以及动态改变参数的值","like_count":0},{"had_liked":false,"id":31922,"user_name":"陈亦凡","can_delete":false,"product_type":"c1","uid":1071734,"ip_address":"","ucode":"52A0731541792D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5a/76/3f8dcda6.jpg","comment_is_top":false,"comment_ctime":1539330169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539330169","product_id":100017301,"comment_content":"用python，最近学习不写项目都是vim&#47;vscode+pudb","like_count":0},{"had_liked":false,"id":31915,"user_name":"小景","can_delete":false,"product_type":"c1","uid":1248694,"ip_address":"","ucode":"8AF6A76BD4DEF3","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/b6/ac16094a.jpg","comment_is_top":false,"comment_ctime":1539329408,"is_pvip":false,"replies":[{"id":"11606","content":"也不是所有的都能总结出你的痛点，还是很难的，多包涵吧，兄弟。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539403423,"ip_address":"","comment_id":31915,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539329408","product_id":100017301,"comment_content":"老师讲得真的很精彩，特别是思维误区那里，我以前看递归总是会陷进去，分析问题也因此多花很多时间。要是以后的课程也多这样总结思维层面的东西就好了，理解起来也更有高度。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426563,"discussion_content":"也不是所有的都能总结出你的痛点，还是很难的，多包涵吧，兄弟。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539403423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31908,"user_name":"雨天","can_delete":false,"product_type":"c1","uid":1056406,"ip_address":"","ucode":"FD9FB404ECA463","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/96/3162d51f.jpg","comment_is_top":false,"comment_ctime":1539327343,"is_pvip":false,"replies":[{"id":"11604","content":"递归的时间复杂度是O(2^n)指数型的。后面我会分析的，不要着急。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539403379,"ip_address":"","comment_id":31908,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539327343","product_id":100017301,"comment_content":"老师:走台阶问题的递归实现的时间复杂度O(n²),空间复杂度为O(n)<br>int f(int n) {<br>  if (n == 1) return 1;<br>  if (n == 2) return 2;<br>  return f(n-1) + f(n-2);<br>}<br>使用哈希表记录中间值的话,时间复杂度O(n),空间复杂度为O(n);分析的对吗?<br>规模比较大、递归层次很深的递归代码可以通过记录日志方式调试.","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426559,"discussion_content":"递归的时间复杂度是O(2^n)指数型的。后面我会分析的，不要着急。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539403379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31904,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1539326555,"is_pvip":false,"replies":[{"id":"11603","content":"你说的也对，不过有些bug是在数据规模比较大的时候才能触发","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539403358,"ip_address":"","comment_id":31904,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539326555","product_id":100017301,"comment_content":"验证递归代码 肯定是传一个数据规模较小的数据进去便于验证啊 因为算法固定 数据规模小的都正常了，那么大的也应该没问题,除开那种数据大到堆栈溢出 应该没问题","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426555,"discussion_content":"你说的也对，不过有些bug是在数据规模比较大的时候才能触发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539403358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31884,"user_name":"刘远通","can_delete":false,"product_type":"c1","uid":1253307,"ip_address":"","ucode":"4D3EE819E4B235","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/bb/c488d5db.jpg","comment_is_top":false,"comment_ctime":1539320085,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539320085","product_id":100017301,"comment_content":"把他想成数学归纳法  最重要的就是k到k+1是怎么过去的","like_count":0},{"had_liked":false,"id":31880,"user_name":"Hurt","can_delete":false,"product_type":"c1","uid":1050946,"ip_address":"","ucode":"DCE7428CCF08EF","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/42/1f762b72.jpg","comment_is_top":false,"comment_ctime":1539319368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539319368","product_id":100017301,"comment_content":"老师 分析分析 递归的时间复杂度和空间复杂度呗😁","like_count":0},{"had_liked":false,"id":31855,"user_name":"along","can_delete":false,"product_type":"c1","uid":1236054,"ip_address":"","ucode":"6855D571DD71AB","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/56/1a5b7e9f.jpg","comment_is_top":false,"comment_ctime":1539312348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539312348","product_id":100017301,"comment_content":"老师，第二个例子，优化重复计算问题后时间还变长了很多，是数据规模还不够大吗?<br>private static int f1(int n){<br>        Map&lt;Integer,Integer&gt; hasSolvedList = new HashMap&lt;&gt;();<br>        if (hasSolvedList.containsKey(n)) {<br>            return hasSolvedList.get(n);<br>        }<br>        if(n == 1){<br>            return 1;<br>        }<br>        if (n == 2) {<br>            return 2;<br>        }<br>        int ret = f1(n-1)+f1(n-2);<br>        hasSolvedList.put(n, ret);<br>        return ret;<br>    }<br><br>print:<br>当n=40时:<br>结果:165580141<br>优化前耗时:765ms<br>结果:165580141<br>优化后耗时:5672ms","like_count":0},{"had_liked":false,"id":31848,"user_name":"喜欢你的笑","can_delete":false,"product_type":"c1","uid":1076836,"ip_address":"","ucode":"DC9867EA2D4D97","user_header":"https://static001.geekbang.org/account/avatar/00/10/6e/64/9b000b4f.jpg","comment_is_top":false,"comment_ctime":1539310711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539310711","product_id":100017301,"comment_content":"我的想法是最开始电影院的例子，每一排其实就是相当于是个链表，每一排维护一个链表，想要知道自己第几排，查找链表就可以知道第几排。这个时间复杂度是O（n），空间复杂度也是O(n)，不知道对不对？<br>还有如果求最终推荐人因为可能有分支，这个是否可以用也用链表实现呢？","like_count":0},{"had_liked":false,"id":31837,"user_name":"yaya","can_delete":false,"product_type":"c1","uid":1233856,"ip_address":"","ucode":"8C7FAC8F828BA4","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/c0/d38daa2d.jpg","comment_is_top":false,"comment_ctime":1539309499,"is_pvip":false,"replies":[{"id":"11491","content":"没办法了 自己多写多练吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539310796,"ip_address":"","comment_id":31837,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539309499","product_id":100017301,"comment_content":"打印？递归解答问题的步骤:找到子问题，找到递归出口。我😂每次遇到问题也喜欢人脑模拟过程。。。尤其在回溯问题的时候。。不是很懂。也明白应该假设小问题都被解决但是还是有点转不过来。。请问有什么好的办法和步骤吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426533,"discussion_content":"没办法了 自己多写多练吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539310796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31835,"user_name":"ryp","can_delete":false,"product_type":"c1","uid":1257903,"ip_address":"","ucode":"423B88C2696D6A","user_header":"https://static001.geekbang.org/account/avatar/00/13/31/af/88f8fdb3.jpg","comment_is_top":false,"comment_ctime":1539309303,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539309303","product_id":100017301,"comment_content":"最终推荐人怎么能死循环呢，必须通过其他手段避免掉，比如每个人都得记录他前边有n个人，这样递归n次就可以了","like_count":0},{"had_liked":false,"id":31825,"user_name":"双木公子","can_delete":false,"product_type":"c1","uid":1116567,"ip_address":"","ucode":"751885864D3AB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/97/4314e2d8.jpg","comment_is_top":false,"comment_ctime":1539307404,"is_pvip":false,"replies":[{"id":"11496","content":"改进前O（2^n） 改进后O（n）","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539311413,"ip_address":"","comment_id":31825,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539307404","product_id":100017301,"comment_content":"第二个例子的在没做改进和改进之后的时间复杂度与空间复杂度分别为多少？老师能分析一下吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426526,"discussion_content":"改进前O（2^n） 改进后O（n）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539311413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31820,"user_name":"喜欢你的笑","can_delete":false,"product_type":"c1","uid":1076836,"ip_address":"","ucode":"DC9867EA2D4D97","user_header":"https://static001.geekbang.org/account/avatar/00/10/6e/64/9b000b4f.jpg","comment_is_top":false,"comment_ctime":1539307001,"is_pvip":false,"replies":[{"id":"11464","content":"具体说说你的思路","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539309723,"ip_address":"","comment_id":31820,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539307001","product_id":100017301,"comment_content":"求最终推荐人是否可以用一个链表来进行查找？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426522,"discussion_content":"具体说说你的思路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539309723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31819,"user_name":"Listen To Me","can_delete":false,"product_type":"c1","uid":1248940,"ip_address":"","ucode":"91C15209E2FAC9","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/ac/17757f0c.jpg","comment_is_top":false,"comment_ctime":1539306960,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539306960","product_id":100017301,"comment_content":"一般会用条件断点debug","like_count":0},{"had_liked":false,"id":31800,"user_name":"凉粉","can_delete":false,"product_type":"c1","uid":1131111,"ip_address":"","ucode":"DD1280BD703948","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/67/b96b843f.jpg","comment_is_top":false,"comment_ctime":1539305356,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539305356","product_id":100017301,"comment_content":"断点加条件","like_count":0},{"had_liked":false,"id":31792,"user_name":"沉睡的木木夕","can_delete":false,"product_type":"c1","uid":1036362,"ip_address":"","ucode":"2C6B23B34C44E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/4a/7e3d158d.jpg","comment_is_top":false,"comment_ctime":1539304762,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539304762","product_id":100017301,"comment_content":"作为递归的一种优化方案，尾递归是不是也讲解一下<br>至于是否有环，可以从gc算法中借鉴，当多个类存在深层次的循环引用，那是不是就是永远无法垃圾回收？其实gc算法中用了引用标记法来解决这种情况","like_count":0},{"had_liked":false,"id":31786,"user_name":"Linuxer","can_delete":false,"product_type":"c1","uid":1153978,"ip_address":"","ucode":"272D9D8089C3D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","comment_is_top":false,"comment_ctime":1539304447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539304447","product_id":100017301,"comment_content":"相同的数据规模应该在同一层，如果不同层出现相同数据规模认为是出现环","like_count":0},{"had_liked":false,"id":31785,"user_name":"Linuxer","can_delete":false,"product_type":"c1","uid":1153978,"ip_address":"","ucode":"272D9D8089C3D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","comment_is_top":false,"comment_ctime":1539304446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539304446","product_id":100017301,"comment_content":"相同的数据规模应该在同一层，如果不同层出现相同数据规模认为是出现环","like_count":0},{"had_liked":false,"id":31782,"user_name":"城","can_delete":false,"product_type":"c1","uid":1035315,"ip_address":"","ucode":"32C4FCE1944000","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cc/33/19f150d9.jpg","comment_is_top":false,"comment_ctime":1539304323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539304323","product_id":100017301,"comment_content":"可以考虑增加调试日志","like_count":0},{"had_liked":false,"id":31779,"user_name":"bluesea","can_delete":false,"product_type":"c1","uid":1099295,"ip_address":"","ucode":"FFBF8CB0FC0546","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/1f/fb994eef.jpg","comment_is_top":false,"comment_ctime":1539304014,"is_pvip":false,"replies":[{"id":"11480","content":"我哪个问题没讲解决思路？！是我眼拙吗","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539310355,"ip_address":"","comment_id":31779,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539304014","product_id":100017301,"comment_content":"递归出现了问题，但是没有说出解决方案，只讲了一堆理论","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426505,"discussion_content":"我哪个问题没讲解决思路？！是我眼拙吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539310355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31778,"user_name":"Linuxer","can_delete":false,"product_type":"c1","uid":1153978,"ip_address":"","ucode":"272D9D8089C3D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","comment_is_top":false,"comment_ctime":1539303976,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539303976","product_id":100017301,"comment_content":"我想到的是小规模情况验证，打点两种方式","like_count":0},{"had_liked":false,"id":31777,"user_name":"","can_delete":false,"product_type":"c1","uid":1031328,"ip_address":"","ucode":"1B73BA45ACD06C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/a0/97c7679b.jpg","comment_is_top":false,"comment_ctime":1539303806,"is_pvip":false,"replies":[{"id":"11481","content":"通项公式 避免递归的副作用","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539310402,"ip_address":"","comment_id":31777,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539303806","product_id":100017301,"comment_content":"我是小白哈。问下从全局来说，求解斐波那契数，用递归和通项公式，哪个更优？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426504,"discussion_content":"通项公式 避免递归的副作用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539310402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}