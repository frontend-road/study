{"id":91289,"title":"11 | 线程：如何让复杂的项目并行执行？","content":"<p>上一节我们讲了如何创建进程，这一节我们来看如何创建线程。</p><h2>为什么要有线程？</h2><p>其实，对于任何一个进程来讲，即便我们没有主动去创建线程，进程也是默认有一个主线程的。线程是负责执行二进制指令的，它会根据项目执行计划书，一行一行执行下去。进程要比线程管的宽多了，除了执行指令之外，内存、文件系统等等都要它来管。</p><p>所以，<strong>进程相当于一个项目，而线程就是为了完成项目需求，而建立的一个个开发任务</strong>。默认情况下，你可以建一个大的任务，就是完成某某功能，然后交给一个人让它从头做到尾，这就是主线程。但是有时候，你发现任务是可以拆解的，如果相关性没有非常大前后关联关系，就可以并行执行。</p><p>例如，你接到了一个开发任务，要开发200个页面，最后组成一个网站。这时候你就可以拆分成20个任务，每个任务10个页面，并行开发。都开发完了，再做一次整合，这肯定比依次开发200个页面快多了。</p><p><img src=\"https://static001.geekbang.org/resource/image/48/9e/485ce8195d241c2a6930803286302e9e.jpg?wh=2209*2111\" alt=\"\"></p><p>那我们能不能成立多个项目组实现并行开发呢？当然可以了，只不过这样做有两个比较麻烦的地方。</p><p>第一个麻烦是，立项。涉及的部门比较多，总是劳师动众。你本来想的是，只要能并行执行任务就可以，不需要把会议室都搞成独立的。另一个麻烦是，项目组是独立的，会议室是独立的，很多事情就不受你控制了，例如一旦有了两个项目组，就会有沟通问题。</p><!-- [[[read_end]]] --><p>所以，使用进程实现并行执行的问题也有两个。第一，创建进程占用资源太多；第二，进程之间的通信需要数据在不同的内存空间传来传去，无法共享。</p><p>除了希望任务能够并行执行，有的时候，你作为项目管理人员，肯定要管控风险，因此还会预留一部分人作为应急小分队，来处理紧急的事情。</p><p>例如，主线程正在一行一行执行二进制命令，突然收到一个通知，要做一点小事情，应该停下主线程来做么？太耽误事情了，应该创建一个单独的线程，单独处理这些事件。</p><p>另外，咱们希望自己的公司越来越有竞争力。要想实现远大的目标，我们不能把所有人力都用在接项目上，应该预留一些人力来做技术积累，比如开发一些各个项目都能用到的共享库、框架等等。</p><p>在Linux中，有时候我们希望将前台的任务和后台的任务分开。因为有些任务是需要马上返回结果的，例如你输入了一个字符，不可能五分钟再显示出来；而有些任务是可以默默执行的，例如将本机的数据同步到服务器上去，这个就没刚才那么着急。因此这样两个任务就应该在不同的线程处理，以保证互不耽误。</p><h2>如何创建线程？</h2><p>看来多线程还是有很多好处的。接下来我们来看一下，如何使用线程来干一件大事。</p><p>假如说，现在我们有N个非常大的视频需要下载，一个个下载需要的时间太长了。按照刚才的思路，我们可以拆分成N个任务，分给N个线程各自去下载。</p><p>我们知道，进程的执行是需要项目执行计划书的，那线程是一个项目小组，这个小组也应该有自己的项目执行计划书，也就是一个函数。我们将要执行的子任务放在这个函数里面，比如上面的下载任务。</p><p>这个函数参数是void类型的指针，用于接收任何类型的参数。我们就可以将要下载的文件的文件名通过这个指针传给它。</p><p>为了方便，我将代码整段都贴在这里，这样你把下面的代码放在一个文件里面就能成功编译。</p><p>当然，这里我们不是真的下载这个文件，而仅仅打印日志，并生成一个一百以内的随机数，作为下载时间返回。这样，每个子任务干活的同时在喊：“我正在下载，终于下载完了，用了多少时间。”</p><pre><code>#include &lt;pthread.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define NUM_OF_TASKS 5\n\nvoid *downloadfile(void *filename)\n{\n   printf(&quot;I am downloading the file %s!\\n&quot;, (char *)filename);\n   sleep(10);\n   long downloadtime = rand()%100;\n   printf(&quot;I finish downloading the file within %d minutes!\\n&quot;, downloadtime);\n   pthread_exit((void *)downloadtime);\n}\n\nint main(int argc, char *argv[])\n{\n   char files[NUM_OF_TASKS][20]={&quot;file1.avi&quot;,&quot;file2.rmvb&quot;,&quot;file3.mp4&quot;,&quot;file4.wmv&quot;,&quot;file5.flv&quot;};\n   pthread_t threads[NUM_OF_TASKS];\n   int rc;\n   int t;\n   int downloadtime;\n\n   pthread_attr_t thread_attr;\n   pthread_attr_init(&amp;thread_attr);\n   pthread_attr_setdetachstate(&amp;thread_attr,PTHREAD_CREATE_JOINABLE);\n\n   for(t=0;t&lt;NUM_OF_TASKS;t++){\n     printf(&quot;creating thread %d, please help me to download %s\\n&quot;, t, files[t]);\n     rc = pthread_create(&amp;threads[t], &amp;thread_attr, downloadfile, (void *)files[t]);\n     if (rc){\n       printf(&quot;ERROR; return code from pthread_create() is %d\\n&quot;, rc);\n       exit(-1);\n     }\n   }\n\n   pthread_attr_destroy(&amp;thread_attr);\n\n   for(t=0;t&lt;NUM_OF_TASKS;t++){\n     pthread_join(threads[t],(void**)&amp;downloadtime);\n     printf(&quot;Thread %d downloads the file %s in %d minutes.\\n&quot;,t,files[t],downloadtime);\n   }\n\n   pthread_exit(NULL);\n}\n</code></pre><p>一个运行中的线程可以调用pthread_exit退出线程。这个函数可以传入一个参数转换为(void *)类型。这是线程退出的返回值。</p><p>接下来，我们来看主线程。在这里面，我列了五个文件名。接下来声明了一个数组，里面有五个pthread_t类型的线程对象。</p><p>接下来，声明一个线程属性pthread_attr_t。我们通过pthread_attr_init初始化这个属性，并且设置属性PTHREAD_CREATE_JOINABLE。这表示将来主线程程等待这个线程的结束，并获取退出时的状态。</p><p>接下来是一个循环。对于每一个文件和每一个线程，可以调用pthread_create创建线程。一共有四个参数，第一个参数是线程对象，第二个参数是线程的属性，第三个参数是线程运行函数，第四个参数是线程运行函数的参数。主线程就是通过第四个参数，将自己的任务派给子线程。</p><p>任务分配完毕，每个线程下载一个文件，接下来主线程要做的事情就是等待这些子任务完成。当一个线程退出的时候，就会发送信号给其他所有同进程的线程。有一个线程使用pthread_join获取这个线程退出的返回值。线程的返回值通过pthread_join传给主线程，这样子线程就将自己下载文件所耗费的时间，告诉给主线程。</p><p>好了，程序写完了，开始编译。多线程程序要依赖于libpthread.so。</p><pre><code>gcc download.c -lpthread\n</code></pre><p>编译好了，执行一下，就能得到下面的结果。</p><pre><code># ./a.out\ncreating thread 0, please help me to download file1.avi\ncreating thread 1, please help me to download file2.rmvb\nI am downloading the file file1.avi!\ncreating thread 2, please help me to download file3.mp4\nI am downloading the file file2.rmvb!\ncreating thread 3, please help me to download file4.wmv\nI am downloading the file file3.mp4!\ncreating thread 4, please help me to download file5.flv\nI am downloading the file file4.wmv!\nI am downloading the file file5.flv!\nI finish downloading the file within 83 minutes!\nI finish downloading the file within 77 minutes!\nI finish downloading the file within 86 minutes!\nI finish downloading the file within 15 minutes!\nI finish downloading the file within 93 minutes!\nThread 0 downloads the file file1.avi in 83 minutes.\nThread 1 downloads the file file2.rmvb in 86 minutes.\nThread 2 downloads the file file3.mp4 in 77 minutes.\nThread 3 downloads the file file4.wmv in 93 minutes.\nThread 4 downloads the file file5.flv in 15 minutes.\n</code></pre><p>这里我们画一张图总结一下，一个普通线程的创建和运行过程。</p><p><img src=\"https://static001.geekbang.org/resource/image/e3/bd/e38c28b0972581d009ef16f1ebdee2bd.jpg?wh=2383*2109\" alt=\"\"></p><h2>线程的数据</h2><p>线程可以将项目并行起来，加快进度，但是也带来的负面影响，过程并行起来了，那数据呢？</p><p>我们把线程访问的数据细分成三类。下面我们一一来看。</p><p><img src=\"https://static001.geekbang.org/resource/image/e7/3f/e7b06dcf431f388170ab0a79677ee43f.jpg?wh=2509*1398\" alt=\"\"></p><p>第一类是<strong>线程栈上的本地数据</strong>，比如函数执行过程中的局部变量。前面我们说过，函数的调用会使用栈的模型，这在线程里面是一样的。只不过每个线程都有自己的栈空间。</p><p>栈的大小可以通过命令ulimit -a查看，默认情况下线程栈大小为8192（8MB）。我们可以使用命令ulimit -s修改。</p><p>对于线程栈，可以通过下面这个函数pthread_attr_t，修改线程栈的大小。</p><pre><code>int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);\n</code></pre><p>主线程在内存中有一个栈空间，其他线程栈也拥有独立的栈空间。为了避免线程之间的栈空间踩踏，线程栈之间还会有小块区域，用来隔离保护各自的栈空间。一旦另一个线程踏入到这个隔离区，就会引发段错误。</p><p>第二类数据就是<strong>在整个进程里共享的全局数据</strong>。例如全局变量，虽然在不同进程中是隔离的，但是在一个进程中是共享的。如果同一个全局变量，两个线程一起修改，那肯定会有问题，有可能把数据改的面目全非。这就需要有一种机制来保护他们，比如你先用我再用。这一节的最后，我们专门来谈这个问题。</p><p>那线程能不能像进程一样，也有自己的私有数据呢？如果想声明一个线程级别，而非进程级别的全局变量，有没有什么办法呢？虽然咱们都是一个大组，分成小组，也应该有点隐私。</p><p>这就是第三类数据，<strong>线程私有数据</strong>（Thread Specific Data），可以通过以下函数创建：</p><pre><code>int pthread_key_create(pthread_key_t *key, void (*destructor)(void*))\n</code></pre><p>可以看到，创建一个key，伴随着一个析构函数。</p><p>key一旦被创建，所有线程都可以访问它，但各线程可根据自己的需要往key中填入不同的值，这就相当于提供了一个同名而不同值的全局变量。</p><p>我们可以通过下面的函数设置key对应的value。</p><pre><code>int pthread_setspecific(pthread_key_t key, const void *value)\n</code></pre><p>我们还可以通过下面的函数获取key对应的value。</p><pre><code>void *pthread_getspecific(pthread_key_t key)\n</code></pre><p>而等到线程退出的时候，就会调用析构函数释放value。</p><h2>数据的保护</h2><p>接下来，我们来看共享的数据保护问题。</p><p>我们先来看一种方式，<strong>Mutex</strong>，全称Mutual Exclusion，中文叫<strong>互斥</strong>。顾名思义，有你没我，有我没你。它的模式就是在共享数据访问的时候，去申请加把锁，谁先拿到锁，谁就拿到了访问权限，其他人就只好在门外等着，等这个人访问结束，把锁打开，其他人再去争夺，还是遵循谁先拿到谁访问。</p><p>我这里构建了一个“转账”的场景。相关的代码我放到这里，你可以看看。</p><pre><code>#include &lt;pthread.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define NUM_OF_TASKS 5\n\nint money_of_tom = 100;\nint money_of_jerry = 100;\n//第一次运行去掉下面这行\npthread_mutex_t g_money_lock;\n\nvoid *transfer(void *notused)\n{\n  pthread_t tid = pthread_self();\n  printf(&quot;Thread %u is transfering money!\\n&quot;, (unsigned int)tid);\n  //第一次运行去掉下面这行\n  pthread_mutex_lock(&amp;g_money_lock);\n  sleep(rand()%10);\n  money_of_tom+=10;\n  sleep(rand()%10);\n  money_of_jerry-=10;\n  //第一次运行去掉下面这行\n  pthread_mutex_unlock(&amp;g_money_lock);\n  printf(&quot;Thread %u finish transfering money!\\n&quot;, (unsigned int)tid);\n  pthread_exit((void *)0);\n}\n\nint main(int argc, char *argv[])\n{\n  pthread_t threads[NUM_OF_TASKS];\n  int rc;\n  int t;\n  //第一次运行去掉下面这行\n  pthread_mutex_init(&amp;g_money_lock, NULL);\n\n  for(t=0;t&lt;NUM_OF_TASKS;t++){\n    rc = pthread_create(&amp;threads[t], NULL, transfer, NULL);\n    if (rc){\n      printf(&quot;ERROR; return code from pthread_create() is %d\\n&quot;, rc);\n      exit(-1);\n    }\n  }\n  \n  for(t=0;t&lt;100;t++){\n    //第一次运行去掉下面这行\n    pthread_mutex_lock(&amp;g_money_lock);\n    printf(&quot;money_of_tom + money_of_jerry = %d\\n&quot;, money_of_tom + money_of_jerry);\n    //第一次运行去掉下面这行\n    pthread_mutex_unlock(&amp;g_money_lock);\n  }\n  //第一次运行去掉下面这行\n  pthread_mutex_destroy(&amp;g_money_lock);\n  pthread_exit(NULL);\n}\n</code></pre><p>这里说，有两个员工Tom和Jerry，公司食堂的饭卡里面各自有100元，并行启动5个线程，都是Jerry转10元给Tom，主线程不断打印Tom和Jerry的资金之和。按说，这样的话，总和应该永远是200元。</p><p>在上面的程序中，我们先去掉mutex相关的行，就像注释里面写的那样。在没有锁的保护下，在Tom的账户里面加上10元，在Jerry的账户里面减去10元，这不是一个原子操作。</p><p>我们来编译一下。</p><pre><code>gcc mutex.c -lpthread\n</code></pre><p>然后运行一下，就看到了下面这样的结果。</p><pre><code>[root@deployer createthread]# ./a.out\nThread 508479232 is transfering money!\nThread 491693824 is transfering money!\nThread 500086528 is transfering money!\nThread 483301120 is transfering money!\nThread 516871936 is transfering money!\nmoney_of_tom + money_of_jerry = 200\nmoney_of_tom + money_of_jerry = 200\nmoney_of_tom + money_of_jerry = 220\nmoney_of_tom + money_of_jerry = 220\nmoney_of_tom + money_of_jerry = 230\nmoney_of_tom + money_of_jerry = 240\nThread 483301120 finish transfering money!\nmoney_of_tom + money_of_jerry = 240\nThread 508479232 finish transfering money!\nThread 500086528 finish transfering money!\nmoney_of_tom + money_of_jerry = 220\nThread 516871936 finish transfering money!\nmoney_of_tom + money_of_jerry = 210\nmoney_of_tom + money_of_jerry = 210\nThread 491693824 finish transfering money!\nmoney_of_tom + money_of_jerry = 200\nmoney_of_tom + money_of_jerry = 200\n</code></pre><p>可以看到，中间有很多状态不正确，比如两个人的账户之和出现了超过200的情况，也就是Tom转入了，Jerry还没转出。</p><p>接下来我们在上面的代码里面，加上mutex，然后编译、运行，就得到了下面的结果。</p><pre><code>[root@deployer createthread]# ./a.out\nThread 568162048 is transfering money!\nThread 576554752 is transfering money!\nThread 551376640 is transfering money!\nThread 542983936 is transfering money!\nThread 559769344 is transfering money!\nThread 568162048 finish transfering money!\nThread 576554752 finish transfering money!\nmoney_of_tom + money_of_jerry = 200\nmoney_of_tom + money_of_jerry = 200\nmoney_of_tom + money_of_jerry = 200\nThread 542983936 finish transfering money!\nThread 559769344 finish transfering money!\nmoney_of_tom + money_of_jerry = 200\nmoney_of_tom + money_of_jerry = 200\nThread 551376640 finish transfering money!\nmoney_of_tom + money_of_jerry = 200\nmoney_of_tom + money_of_jerry = 200\nmoney_of_tom + money_of_jerry = 200\nmoney_of_tom + money_of_jerry = 200\n</code></pre><p>这个结果就正常了。两个账号之和永远是200。这下你看到锁的作用了吧？</p><p>使用Mutex，首先要使用pthread_mutex_init函数初始化这个mutex，初始化后，就可以用它来保护共享变量了。</p><p>pthread_mutex_lock() 就是去抢那把锁的函数，如果抢到了，就可以执行下一行程序，对共享变量进行访问；如果没抢到，就被阻塞在那里等待。</p><p>如果不想被阻塞，可以使用pthread_mutex_trylock去抢那把锁，如果抢到了，就可以执行下一行程序，对共享变量进行访问；如果没抢到，不会被阻塞，而是返回一个错误码。</p><p>当共享数据访问结束了，别忘了使用pthread_mutex_unlock释放锁，让给其他人使用，最终调用pthread_mutex_destroy销毁掉这把锁。</p><p>这里我画个图，总结一下Mutex的使用流程。</p><p><img src=\"https://static001.geekbang.org/resource/image/0c/be/0ccf37aafa2b287363399e130b2726be.jpg?wh=2323*2433\" alt=\"\"></p><p>在使用Mutex的时候，有个问题是如果使用pthread_mutex_lock()，那就需要一直在那里等着。如果是pthread_mutex_trylock()，就可以不用等着，去干点儿别的，但是我怎么知道什么时候回来再试一下，是不是轮到我了呢？能不能在轮到我的时候，通知我一下呢？</p><p>这其实就是条件变量，也就是说如果没事儿，就让大家歇着，有事儿了就去通知，别让人家没事儿就来问问，浪费大家的时间。</p><p>但是当它接到了通知，来操作共享资源的时候，还是需要抢互斥锁，因为可能很多人都受到了通知，都来访问了，所以<strong>条件变量和互斥锁是配合使用的</strong>。</p><p>我这里还是用一个场景给你解释。</p><p>你这个老板，招聘了三个员工，但是你不是有了活才去招聘员工，而是先把员工招来，没有活的时候员工需要在那里等着，一旦有了活，你要去通知他们，他们要去抢活干（为啥要抢活？因为有绩效呀！），干完了再等待，你再有活，再通知他们。</p><p>具体的样例代码我也放在这里。你可以直接编译运行。</p><pre><code>#include &lt;pthread.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define NUM_OF_TASKS 3\n#define MAX_TASK_QUEUE 11\n\nchar tasklist[MAX_TASK_QUEUE]=&quot;ABCDEFGHIJ&quot;;\nint head = 0;\nint tail = 0;\n\nint quit = 0;\n\npthread_mutex_t g_task_lock;\npthread_cond_t g_task_cv;\n\nvoid *coder(void *notused)\n{\n  pthread_t tid = pthread_self();\n\n  while(!quit){\n\n    pthread_mutex_lock(&amp;g_task_lock);\n    while(tail == head){\n      if(quit){\n        pthread_mutex_unlock(&amp;g_task_lock);\n        pthread_exit((void *)0);\n      }\n      printf(&quot;No task now! Thread %u is waiting!\\n&quot;, (unsigned int)tid);\n      pthread_cond_wait(&amp;g_task_cv, &amp;g_task_lock);\n      printf(&quot;Have task now! Thread %u is grabing the task !\\n&quot;, (unsigned int)tid);\n    }\n    char task = tasklist[head++];\n    pthread_mutex_unlock(&amp;g_task_lock);\n    printf(&quot;Thread %u has a task %c now!\\n&quot;, (unsigned int)tid, task);\n    sleep(5);\n    printf(&quot;Thread %u finish the task %c!\\n&quot;, (unsigned int)tid, task);\n  }\n\n  pthread_exit((void *)0);\n}\n\nint main(int argc, char *argv[])\n{\n  pthread_t threads[NUM_OF_TASKS];\n  int rc;\n  int t;\n\n  pthread_mutex_init(&amp;g_task_lock, NULL);\n  pthread_cond_init(&amp;g_task_cv, NULL);\n\n  for(t=0;t&lt;NUM_OF_TASKS;t++){\n    rc = pthread_create(&amp;threads[t], NULL, coder, NULL);\n    if (rc){\n      printf(&quot;ERROR; return code from pthread_create() is %d\\n&quot;, rc);\n      exit(-1);\n    }\n  }\n\n  sleep(5);\n\n  for(t=1;t&lt;=4;t++){\n    pthread_mutex_lock(&amp;g_task_lock);\n    tail+=t;\n    printf(&quot;I am Boss, I assigned %d tasks, I notify all coders!\\n&quot;, t);\n    pthread_cond_broadcast(&amp;g_task_cv);\n    pthread_mutex_unlock(&amp;g_task_lock);\n    sleep(20);\n  }\n\n  pthread_mutex_lock(&amp;g_task_lock);\n  quit = 1;\n  pthread_cond_broadcast(&amp;g_task_cv);\n  pthread_mutex_unlock(&amp;g_task_lock);\n\n  pthread_mutex_destroy(&amp;g_task_lock);\n  pthread_cond_destroy(&amp;g_task_cv);\n  pthread_exit(NULL);\n}\n</code></pre><p>首先，我们创建了10个任务，每个任务一个字符，放在一个数组里面，另外有两个变量head和tail，表示当前分配的工作从哪里开始，到哪里结束。如果head等于tail，则当前的工作分配完毕；如果tail加N，就是新分配了N个工作。</p><p>接下来声明的pthread_mutex_t g_task_lock和pthread_cond_t g_task_cv，是用于通知和抢任务的，工作模式如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/1d/f7/1d4e17fdb1860f7ca7f23bbe682d93f7.jpeg?wh=3713*3815\" alt=\"\"></p><p>图中左边的就是员工的工作模式，对于每一个员工coder，先要获取锁pthread_mutex_lock，这样才能保证一个任务只分配给一个员工。</p><p>然后，我们要判断有没有任务，也就是说，head和tail是否相等。如果不相等的话，就是有任务，则取出head位置代表的任务task，然后将head加一，这样整个任务就给了这个员工，下个员工来抢活的时候，也需要获取锁，获取之后抢到的就是下一个任务了。当这个员工抢到任务后，pthread_mutex_unlock解锁，让其他员工可以进来抢任务。抢到任务后就开始干活了，这里没有真正开始干活，而是sleep，也就是摸鱼了5秒。</p><p>如果发现head和tail相当，也就是没有任务，则需要调用pthread_cond_wait进行等待，这个函数会把锁也作为变量传进去。这是因为等待的过程中需要解锁，要不然，你不干活，等待睡大觉，还把门给锁了，别人也干不了活，而且老板也没办法获取锁来分配任务。</p><p>一开始三个员工都是在等待的状态，因为初始化的时候，head和tail相等都为零。</p><p>现在我们把目光聚焦到老板这里，也就是主线程上。它初始化了条件变量和锁，然后创建三个线程，也就是我们说的招聘了三个员工。</p><p>接下来要开始分配任务了，总共10个任务。老板分四批分配，第一批一个任务三个人抢，第二批两个任务，第三批三个任务，正好每人抢到一个，第四批四个任务，可能有一个员工抢到两个任务。这样三个员工，四批工作，经典的场景差不多都覆盖到了。</p><p>老板分配工作的时候，也是要先获取锁pthread_mutex_lock，然后通过tail加一来分配任务，这个时候head和tail已经不一样了，但是这个时候三个员工还在pthread_cond_wait那里睡着呢，接下来老板要调用pthread_cond_broadcast通知所有的员工，“来活了，醒醒，起来干活”。</p><p>这个时候三个员工醒来后，先抢锁，生怕老板只分配了一个任务，让别人抢去。当然抢锁这个动作是pthread_cond_wait在收到通知的时候，自动做的，不需要我们另外写代码。</p><p>抢到锁的员工就通过while再次判断head和tail是否相同。这次因为有了任务，不相同了，所以就抢到了任务。而没有抢到任务的员工，由于抢锁失败，只好等待抢到任务的员工释放锁，抢到任务的员工在tasklist里面拿到任务后，将head加一，然后就释放锁。这个时候，另外两个员工才能从pthread_cond_wait中返回，然后也会再次通过while判断head和tail是否相同。不过已经晚了，任务都让人家抢走了，head和tail又一样了，所以只好再次进入pthread_cond_wait，接着等任务。</p><p>这里，我们只解析了第一批一个任务的工作的过程。如果运行上面的程序，可以得到下面的结果。我将整个过程在里面写了注释，你看起来就比较容易理解了。</p><pre><code>[root@deployer createthread]# ./a.out\n//招聘三个员工，一开始没有任务，大家睡大觉\nNo task now! Thread 3491833600 is waiting!\nNo task now! Thread 3483440896 is waiting!\nNo task now! Thread 3475048192 is waiting!\n//老板开始分配任务了，第一批任务就一个，告诉三个员工醒来抢任务\nI am Boss, I assigned 1 tasks, I notify all coders!\n//员工一先发现有任务了，开始抢任务\nHave task now! Thread 3491833600 is grabing the task !\n//员工一抢到了任务A，开始干活\nThread 3491833600 has a task A now! \n//员工二也发现有任务了，开始抢任务，不好意思，就一个任务，让人家抢走了，接着等吧\nHave task now! Thread 3483440896 is grabing the task !\nNo task now! Thread 3483440896 is waiting!\n//员工三也发现有任务了，开始抢任务，你比员工二还慢，接着等吧\nHave task now! Thread 3475048192 is grabing the task !\nNo task now! Thread 3475048192 is waiting!\n//员工一把任务做完了，又没有任务了，接着等待\nThread 3491833600 finish the task A !\nNo task now! Thread 3491833600 is waiting!\n//老板又有新任务了，这次是两个任务，叫醒他们\nI am Boss, I assigned 2 tasks, I notify all coders!\n//这次员工二比较积极，先开始抢，并且抢到了任务B\nHave task now! Thread 3483440896 is grabing the task !\nThread 3483440896 has a task B now! \n//这次员工三也聪明了，赶紧抢，要不然没有年终奖了，终于抢到了任务C\nHave task now! Thread 3475048192 is grabing the task !\nThread 3475048192 has a task C now! \n//员工一上次抢到了，这次抢的慢了，没有抢到，是不是飘了\nHave task now! Thread 3491833600 is grabing the task !\nNo task now! Thread 3491833600 is waiting!\n//员工二做完了任务B，没有任务了，接着等待\nThread 3483440896 finish the task B !\nNo task now! Thread 3483440896 is waiting!\n//员工三做完了任务C，没有任务了，接着等待\nThread 3475048192 finish the task C !\nNo task now! Thread 3475048192 is waiting!\n//又来任务了，这次是三个任务，人人有份\nI am Boss, I assigned 3 tasks, I notify all coders!\n//员工一抢到了任务D，员工二抢到了任务E，员工三抢到了任务F\nHave task now! Thread 3491833600 is grabing the task !\nThread 3491833600 has a task D now! \nHave task now! Thread 3483440896 is grabing the task !\nThread 3483440896 has a task E now! \nHave task now! Thread 3475048192 is grabing the task !\nThread 3475048192 has a task F now! \n//三个员工都完成了，然后都又开始等待\nThread 3491833600 finish the task D !\nThread 3483440896 finish the task E !\nThread 3475048192 finish the task F !\nNo task now! Thread 3491833600 is waiting!\nNo task now! Thread 3483440896 is waiting!\nNo task now! Thread 3475048192 is waiting!\n//公司活越来越多了，来了四个任务，赶紧干呀\nI am Boss, I assigned 4 tasks, I notify all coders!\n//员工一抢到了任务G，员工二抢到了任务H，员工三抢到了任务I\nHave task now! Thread 3491833600 is grabing the task !\nThread 3491833600 has a task G now! \nHave task now! Thread 3483440896 is grabing the task !\nThread 3483440896 has a task H now! \nHave task now! Thread 3475048192 is grabing the task !\nThread 3475048192 has a task I now! \n//员工一和员工三先做完了，发现还有一个任务开始抢\nThread 3491833600 finish the task G !\nThread 3475048192 finish the task I !\n//员工三没抢到，接着等\nNo task now! Thread 3475048192 is waiting!\n//员工一抢到了任务J，多做了一个任务\nThread 3491833600 has a task J now! \n//员工二这才把任务H做完，黄花菜都凉了，接着等待吧\nThread 3483440896 finish the task H !\nNo task now! Thread 3483440896 is waiting!\n//员工一做完了任务J，接着等待\nThread 3491833600 finish the task J !\nNo task now! Thread 3491833600 is waiting!\n</code></pre><h2>总结时刻</h2><p>这一节，我们讲了如何创建线程，线程都有哪些数据，如何对线程数据进行保护。</p><p>写多线程的程序是有套路的，我这里用一张图进行总结。你需要记住的是，创建线程的套路、mutex使用的套路、条件变量使用的套路。</p><p><img src=\"https://static001.geekbang.org/resource/image/02/58/02a774d7c0f83bb69fec4662622d6d58.png?wh=2307*2409\" alt=\"\"></p><h2>课堂练习</h2><p>这一节讲了多线程编程的套路，但是我没有对于每一个函数进行详细的讲解，相关的还有很多其他的函数可以调用，这需要你自己去学习。这里我给你推荐一本书$Programming  with  POSIX<br>\nThreads$，你可以系统地学习一下。另外，上面的代码，建议你一定要上手编译运行一下。</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg?wh=1110*659\" alt=\"\"></p>","neighbors":{"left":{"article_title":"10 | 进程：公司接这么多项目，如何管？","id":90855},"right":{"article_title":"12 | 进程数据结构（上）：项目多了就需要项目管理系统","id":91550}},"comments":[{"had_liked":false,"id":87659,"user_name":"刘強","can_delete":false,"product_type":"c1","uid":1035612,"ip_address":"","ucode":"B2E41BB894A727","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","comment_is_top":false,"comment_ctime":1555653313,"is_pvip":false,"replies":[{"id":"49596","content":"赞，太赞啦","user_name":"作者回复","comment_id":87659,"uid":"1001590","ip_address":"","utype":1,"ctime":1567690745,"user_name_real":"刘超@网易云"}],"discussion_count":14,"race_medal":0,"score":"937858523841","product_id":100024701,"comment_content":"两个线程操作同一临界区时，通过互斥锁保护，若A线程已经加锁，B线程再加锁时候会被阻塞，直到A释放锁，B再获得锁运行，进程B必须不停的主动获得锁、检查条件、释放锁、再获得锁、再检查、再释放，一直到满足运行的条件的时候才可以（而此过程中其他线程一直在等待该线程的结束），这种方式是比较消耗系统的资源的。而条件变量同样是阻塞，还需要通知才能唤醒，线程被唤醒后，它将重新检查判断条件是否满足，如果还不满足，该线程就休眠了，应该仍阻塞在这里，等待条件满足后被唤醒，节省了线程不断运行浪费的资源。这个过程一般用while语句实现。当线程B发现被锁定的变量不满足条件时会自动的释放锁并把自身置于等待状态，让出CPU的控制权给其它线程。其它线程 此时就有机会去进行操作，当修改完成后再通知那些由于条件不满足而陷入等待状态的线程。这是一种通知模型的同步方式，大大的节省了CPU的计算资源，减少了线程之间的竞争，而且提高了线程之间的系统工作的效率。这种同步方式就是条件变量。<br>      这是网上的一段话。我觉得说的很清楚了。<br>      如果学过java的话，其实就是线程之间的互斥和协作，条件变量就是用来协作的，对应java里的wait()和notify()函数。<br>     我个人觉得读这个专栏必须有一定的基础理论，具体的说起码看过相关的书籍，了解个大概。如果只有一些语言的基础，没有看过相关计算机体系或者操作系统方面的书籍，看起来会很费劲，不知所云。就我自己来说，我看过于渊写的《一个操作系统的实现》，《linux内核设计与实现》《现代操作系统》《intel汇编程序》《深入理解计算机系统》《unix高级环境编程》等，尤其是于渊写的这本书，从计算机加电开始，一直到多进程，进程间通信，从汇编到c语言，都有完整的代码，都是作者自己亲手写的，可操作性极强。还有csapp（深入理解计算机系统）这本书，所有人公认的学计算机必须看的。还有很多，总之我想说的是自己必须去看书学习，仅仅想靠一个专栏的学习来了解一个东西是远远不够的。<br>      话又说回来，你可能会问你看了这么多书，早应该精通了吧，还到这儿来干嘛？其实这就是我最大的问题，书看的太多，理论知道的不少，但是动手实践太少，就是所谓的眼高手低。而且不实践，看的多，忘的多。一方面是工作原因，除非去大公司，哪有机会让你实践底层的技术。二是自己太懒，没有耐性，任何可用的东西都是一行行代码经过千锤百炼形成的。书看了不少仅仅满足了自己的求知欲，却没有弄出任何有用的东西。<br>       来这儿也是想看看理论是如何通过一行行代码落地的，也学学作者的实践经验，加深一些概念的理解。<br>       多看书没错，但效率比较低，从实践中不断总结，思考才是快速成长的正确方法。<br>       道理知道很多，但还是过不好这一生。理论掌握不少，还是写不出有用的代码。悲催！","like_count":219,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447552,"discussion_content":"赞，太赞啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567690745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339820,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/ac/8295e3e7.jpg","nickname":"书忆江南","note":"","ucode":"90776A7CE06D66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158136,"discussion_content":"强烈建议，看完极客时间的《深入浅出计算机组成原理》再来看刘老师的专栏，能降低理解难度，我就是看完了前者来的，我也不是计科出身，在补基础，但是看完了前者，觉得理解操作系统的一些东西能反应出来计算机组成原理专栏的知识，更加能理解了。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1580555005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099513,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/f9/caf27bd3.jpg","nickname":"大王叫我来巡山","note":"","ucode":"1B8D0C701BC95E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37637,"discussion_content":"总结的很好，很多时候觉得对于写业务的同学来说是屠龙之技，但是出了问题有不知道问题在哪里，只能等大神，要么胡乱查资料，不是学习所有东西都可以精通的，但是可以提供个思考问题的方向","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1571649979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131300,"avatar":"https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg","nickname":"zixuan","note":"","ucode":"C72920DD05B074","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587433,"discussion_content":"你在这里只能看到个人总结和随笔吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663055226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2325145,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkF14X58pdmTgBWwWzxVicJ0LQjNXiceL3xSj73eC4AZheyIPtf8tyqTicbP4VXia1TmDlm9rlCNCuDQ/132","nickname":"Geek_c2c8d1","note":"","ucode":"60B48691C86D6C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388262,"discussion_content":"书籍永远是进步的最好途径，理论+实践是提升的最好方式；书籍读的越多，你的理论知识体系结构就越完善，如果再加上各类配套的实践，哪对整个知识体系的结构认识会更清晰，明白别人为什么这么做？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628673394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258505,"avatar":"https://static001.geekbang.org/account/avatar/00/13/34/09/d34c4385.jpg","nickname":"Honor","note":"","ucode":"36C18ACDF40D26","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361955,"discussion_content":"如果学过java的话，其实就是线程之间的互斥和协作，条件变量就是用来协作的，对应java里的wait()和notify()函数，我看老师写的东西的时候就是这个感觉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616812314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355327,"discussion_content":"还是没理解条件变量， 不都是循环吗，只是多了一个 sleep？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615422773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1576512,"avatar":"https://static001.geekbang.org/account/avatar/00/18/0e/40/49a71ed8.jpg","nickname":"八戒","note":"","ucode":"3F262A99492A65","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352960,"discussion_content":"我好奇，为什么操作系统要以循环轮讯的方式实现互斥量，很浪费资源。为什么不参考条件变量的方式实现互斥量，获取不到锁就休眠放弃CPU，其他线程释放锁的时候再去唤醒就行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614927643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2055993,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/5f/39/8d2c61d3.jpg","nickname":"Kiddy","note":"","ucode":"D07AAEE69BE504","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1576512,"avatar":"https://static001.geekbang.org/account/avatar/00/18/0e/40/49a71ed8.jpg","nickname":"八戒","note":"","ucode":"3F262A99492A65","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556037,"discussion_content":"如果线程太多，该唤醒谁呢？一般都是广播所有线程都唤醒，但是唤醒后所有线程又得竞争，竞争完后又去休眠，其实这样一来一回也是十分耗费性能的。简而言之，没有银弹","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647175537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":352960,"ip_address":""},"score":556037,"extra":""}]},{"author":{"id":1071668,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5a/34/4cbadca6.jpg","nickname":"吃饭睡觉打酱油","note":"","ucode":"95EC98C2B5045B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330794,"discussion_content":"大佬，看书做笔记了么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606709392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1035612,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","nickname":"刘強","note":"","ucode":"B2E41BB894A727","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1071668,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5a/34/4cbadca6.jpg","nickname":"吃饭睡觉打酱油","note":"","ucode":"95EC98C2B5045B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330796,"discussion_content":"这称呼可不敢当，菜鸟而已。做笔记（最好博客）+动手去验证。所谓知行合一。不可只看书，血的教训。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1606710007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":330794,"ip_address":""},"score":330796,"extra":""}]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312589,"discussion_content":"没有基础的飘过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602741072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1988589,"avatar":"","nickname":"Geek_d9dc19","note":"","ucode":"7611B7E8E175DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286364,"discussion_content":"记录","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593149104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1211178,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/2a/7d8b5943.jpg","nickname":"LH","note":"","ucode":"819B9B2409E834","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263610,"discussion_content":"确实很少有时间去深入实践一门技术","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589213091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87630,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1555644441,"is_pvip":false,"replies":[{"id":"49597","content":"赞，对的","user_name":"作者回复","comment_id":87630,"uid":"1001590","ip_address":"","utype":1,"ctime":1567690775,"user_name_real":"刘超@网易云"}],"discussion_count":11,"race_medal":0,"score":"310793289753","product_id":100024701,"comment_content":"很多同学不理解这个BOSS给员工分任务的场景为什么要用条件变量，因为用互斥量也可以实现。员工等在互斥量上一样会进入睡眠，等BOSS释放互斥锁时也会唤醒这些员工。这样看来根本没有用条件变量的必要。<br><br>我们可以换一个思路，如果不使用条件变量，而且BOSS也不是一直生产任务，那么这时互斥量就会空闲出来，总会有一个员工能拿到锁，员工线程这时候就会在while循环中不停的获得锁，判断状态，释放锁，这样的话就会十分消耗cpu资源了。<br>这时候我们可能会想到，在while循环中加个睡眠，例如5秒，也就是员工线程每隔5秒来执行一次获得锁，判断状态，释放锁的操作，这样就会减轻cpu资源的消耗。<br>但是实际应用场景中，我们无法判断到底间隔几秒来执行一次这个获得锁，判断状态，释放锁的流程，时间长了可能影响吞吐量，时间短了会造成cpu利用率过高，所以这时候引入了条件变量，将主动查询方式改成了被动通知方式，效率也就上去了。<br>文中的例子很容易让新手迷惑，我也不保证上述理解是对的，希望老师能够指点一二。","like_count":73,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447538,"discussion_content":"赞，对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567690775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1028754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b2/92/3a3f4281.jpg","nickname":"水煮蛋不好吃","note":"","ucode":"957318CB353F36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5350,"discussion_content":"你补充了老师没讲的关键点: 不一定会一直都有任务. 没任务时占用系统资源.","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1566200584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1798979,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/73/43/ae139b1f.jpg","nickname":"博","note":"","ucode":"F7CA69FF5D09BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217975,"discussion_content":"互斥锁的底层是否是循环有待验证","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585606739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1888132,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/cf/84/88a54107.jpg","nickname":"等待⒈嗰﹌晴天","note":"","ucode":"BCE5E620210B84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213554,"discussion_content":"单纯用互斥锁是不用while循环得，轮询机制应该是mutex内部做的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585104476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1024303,"avatar":"","nickname":"米兰的小铁匠","note":"","ucode":"5CCE3C8AE4FDC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1888132,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/cf/84/88a54107.jpg","nickname":"等待⒈嗰﹌晴天","note":"","ucode":"BCE5E620210B84","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260626,"discussion_content":"是的，就是操作系统的 TICK 处理函数做的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588868751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":213554,"ip_address":""},"score":260626,"extra":""},{"author":{"id":1576512,"avatar":"https://static001.geekbang.org/account/avatar/00/18/0e/40/49a71ed8.jpg","nickname":"八戒","note":"","ucode":"3F262A99492A65","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1024303,"avatar":"","nickname":"米兰的小铁匠","note":"","ucode":"5CCE3C8AE4FDC2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352956,"discussion_content":"Mutex机制为什么用轮询方式，操作系统这么设计不太好吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614925079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":260626,"ip_address":""},"score":352956,"extra":""}]},{"author":{"id":1131300,"avatar":"https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg","nickname":"zixuan","note":"","ucode":"C72920DD05B074","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587435,"discussion_content":"用信号量或者阻塞队列和条件变量一样的，不会消耗cpu","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663055335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1547763,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9d/f3/3f6dd32b.jpg","nickname":"叶紫真","note":"","ucode":"9CD7567FDB7F1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373048,"discussion_content":"恍然大悟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620577744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236002,"avatar":"https://static001.geekbang.org/account/avatar/00/12/dc/22/bb8e93b4.jpg","nickname":"晴天雨伞","note":"","ucode":"F14D8133A1C077","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351822,"discussion_content":"的确会有这种场景，悟了悟了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614478680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1657948,"avatar":"https://static001.geekbang.org/account/avatar/00/19/4c/5c/9ea0f752.jpg","nickname":"程序猿不圆","note":"","ucode":"BC8926A84A07C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70088,"discussion_content":"比心，说的很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575319796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1028754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b2/92/3a3f4281.jpg","nickname":"水煮蛋不好吃","note":"","ucode":"957318CB353F36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5349,"discussion_content":"你的这个说法才是好理解的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566200303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219599,"user_name":"紫墨青川","can_delete":false,"product_type":"c1","uid":1675988,"ip_address":"","ucode":"6BF7598D0BE1CD","user_header":"https://static001.geekbang.org/account/avatar/00/19/92/d4/dc6d916e.jpg","comment_is_top":false,"comment_ctime":1590049004,"is_pvip":true,"replies":[{"id":"83079","content":"牛","user_name":"作者回复","comment_id":219599,"uid":"1001590","ip_address":"","utype":1,"ctime":1591785640,"user_name_real":"刘超@网易云"}],"discussion_count":6,"race_medal":0,"score":"121849133292","product_id":100024701,"comment_content":"关于老师的第一段代码我来说一下吧。首先是开发环境，我的是Ubuntu18.04 gcc7.5.0,执行的结果并不正确。最后的输出是这样的：<br>Thread 0 downloads the file file1.avi in 83 minutes.<br>Thread 0 downloads the file file1.avi in 86 minutes.<br>Thread 1 downloads the file file2.rmvb in 86 minutes.<br>Thread 0 downloads the file file1.avi in 77 minutes.<br>Thread 1 downloads the file file2.rmvb in 77 minutes.<br>Thread 2 downloads the file file3.mp4 in 77 minutes.<br>Thread 0 downloads the file file1.avi in 93 minutes.<br>Thread 1 downloads the file file2.rmvb in 93 minutes.<br>Thread 2 downloads the file file3.mp4 in 93 minutes.<br>Thread 3 downloads the file file4.wmv in 93 minutes.<br>Thread 0 downloads the file file1.avi in 15 minutes.<br>Thread 1 downloads the file file2.rmvb in 15 minutes.<br>Thread 2 downloads the file file3.mp4 in 15 minutes.<br>Thread 3 downloads the file file4.wmv in 15 minutes.<br>Thread 4 downloads the file file5.flv in 15 minutes.<br>我百思不得其解，纯就代码来看，并不复杂，结构也很清晰，并且也没有什么数据竞争。但编译提示给出了线索， 这里有一个警告：<br>old_downloader.c:13:50: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long int’ [-Wformat=]<br>    printf(&quot;I finish downloading the file within %d minutes!\\n&quot;, downloadtime);<br>这时候我就明白了，本该接受long类型的数据，最终的目的是int。每次pthread_join的时候就会再int类型的downloadtime地址写入一个long类型的数据。恰好，int t先于downloadtime压栈，地址和downloadtime在其高字节相邻(栈从高字节到低字节扩张)。所以每次获取downloadtime的时候修改了t，而t控制了循环，因此导致输出的问题。<br>修改：把int downloadtime修改为long downloadtime就迎刃而解了。<br>所以对于c编程来说，理解细节很重要，确保要解决编译过程中的所有warning，否则可能会存在未知的错误。","like_count":29,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495868,"discussion_content":"牛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591785640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2403653,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ad/45/beab1b3f.jpg","nickname":"mouse","note":"","ucode":"3522B61845F46B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385564,"discussion_content":"我直接换了个变量  汗。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627132974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2323261,"avatar":"https://static001.geekbang.org/account/avatar/00/23/73/3d/d6fff7fb.jpg","nickname":"超然","note":"","ucode":"0F4DDB804B923B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383077,"discussion_content":"遇到同样问题，厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625883069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2570882,"avatar":"","nickname":"Geek_434b07","note":"","ucode":"BC170B421C1791","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379739,"discussion_content":"太厉害了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624099224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253384,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","nickname":"Dovelol","note":"","ucode":"9B5DDF7720F307","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349841,"discussion_content":"想请教下，我用的VSCode ide，为啥都是等待10秒后才输出内容，而不是先输出一部分sleep前的内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613573040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1900707,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/nu3aSibHtLuu1IdNxibOicEHBDQVDriawz16nDuicZ5H5sSSaiay0hXicJbuj6WJ91HNK22cicINWk0FhyjAsGbicbR7OVA/132","nickname":"201200794","note":"","ucode":"B67AC8D6BB1ED0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299755,"discussion_content":"向你学习！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597807273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87731,"user_name":"why","can_delete":false,"product_type":"c1","uid":1012937,"ip_address":"","ucode":"C9E796E53F6F5E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/c9/d3439ca4.jpg","comment_is_top":false,"comment_ctime":1555673608,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"83160052232","product_id":100024701,"comment_content":"- 线程复制执行二进制指令<br>- 多进程缺点: 创建进程占用资源多; 进程间通信需拷贝内存, 不能共享<br>- 线程相关操作<br>    - pthread_exit(A), A 是线程退出的返回值<br>    - pthread_attr_t 线程属性, 用辅助函数初始化并设置值; 用完需要销毁<br>    - pthread_create 创建线程, 四个参数(线程对象, 属性, 运行函数, 运行参数)<br>    - pthread_join 获取线程退出返回值, 多线程依赖 libpthread.so<br>    - 一个线程退出, 会发送信号给 其他所有同进程的线程<br>- 线程中有三类数据<br>    - 线程栈本地数据, 栈大小默认 8MB; 线程栈之间有保护间隔, 若误入会引发段错误<br>    - 进程共享的全局数据<br>    - 线程级别的全局变量(线程私有数据, pthread_key_create(key, destructer)); key 所有线程都可以访问, 可填入各自的值(同名不同值的全局变量)<br>- 数据保护<br>    - Mutex(互斥), 初始化; lock(没抢到则阻塞)&#47;trylock(没抢到则返回错误码); unlock; destroy<br>    - 条件变量(通知), 收到通知, 还是要抢锁(由 wait 函数执行); 因此条件变量与互斥锁配合使用<br>    - 互斥锁所谓条件变量的参数, wait 函数会自动解锁&#47;加锁<br>    - broadcast(通知); destroy<br>","like_count":19},{"had_liked":false,"id":87527,"user_name":"张志强","can_delete":false,"product_type":"c1","uid":1249491,"ip_address":"","ucode":"C9D4301CA62DBE","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/d3/cb011861.jpg","comment_is_top":false,"comment_ctime":1555632936,"is_pvip":false,"replies":[{"id":"49602","content":"是的","user_name":"作者回复","comment_id":87527,"uid":"1001590","ip_address":"","utype":1,"ctime":1567691343,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"57390207784","product_id":100024701,"comment_content":"这一章干货很多，操作系统课上都要分好几节讲。消化需要不少时间","like_count":13,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447495,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567691343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286500,"user_name":"JJJJ","can_delete":false,"product_type":"c1","uid":2055131,"ip_address":"","ucode":"7E470301DE9D6C","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5b/db/175911e1.jpg","comment_is_top":false,"comment_ctime":1617348423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40272054087","product_id":100024701,"comment_content":"线程同步，什么时候只需要互斥，什么时候需要互斥➕条件变量。其实这是两种场景。第一种，只需要互斥的场景。多个线程都知道自己要干什么，也就是说线程处理的逻辑不依赖其他线程，线程只需要启动，得到了锁，就可以开始干活。举个例子，比如上厕所，一堆人等一个坑位，只要你抢到了坑位，就可以去上厕所，这个时候只需要一把锁就行。第二种情况，需要互斥+条件变量。线程启动以后，任务不是线程代码写死的，而是其他线程分发的，就是生产者和消费者模型，这个时候要加一个条件变量，有任务，我就干活，没任务我就睡觉。那有人说，我只用互斥锁不行嘛？没事干的时候我直接释放锁不好嘛？当然可以，但是效率低，因为你释放了锁，其他人抢了锁，没任务的时候还是没任务，白白浪费申请锁和释放去呢的资源。<br><br>总结一下，线程同步有两种。第一种只要互斥，线程只要抢到锁，有锁直接干活。第二种互斥+条件变量，线程拿到锁，也不知道要干什么，等待其他线程分配任务，等待的条件就是条件变量。","like_count":10},{"had_liked":false,"id":91264,"user_name":"一只特立独行的猪","can_delete":false,"product_type":"c1","uid":1037041,"ip_address":"","ucode":"421D0A6FE29127","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d2/f1/c071cffa.jpg","comment_is_top":false,"comment_ctime":1556958217,"is_pvip":false,"replies":[{"id":"49486","content":"哦，没有mac","user_name":"作者回复","comment_id":91264,"uid":"1001590","ip_address":"","utype":1,"ctime":1567675148,"user_name_real":"刘超@网易云"}],"discussion_count":9,"race_medal":0,"score":"35916696585","product_id":100024701,"comment_content":"macOS下执行有不同的结果：<br><br>creating thread 0, please help me to download file1.avi<br>creating thread 1, please help me to download file2.rmvb<br>creating thread 2, please help me to download file3.mp4<br>I am downloading the file file1.avi!<br>I am downloading the file file2.rmvb!<br>creating thread 3, please help me to download file4.wmv<br>I am downloading the file file3.mp4!<br>creating thread 4, please help me to download file5.flv<br>I am downloading the file file4.wmv!<br>I am downloading the file file5.flv!<br>I finish downloading the file within 7 minutes!<br>I finish downloading the file within 49 minutes!<br>I finish downloading the file within 73 minutes!<br>I finish downloading the file within 58 minutes!<br>I finish downloading the file within 30 minutes!<br>Thread 0 downloads the file file1.avi in 49 minutes.<br>Thread 0 downloads the file file1.avi in 7 minutes.<br>Thread 1 downloads the file file2.rmvb in 7 minutes.<br>Thread 0 downloads the file file1.avi in 73 minutes.<br>Thread 1 downloads the file file2.rmvb in 73 minutes.<br>Thread 2 downloads the file file3.mp4 in 73 minutes.<br>Thread 0 downloads the file file1.avi in 58 minutes.<br>Thread 1 downloads the file file2.rmvb in 58 minutes.<br>Thread 2 downloads the file file3.mp4 in 58 minutes.<br>Thread 3 downloads the file file4.wmv in 58 minutes.<br>Thread 0 downloads the file file1.avi in 30 minutes.<br>Thread 1 downloads the file file2.rmvb in 30 minutes.<br>Thread 2 downloads the file file3.mp4 in 30 minutes.<br>Thread 3 downloads the file file4.wmv in 30 minutes.<br>Thread 4 downloads the file file5.flv in 30 minutes.","like_count":8,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448864,"discussion_content":"哦，没有mac","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567675148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1476379,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/2tRLBJ1ic0Ud8uEwFd0Y430ibgvQKwibAtiauYCjS3siaJDC4ujHghvbhaWT6iazl5ZsNnqm2S4PzIN73r040UbHmnoA/132","nickname":"成程晨","note":"","ucode":"1FBF6BE312E66C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225113,"discussion_content":"在Ubuntu上是一样的结果，在CentOS上和文中正确结果一样","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586349158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1898192,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f6/d0/9e2feef3.jpg","nickname":"麻薯先生","note":"","ucode":"AAA1F41A796471","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575320,"discussion_content":"参考第3条留言，修改main函数里的downloadtime类型为long。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654746166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2539409,"avatar":"https://static001.geekbang.org/account/avatar/00/26/bf/91/6ea2e712.jpg","nickname":"黑白灰","note":"","ucode":"6BB2EC640FD326","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370633,"discussion_content":"我在ubuntu也是你这个输出，上面大佬其实已经写出了，就是要把int download time  修改为long downloadtime.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619488239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022846,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9b/7e/48fcb2e2.jpg","nickname":"feiniao","note":"","ucode":"91A5B995E1698F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286691,"discussion_content":"楼下评论有解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593262506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592092,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/1c/5eb03a91.jpg","nickname":"cc","note":"","ucode":"FF41E5D87BAD76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34399,"discussion_content":"一样的结果\n为什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571197012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1171107,"avatar":"https://static001.geekbang.org/account/avatar/00/11/de/a3/c4fcd3db.jpg","nickname":"jijun gao","note":"","ucode":"D3CA160F9FDC23","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8262,"discussion_content":"一样的结果","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567859537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448863,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","nickname":"tuyu","note":"","ucode":"B235325B541408","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4419,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565406797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030657,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/01/5ce8ce0b.jpg","nickname":"Leoorz","note":"","ucode":"8912628AD6ADE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1382,"discussion_content":"老铁我跟你的执行结果一样，不过我是在linux上，不是macOS上，正在定位为啥...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562591967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87690,"user_name":"赵又新","can_delete":false,"product_type":"c1","uid":1472829,"ip_address":"","ucode":"B0548DB9A6F2CA","user_header":"https://static001.geekbang.org/account/avatar/00/16/79/3d/29746a4b.jpg","comment_is_top":false,"comment_ctime":1555661242,"is_pvip":false,"replies":[{"id":"49593","content":"是的，赞","user_name":"作者回复","comment_id":87690,"uid":"1001590","ip_address":"","utype":1,"ctime":1567690697,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"35915399610","product_id":100024701,"comment_content":"手敲了第一个代码，报未定义变量的错，查资料发现文章中PTHREAD_CTREATE_JOINABL打错了，末尾少了个E","like_count":8,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447563,"discussion_content":"是的，赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567690697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87482,"user_name":"刘強","can_delete":false,"product_type":"c1","uid":1035612,"ip_address":"","ucode":"B2E41BB894A727","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","comment_is_top":false,"comment_ctime":1555606837,"is_pvip":false,"replies":[{"id":"49605","content":"牛","user_name":"作者回复","comment_id":87482,"uid":"1001590","ip_address":"","utype":1,"ctime":1567691371,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"31620377909","product_id":100024701,"comment_content":"凌晨学习！","like_count":7,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447477,"discussion_content":"牛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567691371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87569,"user_name":"算不出流源","can_delete":false,"product_type":"c1","uid":1178209,"ip_address":"","ucode":"B6CFEF672E3E1C","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/61/691e2936.jpg","comment_is_top":false,"comment_ctime":1555636201,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"27325439977","product_id":100024701,"comment_content":"刘老师，关于条件变量和互斥锁配合使用的一个问题，既然pthread_mutex_lock() 本身就是阻塞的，那么在你举的老板招聘三个员工抢活干的例子中为什么还需要再适使用条件变量pthread_cond_wait()来等活干呢，条件变量等待的时候不也是阻塞的吗？没有理解增加条件变量的意义，请老师指导","like_count":6,"discussions":[{"author":{"id":1480252,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/86QEF74Mhc6ECbBBMr62hVz0ezOicI2Kbv8QBA7qR7KepeoDib9W6KLxxMPuQ24JGusvjC03NNr8uj8GyK0DxKiaw/132","nickname":"HerofH","note":"","ucode":"84EB3243FAB432","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3630,"discussion_content":"个人理解：最主要的问题在于这个“活”并不一定是源源不断的来的，如果老板没有接到活，那么三个员工就会一直来问老板有没有活干，这样就很烦。这就是如果没活干的时候三个员工不断的在while里面获得锁、释放锁，占了CPU，造成了大量的空转。\n所以用条件变量的好处就是：如果没有活干的时候直接让三个员工去睡觉，等到有活干的时候再去叫醒他们来干活，这样没有活干的时候也不会占CPU。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1564648206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1024303,"avatar":"","nickname":"米兰的小铁匠","note":"","ucode":"5CCE3C8AE4FDC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1480252,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/86QEF74Mhc6ECbBBMr62hVz0ezOicI2Kbv8QBA7qR7KepeoDib9W6KLxxMPuQ24JGusvjC03NNr8uj8GyK0DxKiaw/132","nickname":"HerofH","note":"","ucode":"84EB3243FAB432","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260632,"discussion_content":"其实我觉得这个例子里面可以不用互斥锁，直接用信号量通知，这样员工都直接等待就好了，等待老板通知有活。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588869113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3630,"ip_address":""},"score":260632,"extra":""},{"author":{"id":1245504,"avatar":"https://static001.geekbang.org/account/avatar/00/13/01/40/a203a3b9.jpg","nickname":"爱学习不害怕","note":"","ucode":"BE325C02E4C92F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1024303,"avatar":"","nickname":"米兰的小铁匠","note":"","ucode":"5CCE3C8AE4FDC2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286676,"discussion_content":"对同一公共资源的争夺还是要互斥锁的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593259961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":260632,"ip_address":""},"score":286676,"extra":""},{"author":{"id":1892268,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM6fGV3BcHQHyNibzRhsPr6KqYzOtMF8G9fiaNvYUavdlhdqMugcHWggWGBbIibkYTibIXramEXsvg4aXA/132","nickname":"肖海涛","note":"","ucode":"5E4C20D5A69BEC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1024303,"avatar":"","nickname":"米兰的小铁匠","note":"","ucode":"5CCE3C8AE4FDC2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406751,"discussion_content":"收到通知以后，干活的时候还是要用互斥量锁住资源的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634827942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":260632,"ip_address":""},"score":406751,"extra":""}]},{"author":{"id":1066409,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","nickname":"Lorry","note":"","ucode":"BD4754D0F1D786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385050,"discussion_content":"条件通知并不代表你就能抢到锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626862368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154179,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1574388158,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"18754257342","product_id":100024701,"comment_content":"不加锁时的操作也不会出现金额不对，难道跟操作系统版本有关系？ubuntu16.4 X64<br><br>Thread 2136516352 is transfering money!<br>Thread 2094556928 is transfering money!<br>Thread 2115536640 is transfering money!<br>Thread 2105046784 is transfering money!<br>Thread 2126026496 is transfering money!<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>......<br>......<br>......<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br><br><br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>Thread 2105046784 finish transfering money!<br>Thread 2115536640 finish transfering money!<br>Thread 2136516352 finish transfering money!<br>Thread 2126026496 finish transfering money!<br>Thread 2094556928 finish transfering money!<br>","like_count":4,"discussions":[{"author":{"id":1981613,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","nickname":"Geek_ac7784","note":"","ucode":"62F0E5E6D6F4BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299980,"discussion_content":"我在windows上运行也是这样。猜测是主线程运行太快，还没开始转账，就遍历了100遍。此时应该在主线程sleep 1s 试一下。我成功了\n//sleep(1);//这里睡一秒\n  for(t=0;t<100;t++){\n    //第一次运行去掉下面这行\n    //pthread_mutex_lock(&amp;g_money_lock);\n    printf(&#34;money_of_tom + money_of_jerry = %d\\n&#34;, money_of_tom + money_of_jerry);\n    //第一次运行去掉下面这行\n    //pthread_mutex_unlock(&amp;g_money_lock);\n  }","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597893901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2402027,"avatar":"https://static001.geekbang.org/account/avatar/00/24/a6/eb/11f58b60.jpg","nickname":"SheehanChen","note":"","ucode":"C7A033CF3F9E48","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1981613,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","nickname":"Geek_ac7784","note":"","ucode":"62F0E5E6D6F4BA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356176,"discussion_content":"我试着延时1s不行，得5s，Centos8","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615545909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299980,"ip_address":""},"score":356176,"extra":""}]},{"author":{"id":2028811,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","nickname":"兔嘟嘟","note":"","ucode":"5A9042B4C7670C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389502,"discussion_content":"这边模拟原子操作出错，是在多个线程执行时，输出中间结果，所以考虑是线程执行太快、太慢，或者主线程执行太快、太慢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629296276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2403653,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ad/45/beab1b3f.jpg","nickname":"mouse","note":"","ucode":"3522B61845F46B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385603,"discussion_content":"调时间 能解决  位置或者大小","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627169008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1402798,"avatar":"https://static001.geekbang.org/account/avatar/00/15/67/ae/fbe82504.jpg","nickname":"笨笨的博克","note":"","ucode":"6ED60202361642","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295328,"discussion_content":"是的,加不加锁都一样,我提CentOS7.7.1908 x86-64","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596166111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1319529,"avatar":"https://static001.geekbang.org/account/avatar/00/14/22/69/09f7a8a2.jpg","nickname":"Don Wang","note":"","ucode":"1853365FA279F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1402798,"avatar":"https://static001.geekbang.org/account/avatar/00/15/67/ae/fbe82504.jpg","nickname":"笨笨的博克","note":"","ucode":"6ED60202361642","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299783,"discussion_content":"这是什么原因呢？ 我加大了 sleep时间，仍然是一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597817748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":295328,"ip_address":""},"score":299783,"extra":""},{"author":{"id":2460931,"avatar":"https://static001.geekbang.org/account/avatar/00/25/8d/03/999ae4cd.jpg","nickname":"翔尼玛","note":"","ucode":"90831EDFDD3F19","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1319529,"avatar":"https://static001.geekbang.org/account/avatar/00/14/22/69/09f7a8a2.jpg","nickname":"Don Wang","note":"","ucode":"1853365FA279F2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359159,"discussion_content":"在for循环里sleep试试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616124005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299783,"ip_address":""},"score":359159,"extra":""}]}]},{"had_liked":false,"id":87590,"user_name":"Geek_f9e53a","can_delete":false,"product_type":"c1","uid":1481679,"ip_address":"","ucode":"BDE45D2F97B733","user_header":"","comment_is_top":false,"comment_ctime":1555638738,"is_pvip":false,"replies":[{"id":"31540","content":"相当于全局变量，可以在多个函数间共享，比如线程里面有多个函数","user_name":"作者回复","comment_id":87590,"uid":"1001590","ip_address":"","utype":1,"ctime":1555667631,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"18735507922","product_id":100024701,"comment_content":"线程栈上的本地数据和线程私有数据有什么本质区别，能否举例说明？谢谢","like_count":4,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447522,"discussion_content":"相当于全局变量，可以在多个函数间共享，比如线程里面有多个函数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555667631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174605,"user_name":"何柄融","can_delete":false,"product_type":"c1","uid":1398884,"ip_address":"","ucode":"A4C165D1EE3726","user_header":"https://static001.geekbang.org/account/avatar/00/15/58/64/b715d45a.jpg","comment_is_top":false,"comment_ctime":1580292810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14465194698","product_id":100024701,"comment_content":"不就是wait和notify吗？","like_count":4},{"had_liked":false,"id":87583,"user_name":"罗 乾 林","can_delete":false,"product_type":"c1","uid":1188222,"ip_address":"","ucode":"D0406F95176ABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","comment_is_top":false,"comment_ctime":1555638158,"is_pvip":false,"replies":[{"id":"49599","content":"是的","user_name":"作者回复","comment_id":87583,"uid":"1001590","ip_address":"","utype":1,"ctime":1567691242,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"14440540046","product_id":100024701,"comment_content":"@算不出流源 我的理解pthread_cond_wait 调用之后是会让出互锁，避免占着资源不干活，其他线程才可能获取该锁。对应这个例子就是Boss拿不到锁无法进行任务分配","like_count":3,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447518,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567691242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280515,"user_name":"人在江湖龙在江湖","can_delete":false,"product_type":"c1","uid":2285946,"ip_address":"","ucode":"20850038573DAE","user_header":"https://static001.geekbang.org/account/avatar/00/22/e1/7a/b206cded.jpg","comment_is_top":false,"comment_ctime":1614238904,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10204173496","product_id":100024701,"comment_content":"#include &lt;fcntl.h&gt; <br>#include &lt;unistd.h&gt; <br>作者忘了加这二个头文件，如果没有unistd.h ,sleep这个函数肯定是找不到的","like_count":2},{"had_liked":false,"id":105592,"user_name":"garlic","can_delete":false,"product_type":"c1","uid":1019579,"ip_address":"","ucode":"FEB147EDB5774E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/bb/c039dc11.jpg","comment_is_top":false,"comment_ctime":1561038482,"is_pvip":true,"replies":[{"id":"48889","content":"赞","user_name":"作者回复","comment_id":105592,"uid":"1001590","ip_address":"","utype":1,"ctime":1567504596,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":1,"score":"10150973074","product_id":100024701,"comment_content":"看了下老师推荐的书，网上有找些资料，整理了下相关API example <br> https:&#47;&#47;garlicspace.com&#47;2019&#47;06&#47;20&#47;posix-threads-api-整理&#47;","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454733,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567504596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94264,"user_name":"Gojustforfun","can_delete":false,"product_type":"c1","uid":1187021,"ip_address":"","ucode":"7513A40F27344F","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","comment_is_top":false,"comment_ctime":1557756271,"is_pvip":true,"replies":[{"id":"49366","content":"用户线程对应内核的task_struct，有几种模式，linux是一个线程对应内核一个task_struct，操作系统原理也有多个线程对应内核一个task_struct的，只不过linux没有采取这种模式","user_name":"作者回复","comment_id":94264,"uid":"1001590","ip_address":"","utype":1,"ctime":1567651491,"user_name_real":"刘超@网易云"}],"discussion_count":2,"race_medal":0,"score":"10147690863","product_id":100024701,"comment_content":"请问什么是用户级线程？内核级线程？在linux中都是用task_struct实现的吗？操作系统教材上说的“多个用户级线程运行在一个内核级线程上”指的是什么意思？<br><br>困扰好久了，希望大家不吝赐教，谢谢","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449985,"discussion_content":"用户线程对应内核的task_struct，有几种模式，linux是一个线程对应内核一个task_struct，操作系统原理也有多个线程对应内核一个task_struct的，只不过linux没有采取这种模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567651491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245504,"avatar":"https://static001.geekbang.org/account/avatar/00/13/01/40/a203a3b9.jpg","nickname":"爱学习不害怕","note":"","ucode":"BE325C02E4C92F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286678,"discussion_content":"我自己的理解，按照操作系统原理的说法，进程是资源分配的最小单位，线程是调度的最小单位。所以一般一个大进程中会有一些小线程(比如一个浏览器开多个标签)，这就是用户级线程，线程共享大进程内部的资源和数据，所以这些线程再怎么折腾，都是在他依附的进程之内。而这个大的进程，可以直接与内核进行交互的，就是内核级线程。相应的，一个用户级线程，维护的是他自己的pcb，一个内核级线程，维护所有依附在他身上的线程的pcb。\n\n个人理解，有错误请大家指正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593260435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87519,"user_name":"Geek_082575","can_delete":false,"product_type":"c1","uid":1304308,"ip_address":"","ucode":"6DDEBB7D422072","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Bmcr48jvTjq7sJfcmN4adOUIckhql2ThBtByyhbmuczX0vc2qXgSYVV38iawwy8icS4QpOzm6ArAicVwneuDWVIAQ/132","comment_is_top":false,"comment_ctime":1555631856,"is_pvip":false,"replies":[{"id":"31542","content":"后面会讲的","user_name":"作者回复","comment_id":87519,"uid":"1001590","ip_address":"","utype":1,"ctime":1555667972,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"10145566448","product_id":100024701,"comment_content":"刘老师可以再深入讲解线程的实现吗","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447492,"discussion_content":"后面会讲的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555667972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175304,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1580649383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5875616679","product_id":100024701,"comment_content":"其实看看Java里面JUC的源码，再来看这个并发组件，大概都能明白。因为Java底层也是依赖linux系统库","like_count":1},{"had_liked":false,"id":174404,"user_name":"崔子昂","can_delete":false,"product_type":"c1","uid":1124961,"ip_address":"","ucode":"79A007047F207F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eprazLDhfhCOtPtDf9mNOkgdxjut8iadXWTnVibO8Apuzr3FJQibzKzsGDnp2zAialEqdm9zou2BxZ4Dw/132","comment_is_top":false,"comment_ctime":1580195016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5875162312","product_id":100024701,"comment_content":"在上OMSCS的操作系统那门课，结合这门课感觉容易理解很多。","like_count":2},{"had_liked":false,"id":112247,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1562690302,"is_pvip":false,"replies":[{"id":"46723","content":"不加sleep就太快了，看不出来","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566386575,"ip_address":"","comment_id":112247,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5857657598","product_id":100024701,"comment_content":"再说第二个例子, 不加锁情况下, 我这边在main 函数的for 里面加了sleep才会出现错误值, 如果不加,则不会出现","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457638,"discussion_content":"不加sleep就太快了，看不出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566386575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101200,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1559740060,"is_pvip":false,"replies":[{"id":"37037","content":"是的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1560255482,"ip_address":"","comment_id":101200,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5854707356","product_id":100024701,"comment_content":"条件变量的使用应该也是有场景的，它主要是为了避免线程一直竞争锁而导致cpu占用高，但是它也是有代价的，线程被唤醒也是要消耗cpu资源的。其实如果老板一直发任务，不会间隔很长时间才发新任务的话，只用互斥锁就可以了","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452849,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560255482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92482,"user_name":"zhj","can_delete":false,"product_type":"c1","uid":1311772,"ip_address":"","ucode":"65B9E222D6E075","user_header":"https://static001.geekbang.org/account/avatar/00/14/04/1c/b0c6c009.jpg","comment_is_top":false,"comment_ctime":1557280612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5852247908","product_id":100024701,"comment_content":"由trylock轮训引申出条件变量，这个举例貌似不很恰当，条件变量本身已经获取了锁，只是运行条件不满足进而主动弃锁等待满足条件的发生，而trylock则是压根没竞争到锁，更无从谈起锁内运行的问题","like_count":1},{"had_liked":false,"id":90314,"user_name":"任鹏斌","can_delete":false,"product_type":"c1","uid":1104086,"ip_address":"","ucode":"34319B05EA6E74","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg","comment_is_top":false,"comment_ctime":1556492479,"is_pvip":false,"replies":[{"id":"49509","content":"是的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567677029,"ip_address":"","comment_id":90314,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5851459775","product_id":100024701,"comment_content":"老师关于线程私有数据？设置同样的key不同的线程如何访问到不同的值，不是很理解，是不是类似java里ThreadLocal变量？","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448468,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567677029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90138,"user_name":"不一样的烟火","can_delete":false,"product_type":"c1","uid":1473251,"ip_address":"","ucode":"6E305F0EE90E8B","user_header":"https://static001.geekbang.org/account/avatar/00/16/7a/e3/145adba9.jpg","comment_is_top":false,"comment_ctime":1556425626,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5851392922","product_id":100024701,"comment_content":"while(!quit){<br><br>    pthread_mutex_lock(&amp;g_task_lock);<br>    while(tail == head){<br>      if(quit){<br>        pthread_mutex_unlock(&amp;g_task_lock);<br>        pthread_exit((void *)0);<br>      }<br>      printf(&quot;No task now! Thread %u is waiting!\\n&quot;, (unsigned int)tid);<br>      pthread_cond_wait(&amp;g_task_cv, &amp;g_task_lock);<br>      printf(&quot;Have task now! Thread %u is grabing the task !\\n&quot;, (unsigned int)tid);<br>    }<br>    char task = tasklist[head++];<br>    pthread_mutex_unlock(&amp;g_task_lock);<br>    printf(&quot;Thread %u has a task %c now!\\n&quot;, (unsigned int)tid, task);<br>    sleep(5);<br>    printf(&quot;Thread %u finish the task %c!\\n&quot;, (unsigned int)tid, task); <br>}<br>这段其实有个疑问，上一个线程执行完加锁等待任务之后，下一个线程为什么还可以打印自己在等待任务，打印那一段不是已经被锁住了吗","like_count":1,"discussions":[{"author":{"id":1260419,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3b/83/a5327123.jpg","nickname":"ysnows","note":"","ucode":"2CA3374E1C3DA8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4579,"discussion_content":"\t/* caller must lock mutex */\n\tpthread_cond_wait(cond, mutex)\n\t{\n\t\tlock(cond->__data.__lock);\n\t\tunlock(mutex);\n\t\tdo {\n\t\tunlock(cond->__data.__lock);\n\t\tfutex_wait(cond->__data.__futex);\n\t\tlock(cond->__data.__lock);\n\t\t} while(...)\n\t\tunlock(cond->__data.__lock);\n\t\tlock(mutex);\n\t}\n\n在 pthread_cond_wait里面，会解锁之前锁住的g_task_lock,其他线程就可以执行了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565574232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1519189,"avatar":"","nickname":"Geek_00711d","note":"","ucode":"2B0B98853D4CCF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4815,"discussion_content":"pthread_cond_wait 先会解锁，等待通知，下一个线程就会得到这个锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565751126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87978,"user_name":"唐龙","can_delete":false,"product_type":"c1","uid":1471657,"ip_address":"","ucode":"87A10AE04F2037","user_header":"https://static001.geekbang.org/account/avatar/00/16/74/a9/5eb3ebc6.jpg","comment_is_top":false,"comment_ctime":1555775373,"is_pvip":false,"replies":[{"id":"49575","content":"我这里是对的呀","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567689747,"ip_address":"","comment_id":87978,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5850742669","product_id":100024701,"comment_content":"本节的创建五条线程模拟文件下载的例子，我这里操作有一些问题。首先，我在主线程里使用同一个变量downloadtime接收子线程的返回值的时候，输出和预想的不一样。thread 0返回时没有问题，thread 1返回时会输出两条，downloadtime一样但是前面会把thread0 file0重新输出一遍再输出一遍thread1 file1……thread4返回时会输出五条，五个一样的downloadtime，一条thread0 file0，一条thread1 file1……最后一条一条thread4 file4。但是如果我把downloadtime设置为一个数组，即使用不同的地址，就不会出现这个问题了。我想知道出现前面情况的原因是什么。","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447671,"discussion_content":"我这里是对的呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567689747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1708157,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/10/7d/e2e9d222.jpg","nickname":"hinzer","note":"","ucode":"021A687DF49F02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":231895,"discussion_content":"我也遇到了同样的情况~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586836673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87934,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1555759197,"is_pvip":false,"replies":[{"id":"32069","content":"少了一个E","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1556198456,"ip_address":"","comment_id":87934,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850726493","product_id":100024701,"comment_content":"老师请问一下， 我编译文章中的例子时报错： error: &#39;PTHREAD_CREATE_JOINABL&#39; undeclared (first use in this function) 这个应该咋解决","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447656,"discussion_content":"少了一个E","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556198456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87854,"user_name":"Vilochen.","can_delete":false,"product_type":"c1","uid":1101556,"ip_address":"","ucode":"19D9BF8534B480","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/f4/5bfc786a.jpg","comment_is_top":false,"comment_ctime":1555732585,"is_pvip":false,"replies":[{"id":"49581","content":"java底层就是操作系统呀","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567690237,"ip_address":"","comment_id":87854,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850699881","product_id":100024701,"comment_content":"最近也正好在看java的线程。看了这章才真正知道了什么是知识是相通的。java实现的机制和linux多线程简直如出一辙。受教了","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447624,"discussion_content":"java底层就是操作系统呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567690237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87673,"user_name":"天涯咫尺间","can_delete":false,"product_type":"c1","uid":1134316,"ip_address":"","ucode":"87D13B0C3FC35C","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/ec/0340146a.jpg","comment_is_top":false,"comment_ctime":1555657643,"is_pvip":false,"replies":[{"id":"49594","content":"是的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567690724,"ip_address":"","comment_id":87673,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850624939","product_id":100024701,"comment_content":"这节课超哥讲的条件锁, 其实类比java里的condition锁来说,调用pthread_cond_wait之前会先加锁,然后再调用pthread_cond_wait等待,pthread_cond_wait 其实内部实现应该是先解锁,然后等待其他线程唤醒, 当我pthread_cond_wait的时候,我自己持有的锁已经unlock了,所以其他线程是可以拿到的.","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447558,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567690724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87626,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1555644055,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5850611351","product_id":100024701,"comment_content":"总算理解了多线程，互斥量和条件变量的作用。","like_count":1},{"had_liked":false,"id":87608,"user_name":"李程程","can_delete":false,"product_type":"c1","uid":1476306,"ip_address":"","ucode":"5C592CC73DF302","user_header":"https://static001.geekbang.org/account/avatar/00/16/86/d2/2d54f1a0.jpg","comment_is_top":false,"comment_ctime":1555640770,"is_pvip":false,"replies":[{"id":"49598","content":"是的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567690785,"ip_address":"","comment_id":87608,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850608066","product_id":100024701,"comment_content":"这个线程的例子感觉是消费者生产者模型呢","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447530,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567690785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87594,"user_name":"罗 乾 林","can_delete":false,"product_type":"c1","uid":1188222,"ip_address":"","ucode":"D0406F95176ABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","comment_is_top":false,"comment_ctime":1555639092,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5850606388","product_id":100024701,"comment_content":"刘老师，在boss分配任务的例子中退出时主线程设置quit = 1，叫醒其他等待的线程之后就直接销毁了g_task_lock，g_task_cv，有可能之后coder 重新获取锁，检测到quit==1 然后释放锁。这种情况下我认为锁都被销毁了可能会出问题，代码测试了下，发现程序没出问题。不明白这是什么原因？","like_count":1},{"had_liked":false,"id":87539,"user_name":"🗿顾晓峰🈹🈳🈴🈷🎏","can_delete":false,"product_type":"c1","uid":1109785,"ip_address":"","ucode":"F3447F81832780","user_header":"https://static001.geekbang.org/account/avatar/00/10/ef/19/ba159b8c.jpg","comment_is_top":false,"comment_ctime":1555633775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5850601071","product_id":100024701,"comment_content":"学习了","like_count":1},{"had_liked":false,"id":87523,"user_name":"ninuxer","can_delete":false,"product_type":"c1","uid":1243135,"ip_address":"","ucode":"5394ADAF2667D6","user_header":"https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132","comment_is_top":false,"comment_ctime":1555632492,"is_pvip":false,"replies":[{"id":"49603","content":"加油","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567691353,"ip_address":"","comment_id":87523,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850599788","product_id":100024701,"comment_content":"打卡day12<br>线程这篇，算是看懂了😂","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447493,"discussion_content":"加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567691353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340316,"user_name":"小杰","can_delete":false,"product_type":"c1","uid":2853200,"ip_address":"","ucode":"BBDF8E9F348F65","user_header":"https://static001.geekbang.org/account/avatar/00/2b/89/50/aee9fdab.jpg","comment_is_top":false,"comment_ctime":1648737872,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648737872","product_id":100024701,"comment_content":"最后一个条件变量和互斥锁的代码，看了两个小时，将老师后面的解释，给每一段代码加上注释，终于算是明白了。由此发现，老师讲得很好","like_count":0},{"had_liked":false,"id":332597,"user_name":"凉凉","can_delete":false,"product_type":"c1","uid":1325256,"ip_address":"","ucode":"FCCF976E41EF71","user_header":"https://static001.geekbang.org/account/avatar/00/14/38/c8/972a5024.jpg","comment_is_top":false,"comment_ctime":1643359839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643359839","product_id":100024701,"comment_content":"&quot;只不过每个线程都有自己的栈空间&quot;，这里的栈空间是指内核栈嘛？还是用户态栈","like_count":0},{"had_liked":false,"id":326171,"user_name":"四有青年","can_delete":false,"product_type":"c1","uid":2004350,"ip_address":"","ucode":"121A7C613E6C32","user_header":"https://static001.geekbang.org/account/avatar/00/1e/95/7e/1057f77a.jpg","comment_is_top":false,"comment_ctime":1639404511,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639404511","product_id":100024701,"comment_content":"这章看着舒服了，工作中多线程是常用的，因此线程同步也是绕不过去的。当然在工作中应该比较少直接使用pthread库，对应在c++中的标准库封装，互斥锁就是std::mutex，条件变量即是std::condition_variable。","like_count":0},{"had_liked":false,"id":325544,"user_name":"Kenny","can_delete":false,"product_type":"c1","uid":2783154,"ip_address":"","ucode":"311C6CCBCBA105","user_header":"https://static001.geekbang.org/account/avatar/00/2a/77/b2/85bd7eca.jpg","comment_is_top":false,"comment_ctime":1639019261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639019261","product_id":100024701,"comment_content":"这节如果在实际操作中有用过系统的线程、锁那些的函数就会印象更深，无论哪个系统都行，像我就在freeertso系统中用过类似的，然后再来看这一节，就会发现每个操作系统的函数功能都相似，这大概就是举一反三吧。","like_count":0},{"had_liked":false,"id":323438,"user_name":"Emma","can_delete":false,"product_type":"c1","uid":2698428,"ip_address":"","ucode":"C93FFB7DF0B3F3","user_header":"https://static001.geekbang.org/account/avatar/00/29/2c/bc/5311e976.jpg","comment_is_top":false,"comment_ctime":1637903894,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637903894","product_id":100024701,"comment_content":"如果进程只有一个线程，那pid也是指主线程的id吗","like_count":0},{"had_liked":false,"id":306969,"user_name":"银子","can_delete":false,"product_type":"c1","uid":1125765,"ip_address":"","ucode":"5233F5FB5D2755","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/85/55f19976.jpg","comment_is_top":false,"comment_ctime":1628815707,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1628815707","product_id":100024701,"comment_content":"老师您好，有个疑问，希望您有时间帮忙解惑；<br>栈大小默认是8M，而栈调用深度超过65535会出现overflow 栈溺出，那么栈溺出是不是只要满足栈大小超过8M或者超过65535调用深度，都会出现栈溺出","like_count":0},{"had_liked":false,"id":303961,"user_name":"mouse","can_delete":false,"product_type":"c1","uid":2403653,"ip_address":"","ucode":"3522B61845F46B","user_header":"https://static001.geekbang.org/account/avatar/00/24/ad/45/beab1b3f.jpg","comment_is_top":false,"comment_ctime":1627126829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627126829","product_id":100024701,"comment_content":"pthread_attr_setdetachstate(&amp;thread_attr,PTHREAD_CREATE_JOINABLE);<br>是配合pthread_join（）使用的吗？ 如果设置为detached state 会怎么样","like_count":0},{"had_liked":false,"id":295217,"user_name":"sharpblade","can_delete":false,"product_type":"c1","uid":1156299,"ip_address":"","ucode":"170B74D5DEC517","user_header":"https://static001.geekbang.org/account/avatar/00/11/a4/cb/5db54f58.jpg","comment_is_top":false,"comment_ctime":1622301297,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1622301297","product_id":100024701,"comment_content":"转账的例子，主线程没有sleep连续打印100次之后，直接把锁destroy了，子线程还在sleep呢。。。","like_count":0},{"had_liked":false,"id":295213,"user_name":"sharpblade","can_delete":false,"product_type":"c1","uid":1156299,"ip_address":"","ucode":"170B74D5DEC517","user_header":"https://static001.geekbang.org/account/avatar/00/11/a4/cb/5db54f58.jpg","comment_is_top":false,"comment_ctime":1622300774,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1622300774","product_id":100024701,"comment_content":"&#47;&#47;员工二也发现有任务了，开始抢任务，不好意思，就一个任务，让人家抢走了，接着等吧<br>Have task now! Thread 3483440896 is grabing the task !    -- this message is misleading.<br>No task now! Thread 3483440896 is waiting!<br><br>","like_count":0},{"had_liked":false,"id":292821,"user_name":"🇲 🇦 🇸 🇹 🇪 🇷","can_delete":false,"product_type":"c1","uid":2582944,"ip_address":"","ucode":"B2C543B98862F0","user_header":"https://static001.geekbang.org/account/avatar/00/27/69/a0/d78b0e21.jpg","comment_is_top":false,"comment_ctime":1620994983,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620994983","product_id":100024701,"comment_content":"老师需要每个API都详细学习一下吗? 我搞嵌入式的,嵌入式系统也玩过不少,一些概念都大同小异,所以你说的我都能明白.","like_count":0},{"had_liked":false,"id":290764,"user_name":"喜剧。","can_delete":false,"product_type":"c1","uid":1042681,"ip_address":"","ucode":"5F9CF567792B8A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/f9/4412b473.jpg","comment_is_top":false,"comment_ctime":1619745263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619745263","product_id":100024701,"comment_content":"这里有个疑惑点。主线程通知线程吃线程干活。如果只有一个任务的情况下，一个线程获得执行任务的机会，另外两个也要等待释放锁。这里是不是可以有优化的地方。是不是有一个线程专门负责监听，并把活指定给哪个线程？","like_count":0},{"had_liked":false,"id":288055,"user_name":"S","can_delete":false,"product_type":"c1","uid":2436407,"ip_address":"","ucode":"E88F6A338F34A6","user_header":"https://static001.geekbang.org/account/avatar/00/25/2d/37/f8733b67.jpg","comment_is_top":false,"comment_ctime":1618282711,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1618282711","product_id":100024701,"comment_content":"for(t=1;t&lt;=4;t++)<br>{    <br>\tpthread_mutex_lock(&amp;g_task_lock);    <br>\ttail+=t;    <br>\tprintf(&quot;I am Boss, I assigned %d tasks, I notify all coders!\\n&quot;, t);    <br>\tpthread_cond_broadcast(&amp;g_task_cv);    <br>\tpthread_mutex_unlock(&amp;g_task_lock);    <br>\tsleep(20);  <br>}<br>为什么BOSS分配任务的时候也要加锁呢？也没有其他地方会修改tail的值呀","like_count":0,"discussions":[{"author":{"id":1066409,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","nickname":"Lorry","note":"","ucode":"BD4754D0F1D786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385080,"discussion_content":"这里获取锁是为了确认所有的现成都已经处理完操作了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626871810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283888,"user_name":"kyle","can_delete":false,"product_type":"c1","uid":2420815,"ip_address":"","ucode":"A44D89806EB64C","user_header":"https://static001.geekbang.org/account/avatar/00/24/f0/4f/9652d41d.jpg","comment_is_top":false,"comment_ctime":1615972990,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615972990","product_id":100024701,"comment_content":"老师能不能后面讲讲自旋锁 我还是搞不懂自旋锁和互斥锁的区别 谢谢","like_count":0},{"had_liked":false,"id":280679,"user_name":"__nop( )","can_delete":false,"product_type":"c1","uid":2454087,"ip_address":"","ucode":"8A914603246F2E","user_header":"https://static001.geekbang.org/account/avatar/00/25/72/47/19abb8a5.jpg","comment_is_top":false,"comment_ctime":1614315032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614315032","product_id":100024701,"comment_content":"类似于arm-Linux的条件阻塞","like_count":0},{"had_liked":false,"id":279047,"user_name":"Dovelol","can_delete":false,"product_type":"c1","uid":1253384,"ip_address":"","ucode":"9B5DDF7720F307","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","comment_is_top":false,"comment_ctime":1613567576,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613567576","product_id":100024701,"comment_content":"老是想，想问下java中的synchronized关键字和LockSupport中的park，unpark方法在jvm底层是用什么实现的？是pthread_mutex吗？","like_count":0},{"had_liked":false,"id":275369,"user_name":"sharpblade","can_delete":false,"product_type":"c1","uid":1156299,"ip_address":"","ucode":"170B74D5DEC517","user_header":"https://static001.geekbang.org/account/avatar/00/11/a4/cb/5db54f58.jpg","comment_is_top":false,"comment_ctime":1611493562,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1611493562","product_id":100024701,"comment_content":"最后一个例子，每个coder线程退出前，应该还会打印一行：<br>Have task now! Thread xxxxxxxxxxx is grabing the task !<br>","like_count":0},{"had_liked":false,"id":271165,"user_name":"刘杰","can_delete":false,"product_type":"c1","uid":1150394,"ip_address":"","ucode":"D45873B34FAA90","user_header":"https://static001.geekbang.org/account/avatar/00/11/8d/ba/30f502ed.jpg","comment_is_top":false,"comment_ctime":1609427043,"is_pvip":true,"discussion_count":0,"race_medal":3,"score":"1609427043","product_id":100024701,"comment_content":"linux系统编程可以参考一下，这方面也比较详细，就是比较厚","like_count":0},{"had_liked":false,"id":255491,"user_name":"戴宇","can_delete":false,"product_type":"c1","uid":1185158,"ip_address":"","ucode":"66A56B2D742903","user_header":"https://static001.geekbang.org/account/avatar/00/12/15/86/cd97bf7e.jpg","comment_is_top":false,"comment_ctime":1603357387,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603357387","product_id":100024701,"comment_content":"JVM 里面的synchronized是不是也用pthread_mutex_unlock这种方法实现","like_count":0},{"had_liked":false,"id":238434,"user_name":"笨笨的博克","can_delete":false,"product_type":"c1","uid":1402798,"ip_address":"","ucode":"6ED60202361642","user_header":"https://static001.geekbang.org/account/avatar/00/15/67/ae/fbe82504.jpg","comment_is_top":false,"comment_ctime":1596166020,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596166020","product_id":100024701,"comment_content":"老师,我在做&quot;转帐&quot;实验时没有看到示例的效果,一直是200,求老师指点迷津,谢谢.","like_count":0},{"had_liked":false,"id":231501,"user_name":"做一个积极的跳蚤","can_delete":false,"product_type":"c1","uid":2035956,"ip_address":"","ucode":"BBE367BBCB6C28","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ecruTrMgzvqIs5iaWVibZw4Rxic42ZXGTflvOFHiaZEkf32Su01gDCWT8tdIcEoybg0ibAYU2Q8f9bleL7Q37fKguxQ/132","comment_is_top":false,"comment_ctime":1593688882,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593688882","product_id":100024701,"comment_content":"linux下线程全局变量用__thread int a；更好吧","like_count":0},{"had_liked":false,"id":230050,"user_name":"Eglinux","can_delete":false,"product_type":"c1","uid":1187353,"ip_address":"","ucode":"4AAB9940789442","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/19/17245c59.jpg","comment_is_top":false,"comment_ctime":1593247569,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1593247569","product_id":100024701,"comment_content":"void *coder(void *notused)<br>{<br>  pthread_t tid = pthread_self();<br><br>  while(!quit){<br><br>    pthread_mutex_lock(&amp;g_task_lock);<br>    while(tail == head){<br>      if(quit){<br>        pthread_mutex_unlock(&amp;g_task_lock);<br>        pthread_exit((void *)0);<br>      }<br>      printf(&quot;No task now! Thread %u is waiting!\\n&quot;, (unsigned int)tid);<br>      pthread_cond_wait(&amp;g_task_cv, &amp;g_task_lock);<br>      printf(&quot;Have task now! Thread %u is grabing the task !\\n&quot;, (unsigned int)tid);<br>    }<br>    char task = tasklist[head++];<br>    pthread_mutex_unlock(&amp;g_task_lock);<br>    printf(&quot;Thread %u has a task %c now!\\n&quot;, (unsigned int)tid, task);<br>    sleep(5);<br>    printf(&quot;Thread %u finish the task %c!\\n&quot;, (unsigned int)tid, task);<br>  }<br><br>  pthread_exit((void *)0);<br>}<br><br>head += 1; 没有看见呀，是不是有点问题？","like_count":0,"discussions":[{"author":{"id":1156299,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a4/cb/5db54f58.jpg","nickname":"sharpblade","note":"","ucode":"170B74D5DEC517","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376740,"discussion_content":"char task = tasklist[head++];","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622301015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217097,"user_name":"一零","can_delete":false,"product_type":"c1","uid":1245896,"ip_address":"","ucode":"76228A1CD2CBE8","user_header":"https://static001.geekbang.org/account/avatar/00/13/02/c8/a79b5838.jpg","comment_is_top":false,"comment_ctime":1589420057,"is_pvip":false,"replies":[{"id":"83093","content":"本来就要配合使用的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1591786130,"ip_address":"","comment_id":217097,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589420057","product_id":100024701,"comment_content":"条件变量+互斥锁那段代码，23行先上锁是为了避免惊群效应嘛？还是本来就应该这么用呀？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495037,"discussion_content":"本来就要配合使用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591786130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216999,"user_name":"Geek_04e22a","can_delete":false,"product_type":"c1","uid":1184505,"ip_address":"","ucode":"B64FF12EA28BA6","user_header":"https://static001.geekbang.org/account/avatar/00/12/12/f9/7e6e3ac6.jpg","comment_is_top":false,"comment_ctime":1589383158,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589383158","product_id":100024701,"comment_content":"for (t=0;t&lt;NUM_OF_TASKS;t++)<br>\t{<br>\t\t&#47;&#47;第一次运行去掉下面这行<br>                &#47;&#47;第一块加sleep<br>\t\tpthread_mutex_lock(&amp;g_money_lock);<br>                &#47;&#47;第二块加sleep<br>                printf(&quot;money_of_tom + money_of_jerry = %d\\n&quot;, money_of_tom + money_of_jerry);<br>               &#47;&#47;第一次运行去掉下面这行<br>              &#47;&#47; pthread_mutex_unlock(&amp;g_money_lock);<br>\t}<br><br>老师，第二个例子sleep(1)应该加在哪个位置呢？自己测试了一下，加在第一块等所有的线程跑完了，才会输出总额，加在第二处，先是跑完总额，才会跑线程","like_count":0},{"had_liked":false,"id":211123,"user_name":"モブ","can_delete":false,"product_type":"c1","uid":1645302,"ip_address":"","ucode":"01BE64E20DEF7C","user_header":"https://static001.geekbang.org/account/avatar/00/19/1a/f6/19e67bea.jpg","comment_is_top":false,"comment_ctime":1587897947,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587897947","product_id":100024701,"comment_content":"想问下pthread_cond_wait这个函数内部实现是不是用的MESA管程？","like_count":0},{"had_liked":false,"id":206146,"user_name":"伟伟动听","can_delete":false,"product_type":"c1","uid":1406808,"ip_address":"","ucode":"60596BE972AC63","user_header":"https://static001.geekbang.org/account/avatar/00/15/77/58/8824cd8f.jpg","comment_is_top":false,"comment_ctime":1586793422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586793422","product_id":100024701,"comment_content":"老师，这里的有个函数没有说明，pthread_cond_wait(&amp;g_task_cv, &amp;g_task_lock); 这个函数的操作如下：<br>1，解锁当前的条件变量基于的那个互斥锁。<br>2，让当前线程进入等待状态，等待broadcast函数。<br>3，收到broadcast函数通知后再尝试去锁定互斥锁。<br>这部分和go 语言的 sync.Cond 是差不多流程的。 ","like_count":0},{"had_liked":false,"id":203504,"user_name":"Initiative Thinker","can_delete":false,"product_type":"c1","uid":1736297,"ip_address":"","ucode":"A884396A1581EF","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI9zRdkKuXMKh30ibeludlAsztmR4rD9iaiclPicOfIhbC4fWxGPz7iceb3o4hKx7qgX2dKwogYvT6VQ0g/132","comment_is_top":false,"comment_ctime":1586222807,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586222807","product_id":100024701,"comment_content":"造成结果大于200 的原因，有没有可能是数据CPU处理完后，根据局部性原理没有写回，缓存和主存不一致产生这样的结果？","like_count":0},{"had_liked":false,"id":190387,"user_name":"有米","can_delete":false,"product_type":"c1","uid":1005042,"ip_address":"","ucode":"C9A10B7A67BC12","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","comment_is_top":false,"comment_ctime":1584634859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584634859","product_id":100024701,"comment_content":"该去复习一下线程的生命周期了","like_count":0},{"had_liked":false,"id":177419,"user_name":"起而行","can_delete":false,"product_type":"c1","uid":1131399,"ip_address":"","ucode":"4F116B0B740776","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/87/7604d7a4.jpg","comment_is_top":false,"comment_ctime":1581389970,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581389970","product_id":100024701,"comment_content":"day11，在大学学习操作系统课的时候，没有通过一个有趣的实例来深入理解互斥锁，条件变量。现在终于理解了条件变量，作用是减少由于互斥锁不断检测带来的资源损耗。线程的使用有四步，初始化线程和属性，赋值属性，指定线程进入的函数开始执行，销毁属性和线程。自己编程的时候能够进一步理解隐式的问题，但是缺乏全局的思考，容易陷入代码。课后的导图非常棒，能够总结整体的过程。","like_count":0},{"had_liked":false,"id":175105,"user_name":"天才小飞猫","can_delete":false,"product_type":"c1","uid":1017409,"ip_address":"","ucode":"82BDC9F23CE320","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoaknSzhibWMuhuQRibib9MP0QyOIYMsyPxicpmTQHlHE0icgRUXicOqt6YyIzJQtDCLsStuRyK2bV74tmA/132","comment_is_top":false,"comment_ctime":1580559603,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580559603","product_id":100024701,"comment_content":"刘老师，最后一个例子中只有一个boss，那boss在broadcast任务时可以不加锁么？","like_count":0},{"had_liked":false,"id":173743,"user_name":"shuff1e","can_delete":false,"product_type":"c1","uid":1756280,"ip_address":"","ucode":"85601271951B5A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep075ibtmxMf3eOYlBJ96CE9TEelLUwePaLqp8M75gWHEcM3za0voylA0oe9y3NiaboPB891rypRt7w/132","comment_is_top":false,"comment_ctime":1579676019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579676019","product_id":100024701,"comment_content":"用C写的确还是挺麻烦的。<br>go的标准库里面有这个场景的实现<br>&#47;&#47; Wait atomically unlocks c.L and suspends execution<br>&#47;&#47; of the calling goroutine. After later resuming execution,<br>&#47;&#47; Wait locks c.L before returning. Unlike in other systems,<br>&#47;&#47; Wait cannot return unless awoken by Broadcast or Signal.<br>&#47;&#47;<br>&#47;&#47; Because c.L is not locked when Wait first resumes, the caller<br>&#47;&#47; typically cannot assume that the condition is true when<br>&#47;&#47; Wait returns. Instead, the caller should Wait in a loop:<br>&#47;&#47;<br>&#47;&#47;    c.L.Lock()<br>&#47;&#47;    for !condition() {<br>&#47;&#47;        c.Wait()<br>&#47;&#47;    }<br>&#47;&#47;    ... make use of condition ...<br>&#47;&#47;    c.L.Unlock()<br>&#47;&#47;<br>func (c *Cond) Wait() {<br>\tc.checker.check()<br>\tt := runtime_notifyListAdd(&amp;c.notify)<br>\tc.L.Unlock()<br>\truntime_notifyListWait(&amp;c.notify, t)<br>\tc.L.Lock()<br>}<br><br>&#47;&#47; Signal wakes one goroutine waiting on c, if there is any.<br>&#47;&#47;<br>&#47;&#47; It is allowed but not required for the caller to hold c.L<br>&#47;&#47; during the call.<br>func (c *Cond) Signal() {<br>\tc.checker.check()<br>\truntime_notifyListNotifyOne(&amp;c.notify)<br>}<br><br>&#47;&#47; Broadcast wakes all goroutines waiting on c.<br>&#47;&#47;<br>&#47;&#47; It is allowed but not required for the caller to hold c.L<br>&#47;&#47; during the call.<br>func (c *Cond) Broadcast() {<br>\tc.checker.check()<br>\truntime_notifyListNotifyAll(&amp;c.notify)<br>}","like_count":0},{"had_liked":false,"id":155291,"user_name":"czh","can_delete":false,"product_type":"c1","uid":1159078,"ip_address":"","ucode":"649FE5C9269D69","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/a6/3f15ba2f.jpg","comment_is_top":false,"comment_ctime":1574675203,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574675203","product_id":100024701,"comment_content":"这一节讲了多线程编程的套路，但是我没有对于每一个函数进行详细的讲解。有点感觉像是系统函数手册！","like_count":0},{"had_liked":false,"id":153168,"user_name":"Marshall","can_delete":false,"product_type":"c1","uid":1476507,"ip_address":"","ucode":"0FB004E8163F44","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/9b/8bebc8b6.jpg","comment_is_top":false,"comment_ctime":1574173310,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574173310","product_id":100024701,"comment_content":"老师能说下 用户线程 轻量级进程 内核线程 以及jvm在Linux下生成的线程 。","like_count":0},{"had_liked":false,"id":135734,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1569248551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569248551","product_id":100024701,"comment_content":"再次复习这篇文章，看懂这篇需要知道一件事：线程共享同一地址空间；另外推荐apue，里面的示例代码也很好","like_count":0},{"had_liked":false,"id":134704,"user_name":"石将从","can_delete":false,"product_type":"c1","uid":1375617,"ip_address":"","ucode":"12F43E643D1D58","user_header":"https://static001.geekbang.org/account/avatar/00/14/fd/81/1864f266.jpg","comment_is_top":false,"comment_ctime":1568899344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568899344","product_id":100024701,"comment_content":"这篇很精彩，动手一行一行代码敲上去，理解了锁和条件变量的关系","like_count":0},{"had_liked":false,"id":127236,"user_name":"梦醒十分","can_delete":false,"product_type":"c1","uid":1043585,"ip_address":"","ucode":"33830A5A73DDF8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/81/2127e215.jpg","comment_is_top":false,"comment_ctime":1566617276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566617276","product_id":100024701,"comment_content":"这样写文章就对了!","like_count":0},{"had_liked":false,"id":115660,"user_name":"江山未","can_delete":false,"product_type":"c1","uid":1090196,"ip_address":"","ucode":"5293DD9482717F","user_header":"https://static001.geekbang.org/account/avatar/00/10/a2/94/ae0a60d8.jpg","comment_is_top":false,"comment_ctime":1563687228,"is_pvip":false,"replies":[{"id":"46555","content":"cond本身唤醒的时候，就会去抢锁的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566356792,"ip_address":"","comment_id":115660,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563687228","product_id":100024701,"comment_content":"请问下老师，while (tail == head)以及下面的tasklist[head++]，这两句执行起来是原子的吗。感觉如果同时唤醒多个线程，可能会有不止一个线程通过这个条件判断啊。<br>还是说唤醒的同时，还要先去抢一下锁才能执行？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459213,"discussion_content":"cond本身唤醒的时候，就会去抢锁的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566356792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112594,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1562768051,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562768051","product_id":100024701,"comment_content":"第三个cond.c 的例子运行起来没问题,补充pthread_cond_wait说明如下:<br>DESCRIPTION<br>The pthread_cond_wait() function blocks on the specified condition variable, which atomically releases the specified mutex and causes the calling thread to block on the condition variable The blocked thread may be awakened by a call to pthread_cond_signal() or pthread_cond_broadcast().<br><br>This function atomically releases the mutex, causing the calling thread to block on the condition variable Upon successful completion, the mutex is locked and owned by the calling thread.","like_count":0},{"had_liked":false,"id":112221,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1562686509,"is_pvip":false,"replies":[{"id":"46724","content":"多线程结果难以预估。看这个结果，还是保持一致了","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566386749,"ip_address":"","comment_id":112221,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562686509","product_id":100024701,"comment_content":"虽然理解mutex, 但是第二个例子去掉注释后,在我的机器上跑的结果和预期不一致<br><br> ~&#47;View&#47;os&#47;test&#47;thread  .&#47;mutex                       <br>Thread 3880032000 is transfering money!<br>Thread 3888424704 is transfering money!<br>Thread 3871639296 is transfering money!<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>money_of_tom + money_of_jerry = 200<br>Thread 3863246592 is transfering money!<br>Thread 3854853888 is transfering money!<br>Thread 3863246592 finish transfering money!<br>Thread 3880032000 finish transfering money!<br>Thread 3871639296 finish transfering money!<br>Thread 3854853888 finish transfering money!<br>Thread 3888424704 finish transfering money!<br> ~&#47;View&#47;os&#47;test&#47;thread  <br>","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457625,"discussion_content":"多线程结果难以预估。看这个结果，还是保持一致了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566386749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112205,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1562683851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562683851","product_id":100024701,"comment_content":"居然有字数限制, 而且极客时间这个回复栏做的也不是很友好<br><br>接上条...<br><br>我把主线程的download 改成了 download[NUM_OF_THREAD], 得到的结果如下:<br> ~&#47;View&#47;os&#47;test&#47;thread  .&#47;a.out                  <br>creating thread 0, please help me to download file1.avi<br>creating thread 1, please help me to download file2.rmvb<br>creating thread 2, please help me to download file3.mp4<br>I am downloading the file file2.rmvb!<br>I am downloading the file file1.avi!<br>I am downloading the file file3.mp4!<br>creating thread 3, please help me to download file4.wmv<br>creating thread 4, please help me to download file5.flv<br>I am downloading the file file5.flv!<br>I am downloading the file file4.wmv!<br>I finish downloading the file within 83 minutes!<br>I finish downloading the file within 77 minutes!<br>I finish downloading the file within 86 minutes!<br>I finish downloading the file within 15 minutes!<br>I finish downloading the file within 93 minutes!<br>Thread 0 downloads the file file1.avi in 86 minutes.<br>Thread 1 downloads the file file2.rmvb in 83 minutes.<br>Thread 2 downloads the file file3.mp4 in 77 minutes.<br>Thread 3 downloads the file file4.wmv in 93 minutes.<br>Thread 4 downloads the file file5.flv in 15 minutes.<br> ~&#47;View&#47;os&#47;test&#47;thread  <br>","like_count":0},{"had_liked":false,"id":112204,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1562683797,"is_pvip":false,"replies":[{"id":"46726","content":"感觉你分析的还是有问题的。我的pthread_join是依次运行的呀。就算是thread2先exit的，如果thread 1没有exit，主线程会一直等着他的，直到thread1 exit之后，再获取，获取后马上就打印出来了呀。thread2就算是早exit，exit的变量保存在内核里面，不join是不会丢失的，等到thread1 join完了，join thread2的时候，才把thread 2的exit变量拿出来，也是马上就打印出来了。","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566387146,"ip_address":"","comment_id":112204,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562683797","product_id":100024701,"comment_content":"第一段代码有些问题: 看起来像是因为五个线程公用一个download变量,当线程1,phtread_exit后, phtread_join还会继续获取线程1的状态, 当线程2,exit了,线程1的download被刷新了, 主线程获取了新的线程1, 和线程2的状态...<br><br>按你的例子,在我电脑上面运行结果如下:<br> ~&#47;View&#47;os&#47;test&#47;thread  .&#47;a.out        <br> ~&#47;View&#47;os&#47;test&#47;thread  .&#47;a.out | grep &#39;Thread 0&#39;<br>Thread 0 downloads the file file1.avi in 86 minutes.<br>Thread 0 downloads the file file1.avi in 93 minutes.<br>Thread 0 downloads the file file1.avi in 83 minutes.<br>Thread 0 downloads the file file1.avi in 15 minutes.<br>Thread 0 downloads the file file1.avi in 77 minutes.<br> ~&#47;View&#47;os&#47;test&#47;thread  .&#47;a.out | grep &#39;Thread 1&#39;<br>Thread 1 downloads the file file2.rmvb in 83 minutes.<br>Thread 1 downloads the file file2.rmvb in 86 minutes.<br>Thread 1 downloads the file file2.rmvb in 15 minutes.<br>Thread 1 downloads the file file2.rmvb in 93 minutes.<br> ~&#47;View&#47;os&#47;test&#47;thread  .&#47;a.out | grep &#39;Thread 2&#39;<br>Thread 2 downloads the file file3.mp4 in 93 minutes.<br>Thread 2 downloads the file file3.mp4 in 83 minutes.<br>Thread 2 downloads the file file3.mp4 in 77 minutes.<br> ~&#47;View&#47;os&#47;test&#47;thread  .&#47;a.out | grep &#39;Thread 3&#39;<br>Thread 3 downloads the file file4.wmv in 15 minutes.<br>Thread 3 downloads the file file4.wmv in 77 minutes.<br> ~&#47;View&#47;os&#47;test&#47;thread  .&#47;a.out | grep &#39;Thread 4&#39;<br>Thread 4 downloads the file file5.flv in 93 minutes.<br> ~&#47;View&#47;os&#47;test&#47;thread  <br>","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457618,"discussion_content":"感觉你分析的还是有问题的。我的pthread_join是依次运行的呀。就算是thread2先exit的，如果thread 1没有exit，主线程会一直等着他的，直到thread1 exit之后，再获取，获取后马上就打印出来了呀。thread2就算是早exit，exit的变量保存在内核里面，不join是不会丢失的，等到thread1 join完了，join thread2的时候，才把thread 2的exit变量拿出来，也是马上就打印出来了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566387146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107438,"user_name":"没心没肺","can_delete":false,"product_type":"c1","uid":1258867,"ip_address":"","ucode":"121FD3AEBA3BEA","user_header":"https://static001.geekbang.org/account/avatar/00/13/35/73/46d6dadc.jpg","comment_is_top":false,"comment_ctime":1561536259,"is_pvip":false,"replies":[{"id":"48866","content":"是的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567501886,"ip_address":"","comment_id":107438,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561536259","product_id":100024701,"comment_content":"pthread_cond_wait在等待的同时还会释放锁，这才给了主线程分派任务的机会。","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455511,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567501886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103561,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1560473566,"is_pvip":false,"replies":[{"id":"49052","content":"为了构建一个特殊的场景","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567584838,"ip_address":"","comment_id":103561,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560473566","product_id":100024701,"comment_content":"为什么多线程都需要加一个sleep(10);","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453921,"discussion_content":"为了构建一个特殊的场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567584838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102315,"user_name":"Sudazzle","can_delete":false,"product_type":"c1","uid":1559482,"ip_address":"","ucode":"8C5D9381ED1157","user_header":"https://static001.geekbang.org/account/avatar/00/17/cb/ba/a178f2d8.jpg","comment_is_top":false,"comment_ctime":1560190866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560190866","product_id":100024701,"comment_content":"creating thread 0, please help me to download file1.avi<br>creating thread 1, please help me to download file2.rmvb<br>creating thread 2, please help me to download file3.mp4<br>I am downloading the file file1.avi!<br>I am downloading the file file2.rmvb!<br>creating thread 3, please help me to download file4.wmv<br>I am downloading the file file3.mp4!<br>creating thread 4, please help me to download file5.flv<br>I am downloading the file file4.wmv!<br>I am downloading the file file5.flv!<br>I finish downloading the file within 7 minutes!<br>I finish downloading the file within 49 minutes!<br>I finish downloading the file within 73 minutes!<br>I finish downloading the file within 58 minutes!<br>I finish downloading the file within 30 minutes!<br>Thread 0 downloads the file file1.avi in 49 minutes.<br>Thread 0 downloads the file file1.avi in 7 minutes.<br>Thread 1 downloads the file file2.rmvb in 7 minutes.<br>Thread 0 downloads the file file1.avi in 73 minutes.<br>Thread 1 downloads the file file2.rmvb in 73 minutes.<br>Thread 2 downloads the file file3.mp4 in 73 minutes.<br>Thread 0 downloads the file file1.avi in 58 minutes.<br>Thread 1 downloads the file file2.rmvb in 58 minutes.<br>Thread 2 downloads the file file3.mp4 in 58 minutes.<br>Thread 3 downloads the file file4.wmv in 58 minutes.<br>Thread 0 downloads the file file1.avi in 30 minutes.<br>Thread 1 downloads the file file2.rmvb in 30 minutes.<br>Thread 2 downloads the file file3.mp4 in 30 minutes.<br>Thread 3 downloads the file file4.wmv in 30 minutes.<br>Thread 4 downloads the file file5.flv in 30 minutes.<br><br>出现一个线程终止后主线程打印出多行的原因是什么？","like_count":0},{"had_liked":false,"id":99303,"user_name":"冯二 傻子","can_delete":false,"product_type":"c1","uid":1487027,"ip_address":"","ucode":"A7476A2E6458E5","user_header":"https://static001.geekbang.org/account/avatar/00/16/b0/b3/bc2c54af.jpg","comment_is_top":false,"comment_ctime":1559189015,"is_pvip":false,"replies":[{"id":"49232","content":"没有，因为四个任务是紧接着下放的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567604896,"ip_address":"","comment_id":99303,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559189015","product_id":100024701,"comment_content":"最后一个例子的打印信息在69行之前是不是少了员工一的一个获得任务的信息<br>Have task now! Thread 3491833600 is grabing the task !<br><br>","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452054,"discussion_content":"没有，因为四个任务是紧接着下放的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567604896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98830,"user_name":"王聪 Claire","can_delete":false,"product_type":"c1","uid":1090310,"ip_address":"","ucode":"0D9CC82C9F44D4","user_header":"https://static001.geekbang.org/account/avatar/00/10/a3/06/9fa93074.jpg","comment_is_top":false,"comment_ctime":1559101758,"is_pvip":false,"replies":[{"id":"49246","content":"加锁不代表获得锁，只有一个获得锁，其他的等着。","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567605674,"ip_address":"","comment_id":98830,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1559101758","product_id":100024701,"comment_content":"最后一个例子中，每个线程都会先通过pthread_mutex_lock()进行加锁，想问一下锁不是互斥资源吗？3个线程可以依次在没有释放锁的情况下加锁，然后一起等待boss分配任务？不是很理解。谢谢。","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451856,"discussion_content":"加锁不代表获得锁，只有一个获得锁，其他的等着。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567605674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008945,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/65/31/c1b7e8ca.jpg","nickname":"Xtao","note":"","ucode":"FBE9B1D144DEA2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":136832,"discussion_content":"明白了，pthread_cond_wait在等待的同时还会释放锁，这才给了主线程分派任务的机会。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579166870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008945,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/65/31/c1b7e8ca.jpg","nickname":"Xtao","note":"","ucode":"FBE9B1D144DEA2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":136822,"discussion_content":"同样的疑问，如果没获得锁的等着，那不应该打印出这样的结果：\n[root@deployer createthread]# ./a.out\n//招聘三个员工，一开始没有任务，大家睡大觉\nNo task now! Thread 3491833600 is waiting!\nNo task now! Thread 3483440896 is waiting!\nNo task now! Thread 3475048192 is waiting!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579166226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98814,"user_name":"王聪 Claire","can_delete":false,"product_type":"c1","uid":1090310,"ip_address":"","ucode":"0D9CC82C9F44D4","user_header":"https://static001.geekbang.org/account/avatar/00/10/a3/06/9fa93074.jpg","comment_is_top":false,"comment_ctime":1559099558,"is_pvip":false,"replies":[{"id":"49247","content":"加上sleep就能看到效果了。试试看","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567605737,"ip_address":"","comment_id":98814,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559099558","product_id":100024701,"comment_content":"tom jerry转钱的例子，不加mutex时，我测试的所有结果也是200.观察输出发现，主线程的和输出早于子线程的输出，是因为主线程没有wait子线程的结束就执行了for(t=0;t&lt;100;t++)循环中的输出money_of_tom + money_of_jerry和的结果的操作，该循环在所有子线程转账行为之前执行结束了，是因为这样吗？谢谢。","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451851,"discussion_content":"加上sleep就能看到效果了。试试看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567605737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90223,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1556451894,"is_pvip":false,"replies":[{"id":"49523","content":"不是的，是这个变量的key","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567680166,"ip_address":"","comment_id":90223,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556451894","product_id":100024701,"comment_content":"老师请问一下, int pthread_key_create(pthread_key_t *key, void (*destructor)(void*)) 在这个方法中的第一个参数pthread_key_t *key 这个*key是什么是线程的p_id吗? 还有这个传进去的析构函数起到什么什么是销毁这个  pthread_key_reate时执行吗?<br><br>","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448427,"discussion_content":"不是的，是这个变量的key","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567680166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90093,"user_name":"不一样的烟火","can_delete":false,"product_type":"c1","uid":1473251,"ip_address":"","ucode":"6E305F0EE90E8B","user_header":"https://static001.geekbang.org/account/avatar/00/16/7a/e3/145adba9.jpg","comment_is_top":false,"comment_ctime":1556413304,"is_pvip":false,"replies":[{"id":"49550","content":"是的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567688139,"ip_address":"","comment_id":90093,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1556413304","product_id":100024701,"comment_content":"第一个mutex例子中貌似打印for循环里面少了sleep语句，会一直打印完成，子线程还没来得及改变共享数据","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448387,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567688139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003594,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","nickname":"kdb_reboot","note":"","ucode":"4C56FCA563FCA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1570,"discussion_content":"确实,加了sleep之后,会出现错误的值, 如果不加, 就算把for的次数调大, 也不会出现...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562689913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90055,"user_name":"Arya","can_delete":false,"product_type":"c1","uid":1490181,"ip_address":"","ucode":"48FE06A3819A54","user_header":"https://static001.geekbang.org/account/avatar/00/16/bd/05/c8087b35.jpg","comment_is_top":false,"comment_ctime":1556380568,"is_pvip":false,"replies":[{"id":"49553","content":"应该加个sleep才行","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567688256,"ip_address":"","comment_id":90055,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1556380568","product_id":100024701,"comment_content":"老师我注释掉mutex的时候，运行多次，始终不报错。。是什么原因呀","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448371,"discussion_content":"应该加个sleep才行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567688256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003594,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","nickname":"kdb_reboot","note":"","ucode":"4C56FCA563FCA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1567,"discussion_content":"和你遇到了同样的问题,一直是200","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562687947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89793,"user_name":"Frankenstein","can_delete":false,"product_type":"c1","uid":1499290,"ip_address":"","ucode":"B81CFF9BB45AF9","user_header":"https://static001.geekbang.org/account/avatar/00/16/e0/9a/9540c04a.jpg","comment_is_top":false,"comment_ctime":1556266225,"is_pvip":false,"replies":[{"id":"49557","content":"应该是随机的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567688331,"ip_address":"","comment_id":89793,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556266225","product_id":100024701,"comment_content":"有谁知道为什么我第一段代码 downloadtime 都是 33 吗，不应该是随机的吗？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448262,"discussion_content":"应该是随机的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567688331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89718,"user_name":"Frankenstein","can_delete":false,"product_type":"c1","uid":1499290,"ip_address":"","ucode":"B81CFF9BB45AF9","user_header":"https://static001.geekbang.org/account/avatar/00/16/e0/9a/9540c04a.jpg","comment_is_top":false,"comment_ctime":1556249339,"is_pvip":false,"replies":[{"id":"49563","content":"弄个putty登录到一台linux上","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567688429,"ip_address":"","comment_id":89718,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556249339","product_id":100024701,"comment_content":"在PC端，怎么复制文中的代码运行？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448233,"discussion_content":"弄个putty登录到一台linux上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567688429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89482,"user_name":"尚墨","can_delete":false,"product_type":"c1","uid":1300116,"ip_address":"","ucode":"114EE139168CB9","user_header":"http://thirdwx.qlogo.cn/mmopen/uqaRIfRCAhJ6t1z92XYEzXpqpgpS1veBc5DNGhfRHFsHgE19qHqG0cevcIJRRsjIKxsSEcIPVP1nOkaVKLibb2xFq04A4KMY3/132","comment_is_top":false,"comment_ctime":1556182962,"is_pvip":false,"replies":[{"id":"32011","content":"做爬虫，还是python比较方便，也可以试下map-reduce<br>","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1556193932,"ip_address":"","comment_id":89482,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556182962","product_id":100024701,"comment_content":"我曾经用 Python 多线程实现了一个 多线程下载任务的脚本。Python 的实现虽然没有 C 那么详尽，但是对于 多线程理解 也很有帮助。<br>https:&#47;&#47;github.com&#47;sober-wang&#47;OpScript&#47;blob&#47;master&#47;request-sort-download&#47;up-download.py","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448149,"discussion_content":"做爬虫，还是python比较方便，也可以试下map-reduce\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556193932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88297,"user_name":"Virtue","can_delete":false,"product_type":"c1","uid":1441187,"ip_address":"","ucode":"67B2D1AD06D714","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKbwJ55niaS6Df8BjvKK2ug2jFibCYhicz1lx7GDYOGs9MMgbHJmWoH1DXZAR5TKsESyUz1zsaw4Flew/132","comment_is_top":false,"comment_ctime":1555902369,"is_pvip":false,"replies":[{"id":"49572","content":"对的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567688870,"ip_address":"","comment_id":88297,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555902369","product_id":100024701,"comment_content":"mutex的例子，开始不理解为什么主线程打印的时候也需要加锁。后来细想了下，有这样的可能：线程0，执行完transfer函数后，存款变成了110和90，要执行print函数打印二者之和的时候，线程1可能刚好执行完+10的操作，导致二者之和变成了210，这时候线程0刚好打印，结果就是210。结果也只可能是210，因为线程1拿到了锁，其他线程无法访问共享变量。","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447781,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567688870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88139,"user_name":"tux","can_delete":false,"product_type":"c1","uid":1477811,"ip_address":"","ucode":"BB7202009FC885","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/b3/a74a7125.jpg","comment_is_top":false,"comment_ctime":1555857840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555857840","product_id":100024701,"comment_content":"复习完此篇，再复习前面的，有新感觉🐧","like_count":0},{"had_liked":false,"id":88028,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1555818126,"is_pvip":true,"replies":[{"id":"32063","content":"不共享资源，尤其是内存空间，比如定义了一个全局变量a，同一个进程的线程能访问，另一个进程就访问不了","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1556198197,"ip_address":"","comment_id":88028,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1555818126","product_id":100024701,"comment_content":"老师，请叫个问题的，子进程 和线程有什么的本质的区别呢？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447688,"discussion_content":"不共享资源，尤其是内存空间，比如定义了一个全局变量a，同一个进程的线程能访问，另一个进程就访问不了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556198197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88021,"user_name":"不一样的烟火","can_delete":false,"product_type":"c1","uid":1473251,"ip_address":"","ucode":"6E305F0EE90E8B","user_header":"https://static001.geekbang.org/account/avatar/00/16/7a/e3/145adba9.jpg","comment_is_top":false,"comment_ctime":1555816017,"is_pvip":false,"replies":[{"id":"32066","content":"是的，本来都是砖头厚的书，语音很难短时间全讲清楚","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1556198310,"ip_address":"","comment_id":88021,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555816017","product_id":100024701,"comment_content":"语音只有二十分钟 但是我这个6年经验的老码农觉得需要六十分钟的课外学习和实践才能掌握","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447683,"discussion_content":"是的，本来都是砖头厚的书，语音很难短时间全讲清楚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556198310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88013,"user_name":"张飞online","can_delete":false,"product_type":"c1","uid":1249136,"ip_address":"","ucode":"C9787E4B35888C","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","comment_is_top":false,"comment_ctime":1555812536,"is_pvip":false,"replies":[{"id":"32067","content":"赞","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1556198320,"ip_address":"","comment_id":88013,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555812536","product_id":100024701,"comment_content":"对于互斥锁的用法，只需要注意两个点，<br>1.理解你业务整体，明确哪里加锁是锁住了语意整体。<br>2.减小锁粒度<br><br>对于条件变量，你要明确 ，条件变量是有”丢”的可能，而且在linux系统是一定有的，那就是没有wait的时候发信号。<br><br>3.麻烦老师讲讲内核的同步互斥，以及内核线程，以及调度，优先级等","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447679,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556198320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88008,"user_name":"change","can_delete":false,"product_type":"c1","uid":1455068,"ip_address":"","ucode":"616071E26C861A","user_header":"https://static001.geekbang.org/account/avatar/00/16/33/dc/5197a6b2.jpg","comment_is_top":false,"comment_ctime":1555810035,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555810035","product_id":100024701,"comment_content":"请问Mac下用啥工具来玩，本身是做iOSK开发的","like_count":0},{"had_liked":false,"id":87982,"user_name":"༺程༻","can_delete":false,"product_type":"c1","uid":1442199,"ip_address":"","ucode":"05B0370E629E60","user_header":"https://static001.geekbang.org/account/avatar/00/16/01/97/16badf02.jpg","comment_is_top":false,"comment_ctime":1555778794,"is_pvip":false,"replies":[{"id":"32068","content":"少了一个E","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1556198348,"ip_address":"","comment_id":87982,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555778794","product_id":100024701,"comment_content":"download.c:26:45: note: each undeclared identifier is reported only once for each function it appears in<br>[root@49df549388ab linux]# gcc download.c -lpthread<br>download.c: In function &#39;main&#39;:<br>download.c:26:45: error: &#39;PTHREAD_CREATE_JOINABL&#39; undeclared (first use in this function)<br>    pthread_attr_setdetachstate(&amp;thread_attr,PTHREAD_CREATE_JOINABL);<br>                                             ^<br>download.c:26:45: note: each undeclared identifier is reported only once for each function it appears in<br><br><br>我查了【PTHREAD_CREATE_JOINABL】是一个线程属性常量，没定义怎么办。这个应该实在头文件里就该有的吧。<br>【放不方便建个微信或者QQ群，方便群友交流】","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447673,"discussion_content":"少了一个E","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556198348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87931,"user_name":"tiankonghewo","can_delete":false,"product_type":"c1","uid":1476427,"ip_address":"","ucode":"7A55A9C17DD9DF","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/4b/16ea3997.jpg","comment_is_top":false,"comment_ctime":1555757471,"is_pvip":false,"replies":[{"id":"49577","content":"PTHREAD_CREATE_JOINABLE","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567689815,"ip_address":"","comment_id":87931,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1555757471","product_id":100024701,"comment_content":"gcc download.c -lpthread<br>执行报错<br><br>download.c:26:45: error: ‘PTHREAD_CREATE_JOINABL’ undeclared (first use in this function)<br><br>centOS7.6系统,华为云服务器","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447653,"discussion_content":"PTHREAD_CREATE_JOINABLE","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567689815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003594,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","nickname":"kdb_reboot","note":"","ucode":"4C56FCA563FCA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1564,"discussion_content":"前面说的很明白了,这东西在pthread.so里面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562687711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87663,"user_name":"积微致知","can_delete":false,"product_type":"c1","uid":1476670,"ip_address":"","ucode":"34EDEAB1112122","user_header":"https://static001.geekbang.org/account/avatar/00/16/88/3e/dd4fa2b6.jpg","comment_is_top":false,"comment_ctime":1555654695,"is_pvip":false,"replies":[{"id":"31538","content":"是的，锁被传进去了，自动解锁","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1555667487,"ip_address":"","comment_id":87663,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555654695","product_id":100024701,"comment_content":"1、线程执行pthread_cond_wait，进入等待队列之前，是不是需要解锁它之前锁住的mutex？<br>2、pthread_cond_broadcast这一步上有没有解锁mutex的操作？<br>3、线程从等待队列里面出来，进入到执行队列的时候（pthread_cond_wait的下一步），加锁mutex的动作是在哪里完成的？<br>","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447555,"discussion_content":"是的，锁被传进去了，自动解锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555667487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87609,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1555640796,"is_pvip":false,"replies":[{"id":"31539","content":"不是，硬件的线程和软件不是一回事","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1555667552,"ip_address":"","comment_id":87609,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1555640796","product_id":100024701,"comment_content":"老师我想问个问题 处理器 4核8线程 这个8是指的内核级线程的数量么 ","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447531,"discussion_content":"不是，硬件的线程和软件不是一回事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555667552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003594,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","nickname":"kdb_reboot","note":"","ucode":"4C56FCA563FCA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1566,"discussion_content":"硬件概念, google: 超线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562687862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87588,"user_name":"dancer","can_delete":false,"product_type":"c1","uid":1019036,"ip_address":"","ucode":"B8D5641A3AC490","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/9c/d48473ab.jpg","comment_is_top":false,"comment_ctime":1555638637,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555638637","product_id":100024701,"comment_content":"day11打卡","like_count":0}]}