{"id":4121,"title":"47 | 弹力设计篇之“重试设计”","content":"<p>你好，我是陈皓，网名左耳朵耗子。</p><p>关于重试，这个模式应该是一个很普遍的设计模式了。当我们把单体应用服务化，尤其是微服务化，本来在一个进程内的函数调用就成了远程调用，这样就会涉及到网络上的问题。</p><p>网络上有很多的各式各样的组件，如DNS服务、网卡、交换机、路由器、负载均衡等设备，这些设备都不一定是稳定的。在数据传输的整个过程中，只要任何一个环节出了问题，最后都会影响系统的稳定性。</p><h1>重试的场景</h1><p>所以，我们需要一个重试的机制。但是，我们需要明白的是，<strong>“重试”的语义是我们认为这个故障是暂时的，而不是永久的，所以，我们会去重试</strong>。</p><p>我认为，设计重试时，我们需要定义出什么情况下需要重试，例如，调用超时、被调用端返回了某种可以重试的错误（如繁忙中、流控中、维护中、资源不足等）。</p><p>而对于一些别的错误，则最好不要重试，比如：业务级的错误（如没有权限、或是非法数据等错误），技术上的错误（如：HTTP的503等，这种原因可能是触发了代码的bug，重试下去没有意义）。</p><h1>重试的策略</h1><p>关于重试的设计，一般来说，都需要有个重试的最大值，经过一段时间不断的重试后，就没有必要再重试了，应该报故障了。在重试过程中，每一次重试失败时都应该休息一会儿再重试，这样可以避免因为重试过快而导致网络上的负担加重。</p><!-- [[[read_end]]] --><p>在重试的设计中，我们一般都会引入，Exponential Backoff的策略，也就是所谓的“指数级退避”。在这种情况下，每一次重试所需要的休息时间都会成倍增加。这种机制主要是用来让被调用方能够有更多的时间来从容处理我们的请求。这其实和TCP的拥塞控制有点像。</p><p>如果我们写成代码应该是下面这个样子。</p><p>首先，我们定义一个调用返回的枚举类型，其中包括了5种返回错误——成功SUCCESS、维护中NOT_READY、流控中TOO_BUSY、没有资源NO_RESOURCE、系统错误SERVER_ERROR。</p><pre><code>public enum Results {\n    SUCCESS, \n    NOT_READY, \n    TOO_BUSY,\n    NO_RESOURCE,\n    SERVER_ERROR\n}\n\n</code></pre><p>接下来，我们定义一个Exponential Backoff的函数，其返回2的指数。这样，每多一次重试就需要多等一段时间。如：第一次等200ms，第二次要400ms，第三次要等800ms……</p><pre><code>public static long getWaitTimeExp(int retryCount) {\n    long waitTime = ((long) Math.pow(2, retryCount) );\n    return waitTime;\n}\n</code></pre><p>下面是真正的重试逻辑。我们可以看到，在成功的情况下，以及不属于我们定义的错误下，我们是不需要重试的，而两次重试间需要等的时间是以指数上升的。</p><pre><code>public static void doOperationAndWaitForResult() {\n    \n    // Do some asynchronous operation.\nlong token = asyncOperation();\n\n    int retries = 0;\n    boolean retry = false;\n\n    do {\n        // Get the result of the asynchronous operation.\n        Results result = getAsyncOperationResult(token);\n\n        if (Results.SUCCESS == result) {\n            retry = false;\n        } else if ( (Results.NOT_READY == result) ||\n                      (Results.TOO_BUSY == result) ||\n                      (Results.NO_RESOURCE == result) ||\n                      (Results.SERVER_ERROR == result) ) {\n            retry = true;\n        } else {\n            retry = false;\n        }\n        if (retry) {\n            long waitTime = Math.min(getWaitTimeExp(retries), MAX_WAIT_INTERVAL);\n            // Wait for the next Retry.\n            Thread.sleep(waitTime);\n        }\n    } while (retry &amp;&amp; (retries++ &lt; MAX_RETRIES));\n}\n\n</code></pre><p>上面的代码是非常基本的重试代码，没有什么新鲜的，我们来看看Spring中所支持的一些重试策略。</p><h1>Spring的重试策略</h1><p><a href=\"https://github.com/spring-projects/spring-retry\">Spring Retry</a> 是一个单独实现重试功能的项目，我们可以通过Annotation的方式使用。具体如下。</p><pre><code>@Service\npublic interface MyService {\n    @Retryable(\n      value = { SQLException.class }, \n      maxAttempts = 2,\n      backoff = @Backoff(delay = 5000))\n    void retryService(String sql) throws SQLException;\n    ...\n}\n</code></pre><p>配置 @Retryable 注解，只对 SQLException 的异常进行重试，重试两次，每次延时5000ms。相关的细节可以看相应的文档。我在这里，只想让你看一下Spring有哪些重试的策略。</p><ul>\n<li>\n<p>NeverRetryPolicy：只允许调用RetryCallback一次，不允许重试。</p>\n</li>\n<li>\n<p>AlwaysRetryPolicy：允许无限重试，直到成功，此方式逻辑不当会导致死循环。</p>\n</li>\n<li>\n<p>SimpleRetryPolicy：固定次数重试策略，默认重试最大次数为3次，RetryTemplate默认使用的策略。</p>\n</li>\n<li>\n<p>TimeoutRetryPolicy：超时时间重试策略，默认超时时间为1秒，在指定的超时时间内允许重试。</p>\n</li>\n<li>\n<p>CircuitBreakerRetryPolicy：有熔断功能的重试策略，需设置3个参数openTimeout、resetTimeout和delegate；关于熔断，会在后面描述。</p>\n</li>\n<li>\n<p>CompositeRetryPolicy：组合重试策略。有两种组合方式，乐观组合重试策略是指只要有一个策略允许重试即可以，悲观组合重试策略是指只要有一个策略不允许重试即不可以。但不管哪种组合方式，组合中的每一个策略都会执行。</p>\n</li>\n</ul><p>关于Backoff的策略如下。</p><ul>\n<li>\n<p>NoBackOffPolicy：无退避算法策略，即当重试时是立即重试；</p>\n</li>\n<li>\n<p>FixedBackOffPolicy：固定时间的退避策略，需设置参数sleeper和backOffPeriod，sleeper指定等待策略，默认是Thread.sleep，即线程休眠，backOffPeriod指定休眠时间，默认1秒。</p>\n</li>\n<li>\n<p>UniformRandomBackOffPolicy：随机时间退避策略，需设置sleeper、minBackOffPeriod和maxBackOffPeriod。该策略在[minBackOffPeriod, maxBackOffPeriod]之间取一个随机休眠时间，minBackOffPeriod默认为500毫秒，maxBackOffPeriod默认为1500毫秒。</p>\n</li>\n<li>\n<p>ExponentialBackOffPolicy：指数退避策略，需设置参数sleeper、initialInterval、maxInterval和multiplier。initialInterval指定初始休眠时间，默认为100毫秒。maxInterval指定最大休眠时间，默认为30秒。multiplier指定乘数，即下一次休眠时间为当前休眠时间*multiplier。</p>\n</li>\n<li>\n<p>ExponentialRandomBackOffPolicy：随机指数退避策略，引入随机乘数，之前说过固定乘数可能会引起很多服务同时重试导致DDos，使用随机休眠时间来避免这种情况。</p>\n</li>\n</ul><h1>重试设计的重点</h1><p>重试的设计重点主要如下：</p><ul>\n<li>\n<p>要确定什么样的错误下需要重试；</p>\n</li>\n<li>\n<p>重试的时间和重试的次数。这种在不同的情况下要有不同的考量。有时候，面对一些不是很重要的问题时，我们应该更快失败而不是重试一段时间若干次。比如一个前端的交互需要用到后端的服务。这种情况下，在面对错误的时候，应该快速失败报错（比如：网络错误请重试）。而面对其它的一些错误，比如流控，那么应该使用指数退避的方式，以避免造成更多的流量。</p>\n</li>\n<li>\n<p>如果超过重试次数，或是一段时间，那么重试就没有意义了。这个时候，说明这个错误不是一个短暂的错误，那么我们对于新来的请求，就没有必要再进行重试了，这个时候对新的请求直接返回错误就好了。但是，这样一来，如果后端恢复了，我们怎么知道呢，此时需要使用我们的熔断设计了。这个在后面会说。</p>\n</li>\n<li>\n<p>重试还需要考虑被调用方是否有幂等的设计。如果没有，那么重试是不安全的，可能会导致一个相同的操作被执行多次。</p>\n</li>\n<li>\n<p>重试的代码比较简单也比较通用，完全可以不用侵入到业务代码中。这里有两个模式。一个是代码级的，像Java那样可以使用Annotation的方式（在Spring中你可以用到这样的注解），如果没有注解也可以包装在底层库或是SDK库中不需要让上层业务感知到。另外一种是走Service Mesh的方式（关于Service Mesh的方式，我会在后面的文章中介绍）。</p>\n</li>\n<li>\n<p>对于有事务相关的操作。我们可能会希望能重试成功，而不至于走业务补偿那样的复杂的回退流程。对此，我们可能需要一个比较长的时间来做重试，但是我们需要保存请求的上下文，这可能对程序的运行有比较大的开销，因此，有一些设计会先把这样的上下文暂存在本机或是数据库中，然后腾出资源来做别的事，过一会再回来把之前的请求从存储中捞出来重试。</p>\n</li>\n</ul><h1>小结</h1><p>好了，我们来总结一下今天分享的主要内容。首先，我讲了重试的场景，比如流控，但并不是所有的失败场景都适合重试。接着我讲了重试的策略，包括简单的指数退避策略，和Spring实现的多种策略。</p><p>这些策略可以用Java的Annotation来实现，或者用Service Mesh的方式，从而不必写在业务逻辑里。最后，我总结了重试设计的重点。下节课，我们讲述熔断设计。希望对你有帮助。</p><p>也欢迎你分享一下你实现过哪些场景下的重试？所采用的策略是什么？实现的过程中遇到过哪些坑？</p><p>文末给出了《分布式系统设计模式》系列文章的目录，希望你能在这个列表里找到自己感兴趣的内容。</p><ul>\n<li>弹力设计篇\n<ul>\n<li><a href=\"https://time.geekbang.org/column/article/3912\">认识故障和弹力设计</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/3917\">隔离设计Bulkheads</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/3926\">异步通讯设计Asynchronous</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4050\">幂等性设计Idempotency</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4086\">服务的状态State</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4087\">补偿事务Compensating Transaction</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4121\">重试设计Retry</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4241\">熔断设计Circuit Breaker</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4245\">限流设计Throttle</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4252\">降级设计degradation</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4253\">弹力设计总结</a></li>\n</ul>\n</li>\n<li>管理设计篇\n<ul>\n<li><a href=\"https://time.geekbang.org/column/article/5175\">分布式锁Distributed Lock</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/5819\">配置中心Configuration Management</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/5909\">边车模式Sidecar</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/5920\">服务网格Service Mesh</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/6086\">网关模式Gateway</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/6283\">部署升级策略</a></li>\n</ul>\n</li>\n<li>性能设计篇\n<ul>\n<li><a href=\"https://time.geekbang.org/column/article/6282\">缓存Cache</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/7036\">异步处理Asynchronous</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/7045\">数据库扩展</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/7047\">秒杀Flash Sales</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/7086\">边缘计算Edge Computing</a></li>\n</ul>\n</li>\n</ul>","neighbors":{"left":{"article_title":"46 | 弹力设计篇之“补偿事务”","id":4087},"right":{"article_title":"48 | 弹力设计篇之“熔断设计”","id":4241}},"comments":[{"had_liked":false,"id":9976,"user_name":"来","can_delete":false,"product_type":"c1","uid":1048433,"ip_address":"","ucode":"2612C1D888ED03","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ff/71/c492b7fa.jpg","comment_is_top":false,"comment_ctime":1527208817,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"143261129585","product_id":100002201,"comment_content":"重试的场景：<br>1、服务timeout超时异常<br>2、服务不存在，配置问题，服务流控<br>3、对error错误不重试，如无权限、参数错误<br><br>重试的策略：<br>1、数据库中保存重试需要的上下文，目前通过json来保存，指定最大重试次数、当前重试次数，下次运行时间<br><br>重试需要注意的地方：<br>1、服务幂等性，在重试时需证调用服务的幂等性<br>2、重试数据的监控，邮件，短信及时通知<br>3、重试数据的结转，防止表数据量过大","like_count":34},{"had_liked":false,"id":3910,"user_name":"shufang","can_delete":false,"product_type":"c1","uid":1055576,"ip_address":"","ucode":"1F16B2D15E0151","user_header":"","comment_is_top":false,"comment_ctime":1520950930,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"44470623890","product_id":100002201,"comment_content":"spring真的是只有想不到没有做不到～","like_count":11,"discussions":[{"author":{"id":1503506,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f1/12/7dac30d6.jpg","nickname":"你为啥那么牛","note":"","ucode":"1ABC604A54A8F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318621,"discussion_content":"被套牢在生态链里面的孩儿们","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603792141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202,"discussion_content":"spring 生态链","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561277282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210817,"user_name":"顾海","can_delete":false,"product_type":"c1","uid":1103602,"ip_address":"","ucode":"13F4E0A21975CE","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/f2/0601a60e.jpg","comment_is_top":false,"comment_ctime":1587828798,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31652599870","product_id":100002201,"comment_content":"视情况不同，重试策略可能不同<br>1.被调用方是集群，例如微服务调用，当一次调用失败时，一般不会采用backoff策略，而是会换一台被调用机器立即自动发起一次重试。不采用backoff的原因是，RPC调用通常对响应时间比较敏感。<br>2.被调用方是单机(或者是集群，但是请求会打到master一台机器时)而且对超时时间不敏感的调用，通常会采用backoff策略。在这种情况下，由于被调用方只有一台机器，调用超时时马上重试多半还会超时，而且连续重试会进一步加大被调用机器的压力，进一步加大调用失败的可能。","like_count":8},{"had_liked":false,"id":4041,"user_name":"NonStatic","can_delete":false,"product_type":"c1","uid":1048909,"ip_address":"","ucode":"9F8BAD86389890","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6icqg5GGFVo2CkFnjSGleOuDBvTTpXywFbBKicKSNXUH1PibHEq2IgWWGJZsn4ErV6J9mlcBiczV7T5QnpiajLsOibOw/132","comment_is_top":false,"comment_ctime":1521345798,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31586116870","product_id":100002201,"comment_content":"用过.net core上的Polly：http:&#47;&#47;www.thepollyproject.org&#47; 推荐给用C#的兄弟姐妹们。","like_count":7,"discussions":[{"author":{"id":1503506,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f1/12/7dac30d6.jpg","nickname":"你为啥那么牛","note":"","ucode":"1ABC604A54A8F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318622,"discussion_content":"up","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603792164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":3871,"user_name":"小沫","can_delete":false,"product_type":"c1","uid":1000977,"ip_address":"","ucode":"52341656210E0D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/11/1cf8c174.jpg","comment_is_top":false,"comment_ctime":1520896688,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"22995733168","product_id":100002201,"comment_content":"你好，对于重试是否可以不让当前线程休眠呢。如果当前线程休眠 此时这个线程的利用率就不高，我觉得应该放到线程池里面是否好一些呢？","like_count":6,"discussions":[{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591897,"discussion_content":"那就要看重试与补偿的定义了。。或者直接合并一个。。利用rocketmq的消息重新消费逻辑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666923358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1052994,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/226NabDEu1IGMN7Om1gQqG22hk2dZKojpB0KDpAK0vtujQLdlgZsVaPbIc4ymcib0NdH3Syh8YibRuL7Lv5kVCkg/132","nickname":"果子","note":"","ucode":"D7B288A3E722F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408243,"discussion_content":"老师写的是伪代码，生产上肯定要用定时器重试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635212027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1503506,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f1/12/7dac30d6.jpg","nickname":"你为啥那么牛","note":"","ucode":"1ABC604A54A8F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318623,"discussion_content":"好问题啊 考虑下go吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603792210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":3922,"user_name":"道道","can_delete":false,"product_type":"c1","uid":1063381,"ip_address":"","ucode":"1BE592CE48B3F6","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/d5/15ded80e.jpg","comment_is_top":false,"comment_ctime":1520989501,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10110924093","product_id":100002201,"comment_content":"之前做的重试策略是：异常发生的时候，数据库记录当前上下文，依据重试次数来确定重试时间，推送给延迟消息队列控制重试","like_count":3,"discussions":[{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203,"discussion_content":"请问延迟消息队列 用的是中间件还是 jdk提供的jvm内部队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561277337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":3886,"user_name":"Sam_Deep_Thinking","can_delete":false,"product_type":"c1","uid":1001152,"ip_address":"","ucode":"8E4EF6F24B821B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/c0/bf880bda.jpg","comment_is_top":false,"comment_ctime":1520912899,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10110847491","product_id":100002201,"comment_content":"又一篇好文。感恩。。。","like_count":2},{"had_liked":false,"id":198241,"user_name":"cash","can_delete":false,"product_type":"c1","uid":1089607,"ip_address":"","ucode":"16C33E7182855B","user_header":"https://static001.geekbang.org/account/avatar/00/10/a0/47/36207f72.jpg","comment_is_top":false,"comment_ctime":1585431399,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5880398695","product_id":100002201,"comment_content":"终于搞明白了现在架构中的重试机制设计了，原来是直接copy的spring的重试设计，醍醐灌顶。","like_count":2},{"had_liked":false,"id":168988,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1521486,"ip_address":"","ucode":"2B8E634FC4CFB7","user_header":"https://static001.geekbang.org/account/avatar/00/17/37/4e/5c3153b2.jpg","comment_is_top":false,"comment_ctime":1578233246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5873200542","product_id":100002201,"comment_content":"重试依赖被调用方做了良好的幂等设计和接口返回码规范，知道什么情况下应该重试，什么情况下直接报故障。重试也需要做避让设计，防止被调用方压力过大，压垮系统。spring重试项目可以做到注解方式定义重试，防止代码注入。server mess还需要多了解了解。","like_count":2},{"had_liked":false,"id":111852,"user_name":"edisonhuang","can_delete":false,"product_type":"c1","uid":1530167,"ip_address":"","ucode":"BB2F639A779F96","user_header":"https://static001.geekbang.org/account/avatar/00/17/59/37/bd2de0a4.jpg","comment_is_top":false,"comment_ctime":1562631562,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5857598858","product_id":100002201,"comment_content":"重试策略的设计需要考虑重试的场景，重试的次数自己相应时间的限制。由于单机的服务变成了分布式的微服务，由于网络，流量等等未知原因，重试不可避免，应该考虑在代码设计中。对于事物性的操作，还需要考虑服务调用的幂等性，保证服务最终状态不出错","like_count":1},{"had_liked":false,"id":14348,"user_name":"徐","can_delete":false,"product_type":"c1","uid":1081808,"ip_address":"","ucode":"B1866D4EA4C238","user_header":"https://static001.geekbang.org/account/avatar/00/10/81/d0/76d29a90.jpg","comment_is_top":false,"comment_ctime":1530323186,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5825290482","product_id":100002201,"comment_content":"503 502 都需要重试吧 老师 500 400 403 401 可以不用重试吧","like_count":1},{"had_liked":false,"id":13392,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1529580339,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5824547635","product_id":100002201,"comment_content":"有一个很小白的错误，我记得n年前一个同事写过一个很简单的服务，轮询需要处理的数据，每次取出m条，然后处理。测试时发现，有数据的时候，没任何问题，一旦数据处理完毕，系统CPU负载就飙升。最后看了一下，当没有重试数据的时候，就不断的轮询，不断的轮询，导致CPU飙升。后面对于批量处理数据的代码，都要重点看下有没有必要的延时。。。<br><br>另外，对于很特殊的数据，比如会引起服务挂掉的特殊数据（本文中的SERVER_ERROR），必须要特殊处理一下，不要继续重试，否则就滚雪球直接崩盘了。","like_count":2},{"had_liked":false,"id":5078,"user_name":"诤","can_delete":false,"product_type":"c1","uid":1046141,"ip_address":"","ucode":"1EEA4BDDD6227E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f6/7d/29432580.jpg","comment_is_top":false,"comment_ctime":1522719034,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5817686330","product_id":100002201,"comment_content":"server error不是不应该重试，属于服务端内部错误，不是暂时性的","like_count":1},{"had_liked":false,"id":319434,"user_name":"方勇(gopher)","can_delete":false,"product_type":"c1","uid":1290625,"ip_address":"","ucode":"D199911C4CFEF5","user_header":"https://static001.geekbang.org/account/avatar/00/13/b1/81/13f23d1e.jpg","comment_is_top":false,"comment_ctime":1635815447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635815447","product_id":100002201,"comment_content":"我们在消息队列中，发布消费重试","like_count":0},{"had_liked":false,"id":308885,"user_name":"闻人","can_delete":false,"product_type":"c1","uid":1102584,"ip_address":"","ucode":"E4970C0D944243","user_header":"https://static001.geekbang.org/account/avatar/00/10/d2/f8/d5006178.jpg","comment_is_top":false,"comment_ctime":1629852831,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1629852831","product_id":100002201,"comment_content":"重试设计需要考虑场景，行为，间隔","like_count":0},{"had_liked":false,"id":209112,"user_name":"Nick","can_delete":false,"product_type":"c1","uid":1921287,"ip_address":"","ucode":"64BBE005890845","user_header":"https://static001.geekbang.org/account/avatar/00/1d/51/07/b5a945b6.jpg","comment_is_top":false,"comment_ctime":1587511487,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587511487","product_id":100002201,"comment_content":"又学了一种新技术，原来项目中还真没使用过，比如出现调用超时，那么默认就会一直请求，直到系统返回一次，消耗服务器资源。","like_count":0},{"had_liked":false,"id":197548,"user_name":"半盏流年","can_delete":false,"product_type":"c1","uid":1921458,"ip_address":"","ucode":"FCE008CD80CF44","user_header":"https://static001.geekbang.org/account/avatar/00/1d/51/b2/e0f26113.jpg","comment_is_top":false,"comment_ctime":1585384738,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585384738","product_id":100002201,"comment_content":"厉害👍🏻👍🏻👍🏻👍🏻👍🏻👍🏻👍🏻👍🏻👍🏻👍🏻👍🏻","like_count":0},{"had_liked":false,"id":167341,"user_name":"blackpiglet","can_delete":false,"product_type":"c1","uid":1032928,"ip_address":"","ucode":"58AA8329C91767","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c2/e0/7188aa0a.jpg","comment_is_top":false,"comment_ctime":1577771360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577771360","product_id":100002201,"comment_content":"总结：使用重试策略有个前提，就是问题不是永久性的，如果问题一直无法解决就没有必要再重试了。很有必要根据出错原因来判断是否有必要进行重试。重试策略主要分为以下几种：不退避、固定退避时长、随机时间退避、指数退避、随即指数退避。<br>应用重试机制需要注意以下几点：是否需要进行重试、使用什么重试策略以及重试几次、熔断和恢复策略、重试需要有幂等的支持、重试策略可以复用、复杂操作，比如有事务需要有特殊设计。","like_count":0},{"had_liked":false,"id":165166,"user_name":"文刂 氵共 超","can_delete":false,"product_type":"c1","uid":1282813,"ip_address":"","ucode":"C2CE1512D23012","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/fd/6b0e58fe.jpg","comment_is_top":false,"comment_ctime":1577174440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577174440","product_id":100002201,"comment_content":"坚持学习，学习笔记 https:&#47;&#47;mubu.com&#47;colla&#47;3HCUwf3_nJM","like_count":0},{"had_liked":false,"id":64457,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1548807687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548807687","product_id":100002201,"comment_content":"我们的系统比较靠后，提供的接口中会标识出当请求失败时是否建议调用方重试，具体重师与否有调用方自己选择。<br>一般超时才建议重试。","like_count":0},{"had_liked":false,"id":40195,"user_name":"Geek_fb3db2","can_delete":false,"product_type":"c1","uid":1218254,"ip_address":"","ucode":"8089B8311B6C80","user_header":"https://static001.geekbang.org/account/avatar/00/12/96/ce/8c3bdbe5.jpg","comment_is_top":false,"comment_ctime":1542546441,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1542546441","product_id":100002201,"comment_content":"一个重试机制都有如此优雅的设计模式，想问下，重试是同步还是异步进行的，还是需要看业务呢","like_count":0},{"had_liked":false,"id":4070,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1521463028,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1521463028","product_id":100002201,"comment_content":"好文","like_count":0},{"had_liked":false,"id":3882,"user_name":"Kennedy","can_delete":false,"product_type":"c1","uid":1049022,"ip_address":"","ucode":"C50627007E5ED0","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/be/be358cab.jpg","comment_is_top":false,"comment_ctime":1520905433,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1520905433","product_id":100002201,"comment_content":"503是服务过载，短暂不可用，可以重试吧？陈老师","like_count":0,"discussions":[{"author":{"id":1169474,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d8/42/d4e7a136.jpg","nickname":"有思想的芦苇","note":"","ucode":"AA0B96363B1587","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":113430,"discussion_content":"看业务场景吧，比如数据库连接超时，也是服务器端错误，会返回503，可能是数据库连接池用完，或者超出允许的最大连接数等，这时候个人认为应该重试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577894091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}