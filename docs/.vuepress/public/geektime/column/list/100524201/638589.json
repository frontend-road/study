{"id":638589,"title":"12｜二叉树：如何存储二叉树？","content":"<p>你好，我是王健伟。</p><p>聊过了二叉树的遍历问题，终于要开始写程序了，所以今天就来聊聊存储二叉树的几种方法。</p><p>二叉树的存储一般有两种方式，一种是基于数组的<strong>顺序</strong>存储方式，一种是<strong>链式</strong>存储方式。它们有什么不同呢？</p><h2>顺序存储方式</h2><p>顺序存储方式是用一段连续的内存单元<span class=\"reference\">（数组）</span>依次从上到下、从左到右存储二叉树各个节点元素。</p><p>假设我们存储的是一棵完全二叉树，如果把根节点存储在数组中下标i = 1的位置，那么根据之前讲解的二叉树编号规律<a href=\"https://time.geekbang.org/column/article/637022\">（二叉树性质6）</a>，左子节点就存储在下标2 * i = 2的位置，右子节点就存储在2 * i + 1 = 3的位置。这样就可以通过下标把整棵树串起来。</p><p>因为节点编号从1开始，所以数组中下标为0的位置可以空出来不用，让数组下标和节点编号保持一致。虽然这样浪费了一个存储空间，不过这点你可以自由决定。</p><p>参考下图1。</p><p><img src=\"https://static001.geekbang.org/resource/image/a1/f7/a1f7281f030a3e2be14d6fe4a5392cf7.jpg?wh=2284x940\" alt=\"\" title=\"图1 存储完全二叉树节点时所对应的数组下标示意图\"></p><p>不难看到，数组的下标可以体现出节点的存储位置。换句话说，数组的下标能够体现出节点之间的逻辑关系<span class=\"reference\">（父子、兄弟）</span>。</p><p>但如果存储的不是一棵完全二叉树，而是普通二叉树，那么存储的时候，也需要将其按照完全二叉树的方式来编号存储，这样肯定会浪费较多的数组存储空间。</p><p>参考下图2。</p><p><img src=\"https://static001.geekbang.org/resource/image/16/c0/16232c4d7120da479f622376cbc4aec0.jpg?wh=2284x940\" alt=\"\" title=\"图2 存储普通二叉树节点时所对应的数组下标示意图\"></p><p>图2中虚线表示的节点表示不存在的节点，但在存储时却要给其留出位置。可以看到，下标6、8的数组空间都被浪费掉了。</p><!-- [[[read_end]]] --><p>你可以想一种极端的情况：如果有一棵深度为4的右斜树需要保存，会浪费多少个数组空间呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/de/1e/de4cdd08d36df7caeaf9d658b084201e.jpg?wh=2284x940\" alt=\"\" title=\"图3 右斜树顺序存储方式会浪费很大的空间\"></p><p>根据二叉树性质2，“高度为k的二叉树至多有$2^{k}$-1个节点”，存储高度为4的二叉树，最坏情况下空间需求是$2^{4}$-1=15，因为下标为0的空间不使用，所以最坏情况下空间需求是$2^{4}$=16，而图3的右斜树恰恰需要$2^{4}$=16个存储空间。即便下标为0的位置不计算在内，也整整浪费了11个位置。</p><p>可是，完全二叉树就不会存在这个问题。这就是完全二叉树最后一层叶节点都靠左侧排列这种硬性规定所带来的存储益处。换句话说，<strong>顺序存储结构一般是用于存储完全二叉树</strong>。</p><h2>链式存储方式</h2><p>链式存储方式要存储额外的左右子节点的指针，而顺序存储方式是不需要指针的，所以通常来讲，<strong>链式存储方式多用于存储普通的二叉树。</strong></p><p>链式存储中，二叉树的每个节点最多有两个子节点，所以为每个节点设计结构时一般都包括一个数据域和两个指针域，分别指向左孩子节点和右孩子节点。至于没有用到的指针，设置为nullptr即可。结构示意图如图4所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d3/dc/d31cbyy3811c780b94ab573643ed46dc.jpg?wh=2284x852\" alt=\"\" title=\"图4 链式存储方式的结构示意图\"></p><p>从图4可以看到，只要<strong>拎住最上面的根节点</strong>，就可以通过左右子节点的指针把整棵树串起来。</p><p>利用这种节点结构所得到的二叉树存储结构，叫做<strong>二叉链表</strong>，一个节点结构中带两个指针。有时候为了方便找到某个节点的父节点，还可以在设计节点结构的时候再增加一个指针，用于指向其父节点，这种节点结构所得到的二叉树存储结构，就叫做<strong>三叉链表</strong>，也就是一个节点结构中带三个指针。</p><h2>二叉树顺序存储的常用操作</h2><p>概念理清之后，我们就要开始代码层面的学习了。虽然顺序存储结构一般是用于存储完全二叉树，但为了让写出的代码也支持普通二叉树，所以我会用二叉树的顺序存储方式，存储图5左侧所示的普通二叉树。</p><p><img src=\"https://static001.geekbang.org/resource/image/6c/96/6c6677c3ee666c91951aaba931941196.jpg?wh=2284x728\" alt=\"\" title=\"图5 左侧为一个二叉树，右侧为一个二叉树的扩展二叉树\"></p><p>二叉树顺序存储的实现代码<a href=\"https://gitee.com/jianw_wang/geektime_cpp_dsa/blob/master/14%EF%BD%9C%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9F/%EF%BC%881%EF%BC%89%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8/MyProject.cpp\">参见课件</a>。</p><p>在main主函数中，增加如下测试代码。</p><pre><code class=\"language-plain\">BinaryTree&lt;int&gt; mytree;\n//创建一棵二叉树\nint indexRoot = mytree.CreateNode(-1, E_Root, 'A'); //创建树根节点A\nint indexNodeB = mytree.CreateNode(indexRoot, E_ChildLeft, 'B');&nbsp; //创建树根的左子节点B\nint indexNodeC = mytree.CreateNode(indexRoot, E_ChildRight, 'C'); //创建树根的右子节点C\n\nint indexNodeD = mytree.CreateNode(indexNodeB, E_ChildLeft, 'D'); //创建节点B的左子节点D\nint indexNodeE = mytree.CreateNode(indexNodeC, E_ChildRight, 'E'); //创建节点C的右子节点E\t\n\nint iParentIndexE = mytree.getParentIdx(indexNodeE);&nbsp; &nbsp;//获取某个节点的父节点的下标\ncout &lt;&lt; \"节点E的父节点的下标是：\" &lt;&lt; iParentIndexE &lt;&lt; endl;\n\t\nint iLevel = mytree.getPointLevel(indexNodeD);&nbsp; //获取某个节点所在的高度\ncout &lt;&lt; \"节点D所在的高度是：\" &lt;&lt; iLevel &lt;&lt; endl;\niLevel = mytree.getPointLevel(indexNodeE);\ncout &lt;&lt; \"节点E所在的高度是：\" &lt;&lt; iLevel &lt;&lt; endl;\ncout &lt;&lt; \"二叉树的深度是：\" &lt;&lt; mytree.getLevel() &lt;&lt; endl;\ncout &lt;&lt; \"二叉树是个完全二叉树吗？\" &lt;&lt; mytree.ifCompleteBT() &lt;&lt; endl;\n\t\ncout &lt;&lt; \"------------\" &lt;&lt; endl;\ncout &lt;&lt; \"前序遍历序列为：\";\nmytree.preOrder();&nbsp; &nbsp;//前序遍历\n</code></pre><p>代码的执行结果如下。</p><p><img src=\"https://static001.geekbang.org/resource/image/a7/d8/a7858b75179409b43bd9b593143326d8.jpg?wh=1920x516\" alt=\"图片\"></p><p>特别说明，因为在面试和实际应用中，二叉树的链式存储使用得更加频繁，因此许多常用操作我会在下面讲解链式存储中实现，有兴趣的话，你也可以尝试将这些常用操作搬移到二叉树的顺序存储中实现。</p><h2>二叉树链式存储的常用操作</h2><p>下面我们熟悉一下二叉树链式存储的常用操作。完整的<a href=\"https://gitee.com/jianw_wang/geektime_cpp_dsa/blob/master/14%EF%BD%9C%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9F/%EF%BC%882%EF%BC%89%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/MyProject.cpp\">课件在这里</a>。</p><h3><strong>类定义、初始化和释放操作</strong></h3><pre><code class=\"language-plain\">enum ECCHILDSIGN&nbsp; //节点标记\n{\n\tE_Root,&nbsp; &nbsp; &nbsp; &nbsp;//树根\n\tE_ChildLeft,&nbsp; //左孩子\n\tE_ChildRight&nbsp; //右孩子\n};\n//树中每个节点的定义\ntemplate &lt;typename T&gt; //T代表数据元素的类型\nstruct BinaryTreeNode\n{\n\tT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;data;&nbsp; &nbsp; &nbsp; &nbsp; //数据域，存放数据元素\n\tBinaryTreeNode* leftChild,&nbsp; &nbsp;//左子节点指针\n\t\t\t&nbsp; &nbsp; &nbsp; * rightChild;&nbsp; //右子节点指针\n\t\t\n\t//BinaryTreeNode* parent;&nbsp; &nbsp; &nbsp; //父节点指针，可以根据需要决定是否引入\n};\n//二叉树的定义\ntemplate &lt;typename T&gt;\nclass BinaryTree\n{\npublic:\n\tBinaryTree();&nbsp; //构造函数\n\t~BinaryTree(); //析构函数\npublic:\n\t//创建一个树节点\n\tBinaryTreeNode&lt;T&gt;* CreateNode(BinaryTreeNode&lt;T&gt;* parentnode, ECCHILDSIGN pointSign, const T&amp; e);\n\t//释放树节点\n\tvoid ReleaseNode(BinaryTreeNode&lt;T&gt;* pnode);\nprivate:\n\tBinaryTreeNode&lt;T&gt;* root; //树根指针\t\n};\n\t\n//构造函数\ntemplate&lt;class T&gt;\nBinaryTree&lt;T&gt;::BinaryTree()\n{\n\troot = nullptr;\n}\n\t\n//析构函数\ntemplate&lt;class T&gt;\nBinaryTree&lt;T&gt;::~BinaryTree()\n{\n\tReleaseNode(root);\n};\n\t\n//释放二叉树节点\ntemplate&lt;class T&gt;\nvoid BinaryTree&lt;T&gt;::ReleaseNode(BinaryTreeNode&lt;T&gt;* pnode)\n{\n\tif (pnode != nullptr)\n\t{\n\t\tReleaseNode(pnode-&gt;leftChild);\n\t\tReleaseNode(pnode-&gt;rightChild);\n\t}\n\tdelete pnode;\n}\n</code></pre><h3><strong>创建树节点操作</strong></h3><pre><code class=\"language-plain\">//创建一个树节点\ntemplate&lt;class T&gt;\n//参数1：父节点指针，参数2：标记所创建的是树根、左孩子、右孩子，参数3：插入的树节点的元素值\nBinaryTreeNode&lt;T&gt;* BinaryTree&lt;T&gt;::CreateNode(BinaryTreeNode&lt;T&gt;* parentnode, ECCHILDSIGN pointSign, const T&amp; e)\n{\n\t//将新节点创建出来\n\tBinaryTreeNode&lt;T&gt;*&nbsp; tmpnode = new BinaryTreeNode&lt;T&gt;;&nbsp;\n\ttmpnode-&gt;data = e;\n\ttmpnode-&gt;leftChild = nullptr;\n\ttmpnode-&gt;rightChild = nullptr;\n\t\n\t//把新节点放入正确的位置\n\tif (pointSign == E_Root)\n\t{\n\t\t//创建的是根节点\n\t\troot = tmpnode;\n\t}\n\tif (pointSign == E_ChildLeft)\n\t{\n\t\t//创建的是左孩子节点\n\t\tparentnode-&gt;leftChild = tmpnode;\n\t}\n\telse&nbsp; if (pointSign == E_ChildRight)\n\t{\n\t\t//创建的是右孩子节点\n\t\tparentnode-&gt;rightChild = tmpnode;\n\t}\n\treturn tmpnode;\n}\n</code></pre><p>在main主函数中，加入如下代码，创建一个如前面图5左侧所示的一棵二叉树。</p><pre><code class=\"language-plain\">BinaryTree&lt;int&gt; mytree;\t\n//创建一棵二叉树\nBinaryTreeNode&lt;int&gt;* rootpoint = mytree.CreateNode(nullptr, E_Root, 'A'); //创建树根节点A\nBinaryTreeNode&lt;int&gt;* subpoint = mytree.CreateNode(rootpoint, E_ChildLeft, 'B'); //创建树根的左子节点B\nsubpoint = mytree.CreateNode(subpoint, E_ChildLeft, 'D'); //创建左子节点B下的左子节点D\n\nsubpoint = mytree.CreateNode(rootpoint, E_ChildRight, 'C'); //创建树根的右子节点C\nsubpoint = mytree.CreateNode(subpoint, E_ChildRight, 'E');&nbsp; //创建右子节点C下的右子节点E\n</code></pre><p>在前面讲解扩展二叉树时，你已经知道，给出一个扩展二叉树的前序遍历序列，能够唯一确定一棵二叉树。前面图5中右侧的扩展二叉树，其前序遍历序列是“ABD###C#E##”，那么如果想通过这个遍历序列把这棵二叉树创建，是否可以做到呢？可以。</p><p>我们在类模板BinaryTree中增加如下两个成员函数声明。</p><pre><code class=\"language-plain\">public:\n\t//利用扩展二叉树的前序遍历序列来创建一棵二叉树\n\tvoid CreateBTreeAccordPT(char* pstr);\nprivate:\n\t//利用扩展二叉树的前序遍历序列创建二叉树的递归函数\n\tvoid CreateBTreeAccordPTRecu(BinaryTreeNode&lt;T&gt;*&amp; tnode, char*&amp; pstr);//参数为引用类型，确保递归调用中对参数的改变会影响到调用者\n</code></pre><p>在类模板BinaryTree定义之外，实现上述两个成员函数。</p><pre><code class=\"language-plain\">//利用扩展二叉树的前序遍历序列来创建一棵二叉树\ntemplate&lt;class T&gt;\nvoid BinaryTree&lt;T&gt;::CreateBTreeAccordPT(char* pstr)\n{\n\tCreateBTreeAccordPTRecu(root, pstr);\n}\n\t\n//利用扩展二叉树的前序遍历序列创建二叉树的递归函数\ntemplate&lt;class T&gt;\nvoid BinaryTree&lt;T&gt;::CreateBTreeAccordPTRecu(BinaryTreeNode&lt;T&gt;* &amp;tnode, char* &amp;pstr)\n{\n\tif (*pstr == '#')\n\t{\n\t\ttnode = nullptr;\n\t}\n\telse\n\t{\n\t\ttnode = new BinaryTreeNode&lt;T&gt;; //创建根节点\n\t\ttnode-&gt;data = *pstr;\n\t\tCreateBTreeAccordPTRecu(tnode-&gt;leftChild, ++pstr); //创建左子树\n\t\tCreateBTreeAccordPTRecu(tnode-&gt;rightChild, ++pstr);//创建右子树\n\t}\n}\n</code></pre><p>在main主函数中，注释掉以往的代码，新增如下测试代码。</p><pre><code class=\"language-plain\">BinaryTree&lt;int&gt; mytree2;\nmytree2.CreateBTreeAccordPT((char *)\"ABD###C#E##\");\n</code></pre><p>通过跟踪调试，不难看到，上述的mytree2所存储的数据正是图5左侧所示的二叉树。</p><h3><strong>遍历操作</strong></h3><p>二叉树创建出来后，就可以通过前面讲解过的遍历方式，将树中各个节点的内容输出出来以方便观察。我们从深度、广度优先遍历两种方式的角度去了解。</p><ul>\n<li><strong>深度优先遍历</strong></li>\n</ul><p>将下列前序、中序、后序遍历的代码加入到类模板BinaryTree的定义中，注意用public修饰。</p><pre><code class=\"language-plain\">//前序遍历二叉树\nvoid preOrder()\n{\n\tpreOrder(root);\t\n}\nvoid preOrder(BinaryTreeNode&lt;T&gt;* tNode)&nbsp;\n{\n\tif (tNode != nullptr) //若二叉树非空\n\t{\n\t\t//根左右顺序\t\t\t\t\n\t\tcout &lt;&lt; (char) tNode-&gt;data &lt;&lt; \" \"; //输出节点的数据域的值，为方便观察，用char以显示字母\n\t\tpreOrder(tNode-&gt;leftChild);&nbsp; //递归方式前序遍历左子树\n\t\tpreOrder(tNode-&gt;rightChild); //递归方式前序遍历右子树\n\t}\t\t\t\n}\n//--------------------------\n//中序遍历二叉树\nvoid inOrder()\n{\n\tinOrder(root);\t\t\t\n}\nvoid inOrder(BinaryTreeNode&lt;T&gt;* tNode)&nbsp; //中序遍历二叉树\n{\n\tif (tNode != nullptr) //若二叉树非空\n\t{\n\t\t//左根右顺序\n\t\tinOrder(tNode-&gt;leftChild);&nbsp; //递归方式中序遍历左子树\n\t\tcout &lt;&lt; (char)tNode-&gt;data &lt;&lt; \" \"; //输出节点的数据域的值\n\t\tinOrder(tNode-&gt;rightChild); //递归方式中序遍历右子树\n\t}\n}\n//--------------------------\n//后序遍历二叉树\nvoid postOrder()\n{\n\tpostOrder(root);\n}\nvoid postOrder(BinaryTreeNode&lt;T&gt;* tNode)&nbsp; //后序遍历二叉树\n{\n\tif (tNode != nullptr) //若二叉树非空\n\t{\n\t\t//左右根顺序\n\t\tpostOrder(tNode-&gt;leftChild);&nbsp; //递归方式后序遍历左子树\n\t\tpostOrder(tNode-&gt;rightChild); //递归方式后序遍历右子树\n\t\tcout &lt;&lt; (char)tNode-&gt;data &lt;&lt; \" \"; //输出节点的数据域的值\n\t}\n}\n</code></pre><p>在main主函数中，继续增加如下代码对刚刚创建的树进行前序、中序和后序遍历。</p><pre><code class=\"language-plain\">cout &lt;&lt; \"前序遍历序列为：\";&nbsp;\nmytree2.preOrder();&nbsp; &nbsp;//前序遍历\ncout &lt;&lt; endl; //换行\n\t\ncout &lt;&lt; \"中序遍历序列为：\";\nmytree2.inOrder();&nbsp; &nbsp; //中序遍历\ncout &lt;&lt; endl; //换行\n\t\ncout &lt;&lt; \"后序遍历序列为：\";\nmytree2.postOrder();&nbsp; //后序遍历\n</code></pre><p>新增代码的执行结果如下，正是对图5左侧所示的二叉树进行前序、中序、后序遍历得到的结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/5a/64/5a3f272a75917445bf5bc45168f25a64.jpg?wh=1920x253\" alt=\"图片\"></p><ul>\n<li><strong>广度优先遍历</strong></li>\n</ul><p>除了对二叉树进行前序、中序、后序遍历之外，还有一种遍历方式叫层序遍历。前面说过，二叉树的层序遍历需要借助队列来完成，因为难以估计二叉树节点个数，所以使用顺序队列不合适，这里就用链式队列。</p><p>我们把以往讲解的链式队列相关的代码复制到本项目当前的MyProject.cpp文件中来。将下列代码加入到类模板BinaryTree的定义中。</p><pre><code class=\"language-plain\">//--------------------------\n//层序遍历二叉树\nvoid levelOrder()\n{\n\tlevelOrder(root);\n}\nvoid levelOrder(BinaryTreeNode&lt;T&gt;* tNode)\n{\n\tif (tNode != nullptr) //若二叉树非空\n\t{\n\t\tBinaryTreeNode&lt;T&gt;* tmpnode;\n\t\tLinkQueue&lt;BinaryTreeNode&lt;T&gt;*&gt; lnobj;//注意，队列的元素类型是“节点指针”类型\n\t\tlnobj.EnQueue(tNode); //先把根节点指针入队\n\t\twhile (!lnobj.IsEmpty()) //循环判断队列是否为空\n\t\t{\n\t\t\tlnobj.DeQueue(tmpnode); //出队列\n\t\t\tcout &lt;&lt; (char)tmpnode-&gt;data &lt;&lt; \" \";\n\t\t\tif(tmpnode-&gt;leftChild != nullptr)\n\t\t\t\tlnobj.EnQueue(tmpnode-&gt;leftChild);&nbsp; //左孩子入队\n\t\t\tif (tmpnode-&gt;rightChild != nullptr)&nbsp; &nbsp; &nbsp;//右孩子入队\n\t\t\t\tlnobj.EnQueue(tmpnode-&gt;rightChild);\n\t\t} //end while\n\t}\n}\n</code></pre><p>在main主函数中，继续增加如下代码对刚刚创建的树进行层序遍历。</p><pre><code class=\"language-plain\">cout &lt;&lt; endl; //换行\ncout &lt;&lt; \"层序遍历序列为：\";\nmytree2.levelOrder();\n</code></pre><p>新增代码的执行结果如下。</p><p><img src=\"https://static001.geekbang.org/resource/image/b7/0d/b7e67f458a353d980042e44ac796740d.jpg?wh=2838x138\" alt=\"\"></p><p>这里可以进一步思考一下，如何在上述层序遍历代码中加入一些代码来<strong>判断二叉树是否是一棵完全二叉树</strong>呢？</p><p>如果某个节点的左子节点不存在而右子节点存在，那么这棵二叉树就不是完全二叉树，所以上述层序遍历代码中，在出队列一个节点后，可以加入如下代码来判断一棵二叉树是否是完全二叉树。</p><pre><code class=\"language-plain\">if(tmpnode-&gt;leftChild == nullptr &amp;&amp; tmpnode-&gt;rightChild != nullptr)\n{\n\t//这棵二叉树不是一棵完全二叉树。\n}\n</code></pre><p>上述无论何种遍历方式，每个节点被访问的次数都是有限的，所以遍历操作的时间复杂度和二叉树的节点个数成正比，即二叉树遍历的时间复杂度为O(n)。</p><h3><strong>其他常用操作</strong></h3><p>最后，我们将分别实现二叉树的一些常用操作，包括计算节点个数、求二叉树的高度、根据给的节点值查找某个节点、查找某个节点的父节点、二叉树的拷贝。这些代码都可以在类模板BinaryTree的定义中实现。</p><ul>\n<li><strong>计算二叉树的节点个数</strong></li>\n</ul><pre><code class=\"language-plain\">//求二叉树节点个数\nint getSize()\n{\n\treturn getSize(root);\n}\nint getSize(BinaryTreeNode&lt;T&gt;* tNode) //也可以用遍历二叉树的方式求节点个数\n{\n\tif (tNode == nullptr)\n\t\treturn&nbsp; 0;\n\t\t\n\treturn getSize(tNode-&gt;leftChild) + getSize(tNode-&gt;rightChild) + 1; //之所以+1，是因为还有个根节点\n}\n</code></pre><p>增加下列测试代码（在main主函数中），确保增加的操作能够正常运行。</p><pre><code class=\"language-plain\">cout &lt;&lt; \"二叉树节点个数为：\" &lt;&lt; mytree2.getSize() &lt;&lt; endl;\n</code></pre><pre><code class=\"language-plain\">//求二叉树高度（取左右子树中高度更高的）\nint getHeight()\n{\n\treturn getHeight(root);\n}\nint getHeight(BinaryTreeNode&lt;T&gt;* tNode)\n{\n\tif (tNode == nullptr)\n\t\treturn&nbsp; 0;\n\tint lheight = getHeight(tNode-&gt;leftChild); //左子树高度\n\tint rheight = getHeight(tNode-&gt;rightChild); //右子树高度\n\tif (lheight &gt; rheight)\n\t\treturn lheight + 1 ; //之所以+1，是因为还包括根节点的高度\n\treturn rheight + 1;&nbsp; &nbsp;//之所以+1，是因为还包括根节点的高度\n}\n</code></pre><p>增加下列测试代码。</p><pre><code class=\"language-plain\">cout &lt;&lt; \"二叉树的高度为：\" &lt;&lt; mytree2.getHeight() &lt;&lt; endl;\n</code></pre><ul>\n<li><strong>查找某个节点（假设二叉树的节点各不相同）</strong></li>\n</ul><pre><code class=\"language-plain\">BinaryTreeNode&lt;T&gt;* SearchElem(const T&amp; e)\n{\n\treturn SearchElem(root, e);\n}\nBinaryTreeNode&lt;T&gt;* SearchElem(BinaryTreeNode&lt;T&gt;* tNode,const T&amp; e)\n{\n\tif (tNode == nullptr)\n\t\treturn nullptr;\n\tif (tNode-&gt;data == e)&nbsp; //从根开始找\n\t\treturn tNode;\n\tBinaryTreeNode&lt;T&gt;* p = SearchElem(tNode-&gt;leftChild, e); //查找左子树\n\tif (p != nullptr) //这里的判断不可缺少\n\t\treturn p;\n\treturn SearchElem(tNode-&gt;rightChild, e); //左子树查不到，继续到右子树查找，这里可以直接return\n}\n</code></pre><p>增加下列测试代码。</p><pre><code class=\"language-plain\">//查找某个节点\nint val = 'B';\nBinaryTreeNode&lt;int&gt;*&nbsp; p = mytree2.SearchElem(val);\nif (p != nullptr)\t\n\tcout &lt;&lt; \"找到了值为\" &lt;&lt; (char)val &lt;&lt; \"的节点\" &lt;&lt; endl;\t\nelse\t\n\tcout &lt;&lt; \"没找到值为\" &lt;&lt; (char)val &lt;&lt; \"的节点\" &lt;&lt; endl;\n</code></pre><ul>\n<li><strong>查找某个节点的父节点</strong></li>\n</ul><pre><code class=\"language-plain\">BinaryTreeNode&lt;T&gt;* GetParent(BinaryTreeNode&lt;T&gt;* tSonNode)\n{\n\treturn GetParent(root, tSonNode);\n}\nBinaryTreeNode&lt;T&gt;* GetParent(BinaryTreeNode&lt;T&gt;* tParNode, BinaryTreeNode&lt;T&gt;* tSonNode)\n{\n\tif (tParNode == nullptr || tSonNode == nullptr)\n\t\treturn nullptr;\n\t\n\tif (tParNode-&gt;leftChild == tSonNode || tParNode-&gt;rightChild == tSonNode)\n\t\treturn tParNode;\n\t\t\n\tBinaryTreeNode&lt;T&gt;* pl = GetParent(tParNode-&gt;leftChild, tSonNode);\n\tif (pl != nullptr)\n\t\treturn pl;\n\t\t\n\treturn&nbsp; GetParent(tParNode-&gt;rightChild, tSonNode);\n}\n</code></pre><p>增加下列测试代码。</p><pre><code class=\"language-plain\">//查找某个节点的父节点\nBinaryTreeNode&lt;int&gt;* parp = mytree2.GetParent(p);\nif (parp != nullptr)\n\tcout &lt;&lt; \"找到了值为\" &lt;&lt; (char)val &lt;&lt; \"的节点的父节点\" &lt;&lt; (char)parp-&gt;data &lt;&lt; endl;\nelse\n\tcout &lt;&lt; \"没找到值为\" &lt;&lt; (char)val &lt;&lt; \"的节点的父节点\" &lt;&lt; endl;\t\n</code></pre><ul>\n<li><strong>树的拷贝</strong></li>\n</ul><pre><code class=\"language-plain\">void CopyTree(BinaryTree&lt;T&gt;* targetTree)\n{\n\tCopyTree(root,targetTree-&gt;root);\n}\nvoid CopyTree(BinaryTreeNode&lt;T&gt;* tSource,BinaryTreeNode&lt;T&gt;* &amp;tTarget) //注意第二个参数类型为引用\n{\n\tif (tSource == nullptr)\n\t{\n\t\ttTarget = nullptr;\n\t}\n\telse\n\t{\n\t\ttTarget = new BinaryTreeNode&lt;T&gt;;\n\t\ttTarget-&gt;data = tSource-&gt;data;\n\t\tCopyTree(tSource-&gt;leftChild, tTarget-&gt;leftChild);&nbsp; //对左子树进行拷贝\n\t\tCopyTree(tSource-&gt;rightChild, tTarget-&gt;rightChild);//对右子树进行拷贝\n\t}\n}\n</code></pre><p>增加下列测试代码。</p><pre><code class=\"language-plain\">//测试树的拷贝\nBinaryTree&lt;int&gt; mytree3;\nmytree2.CopyTree(&amp;mytree3);\n</code></pre><h3>非递归遍历操作</h3><p>在前面的二叉树遍历代码实现中，除层序遍历外，前序、中序、后序遍历采用的都是递归方式来实现的，这种实现方法代码比较简单。但实际的面试中，有时也会要求采用非递归的方式实现前序、中序、后序遍历，这往往需要借助栈来实现。并且实际的应用中，如果二叉树的高度特别高，节点特别多，用递归的方式遍历可能会导致栈溢出，此时就需要采用非递归方式遍历了。</p><p>把<a href=\"https://time.geekbang.org/column/article/635174\">第10节课</a>提到的链式栈相关代码复制到当前的MyProject.cpp文件中来。非递归遍历代码都可以在类模板BinaryTree的定义中实现。</p><ul>\n<li><strong>前序遍历（根左右）</strong></li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/13/d0/139e0d2786111062de14ddbe604a43d0.jpg?wh=1920x552\" alt=\"图片\" title=\"前序遍历过程\"></p><p>你可以根据图片提示，自己手工绘制一下入栈和出栈的过程，这样也会对通过栈实现前序遍历有一个更深刻的认识。</p><p>我们把以往讲解的链式栈相关的代码复制到本项目当前的MyProject.cpp文件中来。将下列代码加入到类模板BinaryTree的定义中。</p><pre><code class=\"language-plain\">//非递归方式前序遍历二叉树\nvoid preOrder_noRecu()\n{\n\tpreOrder_noRecu(root);\n}\nvoid preOrder_noRecu(BinaryTreeNode&lt;T&gt;* tRoot)\n{\n\tif (tRoot == nullptr)&nbsp;\n\t\treturn;\t\t\t\n\t\n\tLinkStack&lt; BinaryTreeNode&lt;T&gt;* &gt; slinkobj;\n\tslinkobj.Push(tRoot); //根节点入栈\n\t\t\n\tBinaryTreeNode&lt;T&gt;* tmpnode;\n\twhile (!slinkobj.Empty()) //栈不空\n\t{\t\t\t\t\t\n\t\tslinkobj.Pop(tmpnode);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//栈顶元素出栈\n\t\tcout &lt;&lt; (char)tmpnode-&gt;data &lt;&lt; \" \";&nbsp; //访问栈顶元素\n\t\t\t\n\t\tif (tmpnode-&gt;rightChild != nullptr) //注意先判断右树再判断左树\n\t\t{\n\t\t\tslinkobj.Push(tmpnode-&gt;rightChild); //把右树入栈\n\t\t}\n\t\tif (tmpnode-&gt;leftChild != nullptr)\n\t\t{\n\t\t\tslinkobj.Push(tmpnode-&gt;leftChild); //把左树入栈\n\t\t}\n\t} //end while\n}\n</code></pre><p>增加下列测试代码。</p><pre><code class=\"language-plain\">cout &lt;&lt; \"非递归方式前序遍历序列为：\";&nbsp;\nmytree2.preOrder_noRecu();\ncout &lt;&lt; endl;\n</code></pre><p>新增代码的执行结果如下。</p><p><img src=\"https://static001.geekbang.org/resource/image/af/23/aff1b373902fb93c10b9dbe87ae70d23.jpg?wh=2838x146\" alt=\"\"></p><ul>\n<li><strong>中序遍历（左根右）</strong></li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/07/5a/07435580da82f865bf6d6da409938b5a.jpg?wh=1920x765\" alt=\"图片\" title=\"中序遍历过程\"></p><p>相应的代码我也放在了下面，不过写法不限于这一种，有兴趣可以发挥自己的想象力，根据“左根右”这个遍历顺序写出不同的非递归遍历代码。</p><pre><code class=\"language-plain\">//非递归方式中序遍历二叉树\nvoid inOrder_noRecu()\n{\n\tinOrder_noRecu(root);\n}\nvoid inOrder_noRecu(BinaryTreeNode&lt;T&gt;* tRoot)\n{\n\tif (tRoot == nullptr)\n\t\treturn;\n\t\t\t\n\tLinkStack&lt; BinaryTreeNode&lt;T&gt;* &gt; slinkobj;\n\tslinkobj.Push(tRoot);//根节点入栈\n\t\t\n\tBinaryTreeNode&lt;T&gt;* tmpnode;\n\twhile (!slinkobj.Empty()) //栈不空\n\t{\t\t\t\t\n\t\twhile (tRoot-&gt;leftChild != nullptr)&nbsp;\n\t\t{\t\t\t\t\t\n\t\t\tslinkobj.Push(tRoot-&gt;leftChild);\t//将“当前节点的左节点”入栈\n\t\t\ttRoot = tRoot-&gt;leftChild; //将“当前节点的左节点”重新标记为当前节点。\n\t\t} //end while\n\t\t\t\n\t\tslinkobj.Pop(tmpnode); //对栈顶元素出栈(同时获取了栈顶元素)\n\t\tcout &lt;&lt; (char)tmpnode-&gt;data &lt;&lt; \" \";\n\t\t\t\n\t\t//查看右树\n\t\tif (tmpnode-&gt;rightChild != nullptr)\n\t\t{\t\t\t\t\t\n\t\t\ttRoot = tmpnode-&gt;rightChild;&nbsp; //将刚刚从栈顶出栈的元素的右节点标记为当前节点\n\t\t\tslinkobj.Push(tRoot); //右节点入栈\n\t\t}\n\t}//end while\n}\n</code></pre><p>增加下列测试代码。</p><pre><code class=\"language-plain\">cout &lt;&lt; \"非递归方式中序遍历序列为：\";\nmytree2.inOrder_noRecu();\ncout &lt;&lt; endl;\n</code></pre><p>新增代码的执行结果如下。<br>\n<img src=\"https://static001.geekbang.org/resource/image/ee/18/ee4681a18c304d429af4a6246f929818.jpg?wh=2838x132\" alt=\"\"></p><ul>\n<li><strong>后序遍历（左右根）</strong></li>\n</ul><p>后序遍历的实现比前序和中序遍历更繁琐一些。因为后序遍历的顺序是“左右根”，也就是说，<strong>是否访问某个节点，取决于当前访问完毕的是该节点的左子树还是右子树</strong>。</p><p>如果是左子树访问完毕，根据“左右根”的遍历顺序，必须去访问右子树，如果是右子树访问完毕，则就可以去访问该根节点。</p><p>因此，要实现这里的后序遍历，当将一个节点入栈的时候，必须<strong>同时标记后续入栈的是该节点的左子树还是右子树</strong>，这意味着需要将“<strong>节点指针和标记</strong>”同时入栈和出栈。</p><p>所以，前面代码中定义的用于表示树中每个节点的BinaryTreeNode类模板中，缺少了一个标记字段用来标记左右子树。</p><p>为了实现<strong>非递归后序遍历</strong>，可以考虑扩充BinaryTreeNode类模板的定义，也就是增加一个左右节点的标记，也可以定义一个新的类模板增加一个左右节点的标记，并将BinaryTreeNode类模板包含在其中。</p><p>这里采用后一种实现方式——在BinaryTreeNode类模板的实现代码之下，增加新的类模板BTNode_extra，实现代码如下。</p><pre><code class=\"language-plain\">//为实现二叉树的非递归后序遍历引入的新类模板\ntemplate &lt;typename T&gt; //T代表数据元素的类型\nstruct BTNode_extra\n{\n\tBinaryTreeNode&lt;T&gt; * point;\n\tECCHILDSIGN pointSign;\n};\n</code></pre><p>在这里先把后序遍历的过程描述一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/9d/2d/9db7a9684c2617fb69dfd48c0ab04b2d.jpg?wh=1920x1223\" alt=\"图片\" title=\"后序遍历过程\"></p><p>非递归方式后序遍历二叉树的代码如下。</p><pre><code class=\"language-plain\">//非递归后序遍历二叉树\nvoid postOrder_noRecu()\n{\n\tpostOrder_noRecu(root);\n}\nvoid postOrder_noRecu(BinaryTreeNode&lt;T&gt;* tRoot)\n{\n\tif (tRoot == nullptr)\n\t\treturn;\n\t\n\tLinkStack&lt; BTNode_extra&lt;T&gt; &gt; slinkobj;\n\tBTNode_extra&lt;T&gt; ext_tmpnode;\n\t\t\n\tdo\n\t{\n\t\twhile (tRoot != nullptr)\n\t\t{\n\t\t\text_tmpnode.point = tRoot;\n\t\t\text_tmpnode.pointSign = E_ChildLeft;&nbsp; //标记先处理该节点的左孩子\n\t\t\tslinkobj.Push(ext_tmpnode);\n\t\t\ttRoot = tRoot-&gt;leftChild;\n\t\t}\t\t\t\t\n\t\twhile (!slinkobj.Empty())\n\t\t{\n\t\t\tslinkobj.Pop(ext_tmpnode); //出栈\n\t\t\tif (ext_tmpnode.pointSign == E_ChildLeft)\n\t\t\t{\n\t\t\t\t//把左标记更改为右标记\n\t\t\t\text_tmpnode.pointSign = E_ChildRight; //标记该节点的右孩子\n\t\t\t\tslinkobj.Push(ext_tmpnode);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//重新入栈\t\t\t\t\t\t\t\t\t\t\n\t\t\t\ttRoot = ext_tmpnode.point-&gt;rightChild;\n\t\t\t\tbreak;&nbsp; //终止while循环\n\t\t\t}\n\t\t\telse //if (ext_tmpnode.pointSign == E_ChildRight) 肯定是右子树标记，所以这个if不需要\n\t\t\t{\n\t\t\t\t//根据左右根规则，右节点之后可以访问根节点\n\t\t\t\tcout &lt;&lt; (char)ext_tmpnode.point-&gt;data &lt;&lt; \" \";\n\t\t\t}\n\t\t} //end while\n\t} while (!slinkobj.Empty());\n}\n</code></pre><p>增加下列测试代码。</p><pre><code class=\"language-plain\">cout &lt;&lt; \"非递归方式后序遍历序列为：\";\nmytree2.postOrder_noRecu();\ncout &lt;&lt; endl;\n</code></pre><p>新增代码的执行结果如下。<br>\n<img src=\"https://static001.geekbang.org/resource/image/08/f9/0809106a804cdc5c1c69c711ed276bf9.jpg?wh=1920x88\" alt=\"图片\"></p><h3>通过遍历序列创建二叉树</h3><p>前面我们说过一个结论：<strong>已知前序和中序遍历序列，能够唯一确定一棵二叉树</strong>。那么，是否可以实现一个这样的成员函数，用来实现这棵二叉树的创建呢？</p><p>完全可以。在BinaryTree类模板的定义中实现，代码如下。</p><pre><code class=\"language-plain\">//如何根据前序、中序遍历序列来创建一棵二叉树呢？\t\n//pP_T：前序遍历序列，比如是“ABDCE”，pI_T：中序遍历序列，比如是“DBACE”\nvoid CreateBTreeAccordPI(char* pP_T, char* pI_T)&nbsp;\n{\n\tCreateBTreeAccordPI(root, pP_T, pI_T, strlen(pP_T));&nbsp;\n}\nvoid CreateBTreeAccordPI(BinaryTreeNode&lt;T&gt;*&amp; tnode, char* pP_T,char * pI_T,int n)//参数1为引用类型，确保递归调用中对参数的改变会影响到调用者,n:节点个数\n{\n\tif (n == 0)\n\t{\n\t\ttnode = nullptr;\n\t}\n\telse\n\t{\n\t\t//(1)在中序遍历序列中找根，前序遍历序列中根在最前面\n\t\tint tmpindex = 0;&nbsp; &nbsp;//下标\n\t\twhile (pP_T[0] != pI_T[tmpindex])\n\t\t\t++tmpindex;\n\t\t\t\t\n\t\ttnode = new BinaryTreeNode&lt;T&gt;; //创建根节点\n\t\ttnode-&gt;data = pI_T[tmpindex];&nbsp; //第一次tmpindex=2\n\t\t\n\t\t//(2)创建左孩子\n\t\tCreateBTreeAccordPI(\n\t\t\ttnode-&gt;leftChild,&nbsp; &nbsp;//创建左孩子\n\t\t\tpP_T + 1,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//找到前序遍历序列中左树开始节点的位置，这里跳过第一个（根）节点A，得到的是“BDCE”\n\t\t\tpI_T,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//不需要改动，仍旧是“DBACE”\n\t\t\ttmpindex&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //左孩子有2个节点&nbsp;\n\t\t);\n\t\t\n\t\t//(3)创建右孩子\n\t\tCreateBTreeAccordPI(\n\t\t\ttnode-&gt;rightChild,&nbsp; &nbsp;//创建右孩子\n\t\t\tpP_T + tmpindex + 1, //找到前序遍历系列中右树开始节点的位置，不难发现，前序遍历序列和中序遍历序列右树开始节点的位置相同，得到的是“CE”\n\t\t\tpI_T + tmpindex + 1, //找到中序遍历系列中右树开始节点的位置。得到的是“CE”\n\t\t\tn - tmpindex - 1&nbsp; &nbsp;//右孩子节点数\n\t\t);\n\t}\n}\n</code></pre><p>在main主函数中，把如下创建二叉树的代码行。</p><pre><code class=\"language-plain\">mytree2.CreateBTreeAccordPT((char *)\"ABD###C#E##\");\n</code></pre><p>替换为新的代码行来创建一棵图5左侧所示的二叉树。</p><pre><code class=\"language-plain\">mytree2.CreateBTreeAccordPI((char*)\"ABDCE\", (char*)\"DBACE\");\n</code></pre><p>发现二叉树创建成功。</p><h2>小结</h2><p>这节课，我们学习了二叉树的两种存储方式——顺序存储方式、链式存储方式，以及他们的实现方式。</p><p><strong>二叉树的顺序存储</strong>，是用一段连续的内存依次从上到下从左到右存储二叉树各个节点元素，但是很容易造成存储空间的浪费，因此顺序存储往往比较适合存储完全二叉树。</p><p><strong>二叉树的链式存储</strong>，需要存储额外的左右节点指针。虽然增加了存储的灵活性，但也消耗了更多的存储空间。链式存储方式中，还涉及到了二叉链表和三叉链表的概念。二叉链表的一个节点结构带有两根指针以指向左右孩子节点，而三叉链表中一个节点结构带有三根指针，其中第三个指针用于指向当前节点的父节点，这给找当前节点的父节点带来了最大的便利。</p><p>由于与顺序存储相比，二叉树链式存储更加常用，所以这节课我将重点放在了二叉树链式存储的常用操作。给出了创建树节点，获取二叉树的前序、中序、后序、层序遍历序列，获取二叉树节点个数，获取二叉树高度，查找某个节点，查找某个节点的父节点，树的拷贝等操作代码。这里要重点记忆二叉树前序、中序、后序遍历代码，理解性记忆层序遍历代码，以防在面试中出现。</p><p>此外，我们也利用非递归的编程方式实现了二叉树的前序、中序、后序遍历。注意，<strong>非递归的遍历操作需要借助栈来实现</strong>。这些代码需要我们简单理解、适当记忆，万一面试中出现，能说上几句就是好的。</p><p>最后，如何从无到有创建出一棵二叉树来呢？我们在最后用前序、中序遍历序列创建了一棵二叉树，这些代码都不复杂，但一定可以作为参考和借鉴，帮助你进一步拓展创建二叉树的思路。</p><h2>课后思考</h2><p>已知“<strong>中序和后序</strong>遍历序列”，也能够唯一确定一棵二叉树，请你尝试实现相关代码。</p><p>欢迎在留言区分享你的成果代码。如果觉得有所收获，也可以把课程分享给更多的朋友一起学习。我们下节课见！</p>","comments":[{"had_liked":false,"id":375771,"user_name":"Yj.yolo","can_delete":false,"product_type":"c1","uid":2814082,"ip_address":"广东","ucode":"0ED1B41F124061","user_header":"https://static001.geekbang.org/account/avatar/00/2a/f0/82/f235d91d.jpg","comment_is_top":false,"comment_ctime":1685955475,"is_pvip":false,"replies":[{"id":137161,"content":"加油努力","user_name":"作者回复","user_name_real":"编辑","uid":1104356,"ctime":1686135969,"ip_address":"广东","comment_id":375771,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"越来越觉得这门课是一门是非常值得研读的课，学到很多东西，越来越期待后面的内容了","like_count":1,"discussions":[{"author":{"id":1104356,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/e4/791d0f5e.jpg","nickname":"KuangXiang","note":"","ucode":"BEEB53A49BA695","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620407,"discussion_content":"加油努力","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686135969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375911,"user_name":"阿阳","can_delete":false,"product_type":"c1","uid":1165817,"ip_address":"江苏","ucode":"20A35FB86B1C5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/c9/f9/39492855.jpg","comment_is_top":false,"comment_ctime":1686123729,"is_pvip":false,"replies":[{"id":137181,"content":"每个对呀","user_name":"作者回复","user_name_real":"编辑","uid":1104356,"ctime":1686234161,"ip_address":"广东","comment_id":375911,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"老师，好，在判断是否完全二叉树的时候，在层序遍历的出队列判断：\nif(tmpnode-&gt;leftChild == nullptr &amp;&amp; tmpnode-&gt;rightChild != nullptr)\n{\n  &#47;&#47;这棵二叉树不是一棵完全二叉树。\n}\n如果一棵二叉树是左斜树，也不满足这个逻辑，但是左斜树不是完全二叉树。这样理解对吗？","like_count":0,"discussions":[{"author":{"id":1104356,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/e4/791d0f5e.jpg","nickname":"KuangXiang","note":"","ucode":"BEEB53A49BA695","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620517,"discussion_content":"每个对呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686234161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375548,"user_name":"阿阳","can_delete":false,"product_type":"c1","uid":1165817,"ip_address":"江苏","ucode":"20A35FB86B1C5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/c9/f9/39492855.jpg","comment_is_top":false,"comment_ctime":1685611555,"is_pvip":false,"replies":[{"id":137081,"content":"恭喜你慧眼识金，选择了这门课。😂😂","user_name":"作者回复","user_name_real":"编辑","uid":1104356,"ctime":1685629730,"ip_address":"广东","comment_id":375548,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"这节课内容真实太多了，两种存储方式，树的遍历，还有常用操作。干货满满。尤其是CreateNode的思路和使用扩展二叉树的前序遍历序列去创建二叉树，真是学习到了，解决了数据结构教材上没有具体实现的缺点。","like_count":0,"discussions":[{"author":{"id":1104356,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/e4/791d0f5e.jpg","nickname":"KuangXiang","note":"","ucode":"BEEB53A49BA695","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619946,"discussion_content":"恭喜你慧眼识金，选择了这门课。😂😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685629730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370815,"user_name":"wu526","can_delete":false,"product_type":"c1","uid":1022129,"ip_address":"上海","ucode":"69282EB175B48E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/b1/f89a84d0.jpg","comment_is_top":false,"comment_ctime":1679303091,"is_pvip":false,"replies":[{"id":135303,"content":"对，你看漏了，在CopyTree重载函数中，tTarget是个引用类型，你细看，他的前面有个&amp;符号呦。😸😸","user_name":"作者回复","user_name_real":"编辑","uid":1104356,"ctime":1679321755,"ip_address":"广东","comment_id":370815,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"CopyTree 的重载函数中，只复制了值，没有设置 tTarget的指针域，怎么也可以得到正确的结果呢？我是哪里看漏了吗，望老师解惑~\n","like_count":0,"discussions":[{"author":{"id":1104356,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/e4/791d0f5e.jpg","nickname":"KuangXiang","note":"","ucode":"BEEB53A49BA695","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609983,"discussion_content":"对，你看漏了，在CopyTree重载函数中，tTarget是个引用类型，你细看，他的前面有个&amp;符号呦。😸😸","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679321755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1022129,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/98/b1/f89a84d0.jpg","nickname":"wu526","note":"","ucode":"69282EB175B48E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1104356,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/e4/791d0f5e.jpg","nickname":"KuangXiang","note":"","ucode":"BEEB53A49BA695","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":609987,"discussion_content":"好的 谢谢老师～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679322970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":609983,"ip_address":"重庆","group_id":0},"score":609987,"extra":""}]}]},{"had_liked":false,"id":370208,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1678529436,"is_pvip":false,"replies":[{"id":134967,"content":"A1：链式是一种实现队列的方式，那你用数组也可以实现队列是吧，队列无非就是先进先出这种特性。当然也有双端队列循环队列等算是对基础队列功能的扩展，想了解可以通过搜索引擎查一下。\nA2：标准库没听说有针对二叉树操作的封装好的类或者API，因为一般人还真用不好这种接口。不过标准库中的MAP容器是用红黑树（二叉树的一种）这种数据结构存储数据的。\nA3：二叉树是个通称，后面你会学到各种二叉树比如红黑树等。许多用到红黑树的地方，比如LINUX上实现号称单机百万并发的epoll技术，刚才提到的map容器等，有兴趣在搜索引擎里搜一下“二叉树实际应用”这样的关键字即可找到很多结果。\nA4：没注意到哪里有限制二叉树大小，不过肯定有内存限制是吧。因为每个二叉树节点都占内存。当然，从实用角度一般几万到几十万个节点就差不多了吧。二叉树深度太深也很影响插入，查找，删除等效率是吧。\n我个人建议不用想那么多，用就是了。除非机器性能很吃紧让你不得不精打细算，不然还没听说过有什么限制。","user_name":"作者回复","user_name_real":"作者","uid":1104356,"ctime":1678544116,"ip_address":"广东","comment_id":370208,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"请教老师几个问题：\nQ1：除了链式队列，还有其他队列吗？\nQ2：二叉树操作，C++标准库有封装好的类或API吗？\n如果有，性能怎么样？\nQ3：二叉树的典型应用是什么？\nQ4：实际应用中，二叉树的大小有限制吗？一般多大？","like_count":0,"discussions":[{"author":{"id":1104356,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/e4/791d0f5e.jpg","nickname":"KuangXiang","note":"","ucode":"BEEB53A49BA695","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608612,"discussion_content":"A1：链式是一种实现队列的方式，那你用数组也可以实现队列是吧，队列无非就是先进先出这种特性。当然也有双端队列循环队列等算是对基础队列功能的扩展，想了解可以通过搜索引擎查一下。\nA2：标准库没听说有针对二叉树操作的封装好的类或者API，因为一般人还真用不好这种接口。不过标准库中的MAP容器是用红黑树（二叉树的一种）这种数据结构存储数据的。\nA3：二叉树是个通称，后面你会学到各种二叉树比如红黑树等。许多用到红黑树的地方，比如LINUX上实现号称单机百万并发的epoll技术，刚才提到的map容器等，有兴趣在搜索引擎里搜一下“二叉树实际应用”这样的关键字即可找到很多结果。\nA4：没注意到哪里有限制二叉树大小，不过肯定有内存限制是吧。因为每个二叉树节点都占内存。当然，从实用角度一般几万到几十万个节点就差不多了吧。二叉树深度太深也很影响插入，查找，删除等效率是吧。\n我个人建议不用想那么多，用就是了。除非机器性能很吃紧让你不得不精打细算，不然还没听说过有什么限制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678544116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":392205,"user_name":"Geek_845395","can_delete":false,"product_type":"c1","uid":3899042,"ip_address":"四川","ucode":"F31AF3B562323E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELibhkZWN1BqDCeTKJdtu0UfbHNQ1KnjmOE4Zsy05nEyUKQ5AjTdh29iaGFAoXk2ic6juxI2Gxr294LzzUfIDI9YRgPCbfY84PKp9RuXXqFGibLCw/132","comment_is_top":false,"comment_ctime":1720254966,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"王老师，请问一下\n\n\n&#47;&#47;获取某个节点所在的高度：\n\t&#47;&#47;根据二叉树性质五：具有n（n &gt; 0）个节点的完全二叉树的高度为⌈log(⁡n + 1)⌉或者⌊log(⁡n)⌋ + 1。这里的对数都是以2为底\n\tint getPointLevel(int index)\n\t{\n\t\tif (ifValidRangeIdx(index) == false) &#47;&#47;位置不合理\n\t\t\treturn -1;\n\n\t\tif (SqBiTree[index].isValid == false)&#47;&#47;不是个合理的节点，不要尝试找父节点\n\t\t\treturn -1;\n\n\t\t&#47;&#47;采用公式⌊log(n)⌋ + 1\n\t\tint level = int(log(index) &#47; log(2) + 1);&#47;&#47;c++中的log（n）函数求的是以e(2.71828)为底的对数值，如果要求以数字m为底的对数值，则需要log(n)&#47;log(m)\n\n\t\treturn level;\n\t}\n\n您的这段代码，是不是既可以求某个节点的高度，也可以求整个树的高度呢？ 如果一个完全二叉树的总节点是10，那么代码就是 int(log(10)&#47;log(2),如果我只想求它的第五个节点的高度，代码就写成int(log(5)&#47;log(2)\n\n对吗老师\n","like_count":0},{"had_liked":false,"id":386324,"user_name":"Geek_5ddd2e","can_delete":false,"product_type":"c1","uid":3803927,"ip_address":"重庆","ucode":"50D5D3FA897E8F","user_header":"","comment_is_top":false,"comment_ctime":1704583292,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"这节课开始难度”嗖“地一下上来了&#47;哭","like_count":0}]}