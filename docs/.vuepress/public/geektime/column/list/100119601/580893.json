{"id":580893,"title":"20｜大型项目：源码越来越多，项目该如何扩展？","content":"<p>你好，我是宋一玮，欢迎回到React应用开发的学习。</p><p>上节课提到，为了应对大中型React项目的复杂应用逻辑，我们会分为<strong>局部</strong>和<strong>整体</strong>两个部分来学习。对于作为局部的组件逻辑，可以通过抽象来简化组件的设计和开发。我们学习了React中的自定义Hooks和组件组合这两种抽象方式，也学习了在这两种抽象基础上的代码复用，尤其是高阶组件的写法。</p><p>从局部到整体，复杂度会在代码量上直观地展现出来。在前端工程化和团队协作的基础上，大型React项目代码量上10万很常见。项目从最初的几行代码到如今的数十万代码，你可能会遇到如下问题：</p><ul>\n<li>新功能的组件、Hooks、样式要不要分文件写，源文件都放到哪里？</li>\n<li>Redux的action、reducer、store都写到哪里？</li>\n<li>公共的代码放到哪里？</li>\n<li>代码文件多到找不到怎么办？</li>\n</ul><p>这节课我们会继续讨论React应用的整体逻辑，看看大中型React项目在代码增多后，整体扩展上会遇到的挑战，以及如何应对这些挑战。</p><h2>几种典型的React项目文件目录结构</h2><p>项目源码的文件目录结构并不等同于应用的整体逻辑，但却可以<strong>作为把握应用整体逻辑的一张“地图”</strong>。一个良好的文件目录结构是<strong>自解释</strong>的，可以帮助新接触项目的开发者快速熟悉代码逻辑。</p><!-- [[[read_end]]] --><p>React应用项目有以下五种典型的文件目录结构：</p><ul>\n<li>单文件结构；</li>\n<li>单目录结构；</li>\n<li>按文件职能划分目录结构；</li>\n<li>按组件划分目录结构；</li>\n<li>按业务功能划分目录结构。</li>\n</ul><p>接下来我们分别看一下。</p><h3>单文件结构</h3><p>是的，你没看错，单文件结构就是指，在单个React组件文件中开发所有业务逻辑。</p><p>你肯定亲眼见过这种结构，比如在<a href=\"https://time.geekbang.org/column/article/553817?\">第3节课</a>里CRA创建的 <code>oh-my-kanban</code> 项目，不算样式的话，我们当时把所有代码都写在了 <code>src/app.js</code> 中。需要注意的是，这种结构只适合代码演示或微型的React项目。</p><h3>单目录结构</h3><p>比起单文件结构，这种结构拆分了组件文件，拆分的文件都放在同一个目录下。前面<a href=\"https://time.geekbang.org/column/article/571276\">第12节课</a>末尾，<code>oh-my-kanban</code> 项目完成大重构第一步时的项目结构就是这样。目录树结构（有省略）如下：</p><pre><code class=\"language-plain\">src\n├── App.css\n├── App.js\n├── KanbanBoard.js\n├── KanbanCard.js\n├── KanbanColumn.js\n├── KanbanNewCard.js\n├── index.css\n└── index.js\n</code></pre><p>单目录结构比起单文件结构，能支撑更多组件以及相关逻辑，适合微型React项目。</p><h3>按文件职能划分目录结构</h3><p>顾名思义，在这种结构下，组件文件放一个目录，自定义Hooks文件放一个目录，context文件放一个目录，如果使用了Redux的话，actions、reducers、store各占一个目录（或者Redux Toolkit的slices和store目录）。</p><p><a href=\"https://time.geekbang.org/column/article/574161\">在第13节课</a>，<code>oh-my-kanban</code> 项目完成大重构后，加入的第一个context就放到了独立的 <code>src/context</code> 目录。不只JS项目，在第18节课，我们尝试为TS项目加入的类型定义<code>src/types/KanbanCard.types.ts</code> ，也放到了专门的 <code>types</code> 目录下。目录树结构（有省略）如下：</p><pre><code class=\"language-plain\">src\n├── components\n│&nbsp; &nbsp;├── App.css\n│&nbsp; &nbsp;├── App.tsx\n│&nbsp; &nbsp;├── KanbanBoard.tsx\n│&nbsp; &nbsp;├── KanbanCard.tsx\n│&nbsp; &nbsp;├── KanbanColumn.tsx\n│&nbsp; &nbsp;└── KanbanNewCard.tsx\n├── context\n│&nbsp; &nbsp;└── AdminContext.ts\n├── hooks\n│&nbsp; &nbsp;└── useFetchCards.ts\n├── types\n│   └── KanbanCard.types.ts\n├── index.css\n└── index.tsx\n</code></pre><p>按文件职能划分目录结构的优点在于，可以快速定位任何一种类型的源码，在源码之间导入导出也比较方便：</p><pre><code class=\"language-typescript\">// src/components/App.tsx\nimport AdminContext from '../context/AdminContext';\n</code></pre><p>当其中某个或者某几个目录中的文件数不断增多时，这种结构的缺点就暴露出来了：不容易定位到直接相关的源文件。比如 <code>hooks/useFetchCards.ts</code> 目前只有 <code>components/App.tsx</code> 在用，这从目录结构上是看不出来的，必须进到源码里去看，当 <code>components</code> 目录下的文件足够多时，要花些功夫才能确认这两个文件的关联关系。</p><h3>按组件划分目录结构</h3><p>这种目录结构为每个组件都划分了一个独立、平级的目录，只要跟这个组件强相关，都往这个目录里招呼。这种设计出于两个考虑：</p><ul>\n<li>React的基本开发单元是组件；</li>\n<li>同一组件的相关代码要尽量<strong>共置</strong>（<strong>Colocation</strong>，这里翻译成“托管”不太合适）。<br>\n目录树结构的例子如下：</li>\n</ul><pre><code class=\"language-plain\">src\n├── components\n│   ├── App\n│   │   ├── AdminContext.js\n│   │   ├── App.css\n│   │   ├── App.jsx\n│   │   ├── App.test.jsx\n│   │   ├── index.js\n│   │   └── useFetchCards.js\n│   ├── KanbanBoard\n│   │   ├── KanbanBoard.css\n│   │   ├── KanbanBoard.jsx\n│   │   └── index.js\n│   ├── KanbanCard\n│   │   ├── KanbanCard.css\n│   │   ├── KanbanCard.jsx\n│   │   ├── KanbanNewCard.jsx\n│   │   └── index.js\n│   └── KanbanColumn\n│       ├── KanbanColumn.css\n│       ├── KanbanColumn.jsx\n│       └── index.js\n├── index.css\n└── index.jsx\n</code></pre><p>在每个目录中都有一个 <code>index.js</code> ，负责把当前目录的组件重新导出（Re-export）到目录外面去，这样其他组件在导入这个组件时，不需要关心目录里都有哪些实现，只关注作为入口的 <code>index.js</code> 就行。入口文件示意代码如下：</p><pre><code class=\"language-javascript\">// src/components/KanbanCard/index.js\nexport { default as KanbanCard } from './KanbanCard.jsx';\nexport { default as KanbanNewCard } from './KanbanNewCard.jsx';\n</code></pre><p>这种目录结构的优势在于，能为特定组件提供一定的封装性，在它专属的目录中能找到它强相关的所有代码。但它也有不足，面对一些跨组件复用的逻辑，可能会出现放到哪个组件目录都不太合适的窘境。</p><h3>按业务功能划分目录结构</h3><p>按业务功能划分目录结构，它与我们刚刚讲过的结构都不同，意味着目录划分的主要依据不再是具体框架中的某个具体技术概念（包括React的组件、Hooks、context，也包括Redux的action、reducer、store）。这使得按业务功能划分目录结构成为一个框架无关的方案，也就是说，其他框架的应用也可以利用这种目录结构。</p><p>目录树结构的例子如下：</p><pre><code class=\"language-plain\">src\n├── features\n│&nbsp; &nbsp;├── admin\n│&nbsp; &nbsp;│&nbsp; &nbsp;├── AdminContext.js\n│&nbsp; &nbsp;│&nbsp; &nbsp;├── AdminDashboard.jsx\n│&nbsp; &nbsp;│&nbsp; &nbsp;├── AdminSettings.jsx\n│&nbsp; &nbsp;│&nbsp; &nbsp;└── index.js\n│&nbsp; &nbsp;├── kanban\n│&nbsp; &nbsp;│&nbsp; &nbsp;├── KanbanBoard.jsx\n│&nbsp; &nbsp;│&nbsp; &nbsp;├── KanbanCard.jsx\n│&nbsp; &nbsp;│&nbsp; &nbsp;├── KanbanColumn.jsx\n│&nbsp; &nbsp;│&nbsp; &nbsp;├── KanbanNewCard.jsx\n│&nbsp; &nbsp;│&nbsp; &nbsp;├── index.js\n│&nbsp; &nbsp;│&nbsp; &nbsp;└── useFetchCards.js\n│&nbsp; &nbsp;├── login\n│&nbsp; &nbsp;│&nbsp; &nbsp;├── Login.css\n│&nbsp; &nbsp;│&nbsp; &nbsp;├── Login.jsx\n│&nbsp; &nbsp;│&nbsp; &nbsp;├── LoginForm.jsx\n│&nbsp; &nbsp;│&nbsp; &nbsp;└── index.js\n│&nbsp; &nbsp;└── user\n│&nbsp; &nbsp; &nbsp; &nbsp;├── Password.jsx\n│&nbsp; &nbsp; &nbsp; &nbsp;├── UserProfile.jsx\n│&nbsp; &nbsp; &nbsp; &nbsp;├── UserSettings.jsx\n│&nbsp; &nbsp; &nbsp; &nbsp;└── index.js\n├── index.css\n└── index.jsx\n</code></pre><p>按业务功能划分目录结构可以说，它是这五种结构中最适合大中型React项目的。它既强调了相关源文件的共置，也在增加业务功能时具有良好的可扩展性。但它也具有与按组件划分目录结构类似的缺点，面对一些跨业务功能复用的逻辑，放在哪个业务目录下都不太合适。</p><h3>如何选取合适的文件目录结构？</h3><p>可以参考以下表格：</p><p><img src=\"https://static001.geekbang.org/resource/image/42/65/42ac6b3fe5ae14de728e6fda01a0d165.jpg?wh=1920x738\" alt=\"图片\"></p><h2>前端应用逻辑架构的功用</h2><p>当提到React应用的整体逻辑时，不知你是否还记得<a href=\"https://time.geekbang.org/column/article/553795\">第2节课</a>这张应用逻辑架构图：</p><p><img src=\"https://static001.geekbang.org/resource/image/e9/40/e9b6711982510ef67fb690b8ddca9f40.jpg?wh=1920x1029\" alt=\"图片\"></p><p>我工作早些年间，流行的开发流程是瀑布式开发（Waterfall Model），当时的概要设计阶段和详细设计阶段，对设计文档尤其是架构图的要求非常严格（我画的这种五颜六色的图……基本会被驳回重画）。近些年软件行业追求效率，敏捷开发已经成为主流，但敏捷开发并没有拒绝文档化，也绝不应该被当作拒绝架构设计的借口。</p><p>无论是否精确、美观，这样的架构图<strong>有助于我们把握项目的整体走向</strong>，对于大中型React项目而言是一个值得的先期投入。</p><p>也许你会问：“架构图应该是由架构师来画吧？”</p><p>我会这样理解这个事情：架构设计是一项工作、一项技能，而架构师是一个职位，两者间没有直接的等号。以我个人的经历举例，我参加工作后画的第一张架构图，那是在工作第二年。后来那张图有幸被用到了几场技术评审中，在与技术Leaders交流的过程中起了大作用，反过来也让我学到了很多。当然，这纯粹是我的个人理解，具体情况因人而异。</p><p>你的下一个问题大概是：“好的，我知道架构图有用了，那具体来说，画架构图对文件目录结构有什么用？”</p><p>因为前面提到了：</p><blockquote>\n<p>项目源码的文件目录结构并不等同于应用的整体逻辑，但却可以作为把握应用整体逻辑的一张“地图”。</p>\n</blockquote><p>那么应用逻辑架构图就可以当作是<strong>“地图”的“地图”</strong>。</p><p>下面马上来了解一下，我们为大中型React项目推荐的文件目录结构，也看看跟上面的应用逻辑架构图有什么样的对应关系。</p><h2>大中型React项目推荐的文件目录结构</h2><p>当React项目规模属于中型或大型时，文件目录结构需要满足以下几个目标：</p><ul>\n<li>便于横向扩展（即增加新功能点或视图）；</li>\n<li>易于定位相关代码；</li>\n<li>鼓励代码复用；</li>\n<li>有利于团队协作。</li>\n</ul><p>为了满足上面的目标，我推荐你以<strong>按业务功能划分为主，结合按组件、按文件职能的方式，划分目录结构</strong>。</p><p>参考的目录树结构（有省略）如下：</p><pre><code class=\"language-plain\">src\n├── components\n│&nbsp; &nbsp;├── Button\n│&nbsp; &nbsp;├── Dialog\n│   ├── ErrorBoundary\n│   ├── Form\n│   │   ├── Form.css\n│   │   ├── FormField.jsx\n│   │   ├── Form.jsx\n│   │   └── index.js\n│&nbsp; &nbsp;├── ...\n│   └── Tooltip\n├── context\n│&nbsp; &nbsp;├── ...\n│&nbsp; &nbsp;└── UserContext.js\n├── features\n│   ├── admin\n│   ├── dashboard\n│   │   ├── activies\n│   │   │   └── ActivityList.jsx\n│   │   ├── charts\n│   │   │   └── ...\n│   │   ├── news\n│   │   │   ├── news.png\n│   │   │   ├── NewsDetail.jsx\n│   │   │   └── NewsList.jsx\n│   │   ├── Dashboard.css\n│   │   ├── Dashboard.jsx\n│   │   └── index.js\n│   ├── kanban\n│   │   ├── KanbanBoard.jsx\n│   │   ├── index.js\n│   │   └── useFetchCards.js\n│   ├── home\n│   ├── login\n│   ├── ...\n│   └── user\n├── hooks\n│&nbsp; &nbsp;├── ...\n│&nbsp; &nbsp;└── useLocation.js\n├── servies\n│&nbsp; &nbsp;├── kanbanService.js\n│&nbsp; &nbsp;├── ...\n│   └── userService.js\n├── index.css\n└── index.jsx\n</code></pre><p>对应上面的例子，首先建立 <code>features</code> 目录， <code>features</code> 下面的一级目录都对应一个相对完整的业务功能，目录中有实现这一功能的各类代码。</p><p>对于部分体量比较大的功能，可以根据需要在一级目录下加入二级目录，每个二级目录都对应一个相对独立的子功能（业务），目录内部是实现子功能的各类代码。必要时还可以加入三级、四级目录，但总体目录层级不应过深。所以我们说，在 <code>features</code> 目录，可以从横向、纵向两个方向扩展功能点。</p><p>在 <code>features</code> 目录之外，为公用的代码建立一系列职能型的目录，包括可重用组件的 <code>components</code> 目录、可重用Hooks的 <code>hooks</code> 目录； <code>context</code> 目录的主要目的不是重用，而是跨业务功能使用context； <code>services</code> 目录下，集中定义了整个应用会用到的远程服务，避免四散到各个业务模块中，甚至硬编码（Hardcode）。这些公用代码的目录层级不宜太深，以一到二级为主。</p><p>从代码的导入导出关系来看，在 <code>features</code> 目录下，原则上同级目录间的文件不应互相导入，二级、三级目录只应被直接上一级目录导入，不能反过来被下一级目录导入。<code>features</code> 目录的代码可以导入公用目录的代码，反过来公用目录的代码不能导入<code>features</code> 目录的代码。在任何时候都应该避免循环导入（Circular Import）。</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/f4/7b07ff63751913yyaba2c770a89295f4.jpg?wh=1920x954\" alt=\"图片\"></p><p>来对应一下前面的逻辑架构图：</p><ul>\n<li>图中的功能模块1、功能模块2再到功能模块m这一行，可以对应到features目录；</li>\n<li>图中的服务器通信、前端路由、表单处理、错误处理这一行，可以分别对应到公用的services目录、hooks目录、components目录；</li>\n<li>虽然在目录结构中没有体现，但用户认证、用户授权、前端监控等，也可以放到公用目录中实现。</li>\n</ul><p>这节课到目前为止讲到的目录结构，都是以单个React项目为前提的。</p><p>根据实际项目需要，也有很多React项目使用了多项目或者monorepo的方式来开发和扩展，虽然编译构建、CI/CD更加复杂了，但更有利于多个团队的协作，提高整体开发效率。在这样的实践中，可以把追加功能点到同一个React项目（或monorepo的包）看作纵向扩展，把特定模块、可复用组件和逻辑抽取为独立React项目（或monorepo的包）看作横向扩展。</p><h3>模块导入路径过长怎么办？</h3><p>在大中型React项目中，有时会遇到这样的import语句：</p><pre><code class=\"language-typescript\">// src/a/b/c/d/e/f/g/h/MyComponent.jsx\nimport Dialog from '../../../../../../../../components/Dialog';\n</code></pre><p>这种情况，首先要确定MyComponent.jsx是否真有必要放到这么深的路径下。如果发现这在项目中是个普遍情况，那可以利用Node.js的<a href=\"https://nodejs.org/dist/latest-v16.x/docs/api/packages.html#subpath-imports\">Subpath Imports</a>功能（<a href=\"https://github.com/vitejs/vite/pull/7770\">Vite中尚未支持</a>），或是由前端构建工具提供的非标准的module别名（Alias）功能。</p><pre><code class=\"language-typescript\">// Subpath Imports\nimport Dialog from '#components/Dialog';\n\n// Alias\nimport Dialog from '@components/Dialog';\n</code></pre><h2>小结</h2><p>今天这节课，我们了解了如何从整体层面应对大中型React应用逻辑的扩展，学习了5种典型的React项目文件目录结构，对比了它们各自的优劣势和适用项目规模。</p><p>然后学习了以按业务功能划分为主，结合按组件、按文件职能划分的目录结构的方式，来应对大中型React项目。同时也强调了前端应用逻辑架构对应用逻辑扩展的指导作用。</p><p>专栏的第三模块到目前为止，我们已经学习了大中型React项目的数据流、局部和整体逻辑的相关实践。</p><p>下节课我们会暂时从应用业务开发中跳出来，了解一下常见的React性能问题和优化方案。这些性能优化方案对各种规模的React应用基本都适用，目标都是保证优秀的用户体验。</p><h2>思考题</h2><ol>\n<li>\n<p>其实在业界，React项目中经常会有一个名叫 <code>common</code> 的目录。如果在这节课里讲到的，大中型React项目推荐的文件目录结构中，设置一个这样的 <code>common</code> 目录，你会往这个目录里放什么文件？不放什么文件？为什么？</p>\n</li>\n<li>\n<p>在<a href=\"https://time.geekbang.org/column/article/561203?\">第5节课</a>的思考题中：</p>\n</li>\n</ol><blockquote>\n<p>除了浏览器，你在电脑上最常用的桌面应用是什么？是不是macOS的<strong>Finder</strong>或Windows的<strong>资源管理器</strong>？<br>\n如果是的话就好办了。请你尝试把Finder或资源管理器当作要用React开发的Web应用，按自己的理解做一遍组件拆分。</p>\n</blockquote><p>现在已知Finder或资源管理器是大型React项目，请你为这个项目设计一套文件目录结构，记得把自己在第5节课设计的组件文件都放进去。</p>","comments":[{"had_liked":false,"id":359949,"user_name":"船长","can_delete":false,"product_type":"c1","uid":3170712,"ip_address":"北京","ucode":"EBC0CCDB341E35","user_header":"https://static001.geekbang.org/account/avatar/00/30/61/98/0d6b499d.jpg","comment_is_top":false,"comment_ctime":1666087403,"is_pvip":false,"replies":[{"id":131355,"content":"你好，船长，我看过了你的demo和源码，非常棒！这是到目前为止专栏留言区里最完整的思考题答案了，感谢你的积极和认真。\n\n确实像你说的，目前这个项目相对简单，还不需要使用更加复杂的文件目录结构。你这样的设计恰到好处，尤其是components和pages目录的分工明确，对后续扩展和维护会有很大帮助。\n\n看到你的代码使用了TailwindCSS，是很棒的样式技术。\n\n另外我对Finder首页代码有个小建议： https:&#47;&#47;github.com&#47;TanGuangZhi&#47;ReactLearn&#47;blob&#47;main&#47;src&#47;pages&#47;YeahMyKanBan&#47;FinderSimulate&#47;index.tsx#L18-L25 的 getColumnData 函数可以声明在 useUpdateEffect 回调函数的内部，这样做代码逻辑上并没有什么区别，但可以避免每次组件重新渲染时都创建一个新函数出来，算是一个小优化。","user_name":"作者回复","user_name_real":"编辑","uid":1033973,"ctime":1667282018,"ip_address":"北京","comment_id":359949,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100119601,"comment_content":"模拟的 Finder 目录结构，原本想采用按【业务功能】拆分的结构的，但做的过程中发现项目比较简单，采用这种模式反而会复杂，于是采用了按【文件职能】拆分的结构，结构如下：\n YeahMyKanBan\n│   │       └── FinderSimulate\n│   │           ├── components\n│   │           │   ├── Column.tsx\n│   │           │   ├── CommonCard.tsx\n│   │           │   └── SystemOperate.tsx\n│   │           ├── context\n│   │           │   └── myContext.ts\n│   │           ├── index.tsx\n│   │           └── pages\n│   │               ├── HeaderMenu.tsx\n│   │               ├── LeftMenu.tsx\n│   │               └── MainContent.tsx\n后面用了 vercel 进行了部署（codesanbox 部署 umi 项目有问题）\n在线预览：🔗 https:&#47;&#47;react-learn2-orpin.vercel.app&#47;YeahMyKanBan&#47;FinderSimulate\n源码地址：https:&#47;&#47;github.com&#47;TanGuangZhi&#47;ReactLearn&#47;tree&#47;main&#47;src&#47;pages&#47;YeahMyKanBan&#47;FinderSimulate","like_count":3,"discussions":[{"author":{"id":3170712,"avatar":"https://static001.geekbang.org/account/avatar/00/30/61/98/0d6b499d.jpg","nickname":"船长","note":"","ucode":"EBC0CCDB341E35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592316,"discussion_content":"哈哈，谢谢宋老师的鼓励，优化的这个问题我以后再优化代码时会注意，但现在这个项目就不优化啦，毕竟&#34;过早的优化是万恶之源&#34;，在初期写代码的时候这些优化还没形成肌肉记忆，会挤兑工作记忆，影响心流","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1667302667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1033973,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c6/f5/dae613e0.jpg","nickname":"宋一玮","note":"","ucode":"55E5B710556C1E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592278,"discussion_content":"你好，船长，我看过了你的demo和源码，非常棒！这是到目前为止专栏留言区里最完整的思考题答案了，感谢你的积极和认真。\n\n确实像你说的，目前这个项目相对简单，还不需要使用更加复杂的文件目录结构。你这样的设计恰到好处，尤其是components和pages目录的分工明确，对后续扩展和维护会有很大帮助。\n\n看到你的代码使用了TailwindCSS，是很棒的样式技术。\n\n另外我对Finder首页代码有个小建议： https://github.com/TanGuangZhi/ReactLearn/blob/main/src/pages/YeahMyKanBan/FinderSimulate/index.tsx#L18-L25 的 getColumnData 函数可以声明在 useUpdateEffect 回调函数的内部，这样做代码逻辑上并没有什么区别，但可以避免每次组件重新渲染时都创建一个新函数出来，算是一个小优化。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1667282018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359954,"user_name":"船长","can_delete":false,"product_type":"c1","uid":3170712,"ip_address":"北京","ucode":"EBC0CCDB341E35","user_header":"https://static001.geekbang.org/account/avatar/00/30/61/98/0d6b499d.jpg","comment_is_top":false,"comment_ctime":1666088546,"is_pvip":false,"replies":[{"id":131356,"content":"你好，船长，很棒的答案，“Finder 项目的 左上角最大最小化按钮”确实是个很典型的例子。","user_name":"作者回复","user_name_real":"编辑","uid":1033973,"ctime":1667282292,"ip_address":"北京","comment_id":359954,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100119601,"comment_content":"common 文件夹顾名思义是放公共文件、可复用逻辑的地方，比如网站的 Header，Footer，公共 util 等。\n比如本次 Finder 项目的 左上角最大最小化按钮就应属于 common 目录的一部分，应为不止 Finder 用到了，macos 下所有的窗口都有这部分","like_count":1,"discussions":[{"author":{"id":1033973,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c6/f5/dae613e0.jpg","nickname":"宋一玮","note":"","ucode":"55E5B710556C1E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592279,"discussion_content":"你好，船长，很棒的答案，“Finder 项目的 左上角最大最小化按钮”确实是个很典型的例子。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667282292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359950,"user_name":"船长","can_delete":false,"product_type":"c1","uid":3170712,"ip_address":"美国","ucode":"EBC0CCDB341E35","user_header":"https://static001.geekbang.org/account/avatar/00/30/61/98/0d6b499d.jpg","comment_is_top":false,"comment_ctime":1666087784,"is_pvip":false,"replies":[{"id":131087,"content":"你好，船长，你的第一种写法相当于在组件内动态定义了一个组件，而函数组件每次渲染都会执行整个函数，意味着每次都会新定义一个SearchForm组件，然后加入到渲染中。\n\nReact在重新渲染时会根据组件类型确定有哪个虚拟DOM（FiberNode）是可以复用的，然而每次渲染都定义新组件会导致React每次都新建虚拟DOM，最终销毁并新建真实DOM，导致失去焦点。\n\n我从你的codesandbox fork了一份，把SearchForm组件定义在主组件外面就好了：  https:&#47;&#47;codesandbox.io&#47;s&#47;affectionate-water-jdrhfz?file=&#47;App.tsx","user_name":"作者回复","user_name_real":"编辑","uid":1033973,"ctime":1666538891,"ip_address":"美国","comment_id":359950,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100119601,"comment_content":"在写这个 demo 的时候想起之前困惑的一个问题，想请教下宋老师，即在 jsx 中 &lt;childComponent&#47;&gt; 与 childComponent() 这 2 种调用组件的方式有什么区别？\n这是一个 demo，上面的输入框是用&lt;childComponent&#47;&gt;这种方式调用的，在输入时会有个输入框失焦的问题，下面用childComponent() 调用的就没这个问题。\ndemo 地址：https:&#47;&#47;codesandbox.io&#47;s&#47;fervent-ishizaka-mwusdq?file=&#47;App.tsx），","like_count":1,"discussions":[{"author":{"id":1033973,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c6/f5/dae613e0.jpg","nickname":"宋一玮","note":"","ucode":"55E5B710556C1E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591368,"discussion_content":"你好，船长，你的第一种写法相当于在组件内动态定义了一个组件，而函数组件每次渲染都会执行整个函数，意味着每次都会新定义一个SearchForm组件，然后加入到渲染中。\n\nReact在重新渲染时会根据组件类型确定有哪个虚拟DOM（FiberNode）是可以复用的，然而每次渲染都定义新组件会导致React每次都新建虚拟DOM，最终销毁并新建真实DOM，导致失去焦点。\n\n我从你的codesandbox fork了一份，把SearchForm组件定义在主组件外面就好了：  https://codesandbox.io/s/affectionate-water-jdrhfz?file=/App.tsx","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1666538891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"美国","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1034451,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c8/d3/3020ae46.jpg","nickname":"fatme","note":"","ucode":"75A805D2BB2AD1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591191,"discussion_content":"代码上的原因找到了，是因为 SearchForm 用了函数内部变量去实现。如果把 SearchForm 提到外面，那么就不会再失焦了。原理上的解释，我猜想 run 导致了父组件重新渲染，进一步导致子组件重新渲染。但 SearchForm 是内部变量，每一次都是一个不同的函数对象，这样导致 react 协调的 Diffing Algorithm 把前后两个 SearchForm 当作不同的组件类型，所以每次 SearchForm 的渲染都会更新 dom，这样焦点就失去了。而 {searchForm2} 就不会有这样的问题。但是这个解释好像解释不了我做的实验 1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666348565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1034451,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c8/d3/3020ae46.jpg","nickname":"fatme","note":"","ucode":"75A805D2BB2AD1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591154,"discussion_content":"似乎与组件和 hooks 的实现有关。在你的代码上做了两个实验，\n1. 把 56 行 searchForm2 里面的 run(...) 注释掉，这样第一个 &lt;SearchForm /&gt; 就不会失焦了\n2. 在第 1 点的代码基础上继续修改，删掉 69 行 {searchForm2} ，此时失焦再次出现了\n\n再补充一下，失焦的触发是因为在输入过程中，两次按键的间隔超过了 debounceWait: 300 的设定。可以把 debounceWait 改为 3000，这样两次按键之间要等待更长的时间才会出现失焦。希望以上线索可以帮助你找到问题所在。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666328970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":3170712,"avatar":"https://static001.geekbang.org/account/avatar/00/30/61/98/0d6b499d.jpg","nickname":"船长","note":"","ucode":"EBC0CCDB341E35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1034451,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c8/d3/3020ae46.jpg","nickname":"fatme","note":"","ucode":"75A805D2BB2AD1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591185,"discussion_content":"谢谢 fatme 的回答，按照你的提示我尝试了下，失焦确实又出现了，我感觉是因为子组件调用的父组件的 run 方法，然后触发父子组件重新渲染，导致失焦问题（不知道正确原因是不是这样）。\n\n但是我不能将 debounceWait 改那么大，我的本意是在用户输入的过程，当 form 表单的值改变（即 onchange），就自动触发查询，不用再手动点击查询按钮。\n\n最后：之前的例子表述可能不够清晰，我再次更新了下例子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666343497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":591154,"ip_address":"上海","group_id":0},"score":591185,"extra":""}]}]}]}