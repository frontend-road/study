{"id":178940,"title":"10 | 到底应不应该返回对象？","content":"<p>你好，我是吴咏炜。</p><p>前几讲里我们已经约略地提到了返回对象的问题，本讲里我们进一步展开这个话题，把返回对象这个问题讲深讲透。</p><h2>F.20</h2><p>《C++ 核心指南》的 F.20 这一条款是这么说的 <span class=\"orange\">[1]</span>：</p><blockquote>\n<p>F.20: For “out” output values, prefer return values to output parameters</p>\n</blockquote><p>翻译一下：</p><blockquote>\n<p>在函数输出数值时，尽量使用返回值而非输出参数</p>\n</blockquote><p>这条可能会让一些 C++ 老手感到惊讶——在 C++11 之前的实践里，我们完全是采用相反的做法的啊！</p><p>在解释 F.20 之前，我们先来看看我们之前的做法。</p><h3>调用者负责管理内存，接口负责生成</h3><p>一种常见的做法是，接口的调用者负责分配一个对象所需的内存并负责其生命周期，接口负责生成或修改该对象。这种做法意味着对象可以默认构造（甚至只是一个结构），代码一般使用错误码而非异常。</p><p>示例代码如下：</p><pre><code class=\"language-c++\">MyObj obj;\nec = initialize(&amp;obj);\n…\n</code></pre><p>这种做法和 C 是兼容的，很多程序员出于惯性也沿用了 C 的这种做法。一种略为 C++ 点的做法是使用引用代替指针，这样在上面的示例中就不需要使用 <code>&amp;</code> 运算符了；但这样只是语法略有区别，本质完全相同。如果对象有合理的析构函数的话，那这种做法的主要问题是啰嗦、难于组合。你需要写更多的代码行，使用更多的中间变量，也就更容易犯错误。</p><!-- [[[read_end]]] --><p>假如我们已有矩阵变量 $\\mathbf{A}$、$\\mathbf{B}$ 和 $\\mathbf{C}$，要执行一个操作</p><p>$$<br>\n\\mathbf{R} = \\mathbf{A} \\times \\mathbf{B} + \\mathbf{C}<br>\n$$</p><p>那在这种做法下代码大概会写成：</p><pre><code class=\"language-c++\">error_code_t add(\n  matrix* result,\n  const matrix&amp; lhs,\n  const matrix&amp; rhs);\nerror_code_t multiply(\n  matrix* result,\n  const matrix&amp; lhs,\n  const matrix&amp; rhs);\n…\n  error_code_t ec;\n  …\n  matrix temp;\n  ec = multiply(&amp;temp, a, b);\n  if (ec != SUCCESS) {\n    goto end;\n  }\n  matrix r;\n  ec = add(&amp;r, temp, c);\n  if (ec != SUCCESS) {\n    goto end;\n  }\n  …\nend:\n  // 返回 ec 或类似错误处理\n</code></pre><p>理论上该方法可以有一个变体，不使用返回值，而使用异常来表示错误。实践中，我从来没在实际系统中看到过这样的代码。</p><h3>接口负责对象的堆上生成和内存管理</h3><p>另外一种可能的做法是接口提供生成和销毁对象的函数，对象在堆上维护。<code>fopen</code> 和 <code>fclose</code> 就是这样的接口的实例。注意使用这种方法一般不推荐由接口生成对象，然后由调用者通过调用 <code>delete</code> 来释放。在某些环境里，比如 Windows 上使用不同的运行时库时，这样做会引发问题。</p><p>同样以上面的矩阵运算为例，代码大概就会写成这个样子：</p><pre><code class=\"language-c++\">matrix* add(\n  const matrix* lhs,\n  const matrix* rhs,\n  error_code_t* ec);\nmatrix* multiply(\n  const matrix* lhs,\n  const matrix* rhs,\n  error_code_t* ec);\nvoid deinitialize(matrix** mat);\n…\n  error_code_t ec;\n  …\n  matrix* temp = nullptr;\n  matrix* r = nullptr;\n  temp = multiply(a, b, &amp;ec);\n  if (!temp) {\n    goto end;\n  }\n  r = add(temp, c, &amp;ec);\n  if (!r) {\n    goto end;\n  }\n  …\nend:\n  if (temp) {\n    deinitialize(&amp;temp);\n  }\n  // 返回 ec 或类似错误处理\n</code></pre><p>可以注意到，虽然代码看似稍微自然了一点，但啰嗦程度却增加了，原因是正确的处理需要考虑到各种不同错误路径下的资源释放问题。这儿也没有使用异常，因为异常在这种表达下会产生内存泄漏，除非用上一堆 <code>try</code> 和 <code>catch</code>，但那样异常在表达简洁性上的优势就没有了，没有实际的好处。</p><p>不过，如果我们同时使用智能指针和异常的话，就可以得到一个还不错的变体。如果接口接受和返回的都是 <code>shared_ptr&lt;matrix&gt;</code>，那调用代码就简单了：</p><pre><code class=\"language-c++\">shared_ptr&lt;matrix&gt; add(\n  const shared_ptr&lt;matrix&gt;&amp; lhs,\n  const shared_ptr&lt;matrix&gt;&amp; rhs);\nshared_ptr&lt;matrix&gt; multiply(\n  const shared_ptr&lt;matrix&gt;&amp; lhs,\n  const shared_ptr&lt;matrix&gt;&amp; rhs);\n…\n  auto r = add(multiply(a, b), c);\n</code></pre><p>调用这些接口必须要使用 <code>shared_ptr</code>，这不能不说是一个限制。另外，对象永远是在堆上分配的，在很多场合，也会有一定的性能影响。</p><h3>接口直接返回对象</h3><p>最直接了当的代码，当然就是直接返回对象了。这回我们看实际可编译、运行的代码：</p><pre><code class=\"language-c++\">#include &lt;armadillo&gt;\n#include &lt;iostream&gt;\n\nusing arma::imat22;\nusing std::cout;\n\nint main()\n{\n  imat22 a{{1, 1}, {2, 2}};\n  imat22 b{{1, 0}, {0, 1}};\n  imat22 c{{2, 2}, {1, 1}};\n  imat22 r = a * b + c;\n  cout &lt;&lt; r;\n}\n</code></pre><p>这段代码使用了 Armadillo，一个利用现代 C++ 特性的开源线性代数库 <span class=\"orange\">[2]</span>。你可以看到代码非常简洁，完全表意（<code>imat22</code> 是元素类型为整数的大小固定为 2 x 2 的矩阵）。它有以下优点：</p><ul>\n<li>代码直观、容易理解。</li>\n<li>乘法和加法可以组合在一行里写出来，无需中间变量。</li>\n<li>性能也没有问题。实际执行中，没有复制发生，计算结果直接存放到了变量 <code>r</code> 上。更妙的是，因为矩阵大小是已知的，这儿不需要任何动态内存，所有对象及其数据全部存放在栈上。</li>\n</ul><p>Armadillo 是个比较复杂的库，我们就不以 Armadillo 的代码为例来进一步讲解了。我们可以用一个假想的 <code>matrix</code> 类来看看返回对象的代码是怎样编写的。</p><h2>如何返回一个对象？</h2><p>一个用来返回的对象，通常应当是可移动构造/赋值的，一般也同时是可拷贝构造/赋值的。如果这样一个对象同时又可以默认构造，我们就称其为一个半正则（semiregular）的对象。如果可能的话，我们应当尽量让我们的类满足半正则这个要求。</p><p>半正则意味着我们的 <code>matrix</code> 类提供下面的成员函数：</p><pre><code class=\"language-c++\">class matrix {\npublic:\n  // 普通构造\n  matrix(size_t rows, size_t cols);\n  // 半正则要求的构造\n  matrix();\n  matrix(const matrix&amp;);\n  matrix(matrix&amp;&amp;);\n  // 半正则要求的赋值\n  matrix&amp; operator=(const matrix&amp;);\n  matrix&amp; operator=(matrix&amp;&amp;);\n};\n</code></pre><p>我们先看一下在没有返回值优化的情况下 C++ 是怎样返回对象的。以矩阵乘法为例，代码应该像下面这样：</p><pre><code class=\"language-c++\">matrix operator*(const matrix&amp; lhs,\n                 const matrix&amp; rhs)\n{\n  if (lhs.cols() != rhs.rows()) {\n    throw runtime_error(\n      \"sizes mismatch\");\n  }\n  matrix result(lhs.rows(),\n                rhs.cols());\n  // 具体计算过程\n  return result;\n}\n</code></pre><p>注意对于一个本地变量，我们永远不应该返回其引用（或指针），不管是作为左值还是右值。从标准的角度，这会导致未定义行为（undefined behavior），从实际的角度，这样的对象一般放在栈上可以被调用者正常覆盖使用的部分，随便一个函数调用或变量定义就可能覆盖这个对象占据的内存。这还是这个对象的析构不做事情的情况：如果析构函数会释放内存或破坏数据的话，那你访问到的对象即使内存没有被覆盖，也早就不是有合法数据的对象了……</p><p>回到正题。我们需要回想起，在<a href=\"https://time.geekbang.org/column/article/169268\">[第 3 讲]</a> 里说过的，返回非引用类型的表达式结果是个纯右值（prvalue）。在执行 <code>auto r = …</code> 的时候，编译器会认为我们实际是在构造 <code>matrix r(…)</code>，而“…”部分是一个纯右值。因此编译器会首先试图匹配 <code>matrix(matrix&amp;&amp;)</code>，在没有时则试图匹配 <code>matrix(const matrix&amp;)</code>；也就是说，有移动支持时使用移动，没有移动支持时则拷贝。</p><h2>返回值优化（拷贝消除）</h2><p>我们再来看一个能显示生命期过程的对象的例子：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\n// Can copy and move\nclass A {\npublic:\n  A() { cout &lt;&lt; \"Create A\\n\"; }\n  ~A() { cout &lt;&lt; \"Destroy A\\n\"; }\n  A(const A&amp;) { cout &lt;&lt; \"Copy A\\n\"; }\n  A(A&amp;&amp;) { cout &lt;&lt; \"Move A\\n\"; }\n};\n\nA getA_unnamed()\n{\n  return A();\n}\n\nint main()\n{\n  auto a = getA_unnamed();\n}\n</code></pre><p>如果你认为执行结果里应当有一行“Copy A”或“Move A”的话，你就忽视了返回值优化的威力了。即使完全关闭优化，三种主流编译器（GCC、Clang 和 MSVC）都只输出两行：</p><blockquote>\n<p><code>Create A</code><br>\n<code>Destroy A</code></p>\n</blockquote><p>我们把代码稍稍改一下：</p><pre><code class=\"language-c++\">A getA_named()\n{\n  A a;\n  return a;\n}\n\nint main()\n{\n  auto a = getA_named();\n}\n</code></pre><p>这回结果有了一点点小变化。虽然 GCC 和 Clang 的结果完全不变，但 MSVC 在非优化编译的情况下产生了不同的输出（优化编译——使用命令行参数 <code>/O1</code>、<code>/O2</code> 或 <code>/Ox</code>——则不变）：</p><blockquote>\n<p><code>Create A</code><br>\n<code>Move A</code><br>\n<code>Destroy A</code><br>\n<code>Destroy A</code></p>\n</blockquote><p>也就是说，返回内容被移动构造了。</p><p>我们继续变形一下：</p><pre><code class=\"language-c++\">#include &lt;stdlib.h&gt;\n\nA getA_duang()\n{\n  A a1;\n  A a2;\n  if (rand() &gt; 42) {\n    return a1;\n  } else {\n    return a2;\n  }\n}\n\nint main()\n{\n  auto a = getA_duang();\n}\n</code></pre><p>这回所有的编译器都被难倒了，输出是：</p><blockquote>\n<p><code>Create A</code><br>\n<code>Create A</code><br>\n<code>Move A</code><br>\n<code>Destroy A</code><br>\n<code>Destroy A</code><br>\n<code>Destroy A</code></p>\n</blockquote><p>关于返回值优化的实验我们就做到这里。下一步，我们试验一下把移动构造函数删除：</p><pre><code class=\"language-c++\">  // A(A&amp;&amp;) { cout &lt;&lt; \"Move A\\n\"; }\n</code></pre><p>我们可以立即看到“Copy A”出现在了结果输出中，说明目前结果变成拷贝构造了。</p><p>如果再进一步，把拷贝构造函数也删除呢（注：此时是标成 <code>= delete</code>，而不是简单注释掉——否则，就如我们在<a href=\"https://time.geekbang.org/column/article/176916\">[第 9 讲]</a> 讨论过的，编译器会默认提供拷贝构造和移动构造函数）？是不是上面的 <code>getA_unnamed</code>、<code>getA_named</code> 和 <code>getA_duang</code> 都不能工作了？</p><p>在 C++14 及之前确实是这样的。但从 C++17 开始，对于类似于 <code>getA_unnamed</code> 这样的情况，即使对象不可拷贝、不可移动，这个对象仍然是可以被返回的！C++17 要求对于这种情况，对象必须被直接构造在目标位置上，不经过任何拷贝或移动的步骤 <span class=\"orange\">[3]</span>。</p><h2>回到 F.20</h2><p>理解了 C++ 里的对返回值的处理和返回值优化之后，我们再回过头看一下 F.20 里陈述的理由的话，应该就显得很自然了：</p><blockquote>\n<p>A return value is self-documenting, whereas a <code>&amp;</code> could be either in-out or out-only and is liable to be misused.</p>\n<p>返回值是可以自我描述的；而 <code>&amp;</code> 参数既可能是输入输出，也可能是仅输出，且很容易被误用。</p>\n</blockquote><p>我想我对返回对象的可读性，已经给出了充足的例子。对于其是否有性能影响这一问题，也给出了充分的说明。</p><p>我们最后看一下 F.20 里描述的例外情况：</p><ul>\n<li>“对于非值类型，比如返回值可能是子对象的情况，使用 <code>unique_ptr</code> 或 <code>shared_ptr</code> 来返回对象。”也就是面向对象、工厂方法这样的情况，像<a href=\"https://time.geekbang.org/column/article/169225\">[第 1 讲]</a> 里给出的 <code>create_shape</code> 应该这样改造。</li>\n<li>“对于移动代价很高的对象，考虑将其分配在堆上，然后返回一个句柄（如 <code>unique_ptr</code>），或传递一个非 const 的目标对象的引用来填充（用作输出参数）。”也就是说不方便移动的，那就只能使用一个 RAII 对象来管理生命周期，或者老办法输出参数了。</li>\n<li>“要在一个内层循环里在多次函数调用中重用一个自带容量的对象：将其当作输入/输出参数并将其按引用传递。”这也是个需要继续使用老办法的情况。</li>\n</ul><h2>内容小结</h2><p>C++ 里已经对返回对象做了大量的优化，目前在函数里直接返回对象可以得到更可读、可组合的代码，同时在大部分情况下我们可以利用移动和返回值优化消除性能问题。</p><h2>课后思考</h2><p>请你考虑一下：</p><ol>\n<li>你的项目使用了返回对象了吗？如果没有的话，本讲内容有没有说服你？</li>\n<li>这讲里我们没有深入讨论赋值；请你思考一下，如果例子里改成赋值，会有什么样的变化？</li>\n</ol><p>欢迎留言和我交流你的想法。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Bjarne Stroustrup and Herb Sutter (editors), “C++ core guidelines”, item F.20. <a href=\"https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-out\">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-out</a> (非官方中文版可参见 <a href=\"https://github.com/lynnboy/CppCoreGuidelines-zh-CN\">https://github.com/lynnboy/CppCoreGuidelines-zh-CN</a>) </span></p><p><span class=\"reference\">[2] Conrad Sanderson and Ryan Curtin, Armadillo. <a href=\"http://arma.sourceforge.net/\">http://arma.sourceforge.net/</a> </span></p><p><span class=\"reference\">[3] cppreference.com, “Copy elision”. <a href=\"https://en.cppreference.com/w/cpp/language/copy_elision\">https://en.cppreference.com/w/cpp/language/copy_elision</a> </span></p><p><span class=\"reference\">[3a] cppreference.com, “复制消除”. <a href=\"https://zh.cppreference.com/w/cpp/language/copy_elision\">https://zh.cppreference.com/w/cpp/language/copy_elision</a> </span></p>","neighbors":{"left":{"article_title":"09 | 易用性改进 II：字面量、静态断言和成员函数说明符","id":176916},"right":{"article_title":"11 | Unicode：进入多文字支持的世界","id":179357}},"comments":[{"had_liked":false,"id":163026,"user_name":"小一日一","can_delete":false,"product_type":"c1","uid":1301097,"ip_address":"","ucode":"0A506C2B918C14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","comment_is_top":false,"comment_ctime":1576642142,"is_pvip":false,"replies":[{"id":"61923","content":"简单来说，在对本地变量进行返回时，不用 std::move。实际上，我在第 3 讲就写了：<br><br>“有一种常见的 C++ 编程错误，是在函数里返回一个本地对象的引用。由于在函数结束时本地对象即被销毁，返回一个指向本地对象的引用属于未定义行为。理论上来说，程序出任何奇怪的行为都是正常的。<br><br>“在 C++11 之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化（named return value optimization，或 NRVO），能把对象直接构造到调用者的栈上。从 C++11 开始，返回值优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。这一行为不需要程序员手工用 `std::move` 进行干预——使用`std::move` 对于移动行为没有帮助，反而会影响返回值优化。”","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1576646399,"ip_address":"","comment_id":163026,"utype":1}],"discussion_count":4,"race_medal":0,"score":"186260235870","product_id":100040501,"comment_content":"我认为老师应该讲一下NRVO&#47;RVO与std::move()的区别，这个问题曾经困扰过我，从stackoverflow的问题来看，学习c++11时大多数人都思考过这个问题：https:&#47;&#47;stackoverflow.com&#47;questions&#47;4986673&#47;c11-rvalues-and-move-semantics-confusion-return-statement","like_count":44,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478218,"discussion_content":"简单来说，在对本地变量进行返回时，不用 std::move。实际上，我在第 3 讲就写了：\n\n“有一种常见的 C++ 编程错误，是在函数里返回一个本地对象的引用。由于在函数结束时本地对象即被销毁，返回一个指向本地对象的引用属于未定义行为。理论上来说，程序出任何奇怪的行为都是正常的。\n\n“在 C++11 之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化（named return value optimization，或 NRVO），能把对象直接构造到调用者的栈上。从 C++11 开始，返回值优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。这一行为不需要程序员手工用 `std::move` 进行干预——使用`std::move` 对于移动行为没有帮助，反而会影响返回值优化。”","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576646399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1414215,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiboeh23vhCNruZ7odUjROiac6N9fx0VWAE6zBNRxJIJFZspSUTQdgu9ajg4F0fAZgdk1vBsicnib3QQ/132","nickname":"在水一方","note":"","ucode":"D8371EFEBED2C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":570744,"discussion_content":"编译器是如何把本地对象移动出去的？编译器会做特殊标记即使函数执行完也不释放本地变量吗？因为外部调用者有个引用?还是其他原理?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651899145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":478218,"ip_address":""},"score":570744,"extra":""}]},{"author":{"id":1331396,"avatar":"https://static001.geekbang.org/account/avatar/00/14/50/c4/71d9745f.jpg","nickname":"飏","note":"","ucode":"48701F74729E5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":101112,"discussion_content":"哈哈，确实一开始确实不理解move和NVRO，还写出了在return时调用move的代码。不过看了右值那讲就懂了。函数返回对象是纯右值，return的时候不用move也是右值。其实C++这个设计真的很妙，老的代码不用改，至少调用拷贝的地方直接改成调用move了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577283973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1301097,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","nickname":"小一日一","note":"","ucode":"0A506C2B918C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87136,"discussion_content":"前面学后面忘","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576646537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167342,"user_name":"小白兔纸白又白","can_delete":false,"product_type":"c1","uid":1145139,"ip_address":"","ucode":"1F415287933976","user_header":"https://static001.geekbang.org/account/avatar/00/11/79/33/e4af2cdb.jpg","comment_is_top":false,"comment_ctime":1577771983,"is_pvip":false,"replies":[{"id":"64996","content":"好问题。利用第 14 讲的 SFINAE 技巧，是可以写出来的。比如，你希望检测是不是有下面第一个重载：<br><br>class Obj {<br>public:<br>    void foo() &amp;&amp;;<br>    void foo() const &amp;;<br>};<br><br>可以定义下面这样的 type trait：<br><br>template &lt;typename T, typename = void_t&lt;&gt;&gt;<br>struct has_rvalue_ref_foo : false_type {};<br><br>template &lt;typename T&gt;<br>struct has_rvalue_ref_foo&lt;<br>    T, void_t&lt;decltype(static_cast&lt;void (T::*)() &amp;&amp;&gt;(&amp;T::foo))&gt;&gt;<br>    : true_type {};<br><br>上面第一个 foo 的重载在的话，使用 has_rvalue_ref_foo&lt;Obj&gt;::value 就能得到编译期常量 true。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1577804920,"ip_address":"","comment_id":167342,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40232477647","product_id":100040501,"comment_content":"请问有何方法可以测试编译器是否为一个类提供了右值引用的版本的成员函数","like_count":10,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479832,"discussion_content":"好问题。利用第 14 讲的 SFINAE 技巧，是可以写出来的。比如，你希望检测是不是有下面第一个重载：\n\nclass Obj {\npublic:\n    void foo() &amp;amp;&amp;amp;;\n    void foo() const &amp;amp;;\n};\n\n可以定义下面这样的 type trait：\n\ntemplate &amp;lt;typename T, typename = void_t&amp;lt;&amp;gt;&amp;gt;\nstruct has_rvalue_ref_foo : false_type {};\n\ntemplate &amp;lt;typename T&amp;gt;\nstruct has_rvalue_ref_foo&amp;lt;\n    T, void_t&amp;lt;decltype(static_cast&amp;lt;void (T::*)() &amp;amp;&amp;amp;&amp;gt;(&amp;amp;T::foo))&amp;gt;&amp;gt;\n    : true_type {};\n\n上面第一个 foo 的重载在的话，使用 has_rvalue_ref_foo&amp;lt;Obj&amp;gt;::value 就能得到编译期常量 true。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577804920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181696,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1582619489,"is_pvip":true,"replies":[{"id":"70395","content":"对，好用非常重要！","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1582630283,"ip_address":"","comment_id":181696,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31647390561","product_id":100040501,"comment_content":"Armadillo这个库我用过，挺好用。语法可以和Matlab互转，如果有用Matlab的小伙伴 可以推荐使用 性能杠杠的","like_count":7,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485084,"discussion_content":"对，好用非常重要！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582630283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168749,"user_name":"空气","can_delete":false,"product_type":"c1","uid":1307602,"ip_address":"","ucode":"45F9574A02343D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep73FalJJ7FPUJAcK2Ket1Qia1HOHhmaEcd8zdr4O6LHHk5NwzyUTnBAOzgmMtR3H0gSgYcbH6N5Vg/132","comment_is_top":false,"comment_ctime":1578149803,"is_pvip":false,"replies":[{"id":"65501","content":"如果都是返回而非修改的话，可以使用 pair、tuple、tie 和第 8 讲讨论的结构化绑定。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1578223367,"ip_address":"","comment_id":168749,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23052986283","product_id":100040501,"comment_content":"我在工作中使用引用出参的场景之一是同时返回多个对象，如果使用返回值就要封装很多不同结构体。请问老师这种场景建议怎么实现？","like_count":5,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480319,"discussion_content":"如果都是返回而非修改的话，可以使用 pair、tuple、tie 和第 8 讲讨论的结构化绑定。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578223367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163031,"user_name":"木瓜777","can_delete":false,"product_type":"c1","uid":1512537,"ip_address":"","ucode":"FC52A499AF6374","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aFAYPyw7ywC1xE9h1qibnTBwtWn2ClJqlicy5cMomhZVaruMyqSq76wMkS279mUaGhrLGwWo9ZnW0WCWfmMovlXw/132","comment_is_top":false,"comment_ctime":1576643454,"is_pvip":false,"replies":[{"id":"61926","content":"用默认构造函数代表空，或者用 optional&lt;对象&gt; （不构造）代表空，或者抛异常代表不正常（视是否不正常而定）。<br><br>optional 会在第 22 讲里讨论。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1576647227,"ip_address":"","comment_id":163031,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23051479934","product_id":100040501,"comment_content":"项目中一直使用您说的老方法，目前看编译器有优化的话，后面会逐步考虑采用返回对象的方法！ 有个问题问下，如果要返回空对象，该如何做？ 是直接采用空的构造函数？","like_count":5,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478221,"discussion_content":"用默认构造函数代表空，或者用 optional&amp;lt;对象&amp;gt; （不构造）代表空，或者抛异常代表不正常（视是否不正常而定）。\n\noptional 会在第 22 讲里讨论。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576647227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162868,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1576626755,"is_pvip":true,"replies":[{"id":"61896","content":"看这个页面吧：<br><br>https:&#47;&#47;en.cppreference.com&#47;w&#47;cpp&#47;compiler_support<br><br>目前 GCC 领先一些（可以用 -std=c++2a 启用 20 的功能），但还没有哪家完整支持 C++20。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1576633076,"ip_address":"","comment_id":162868,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18756495939","product_id":100040501,"comment_content":"请问老师这个C++20什么时候发布编译器之类的啊？还是说已经有了？","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478168,"discussion_content":"看这个页面吧：\n\nhttps://en.cppreference.com/w/cpp/compiler_support\n\n目前 GCC 领先一些（可以用 -std=c++2a 启用 20 的功能），但还没有哪家完整支持 C++20。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576633076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1762459,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e4/9b/fcb4b8b7.jpg","nickname":"李义盛","note":"","ucode":"2C79848BCF545D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86917,"discussion_content":"c++20的标准还没有确定呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576632476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1762459,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e4/9b/fcb4b8b7.jpg","nickname":"李义盛","note":"","ucode":"2C79848BCF545D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87141,"discussion_content":"基本确定了。七月时已经确定了哪些功能会进 C++20，哪些进不了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576646750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":86917,"ip_address":""},"score":87141,"extra":""}]}]},{"had_liked":false,"id":319814,"user_name":"阿白","can_delete":false,"product_type":"c1","uid":2736474,"ip_address":"","ucode":"811D111BEC0298","user_header":"https://static001.geekbang.org/account/avatar/00/29/c1/5a/4d4e6200.jpg","comment_is_top":false,"comment_ctime":1635950425,"is_pvip":false,"replies":[{"id":"116021","content":"函数返回一个本地变量是有特殊规则的。请在 cppreference 上查阅 return 和 copy elision 的文档。<br><br>可以类比一下 decltype（规则还是不一样的）来获得一些直观的感受。如果你有 int a; 和 int b; 两个变量，decltype(a) 会得到 int，decltype(a &gt; b ? a : b) 则得到 int&amp;。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1636074146,"ip_address":"","comment_id":319814,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14520852313","product_id":100040501,"comment_content":"老师看到你和别的同学讨论的问题，return :?中:?表达式返回的是左值引用，所以调用的是拷贝构造函数。但是return a1,a1是个标识表达式是个左值为什么就是调用移动构造。我不明白在函数声明返回值为值类型，但是:?返回一个左值引用的时候为什么调用的是拷贝构造？<br><br>A getA_duang()<br>{<br>A a1;<br>A a2;<br>return (rand() &gt; 42 ? a1 : a2);<br>}<br>Create A<br>Create A<br>Copy A<br>Destroy A<br>Destroy A<br>Destroy A<br>auto a = getA_duang();","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529780,"discussion_content":"函数返回一个本地变量是有特殊规则的。请在 cppreference 上查阅 return 和 copy elision 的文档。\n\n可以类比一下 decltype（规则还是不一样的）来获得一些直观的感受。如果你有 int a; 和 int b; 两个变量，decltype(a) 会得到 int，decltype(a &amp;gt; b ? a : b) 则得到 int&amp;amp;。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636074146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308761,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1629788485,"is_pvip":false,"replies":[{"id":"111778","content":"因为 (rand() &gt; 42 ? a1 : a2) 的结果是一个 A 的左值引用，return 语句返回的是左值引用，不是变量，所以就不行了。要移动需要自己加上 std::move。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1629811052,"ip_address":"","comment_id":308761,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14514690373","product_id":100040501,"comment_content":"吴老师，求助，我把getA_duang函数修改为：<br>A getA_duang()<br>{<br>\tA a1;<br>\tA a2;<br>\treturn (rand() &gt; 42 ? a1 : a2);<br>}<br>得到的结果是:<br>Create A<br>Create A<br>Copy A<br>Destroy A<br>Destroy A<br>Destroy A<br>请问为什么用条件表达式，得到的结果是 Copy A，而用你范例中的 if 语句判断就能得到 Move A呢？","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525615,"discussion_content":"因为 (rand() &amp;gt; 42 ? a1 : a2) 的结果是一个 A 的左值引用，return 语句返回的是左值引用，不是变量，所以就不行了。要移动需要自己加上 std::move。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1629811052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293358,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1621349564,"is_pvip":false,"replies":[{"id":"106336","content":"1. 可以参考cppreference.com 网站，或者第 9 讲，里面提到，“用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数”。“= default”和“= delete”这种也算声明。<br><br>2. 移动的代价是看实现的，也就是我们例子里的的 A(A&amp;&amp;)。像我们的玩具例子，移动和拷贝性能就没啥区别。说移动代价高，也不是指比拷贝高，而是指拷贝代价高且没有对移动做优化（如没有移动构造函数），或对象太大，没法做移动优化（如 sizeof 达到数百个字节以上）。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1621470268,"ip_address":"","comment_id":293358,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10211284156","product_id":100040501,"comment_content":"老师，请教2个疑惑：<br>1. 在返回值优化（拷贝消除）小节里，A(const A&amp;) = delete;了，但A(A&amp;&amp;)只是注释掉，不是说编译器会提供默认的移动构造函数吗？为什么getA_named也不行了？不是优先匹配移动构造吗？<br>A getA_named()<br>{<br>\tA a;<br>\treturn a;<br>}<br>2. 哪种情况下移动的代价高？我理解移动的代价都很低，至少比拷贝低吧？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520175,"discussion_content":"1. 可以参考cppreference.com 网站，或者第 9 讲，里面提到，“用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数”。“= default”和“= delete”这种也算声明。\n\n2. 移动的代价是看实现的，也就是我们例子里的的 A(A&amp;amp;&amp;amp;)。像我们的玩具例子，移动和拷贝性能就没啥区别。说移动代价高，也不是指比拷贝高，而是指拷贝代价高且没有对移动做优化（如没有移动构造函数），或对象太大，没法做移动优化（如 sizeof 达到数百个字节以上）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621470268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235888,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1595235093,"is_pvip":false,"replies":[{"id":"87146","content":"是，这些概念都是有深刻数学背景的。要进一步了解的话，我推荐 From Mathematics to Generic Programming，STL 之父的大作。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1595252157,"ip_address":"","comment_id":235888,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10185169685","product_id":100040501,"comment_content":"吴老师您好。<br>抱歉我之前的的提问描述的不太清楚。您文中清楚地描述了semi-regular是“如何”定义的。我好奇的是，这样定义的意义是啥，对于copiable增加一个alias的意义何在？对应的regular定义是什么？<br>在网上仔细搜索了一下，似乎找到了源头：<br>https:&#47;&#47;www.slideshare.net&#47;ilio-catallo&#47;regular-types-in-c <br>这一个ppt描述了regular的定义，以及由此引申出来的semi-regular。这里的各种定义是非常严谨的，类似于数域及其满足操作的扩展。<br>https:&#47;&#47;www.modernescpp.com&#47;index.php&#47;c-20-define-the-concept-regular-and-semiregular<br>这篇文章结合了C++ std20中concept介绍了一下regular和semi-regular定义的实操。其中深度使用了您介绍的SFINAE。<br>从中似乎隐然可以看出C++成为一个公式语言的可能性。","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501866,"discussion_content":"是，这些概念都是有深刻数学背景的。要进一步了解的话，我推荐 From Mathematics to Generic Programming，STL 之父的大作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595252157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164333,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1576939070,"is_pvip":false,"replies":[{"id":"62449","content":"C++编译器哪会做这么不必要的事……就是一次移动。如果有返回值优化的话，一次移动都不会有。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1576983450,"ip_address":"","comment_id":164333,"utype":1}],"discussion_count":4,"race_medal":0,"score":"10166873662","product_id":100040501,"comment_content":"我们继续变形一下：<br>#include &lt;stdlib.h&gt;<br>A getA_duang()<br>{<br>  A a1;<br>  A a2;<br>  if (rand() &gt; 42) {<br>    return a1;<br>  } else {<br>    return a2;<br>  }<br>}<br>int main()<br>{<br>  auto a = getA_duang();<br>}<br>这回所有的编译器都被难倒了，输出是：<br>Create A<br>Create A<br>Move A<br>Destroy A<br>Destroy A<br>Destroy A<br><br>———————<br>老师这个结果应该还是会有优化在的吧？如果完全没有优化应该是两个移动才对，a1或者a2移动给返回值是一次，返回值移动给a又是一次，如果真是这样，哪次被优化掉了？第二次吗","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478727,"discussion_content":"C++编译器哪会做这么不必要的事……就是一次移动。如果有返回值优化的话，一次移动都不会有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576983450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1217554,"avatar":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","nickname":"Jason","note":"","ucode":"C5A540BC5A60B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":123511,"discussion_content":"经过我的测试，编译时加上-std=c++11后，编译器直接把a作为了移动的对象，优化掉了针对返回值的那次移动。如果去掉c++11选项且关闭返回值优化，就会出现两次拷贝（11之前不支持移动）","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1578404483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1098987,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","nickname":"花晨少年","note":"","ucode":"6AA3537A6BA10E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1217554,"avatar":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","nickname":"Jason","note":"","ucode":"C5A540BC5A60B9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":130885,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578803854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":123511,"ip_address":""},"score":130885,"extra":""}]},{"author":{"id":1098987,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","nickname":"花晨少年","note":"","ucode":"6AA3537A6BA10E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":94798,"discussion_content":"我意思是按照人去理解代码执行的过程，应该有哪些步骤，不是说编译器的步骤。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576989797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164543,"user_name":"光城~兴","can_delete":false,"product_type":"c1","uid":1188173,"ip_address":"","ucode":"55A0D25BFCDD47","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/4d/90ea92f8.jpg","comment_is_top":false,"comment_ctime":1577024930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871992226","product_id":100040501,"comment_content":"加入了move assignment后，默认是调用move assignment而不是copy assignment。","like_count":2},{"had_liked":false,"id":163324,"user_name":"nelson","can_delete":false,"product_type":"c1","uid":1271183,"ip_address":"","ucode":"773BE75A23C1C9","user_header":"","comment_is_top":false,"comment_ctime":1576685734,"is_pvip":false,"replies":[{"id":"62146","content":"多谢。已修正。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1576736031,"ip_address":"","comment_id":163324,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5871653030","product_id":100040501,"comment_content":"文稿中的代码片段<br>ec = multiply(&amp;temp, a, b); <br>if (result != SUCCESS) <br>{ <br>  goto end; <br>}<br><br>result 应该是 ec吧","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478348,"discussion_content":"多谢。已修正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576736031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347750,"user_name":"Geek_fadd1e","can_delete":false,"product_type":"c1","uid":3018755,"ip_address":"","ucode":"29BD3BD7143D41","user_header":"","comment_is_top":false,"comment_ctime":1654396337,"is_pvip":false,"replies":[{"id":"126775","content":"Move 和 Copy 也意味着构造，分别调用了移动构造函数和拷贝构造函数。不能说“不需要构造函数初始化”。","user_name":"作者回复","user_name_real":"编辑","uid":"1645639","ctime":1654425382,"ip_address":"","comment_id":347750,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1654396337","product_id":100040501,"comment_content":"老师，想请教一下这里出现两次构造，但析构了三次的原因，我的思考是对于auto a = getA_duang();<br>函数体内两个临时对象生成与析构对应着两次，当返回时因为移动构造，不需要拷贝，直接将一个临时对象的所有权转移给目标a（且此时保证着临时对象仍然处于可析构状态），此时这个目标a不需要构造函数初始化，但仍然析构，因此少了构造的一次析构了三次，这样理解哪里有问题<br>Create A<br>Create A<br>Move A<br>Destroy A<br>Destroy A<br>Destroy A","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574896,"discussion_content":"Move 和 Copy 也意味着构造，分别调用了移动构造函数和拷贝构造函数。不能说“不需要构造函数初始化”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654425382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278952,"user_name":"王旧业","can_delete":false,"product_type":"c1","uid":1013076,"ip_address":"","ucode":"A8DEC38430D007","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/54/73cc7f73.jpg","comment_is_top":false,"comment_ctime":1613480109,"is_pvip":false,"replies":[{"id":"101423","content":"不只是能，而是必须。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1613629876,"ip_address":"","comment_id":278952,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1613480109","product_id":100040501,"comment_content":"在 C++14 及之前确实是这样的。但从 C++17 开始，对于类似于 getA_unnamed 这样的情况，即使对象不可拷贝、不可移动，这个对象仍然是可以被返回的 ----这样的情况就是指能被返回值优化的吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515573,"discussion_content":"不只是能，而是必须。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613629876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278950,"user_name":"王旧业","can_delete":false,"product_type":"c1","uid":1013076,"ip_address":"","ucode":"A8DEC38430D007","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/54/73cc7f73.jpg","comment_is_top":false,"comment_ctime":1613479844,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613479844","product_id":100040501,"comment_content":"在 C++14 及之前确实是这样的。但从 C++17 开始，对于类似于 getA_unnamed 这样的情况，即使对象不可拷贝、不可移动，这个对象仍然是可以被返回的","like_count":0},{"had_liked":false,"id":235569,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1595088211,"is_pvip":false,"replies":[{"id":"87065","content":"1. 还是看正文。我不可能这儿说一两句就比我花力气写的正文更好。<br><br>2. 实用角度是差不多（但跟编译器优化程度有关）。有一个小区别是用 Obj&amp;&amp; 可以接收 Obj 的子类对象。用 Obj 则会发生对象切割，不行。<br><br>3. C++17 的一条新规则是，在你说的情况下编译器必须进行返回值优化，不要求对象可拷贝或移动。之前的规则是不管编译器能不能优化，语言认为这儿发生了对象拷贝或移动。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1595207730,"ip_address":"","comment_id":235569,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1595088211","product_id":100040501,"comment_content":"吴老师您好。<br>1. 您能否介绍一下定义所谓“半正则对象”的意义？<br><br>2. 我测试了一下您在介绍移动一章提到的使用 auto&amp;&amp; 延长prvalue生命周期的方法:<br>auto&amp;&amp; obj = get_obj();<br>发现其和使用auto获得这个prvalue的代码是完全等价的：<br>Obj obj = get_obj();<br>这种等价不仅限于在获得Obj实例之后的使用范围和方式完全一样，其在get_obj()内部对Obj的构造和传递（无论是否激活NRVO）也完全一样。当然在汇编层面还是有一些不同，就是看不太懂T_T<br><br>3. 另外，我测试了一下NRVO的代码，发现了一个挺有意思的情况，在C++14下，形如<br>A get_A_directly() {<br>  return A{};<br>}<br>这样的代码，确实只使用了默认构造了一次，没有其它移动和复制。但是如果A不提供移动和delete掉复制构造，编译不能通过。GCC和clang都如此。“未使用但必须提供”，哈哈，好像违背了“未使用就不需要负担成本”的原则：）","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501770,"discussion_content":"1. 还是看正文。我不可能这儿说一两句就比我花力气写的正文更好。\n\n2. 实用角度是差不多（但跟编译器优化程度有关）。有一个小区别是用 Obj&amp;amp;&amp;amp; 可以接收 Obj 的子类对象。用 Obj 则会发生对象切割，不行。\n\n3. C++17 的一条新规则是，在你说的情况下编译器必须进行返回值优化，不要求对象可拷贝或移动。之前的规则是不管编译器能不能优化，语言认为这儿发生了对象拷贝或移动。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595207730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176978,"user_name":"风清扬","can_delete":false,"product_type":"c1","uid":1047043,"ip_address":"","ucode":"651F1390B64953","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/619e3e48.jpg","comment_is_top":false,"comment_ctime":1581240396,"is_pvip":true,"replies":[{"id":"68680","content":"没有启用 C++17 标准吧？<br><br>应该是上面这种情况。不是的话，请描述具体的编译器版本和编译的命令行参数。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1581245369,"ip_address":"","comment_id":176978,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1581240396","product_id":100040501,"comment_content":"关于返回值优化的实验我们就做到这里。下一步，我们试验一下把移动构造函数删除：<br>A(A&amp;&amp;)=delete 我们可以立即看到“Copy A”出现在了结果输出中，说明目前结果变成拷贝构造了。<br><br>这里我修改成A(A&amp;&amp;) = delete后，编译报错：提示：error: use of deleted function ‘A::A(A&amp;&amp;)","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483266,"discussion_content":"没有启用 C++17 标准吧？\n\n应该是上面这种情况。不是的话，请描述具体的编译器版本和编译的命令行参数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581245369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047043,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/619e3e48.jpg","nickname":"风清扬","note":"","ucode":"651F1390B64953","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165527,"discussion_content":"...... A return statement with any other operand shall be used only in a function whose return type is not cv void; the return statement initializes the glvalue result or prvalue result object of the (explicit or implicit) function call by copy-initialization from the operand. ......\n\n这个语义上的拷贝在 C++17 里也还存在，即使这个拷贝被 RVO 优化掉。所以，语义上，这里需要一个 copy/move constructor 。\n\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581299458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047043,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/619e3e48.jpg","nickname":"风清扬","note":"","ucode":"651F1390B64953","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165522,"discussion_content":"\n#include <iostream>\n\nusing namespace std;\n\n// Can copy and move\nclass A {\npublic:\n  A() { cout << &#34;Create A\\n&#34;; }\n  ~A() { cout << &#34;Destroy A\\n&#34;; }\n  A(const A&amp;) { cout << &#34;Copy A\\n&#34;; }\n  A(A&amp;&amp;) = delete;\n};\n\nA getA_duang()\n{\n  A a1;\n  A a2;\n  if (rand() > 42) {\n    return a1;\n  } else {\n    return a2;\n  }\n}\n\nint main()\n{\n  auto a = getA_duang();\n  return 0;\n}\n\n编译选项及报错信息：\n[root shared_ptr]#g++ -std=c++17 main.cpp\nmain.cpp: In function ‘A getA_duang()’:\nmain.cpp:20:12: error: use of deleted function ‘A::A(A&amp;&amp;)’\n     return a1;\n            ^~\nmain.cpp:12:3: note: declared here\n   A(A&amp;&amp;) = delete;\n   ^\nmain.cpp:22:12: error: use of deleted function ‘A::A(A&amp;&amp;)’\n     return a2;\n            ^~\nmain.cpp:12:3: note: declared here\n   A(A&amp;&amp;) = delete;\n   ^\n\ng++版本信息：\n[root shared_ptr]#g++ --version\ng++ (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0\nCopyright (C) 2017 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581299099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1047043,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/619e3e48.jpg","nickname":"风清扬","note":"","ucode":"651F1390B64953","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":166722,"discussion_content":"应该是GCC 7的bug。我复现了这个问题，同时GCC 8就编译通过了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581424756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":165522,"ip_address":""},"score":166722,"extra":""}]}]},{"had_liked":false,"id":168601,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1578120021,"is_pvip":false,"replies":[{"id":"65375","content":"你这不就是我下面给出的 getA_named 吗？确实不会拷贝啊，我这一讲就是这么写的。就是让你看到，返回值优化在这儿起的作用。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1578124674,"ip_address":"","comment_id":168601,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578120021","product_id":100040501,"comment_content":"#include &lt;iostream&gt;<br>  2 using namespace std;<br>  3 &#47;&#47; Can copy and move<br>  4 class A {<br>  5         public:<br>  6                 A() {<br>  7                         cout &lt;&lt; &quot;Create A\\n&quot;;<br>  8                 }<br>  9                 ~A() {<br> 10                         cout &lt;&lt; &quot;Destroy A\\n&quot;;<br> 11                 }<br> 12                 A(const A&amp;) {<br> 13                         cout &lt;&lt; &quot;Copy A\\n&quot;;<br> 14                 }<br> 15                 A(A&amp;&amp;) { cout &lt;&lt; &quot;Move A\\n&quot;; }<br> 16 };<br> 17 A getA_unnamed(){<br> 18 &#47;&#47;      return A();<br> 19     A a;<br> 20     return a;<br> 21 }<br> 22 int main(){<br> 23         auto a = getA_unnamed();<br> 24 }<br>g++ main.cpp<br>.&#47;a.out 也不会执行copy操作呢？我的操作系统是ubuntu","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480265,"discussion_content":"你这不就是我下面给出的 getA_named 吗？确实不会拷贝啊，我这一讲就是这么写的。就是让你看到，返回值优化在这儿起的作用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578124674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165041,"user_name":"petit_kayak","can_delete":false,"product_type":"c1","uid":1025214,"ip_address":"","ucode":"6889CCCBFA0180","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/be/39cc22f5.jpg","comment_is_top":false,"comment_ctime":1577151484,"is_pvip":true,"replies":[{"id":"62942","content":"先试试升级环境、充分测试看看有没有问题。也许没问题呢？","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1577181695,"ip_address":"","comment_id":165041,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577151484","product_id":100040501,"comment_content":"一直使用共享指针，非常喜欢这些新的优化，能简化非常多代码，但现实是需要考虑很多无法升级的旧环境，不能随便使用c++11及以后的写法","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478998,"discussion_content":"先试试升级环境、充分测试看看有没有问题。也许没问题呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577181695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164494,"user_name":"光城~兴","can_delete":false,"product_type":"c1","uid":1188173,"ip_address":"","ucode":"55A0D25BFCDD47","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/4d/90ea92f8.jpg","comment_is_top":false,"comment_ctime":1577008806,"is_pvip":false,"replies":[{"id":"62549","content":"对于功能和版本的关系，这个页面比较全：<br><br>https:&#47;&#47;en.cppreference.com&#47;w&#47;cpp&#47;compiler_support","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1577065381,"ip_address":"","comment_id":164494,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577008806","product_id":100040501,"comment_content":"您好，老师，我想问一下c++xx与gcc版本的对应关系，还有这节提到的返回值优化在c++17中的结果与c++14及之前的结果(禁用返回值优化，编译后的结果)是不一样的，像这种有没有参考资料呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478790,"discussion_content":"对于功能和版本的关系，这个页面比较全：\n\nhttps://en.cppreference.com/w/cpp/compiler_support","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577065381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164332,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1576938566,"is_pvip":false,"replies":[{"id":"62462","content":"对，是调用移动构造变成调用拷贝构造，如果原来就直接返回值优化掉了，那不会变化。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1576994302,"ip_address":"","comment_id":164332,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576938566","product_id":100040501,"comment_content":"关于返回值优化的实验我们就做到这里。下一步，我们试验一下把移动构造函数删除：<br>  A(A&amp;&amp;) = delete;<br>我们可以立即看到“Copy A”出现在了结果输出中，说明目前结果变成拷贝构造了<br>————————————————————————<br>请问这种情况说的是针对getA_duang()函数吧？不包括 getA_named() 等函数吧","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478726,"discussion_content":"对，是调用移动构造变成调用拷贝构造，如果原来就直接返回值优化掉了，那不会变化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576994302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163811,"user_name":"西钾钾","can_delete":false,"product_type":"c1","uid":1097722,"ip_address":"","ucode":"0EE77083636ED9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJV27QOK57cdpdh3E4hbArCOlccdtjCyWooF9fhjeSKAMo9SN1v9RODkrZUZD4RejjbdsqU2FIeMA/132","comment_is_top":false,"comment_ctime":1576806061,"is_pvip":false,"replies":[{"id":"62310","content":"VS 2017 下也能过的。你没有按环境要求里说的加上 &#47;std:c++17。了解细节，可以看参考资料 [3]。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1576818936,"ip_address":"","comment_id":163811,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576806061","product_id":100040501,"comment_content":"以下的代码中，无论是将拷贝构造函数还是移动构造函数置为delete，都不能正常编译（vs2017）。为啥只是使用一次构造函数，老师能简单讲下这个原理么？<br>#include &lt;iostream&gt;<br><br>using namespace std;<br><br>&#47;&#47; Can copy and move<br>class A {<br>public:<br>  A() { cout &lt;&lt; &quot;Create A\\n&quot;; }<br>  ~A() { cout &lt;&lt; &quot;Destroy A\\n&quot;; }<br>  A(const A&amp;) { cout &lt;&lt; &quot;Copy A\\n&quot;; }<br>  A(A&amp;&amp;) { cout &lt;&lt; &quot;Move A\\n&quot;; }<br>};<br><br>A getA_unnamed()<br>{<br>  return A();<br>}<br><br>int main()<br>{<br>  auto a = getA_unnamed();<br>}","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478538,"discussion_content":"VS 2017 下也能过的。你没有按环境要求里说的加上 /std:c++17。了解细节，可以看参考资料 [3]。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576818936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}