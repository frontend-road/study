{"id":607308,"title":"04｜模版语法和JSX语法：你知道Vue可以用JSX写吗？","content":"<p>你好，我是杨文坚。</p><p>前面几节课，我们讲解了很多Vue.js 3编译相关的内容，了解完Vue.js两个编译打包工具后，我们是时候要开始学习如何使用Vue.js 3进行实际的代码开发了。</p><p>这节课，我主要会从Vue.js的两种主要开发语法进行讲解，它们分别是模板语法和JSX语法。从中你不仅能了解到两种开发语法的差异，还可以知道怎么因地制宜地根据需求场景选择合适的语法，从而扩大个人的技术知识储备，更从容地应对用Vue.js 3开发项目过程中遇到的各种问题。</p><p>Vue.js从版本1.x到版本3.x，官方代码案例和推荐使用都是模板语法，那么这里我们也根据官方的推荐，优先来了解一下模板语法是怎么一回事。</p><h2>什么是模板语法？</h2><p>我们可以把Vue.js的模板语法，直接理解为<strong>HTML语法的一种扩展</strong>，它所有的模板节点声明、属性设置和事件注册等都是按照HTML的语法来进行扩展设计的。按照官方的说法就是“所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析”。</p><p>现在我举个例子，带你了解下模板语法的概念及其不同内容的作用。代码如下所示：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div class=\"counter\"&gt;\n    &lt;div class=\"text\"&gt;Count: {{state.count}}&lt;/div&gt;\n    &lt;button class=\"btn\" v-on:click=\"onClick\"&gt;Add&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\n  import { reactive } from 'vue';\n  const state = reactive({\n    count: 0\n  });\n  const onClick = () =&gt; {\n    state.count ++;\n  }\n&lt;/script&gt;\n\n&lt;style&gt;\n.counter {\n  padding: 10px;\n  margin: 10px auto;\n  text-align: center;\n}\n\n.counter .text {\n  font-size: 28px;\n  font-weight: bolder;\n  color: #666666;\n}\n\n.counter .btn {\n  font-size: 20px;\n  padding: 0 10px;\n  height: 32px;\n  min-width: 80px;\n  cursor: pointer;\n} \n&lt;/style&gt;\n\n</code></pre><!-- [[[read_end]]] --><p>这是基于 Vue.js 3的模板语法实现的加数器组件，代码基础结构都是基于HTML语法实现的，主要由视图模板、JavaScript脚本代码和CSS样式代码构成的。我们拆分开来具体看看。</p><p><strong>首先我们来看看视图层代码：</strong></p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div class=\"counter\"&gt;\n    &lt;div class=\"text\"&gt;Count: {{state.count}}&lt;/div&gt;\n    &lt;button class=\"btn\" v-on:click=\"onClick\"&gt;Add&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre><p>上述视图代码中，只能有一个最外层的template标签，template内部可以允许存在多个template标签，用来定义模板的“插槽”位置（slot）等更多插槽相关信息，你可以查看<a href=\"https://cn.vuejs.org/guide/components/slots.html\">官方对插槽的说明</a>了解一下。</p><p>Vue.js的模板可以直接使用HTML语法的属性（Attribute），例如class也可以直接在Vue.js的模板中使用，但是Vue.js自己定义了一些属性语法，例如 v-on，这个就是Vue.js模板绑定事件的语法。以此类推，你大概可以猜到大部分 Vue.js自定义的模板属性语法，都是以 “v-”为前缀的。更多Vue.js的模板语法，你可以查看<a href=\"https://cn.vuejs.org/guide/essentials/template-syntax.html\">官方文档</a>。</p><p><strong>接下来我们看看JavaScript脚本代码：</strong></p><pre><code class=\"language-xml\">&lt;script setup&gt;\n  import { reactive } from 'vue';\n  const state = reactive({\n    count: 0\n  });\n  const onClick = () =&gt; {\n    state.count ++;\n  }\n&lt;/script&gt;\n\n</code></pre><p>在模板语法中，JavaScript代码只能放在script标签里，而且同一个文件里只能有一个顶级的script标签。</p><p>上述代码使用的是Vue.js的 Composition API，所以必须在script标签中声明 setup属性。我们后续所有内容都默认是基于 Composition API 来讲解Vue.js 3里的JavaScript代码操作。这是因为它是官方推荐的API使用方式，使用起来简单清晰，方便复用逻辑代码，同时这也是Vue.js 3诞生的特色。</p><p><strong>最后再来看下CSS样式代码：</strong></p><pre><code class=\"language-xml\">&lt;style&gt;\n.counter {\n  padding: 10px;\n  margin: 10px auto;\n  text-align: center;\n}\n\n.counter .text {\n  font-size: 28px;\n  font-weight: bolder;\n  color: #666666;\n}\n\n.counter .btn {\n  font-size: 20px;\n  padding: 0 10px;\n  height: 32px;\n  min-width: 80px;\n  cursor: pointer;\n} \n&lt;/style&gt;\n</code></pre><p>这些代码是模板语法里的CSS样式代码，具体使用方式跟HTML里使用CSS代码一致，唯一不同是可以加上scoped和lang属性。</p><p>scoped属性可以在编译Vue.js模板语法代码的时候，用随机数来定义样式选择器名称，保证CSS不会干扰页面上同名的CSS选择器，例如下面代码所示：</p><pre><code class=\"language-xml\">&lt;div class=\"counter\"&gt;&lt;/div&gt;\n&lt;style scoped&gt;\n.counter { /*...*/ }\n&lt;/style&gt;\n\n&lt;!-- 当style加上scoped 后编译成 --&gt;\n\n&lt;div class=\"counter\" data-v-xxxxx&gt;&lt;/div&gt;\n&lt;style&gt;\n.counter[data-v-xxxxx] { /*...*/ }\n&lt;/style&gt;\n\n</code></pre><p>而lang属性可以赋值声明定义用了其它CSS语法，例如 lang=\"less\"就是用了Less语法来写的CSS，但是需要在Vite等对应编译配置加上Less编译插件。</p><p>上面的整体代码就是用一个Vue.js 3模板语法实现一个组件，如果有一个组件需要引用这个“计数器”组件，就直接用import来引用就好了，代码如下：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div class=\"app\"&gt;\n    &lt;Counter /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport Counter from './counter.vue'\n&lt;/script&gt;\n\n&lt;style&gt;\n.app {\n  width: 200px;\n  padding: 10px;\n  margin: 10px auto;\n  box-shadow: 0px 0px 9px #00000066;\n  text-align: center;\n}\n&lt;/style&gt;\n</code></pre><p>讲到这里，你是不是反应过来了，其实只要了解过HTML语法，就能很容易上手Vue.js的模板语法。而且，Vue.js从版本1.x到版本3.x，官方代码案例和推荐使用都是模板语法，因为模板语法更加简单易用。</p><p>不过，既然Vue.js官方代码案例和推荐使用都是模板语法，为什么官方还要实现一套与模板语法不同的JSX语法呢？</p><p>其实这个问题我们可以直接在Vue.js官网找到答案，官网就这么写着：“在绝大多数情况下，Vue 推荐使用模板语法来创建应用。然而在某些使用场景下，我们真的需要用到 JavaScript 完全的编程能力。这时渲染函数就派上用场了。”</p><p>这就是说，虽然官方推荐你用模板语法来写Vue.js 3代码，但是有些功能场景用模板语法可能会很难实现，甚至不能实现，那么就需要用到JSX语法来辅助实现了。而且，Vue.js在2.x版本时候已经开始支持JSX语法了。那么，Vue.js 3的JSX语法是怎样的呢？</p><h2>Vue.js 3的JSX语法是怎样的？</h2><p>在讲解Vue.js 3之前，我先来给你分享一下，什么是JSX语法。</p><p>JSX语法，是JavaScript语法的一种语法扩展，支持在JavaScript直接写类似HTML的模板代码，你可以直接理解为“<strong>HTML in JavaScript</strong>”。从目前在网上能找到的资料来看，JSX语法最早用于React.js，但不是React.js 独有的写法，目前有很多框架支持JSX写法，例如Vue.js和Solid.js（一种类似React.js写法的前端框架）等。</p><p>现在，我把上面的Vue.js 3的模板语法实现的“加数器”组件换成JSX语法实现，你可以对比看看这两个语法的实现差异，如下所示：</p><pre><code class=\"language-javascript\">import { defineComponent, reactive } from 'vue';\n\nconst Counter = defineComponent({\n\n  setup() {\n    const state = reactive({\n      count: 0\n    });\n    const onClick = () =&gt; {\n      state.count ++;\n    }\n    return {\n      state,\n      onClick,\n    }\n  },\n\n  render(ctx) {\n    const { state, onClick } = ctx;\n    return (\n      &lt;div class=\"counter\"&gt;\n        &lt;div class=\"text\"&gt;Count: {state.count}&lt;/div&gt;\n        &lt;button class=\"btn\" onClick={onClick}&gt;Add&lt;/button&gt;\n      &lt;/div&gt;\n    )\n  }\n});\n\nexport default Counter;\n</code></pre><p>现在，我们类比模板语法，逐步分析下这个JSX语法实现的“加数器”组件。<br>\nJSX语法其实可以直接看做是纯JavaScript文件代码，在JavaScript文件代码里定义Vue.js 3组件可以通过API defineComponent来进行声明定义：</p><pre><code class=\"language-javascript\">import { defineComponent } from 'vue';\nconst Counter = defineComponent({\n  // ...\n})\n</code></pre><p>而模板语法有组件视图层相关的代码，类比JSX语法里定义组件中的render方法，如下述代码所示：</p><pre><code class=\"language-javascript\">const Counter = defineComponent({\n  // ...\n  render(ctx) {\n    const { state, onClick } = ctx;\n    return (\n      &lt;div class=\"counter\"&gt;\n        &lt;div class=\"text\"&gt;Count: {state.count}&lt;/div&gt;\n        &lt;button class=\"btn\" onClick={onClick}&gt;Add&lt;/button&gt;\n      &lt;/div&gt;\n    )\n  }\n  // ...\n});\n\n</code></pre><p>上述代码中，render函数返回的代码，就是JSX的写法，用来描述HTML模板内容。这里需要注意的是，所有JSX写法中都是用<strong>单大括号“{state.count}”<strong>来作为内部变量处理，而Vue.js 3模板语法是通过</strong>双大括号来表示“{{state.count}}”</strong>，单大括号描述变量这个是JSX通用写法，Vue.js的JSX语法也是遵循了这个通用写法。</p><p>在模板语法中，模板的&lt;script&gt;标签里有一段JavaScript逻辑代码，这段JavaScript的逻辑代码，就是JSX语法中的defineComponent里除掉render函数外剩下的代码内容，如下代码：</p><pre><code>const Counter = defineComponent({\n  // 这里还可以是定义属性和组件引用\n  props: {},\n  components: {},\n  \n  // ...\n  setup() {\n    const state = reactive({\n      count: 0\n    });\n    const onClick = () =&gt; {\n      state.count ++;\n    }\n    return {\n      state,\n      onClick,\n    }\n  },\n  // ...\n});\n</code></pre><p>看在这里，你会不会觉得少了什么东西？哈哈，是不是觉得少了CSS样式代码？模板语法中style存放的CSS代码，在JSX语法中，又是在哪个位置呢？</p><p>我们先回到最开始的JSX介绍中看看。我们说了，JSX其实也是JavaScript代码，在JavaScript代码中引用CSS代码，一般都是直接 import 对应的CSS文件。所以，在Vue.js中通过JSX语法开发组件，组件的CSS代码也是放在独立的CSS文件，最后通过import引用的，如下代码所示：</p><pre><code class=\"language-javascript\">import './counter.css'\n</code></pre><p>到了这里，你是不是觉得JSX语法跟模板语法类比起来，都能找到一一对应关系，差别好像不是很大？</p><p>其实差别还是有的。只是因为上述的“加数器”组件案例只是简单的组件场景，而实际企业项目开发中我们会遇到很多五花八门的需求场景，这个时候模板语法和JSX语法的区别就体现出来了。接下来我就来讲解模板语法和JSX语法在实际项目中开发的有什么区别。</p><h2>模板语法和JSX语法有什么区别？</h2><p>首先，最大的区别就是模板语法能通过设置<strong>标签&lt;style&gt;属性scoped</strong>，让CSS和对应的DOM在编译后能加上随机的CSS属性选择器，避免干扰其它同名class名称的样式。</p><p>而在JSX语法中并没有可以设置scoped的地方，所以JSX语法在使用样式class名称的时候，不能配置scoped避免CSS样式干扰。</p><p>除了样式的scoped配置差异外，还有更大的差异是体现在<strong>实现需求场景</strong>上，例如动态的组件渲染。假设我们现在有这么个需求，可以动态对组件进行顺序颠倒，如下述两张效果图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/a5/8cffe40a4a1a67267df22d9804c41ca5.png?wh=1298x974\" alt=\"图片\"></p><p><img src=\"https://static001.geekbang.org/resource/image/07/bd/078a26fa436c9894a4ecc46776aff3bd.png?wh=1298x974\" alt=\"图片\"></p><p>这个需求如果要通过Vue.js 3的模板语法实现，可以这么写：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div class=\"app\"&gt;\n    &lt;div v-if=\"isReverse === false\"&gt;\n      &lt;Module01 /&gt;\n      &lt;Module02 /&gt;\n      &lt;Module03 /&gt;\n      &lt;Module04 /&gt;\n    &lt;/div&gt;\n    &lt;div v-else&gt;\n      &lt;Module04 /&gt;\n      &lt;Module03 /&gt;\n      &lt;Module02 /&gt;\n      &lt;Module01 /&gt;\n    &lt;/div&gt;\n    &lt;button class=\"btn\" @click=\"onClick\"&gt;转换顺序: {{isReverse}}&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { ref } from 'vue';\nimport Module01 from './module01.vue';\nimport Module02 from './module02.vue';\nimport Module03 from './module03.vue';\nimport Module04 from './module04.vue';\n\nconst isReverse = ref(false);\nconst onClick = () =&gt; {\n  isReverse.value = !isReverse.value;\n}\n&lt;/script&gt;\n&lt;style&gt;\n/* 完整样式代码请看后续附带仓库链接 */\n&lt;/style&gt;\n</code></pre><p>你可以看到，这个代码是通过一个变量isReverse来控制显示组件的正序和倒序，但是要写两次的顺序的模板代码，如下所示：</p><pre><code class=\"language-xml\">&lt;div v-if=\"isReverse === false\"&gt;\n  &lt;Module01 /&gt;\n  &lt;Module02 /&gt;\n  &lt;Module03 /&gt;\n  &lt;Module04 /&gt;\n&lt;/div&gt;\n&lt;div v-else&gt;\n  &lt;Module04 /&gt;\n  &lt;Module03 /&gt;\n  &lt;Module02 /&gt;\n  &lt;Module01 /&gt;\n&lt;/div&gt;\n</code></pre><p>这样子写代码虽然可以完成功能需求，但是会给后续的维护带来一定的难度。为什么这么说呢？这不是明明已经完成功能了吗，而且代码也很清晰呀，怎么会有后续维护难度呢？</p><p>这是因为企业中的需求是一直变化的。例如这次需求是实现组件的顺序的正序和倒序操作，那么如果下次要实现组件的其它排序，是不是意味着要多个变量来控制多个顺序的组件布局模板呢？这就会导致相关组件顺序控制的代码量翻倍增长。</p><p>这时候，JSX语法就可以来解决这种“动态”的问题了。我们再用JSX实现一次上述功能的代码，如下所示：</p><pre><code class=\"language-javascript\">import { defineComponent, ref } from 'vue';\nimport Module01 from './module01.vue';\nimport Module02 from './module02.vue';\nimport Module03 from './module03.vue';\nimport Module04 from './module04.vue';\n\nconst App = defineComponent({\n\n  setup() {\n    const isReverse = ref(false);\n    const onClick = () =&gt; {\n      isReverse.value = !isReverse.value;\n    }\n    return {\n      isReverse,\n      onClick,\n    }\n  },\n\n  render(ctx) {\n    const { isReverse, onClick } = ctx;\n    const mods = [\n      &lt;Module01 /&gt;,\n      &lt;Module02 /&gt;,\n      &lt;Module03 /&gt;,\n      &lt;Module04 /&gt;\n    ]\n    isReverse === true &amp;&amp; mods.reverse();\n    return (\n      &lt;div class=\"app\"&gt;\n        {mods.map((mod) =&gt; {\n          return mod;\n        })}\n        &lt;button class=\"btn\" onClick={onClick}&gt;\n          转换顺序: {`${isReverse}`}\n        &lt;/button&gt;\n      &lt;/div&gt;\n    )\n  }\n});\n\nexport default App;\n</code></pre><p>上述代码中，控制组件的动态顺序核心代码是这样的：</p><pre><code class=\"language-javascript\">const mods = [\n  &lt;Module01 /&gt;,\n  &lt;Module02 /&gt;,\n  &lt;Module03 /&gt;,\n  &lt;Module04 /&gt;\n]\nisReverse === true &amp;&amp; mods.reverse();\n</code></pre><p>你有没有发现，控制组件顺序的其实就是通过一个<strong>JSX的组件数组</strong>来进行的，如果后续遇到项目需求的变化，要求按各种顺序显示组件，那么我们只需要修改这个JSX数组的顺序就好了，不需要写多套顺序模板，是不是觉得代码量和维度难度一下子就降低很多呢？</p><p>不过，这时你可能会想挑战我：像这种动态顺序，如果项目团队用模板语法多写几次组件顺序也能接受的话，是不是等于JSX语法也没有优势呢？</p><p>那我们再来看一种场景，看看你如果不用JSX语法，能不能接受这样的维护成本。这个场景就是“动态组件的条件渲染”，例如常见的对话框条件显示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c7/72/c7f6ee3298c0883ee3b9df52c0a67172.png?wh=1298x974\" alt=\"图片\"></p><p>如果用模板语法怎么来实现呢？我们先看对话框代码：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div v-if=\"props.show\" class=\"v-dialog-mask\"&gt;\n    &lt;div class=\"v-dialog\"&gt;\n      &lt;div class=\"v-dialog-text\"&gt;\n        {{props.text}}\n      &lt;/div&gt;\n      &lt;div class=\"v-dialog-footer\"&gt;\n        &lt;button class=\"v-dialog-btn\" @click=\"onOk\"&gt;确定&lt;/button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script setup &gt;\nimport { toRef, toRefs, computed } from 'vue';\nconst props = defineProps({\n  text: String,\n  show: Boolean,\n});\nconst emits = defineEmits(['onOk']);\n\nconst onOk = () =&gt; {\n  emits('onOk');\n}\n&lt;/script&gt;\n&lt;style&gt;\n/* 完整样式代码请看后续附带仓库链接 */\n&lt;/style&gt;\n</code></pre><p>再看使用对话框代码：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div class=\"app\"&gt;\n    &lt;button class=\"btn\" @click=\"onClickOpenDialog\" &gt;打开对话框&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;Dialog \n    :show=\"showDialog\" \n    :text=\"showText\"\n    @onOk=\"onDialogOk\"\n  /&gt;\n&lt;/template&gt;\n&lt;script setup&gt;\nimport { ref } from 'vue';\nimport Dialog from './dialog.vue';\n\nconst showDialog = ref(false);\nconst showCount = ref(0);\nconst showText = ref('温馨提示，这是一个对话框')\n\nconst onClickOpenDialog = () =&gt; {\n  showDialog.value = true;\n  showCount.value += 1;\n  showText.value = `温馨提示，这是第${showCount.value}次打开对话框`\n}\n\nconst onDialogOk = () =&gt; {\n  showDialog.value = false;\n}\n&lt;/script&gt;\n&lt;style&gt;\n/* 完整样式代码请看后续附带仓库链接 */\n&lt;/style&gt;\n</code></pre><p>上述是用模板语法实现的对话框“条件动态”显示，你能看到，如果要控制一个对话框显示，不仅需要一个变量 showDialog 来控制，还需要把一个 &lt;Dialog&gt; 标签“埋在”模板里；如果后续有多个对话框显示，就需要控制多个变量和多个对话框标签。这样子代码虽然能运行，但是维护起来就比较冗余了。</p><p>那么换成JSX写法会是怎样呢？我这里给你看一下JSX写法的对话框组件：</p><pre><code class=\"language-javascript\">import { defineComponent, reactive, createApp, h, toRaw } from 'vue';\n\nconst Dialog = defineComponent({\n  props: {\n    text: String,\n  },\n  emits: [ 'onOk' ],\n  setup(props, context) {\n    const { emit } = context;\n    const state = reactive({\n      count: 0\n    });\n    const onOk = () =&gt; {\n      emit('onOk')\n    }\n    return {\n      props,\n      onOk,\n    }\n  },\n  render(ctx) {\n    const { props, onOk } = ctx;\n    return (\n      &lt;div class=\"v-dialog-mask\"&gt;\n        &lt;div class=\"v-dialog\"&gt;\n          &lt;div class=\"v-dialog-text\"&gt;\n            {props.text}\n          &lt;/div&gt;\n          &lt;div class=\"v-dialog-footer\"&gt;\n            &lt;button class=\"v-dialog-btn\" onClick={onOk}&gt;确定&lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    )\n  }\n});\n\nexport function createDialog(params = {}) {\n  const dom = document.createElement('div');\n  const body = document.querySelector('body');\n  body.appendChild(dom);\n  const app = createApp({\n    render() {\n      return h(Dialog, {\n        text: params.text,\n        onOnOk: params.onOk\n      })\n    }\n  });\n  app.mount(dom)\n\n  return {\n    close: () =&gt; {\n      app.unmount();\n      dom.remove();\n    }\n  }\n};\n</code></pre><p>我们来分析上述JSX语法实现的对话框组件代码，核心思路是这样子的：</p><ul>\n<li>提供一个方法直接调用对话框渲染；</li>\n<li>触发方法时候，在页面<code>&lt;body&gt;</code>标签上创建一个动态<code>&lt;div&gt;</code>标签；</li>\n<li>用JSX生成对话框组件，挂载在这个动态<code>&lt;div&gt;</code>标签上，对话框显示；</li>\n<li>调用方法返回一个对象，内置一个方法属性提供对话框的关闭操作。</li>\n</ul><p>使用时就是按照简单的方法使用，如下代码所示：</p><pre><code class=\"language-javascript\">import { createDialog } from './dialog';\n\n// ...\nconst dialog = createDialog({\n  text: `温馨提示，这是第${showCount.value}次打开对话框`,\n  onOk: () =&gt; {\n    dialog.close();\n  }\n});\n</code></pre><p>如果要同时显示多个对话框，就直接执行多次调用，代码如下所示：</p><pre><code class=\"language-javascript\">import { createDialog } from './dialog';\n\n// ...\nconst dialog1 = createDialog({\n  text: `温馨提示，这是第1个对话框`,\n  onOk: () =&gt; {\n    dialog1.close();\n  }\n});\n\nconst dialog2 = createDialog({\n  text: `温馨提示，这是第2个对话框`,\n  onOk: () =&gt; {\n    dialog2.close();\n  }\n});\n</code></pre><p>你看这里的代码，是不是比起模板写法维护起来简单得多呢？只需要用单纯的方法调用来触发对话框就行了，不需要像模板语法那样，对每个对话框维护一个变量和标签。</p><p>看到这里，我们再来回顾一下刚刚提到的场景。“动态组件”场景下，相比模板语法，JSX有更加灵活的功能实现和后续代码维护。<strong>但是这个代码的开发和维护的难度并不是绝对的，而是相对的</strong>。</p><p>为什么说是相对的呢？其实这个“难度相对”是针对人来说的，而不是技术本身。</p><p>因为不同开发者对两种语法的驾驭程度和理解程度不一样，虽然JSX语法比较灵活，但是要驾驭好，需要你有比较好的JavaScript设计思维。而模板语法虽然没有JSX语法那么灵活，但是它学习成本比较低，同时官方也有大量的模板语法的案例。</p><p>那么，现在引申出了一个问题，既然两种语法各有优点，同时它们开发和项目维护难度也是因人而异的，那么我们在企业的项目中如何选择这两种语法呢？</p><p>关于怎么选择，我这里就一个观点，用一句网络话语来讲就是“小朋友才做选择，大人们全都要”。</p><p><strong>其实两种语法不是互斥的，而是可以共存互相使用的</strong>，所以在基于Vue.js 3开发的项目里，我们可以这么选择开发语法：</p><ul>\n<li>普通功能开发以模板语法为主，方便照顾到团队里不同技术能力程度的组员，让项目技术实现沟通起来方便些；</li>\n<li>模板语法比较难实现的功能就换成JSX语法实现，例如一些对话框等动态组件场景，主要为了功能灵活实现和后续代码维护。</li>\n</ul><p>另外，你可能还会有疑问，官方推荐的开发语法就是模板语法，那如果我们要学习JSX语法有什么渠道呢？我的答案是多去借鉴一些使用JSX语法的成熟Vue.js 3开源项目，例如，<a href=\"https://github.com/vueComponent/ant-design-vue\">Ant Design Vue</a>、<a href=\"https://github.com/vant-ui/vant/\">Vant UI</a>等。</p><p>这些开源项目都是比较流行的 Vue.js 3 UI组件库，基本能覆盖大部分的企业项目前端开发场景。如果你遇到了某些场景想用JSX语法开发，可以去参考对应的组件的JSX语法设计。</p><h2>总结</h2><p>我们这节课主要介绍和对比了两种Vue.js 3的开发语法，模板语法和JSX语法。你从中可以理解到两种语法的差异和适用场景。</p><p>在面对普通功能开发中，我们可以选择模板语法进行开发，是基于模板语法的简易学习成本，方便团队组员的项目协同合作，在面对一些动态功能开发（例如对话框等动态渲染场景），可以选择JSX语法进行开发，让代码更灵活扩展和维护迭代。</p><p>但我不希望你只仅仅看到两种语法的使用场景，我希望你能从中理解到Vue.js 3开发语法的选择不是绝对根据语法的优缺点，而是要考虑到团队人员对技术的驾驭程度，如果团队成员是React.js转Vue.js，那么估计对JSX语法比较熟悉，强行统一用模板语法开发Vue.js 3项目估计不是一个最好的选择。</p><p>这也引申出一个概念，技术没有绝对的适用场景。在实际团队的项目开发中，要选择某种技术或者某种技术模式，不仅仅要考虑技术优缺点，还要考虑人员的能力程度，综合考虑选择出高效率的技术方案。</p><h2>思考</h2><p>前端开发组件经常会遇到组件的“递归使用”，也就是组件内部也循环使用了组件自己，那么，如何用模板语法和JSX语法处理组件的“自我递归使用”呢？</p><h3><a href=\"https://github.com/FE-star/vue3-course/tree/main/chapter/04\">完整的代码在这里</a></h3>","neighbors":{"left":{"article_title":"03｜从Rollup到Vite：如何用Vite构建你的Vue 3项目？","id":607039},"right":{"article_title":"05｜响应式开发操作：如何理解和使用Vue 3的响应式数据？","id":608231}},"comments":[{"had_liked":false,"id":364083,"user_name":"深山大泽平原","can_delete":false,"product_type":"c1","uid":1368251,"ip_address":"重庆","ucode":"4FB75D790F6F8F","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/bb/14ab8d70.jpg","comment_is_top":false,"comment_ctime":1670506013,"is_pvip":false,"replies":[{"id":135003,"content":"您好，你提供的代码非常棒！本课受限于篇幅，没能展开讲解Vue.js 3的&lt;component &#47;&gt; 组件。","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1678625970,"ip_address":"浙江","comment_id":364083,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"用模板语法的数组实现组件的reverse：\n\n&lt;template&gt;\n    &lt;div class=&quot;template-reverse-box&quot;&gt;\n        &lt;template v-for=&quot;item in comArr&quot;&gt;\n            &lt;component :is=&quot;item.name&quot;&gt;&lt;&#47;component&gt;\n        &lt;&#47;template&gt;\n        &lt;button @click=&quot;changeModule&quot;&gt;reverse&lt;&#47;button&gt;\n    &lt;&#47;div&gt;\n&lt;&#47;template&gt;\n&lt;script setup lang=&quot;ts&quot;&gt;\nimport { reactive, markRaw} from &#39;vue&#39;;\nimport Module01 from &#39;.&#47;Module01.vue&#39;\nimport Module02 from &#39;.&#47;Module02.vue&#39;\nimport Module03 from &#39;.&#47;Module03.vue&#39;\nimport Module04 from &#39;.&#47;Module04.vue&#39;\n\ntype Item = {\n    name: any\n}\nlet comArr = reactive&lt;Item[]&gt;([\n    {\n        name: markRaw(Module01)\n    },\n    {\n        name: markRaw(Module02)\n    },\n    {\n        name: markRaw(Module03)\n    },\n    {\n        name: markRaw(Module04)\n    },\n])\nconst changeModule = () =&gt; {\n    comArr.reverse()\n}\n&lt;&#47;script&gt;","like_count":6,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608736,"discussion_content":"您好，你提供的代码非常棒！本课受限于篇幅，没能展开讲解Vue.js 3的&lt;component /&gt; 组件。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1678625971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2957469,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/20/9d/791d0f5e.jpg","nickname":"善良的老王","note":"","ucode":"4D305C2279BCD9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597670,"discussion_content":"作者的目的大家知晓就行，还真杠上了。。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1672138960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3587891,"avatar":"","nickname":"Geek_abff8c","note":"","ucode":"E8654E20260019","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":613304,"discussion_content":"这个实现的代码可读性，比jsx要差很多吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681262562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368116,"user_name":"直须","can_delete":false,"product_type":"c1","uid":1434005,"ip_address":"广东","ucode":"C4D86C6C35C4DE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e1/95/5339b68d.jpg","comment_is_top":false,"comment_ctime":1675913093,"is_pvip":false,"replies":[{"id":134959,"content":"您好，在.vue文件里可以直接引入JSX组件的，这个取决于所用的构建工具（Webpack、Vite等）是否加载了Vue JSX语法的编译插件。","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1678524969,"ip_address":"浙江","comment_id":368116,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"怎么在.vue文件中引入jsx组件呢","like_count":2,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608578,"discussion_content":"您好，在.vue文件里可以直接引入JSX组件的，这个取决于所用的构建工具（Webpack、Vite等）是否加载了Vue JSX语法的编译插件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678524970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1782286,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/32/0e/5024c2dd.jpg","nickname":"星空","note":"","ucode":"E4E2090ECBB70F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":615756,"discussion_content":"需要安装 @vitejs/plugin-vue-jsx 这个插件，否则页面会报错","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1682425007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1244031,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fb/7f/5da88fb5.jpg","nickname":"小锅","note":"","ucode":"A1D46851246755","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607423,"discussion_content":"直接import进去就行啦，其实看最后边的demo也能看到啦。你看到jsx-dialog目录就清楚怎么玩了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677852683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1434005,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e1/95/5339b68d.jpg","nickname":"直须","note":"","ucode":"C4D86C6C35C4DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1244031,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fb/7f/5da88fb5.jpg","nickname":"小锅","note":"","ucode":"A1D46851246755","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607573,"discussion_content":"嗯嗯 谢谢解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677947757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":607423,"ip_address":"广东","group_id":0},"score":607573,"extra":""}]}]},{"had_liked":false,"id":363670,"user_name":"ZR-rd","can_delete":false,"product_type":"c1","uid":2076199,"ip_address":"北京","ucode":"427E69255F30D8","user_header":"https://static001.geekbang.org/account/avatar/00/1f/ae/27/74828c37.jpg","comment_is_top":false,"comment_ctime":1669967308,"is_pvip":false,"replies":[{"id":135012,"content":"您好，避免样式干扰方式有很多。\n1. 可以从className角度处理，比如可以约定一个className命名规律，尽量避免className重名。\n2. 可以借助JS in CSS处理方案，比如用 styled-components这个npm模块。","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1678626870,"ip_address":"浙江","comment_id":363670,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"JSX 不能配置 scoped 避免 CSS 样式干扰，那么 JSX 应该如何做才能避免样式干扰呢","like_count":2,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608746,"discussion_content":"您好，避免样式干扰方式有很多。\n1. 可以从className角度处理，比如可以约定一个className命名规律，尽量避免className重名。\n2. 可以借助JS in CSS处理方案，比如用 styled-components这个npm模块。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678626870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3069180,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/d4/fc/e28388fa.jpg","nickname":"不识石务","note":"","ucode":"6A31D67A9F5667","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600777,"discussion_content":"scope-jsx-loader 负责对 jsx 文件进行解析和转换，它会查找 jsx 中所有的 className, 然后将每个 className 的值转换为 ${className}-${hash} 的模式。\n\nscope-css-loader 负责同步样式文件中对应类名的变更，将类名选择器转换为 .${className}-${hash}\n\n这个过程完全是在构建环节自动进行的，你不需要像 css module 那样关注 jsx 和样式文件关联的细节，可以正常编写 className 和样式文件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674874581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"中国香港","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595513,"discussion_content":"同楼上，可以参考 CSS in js，但最近 CSS in js 也有很热烈的讨论，具体可以围观 Ant5 发布后，大家对其使用 CSS in js 的讨论","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670172801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1480933,"avatar":"https://static001.geekbang.org/account/avatar/00/16/98/e5/46c5235b.jpg","nickname":"烛火星光","note":"","ucode":"0CF72A5C4EDBCB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595480,"discussion_content":"这个就得参考react当中的CSS in js 的解决方案了，各有优缺点，我是觉得scoped的方案很优雅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670135116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363674,"user_name":"飞雪👻","can_delete":false,"product_type":"c1","uid":3078329,"ip_address":"陕西","ucode":"6D9EA5D49A90E0","user_header":"https://static001.geekbang.org/account/avatar/00/2e/f8/b9/36a74bc2.jpg","comment_is_top":false,"comment_ctime":1669970240,"is_pvip":false,"replies":[{"id":135013,"content":"您好，两种书写方式都可以的，本课代码只是写多一个模板字符串的使用，无特殊用意。","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1678626988,"ip_address":"浙江","comment_id":363674,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"想请教一下, 我不太明白在用JSX写转换顺序, render函数中-------转换顺序: {`${isReverse}`}------ 为什么不直接写作{ isReverse } , 而是用模板字符串包裹呢 ?","like_count":0,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608748,"discussion_content":"您好，两种书写方式都可以的，本课代码只是写多一个模板字符串的使用，无特殊用意。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678626988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595514,"discussion_content":"emmm，这只是因为本来这个字符串还写了别的东东，后来删了，就变成这样了。这不是一个值得探究的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670172940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363531,"user_name":"都市夜归人","can_delete":false,"product_type":"c1","uid":1071909,"ip_address":"江苏","ucode":"DFF59BE3D80B42","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/25/d78cc1fe.jpg","comment_is_top":false,"comment_ctime":1669792433,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"用模板方法一样能通过调整数组的顺序去实现，而不是用v-if。这是为了使用JSX而这样做的吧，个人觉得例子举的不是很恰当。","like_count":2,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595258,"discussion_content":"感谢提出疑问，站在非初学者的角度来看你说的是对的。但因为本篇在入门Vue，应当在尽量不引入新语法的前提下做对比，由于目前没有介绍“动态组件”，所以只能用v-if来实现，这才有对比价值呀。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1669881248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363440,"user_name":"请叫我潜水员","can_delete":false,"product_type":"c1","uid":2625788,"ip_address":"广东","ucode":"9AF80FF19CD6F2","user_header":"https://static001.geekbang.org/account/avatar/00/28/10/fc/213c381f.jpg","comment_is_top":false,"comment_ctime":1669688619,"is_pvip":true,"replies":null,"discussion_count":3,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"dialog那个例子用模板是一样的效果，Dialog组件从dialog.vue中引入，然后创建一个相同的createDialog，使用效果一模一样。因为我就是这么用的","like_count":1,"discussions":[{"author":{"id":2025816,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/e9/58/7bb2c561.jpg","nickname":"请务必优秀","note":"","ucode":"2B7AE4EF41C972","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609324,"discussion_content":"大佬可以贴下代码吗？什么场景这么用呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678943802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2647147,"avatar":"https://static001.geekbang.org/account/avatar/00/28/64/6b/d8ca3b18.jpg","nickname":"方剑鹏","note":"","ucode":"4F3C9227BA2681","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595301,"discussion_content":"没看懂，大佬可以贴一段代码不","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669906304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1707726,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/0e/ce/1e02a513.jpg","nickname":"刘大夫","note":"","ucode":"B03DCF41E50ADF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2647147,"avatar":"https://static001.geekbang.org/account/avatar/00/28/64/6b/d8ca3b18.jpg","nickname":"方剑鹏","note":"","ucode":"4F3C9227BA2681","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602541,"discussion_content":"类似 vue2 时期的 Vue.extend(dialog.vue)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675822133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":595301,"ip_address":"北京","group_id":0},"score":602541,"extra":""}]}]},{"had_liked":false,"id":393844,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1725079525,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100311101,"comment_content":"组件内递归调用，没有结束条件的话会卡死吧?","like_count":0},{"had_liked":false,"id":393843,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1725079482,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100311101,"comment_content":"学习打卡","like_count":0},{"had_liked":false,"id":386840,"user_name":"xhsndl","can_delete":false,"product_type":"c1","uid":3803175,"ip_address":"贵州","ucode":"22C4A146B1B63A","user_header":"https://static001.geekbang.org/account/avatar/00/3a/08/27/0bd80208.jpg","comment_is_top":false,"comment_ctime":1705650515,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"1. 模板语法实现组件递归（借鉴了前辈的想法）\n&lt;template v-for=&quot;item in array&quot; :key=&quot;item&quot;&gt;\n    &lt;component :is=&quot;item&quot;&#47;&gt;\n&lt;&#47;template&gt;\n&lt;script&gt;\nimport A1 from &quot;.&#47;A1.vue&quot;\nimport A2 from &quot;.&#47;A2.vue&quot;\nimport A3 from &quot;.&#47;A3.vue&quot;\nimport {reactive,markRaw} from &quot;vue&quot;\n\nlet array = reactive([\n    markRaw(A1),\n    markRaw(A2),\n    markRaw(A3),\n])\n&lt;&#47;script&gt;\n\n2. JSX实现模板组件递归\n想法是将组件构造函数引入，结合数组对象来进行实现\n&#47;&#47; 预先用jsx语法实现了A组件,假设用text接收参数、onOk接收点击事件的回调函数\n&#47;&#47; 创建组件后返回onClose方法\n&lt;script&gt;\nimport {createA} from &quot;.&#47;A.jsx&quot;\n\nlet A1 = createA({\n  text:&#39;123456&#39;,\n  onOk:() =&gt; {\n      A1.onClose()  \n  }  \n})\n&lt;&#47;script&gt;\n\n&#47;&#47; ---------------\n&#47;&#47; 实现JSX的循环调用\n&lt;script&gt;\nimport {createA} from &quot;.&#47;A.jsx&quot;\nimport {reactive} from &quot;vue&quot;\n\nlet array = reactive([&#39;123&#39;,&#39;456&#39;,&#39;789&#39;])\narray.forEach(item =&gt; \n    let temp = createA(\n        text:item,\n        onOk:() =&gt; temp.onClose()\n    )\n)\n&lt;&#47;script&gt;","like_count":0},{"had_liked":false,"id":385108,"user_name":"Spike Jim.Fun","can_delete":false,"product_type":"c1","uid":1300707,"ip_address":"中国香港","ucode":"C956A19146E1DA","user_header":"https://static001.geekbang.org/account/avatar/00/13/d8/e3/987c9195.jpg","comment_is_top":false,"comment_ctime":1702092448,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"jsx的css模块化可以使用postcss-modules实现","like_count":0},{"had_liked":false,"id":378715,"user_name":"中欧校友","can_delete":false,"product_type":"c1","uid":3230583,"ip_address":"上海","ucode":"EC752820F3586A","user_header":"https://static001.geekbang.org/account/avatar/00/31/4b/77/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1690678484,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100311101,"comment_content":"模板语法递归在组件内用name名再次引用，JSX在组件函数内直接使用函数名调用实现梯柜","like_count":0}]}