{"id":165103,"title":"08 | 理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口？","content":"<p>在面向对象编程中，抽象类和接口是两个经常被用到的语法概念，是面向对象四大特性，以及很多设计模式、设计思想、设计原则编程实现的基础。比如，我们可以使用接口来实现面向对象的抽象特性、多态特性和基于接口而非实现的设计原则，使用抽象类来实现面向对象的继承特性和模板设计模式等等。</p><p>不过，并不是所有的面向对象编程语言都支持这两个语法概念，比如，C++这种编程语言只支持抽象类，不支持接口；而像Python这样的动态编程语言，既不支持抽象类，也不支持接口。尽管有些编程语言没有提供现成的语法来支持接口和抽象类，我们仍然可以通过一些手段来模拟实现这两个语法概念。</p><p>这两个语法概念不仅在工作中经常会被用到，在面试中也经常被提及。比如，“接口和抽象类的区别是什么？什么时候用接口？什么时候用抽象类？抽象类和接口存在的意义是什么？能解决哪些编程问题？”等等。</p><p>你可以先试着回答一下，刚刚我提出的几个问题。如果你对某些问题还有些模糊不清，那也没关系，今天，我会带你把这几个问题彻底搞清楚。下面我们就一起来看！</p><h2>什么是抽象类和接口？区别在哪里？</h2><p>不同的编程语言对接口和抽象类的定义方式可能有些差别，但差别并不会很大。Java这种编程语言，既支持抽象类，也支持接口，所以，为了让你对这两个语法概念有比较直观的认识，我们拿Java这种编程语言来举例讲解。</p><!-- [[[read_end]]] --><p><strong>首先，我们来看一下，在Java这种编程语言中，我们是如何定义抽象类的。</strong></p><p>下面这段代码是一个比较典型的抽象类的使用场景（模板设计模式）。Logger是一个记录日志的抽象类，FileLogger和MessageQueueLogger继承Logger，分别实现两种不同的日志记录方式：记录日志到文件中和记录日志到消息队列中。FileLogger和MessageQueueLogger两个子类复用了父类Logger中的name、enabled、minPermittedLevel属性和log()方法，但因为这两个子类写日志的方式不同，它们又各自重写了父类中的doLog()方法。</p><pre><code>// 抽象类\npublic abstract class Logger {\n  private String name;\n  private boolean enabled;\n  private Level minPermittedLevel;\n\n  public Logger(String name, boolean enabled, Level minPermittedLevel) {\n    this.name = name;\n    this.enabled = enabled;\n    this.minPermittedLevel = minPermittedLevel;\n  }\n  \n  public void log(Level level, String message) {\n    boolean loggable = enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());\n    if (!loggable) return;\n    doLog(level, message);\n  }\n  \n  protected abstract void doLog(Level level, String message);\n}\n// 抽象类的子类：输出日志到文件\npublic class FileLogger extends Logger {\n  private Writer fileWriter;\n\n  public FileLogger(String name, boolean enabled,\n    Level minPermittedLevel, String filepath) {\n    super(name, enabled, minPermittedLevel);\n    this.fileWriter = new FileWriter(filepath); \n  }\n  \n  @Override\n  public void doLog(Level level, String mesage) {\n    // 格式化level和message,输出到日志文件\n    fileWriter.write(...);\n  }\n}\n// 抽象类的子类: 输出日志到消息中间件(比如kafka)\npublic class MessageQueueLogger extends Logger {\n  private MessageQueueClient msgQueueClient;\n  \n  public MessageQueueLogger(String name, boolean enabled,\n    Level minPermittedLevel, MessageQueueClient msgQueueClient) {\n    super(name, enabled, minPermittedLevel);\n    this.msgQueueClient = msgQueueClient;\n  }\n  \n  @Override\n  protected void doLog(Level level, String mesage) {\n    // 格式化level和message,输出到消息中间件\n    msgQueueClient.send(...);\n  }\n}\n</code></pre><p>通过上面的这个例子，我们来看一下，抽象类具有哪些特性。我总结了下面三点。</p><ul>\n<li>抽象类不允许被实例化，只能被继承。也就是说，你不能new一个抽象类的对象出来（Logger logger = new Logger(...);会报编译错误）。</li>\n<li>抽象类可以包含属性和方法。方法既可以包含代码实现（比如Logger中的log()方法），也可以不包含代码实现（比如Logger中的doLog()方法）。不包含代码实现的方法叫作抽象方法。</li>\n<li>子类继承抽象类，必须实现抽象类中的所有抽象方法。对应到例子代码中就是，所有继承Logger抽象类的子类，都必须重写doLog()方法。</li>\n</ul><p><strong>刚刚我们讲了如何定义抽象类，现在我们再来看一下，在Java这种编程语言中，我们如何定义接口。</strong></p><pre><code>// 接口\npublic interface Filter {\n  void doFilter(RpcRequest req) throws RpcException;\n}\n// 接口实现类：鉴权过滤器\npublic class AuthencationFilter implements Filter {\n  @Override\n  public void doFilter(RpcRequest req) throws RpcException {\n    //...鉴权逻辑..\n  }\n}\n// 接口实现类：限流过滤器\npublic class RateLimitFilter implements Filter {\n  @Override\n  public void doFilter(RpcRequest req) throws RpcException {\n    //...限流逻辑...\n  }\n}\n// 过滤器使用Demo\npublic class Application {\n  // filters.add(new AuthencationFilter());\n  // filters.add(new RateLimitFilter());\n  private List&lt;Filter&gt; filters = new ArrayList&lt;&gt;();\n  \n  public void handleRpcRequest(RpcRequest req) {\n    try {\n      for (Filter filter : filters) {\n        filter.doFilter(req);\n      }\n    } catch(RpcException e) {\n      // ...处理过滤结果...\n    }\n    // ...省略其他处理逻辑...\n  }\n}\n</code></pre><p>上面这段代码是一个比较典型的接口的使用场景。我们通过Java中的interface关键字定义了一个Filter接口。AuthencationFilter和RateLimitFilter是接口的两个实现类，分别实现了对RPC请求鉴权和限流的过滤功能。</p><p>代码非常简洁。结合代码，我们再来看一下，接口都有哪些特性。我也总结了三点。</p><ul>\n<li>接口不能包含属性（也就是成员变量）。</li>\n<li>接口只能声明方法，方法不能包含代码实现。</li>\n<li>类实现接口的时候，必须实现接口中声明的所有方法。</li>\n</ul><p>前面我们讲了抽象类和接口的定义，以及各自的语法特性。从语法特性上对比，这两者有比较大的区别，比如抽象类中可以定义属性、方法的实现，而接口中不能定义属性，方法也不能包含代码实现等等。除了语法特性，从设计的角度，两者也有比较大的区别。</p><p>抽象类实际上就是类，只不过是一种特殊的类，这种类不能被实例化为对象，只能被子类继承。我们知道，继承关系是一种is-a的关系，那抽象类既然属于类，也表示一种is-a的关系。相对于抽象类的is-a关系来说，接口表示一种has-a关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议（contract）。</p><h2>抽象类和接口能解决什么编程问题？</h2><p>刚刚我们学习了抽象类和接口的定义和区别，现在我们再来学习一下，抽象类和接口存在的意义，让你知其然知其所以然。</p><p><strong>首先，我们来看一下，我们为什么需要抽象类？它能够解决什么编程问题？</strong></p><p>刚刚我们讲到，抽象类不能实例化，只能被继承。而前面的章节中，我们还讲到，继承能解决代码复用的问题。所以，抽象类也是为代码复用而生的。多个子类可以继承抽象类中定义的属性和方法，避免在子类中，重复编写相同的代码。</p><p>不过，既然继承本身就能达到代码复用的目的，\b而继承也并不要求父类一定是抽象类，那我们不使用抽象类，照样也可以实现继承和复用。从这个角度上来讲，我们貌似并不需要抽象类这种语法呀。那抽象类除了解决代码复用的问题，还有什么其他存在的意义吗？</p><p>我们还是拿之前那个打印日志的例子来讲解。我们先对上面的代码做下改造。在改造之后的代码中，Logger不再是抽象类，只是一个普通的父类，删除了Logger中log()、doLog()方法，新增了isLoggable()方法。FileLogger和MessageQueueLogger还是继承Logger父类，以达到代码复用的目的。具体的代码如下：</p><pre><code>// 父类：非抽象类，就是普通的类. 删除了log(),doLog()，新增了isLoggable().\npublic class Logger {\n  private String name;\n  private boolean enabled;\n  private Level minPermittedLevel;\n\n  public Logger(String name, boolean enabled, Level minPermittedLevel) {\n    //...构造函数不变，代码省略...\n  }\n\n  protected boolean isLoggable() {\n    boolean loggable = enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());\n    return loggable;\n  }\n}\n// 子类：输出日志到文件\npublic class FileLogger extends Logger {\n  private Writer fileWriter;\n\n  public FileLogger(String name, boolean enabled,\n    Level minPermittedLevel, String filepath) {\n    //...构造函数不变，代码省略...\n  }\n  \n  public void log(Level level, String mesage) {\n    if (!isLoggable()) return;\n    // 格式化level和message,输出到日志文件\n    fileWriter.write(...);\n  }\n}\n// 子类: 输出日志到消息中间件(比如kafka)\npublic class MessageQueueLogger extends Logger {\n  private MessageQueueClient msgQueueClient;\n  \n  public MessageQueueLogger(String name, boolean enabled,\n    Level minPermittedLevel, MessageQueueClient msgQueueClient) {\n    //...构造函数不变，代码省略...\n  }\n  \n  public void log(Level level, String mesage) {\n    if (!isLoggable()) return;\n    // 格式化level和message,输出到消息中间件\n    msgQueueClient.send(...);\n  }\n}\n</code></pre><p>这个设计思路虽然达到了代码复用的目的，但是无法使用多态特性了。像下面这样编写代码，就会出现编译错误，因为Logger中并没有定义log()方法。</p><pre><code>Logger logger = new FileLogger(&quot;access-log&quot;, true, Level.WARN, &quot;/users/wangzheng/access.log&quot;);\nlogger.log(Level.ERROR, &quot;This is a test log message.&quot;);\n</code></pre><p>你可能会说，这个问题解决起来很简单啊。我们在Logger父类中，定义一个空的log()方法，让子类重写父类的log()方法，实现自己的记录日志的逻辑，不就可以了吗？</p><pre><code>public class Logger {\n  // ...省略部分代码...\n  public void log(Level level, String mesage) { // do nothing... }\n}\npublic class FileLogger extends Logger {\n  // ...省略部分代码...\n  @Override\n  public void log(Level level, String mesage) {\n    if (!isLoggable()) return;\n    // 格式化level和message,输出到日志文件\n    fileWriter.write(...);\n  }\n}\npublic class MessageQueueLogger extends Logger {\n  // ...省略部分代码...\n  @Override\n  public void log(Level level, String mesage) {\n    if (!isLoggable()) return;\n    // 格式化level和message,输出到消息中间件\n    msgQueueClient.send(...);\n  }\n}\n</code></pre><p>这个设计思路能用，但是，它显然没有之前通过抽象类的实现思路优雅。我为什么这么说呢？主要有以下几点原因。</p><ul>\n<li>在Logger中定义一个空的方法，会影响代码的可读性。如果我们不熟悉Logger背后的设计思想，代码注释又不怎么给力，我们在阅读Logger代码的时候，就可能对为什么定义一个空的log()方法而感到疑惑，需要查看Logger、FileLogger、MessageQueueLogger之间的继承关系，才能弄明白其设计意图。</li>\n<li>当创建一个新的子类继承Logger父类的时候，我们有可能会忘记重新实现log()方法。之前基于抽象类的设计思路，编译器会强制要求子类重写log()方法，否则会报编译错误。你可能会说，我既然要定义一个新的Logger子类，怎么会忘记重新实现log()方法呢？我们举的例子比较简单，Logger中的方法不多，代码行数也很少。但是，如果Logger有几百行，有n多方法，除非你对Logger的设计非常熟悉，否则忘记重新实现log()方法，也不是不可能的。</li>\n<li>Logger可以被实例化，换句话说，我们可以new一个Logger出来，并且调用空的log()方法。这也增加了类被误用的风险。当然，这个问题可以通过设置私有的构造函数的方式来解决。不过，显然没有通过抽象类来的优雅。</li>\n</ul><p><strong>其次，我们再来看一下，我们为什么需要接口？它能够解决什么编程问题？</strong></p><p>抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下API接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。</p><p>实际上，接口是一个比抽象类应用更加广泛、更加重要的知识点。比如，我们经常提到的“基于接口而非实现编程”，就是一条几乎天天会用到，并且能极大地提高代码的灵活性、扩展性的设计思想。关于接口这个知识点，我会单独再用一节课的时间，更加详细全面的讲解，这里就不展开了。</p><h2>如何模拟抽象类和接口两个语法概念？</h2><p>在前面举的例子中，我们使用Java的接口语法实现了一个Filter过滤器。不过，如果你熟悉的是C++这种编程语言，你可能会说，C++只有抽象类，并没有接口，那从代码实现的角度上来说，是不是就无法实现Filter的设计思路了呢？</p><p>实际上，我们可以通过抽象类来模拟接口。怎么来模拟呢？这是一个不错的面试题，你可以先思考一下，然后再来看我的讲解。</p><p>我们先来回忆一下接口的定义：接口中没有成员变量，只有方法声明，没有方法实现，实现接口的类必须实现接口中的所有方法。只要满足这样几点，从设计的角度上来说，我们就可以把它叫作接口。实际上，要满足接口的这些语法特性并不难。在下面这段C++代码中，我们就用抽象类模拟了一个接口（下面这段代码实际上是策略模式中的一段代码）。</p><pre><code>class Strategy { // 用抽象类模拟接口\n  public:\n    ~Strategy();\n    virtual void algorithm()=0;\n  protected:\n    Strategy();\n};\n</code></pre><p>抽象类Strategy没有定义任何属性，并且所有的方法都声明为virtual类型（等同于Java中的abstract关键字），这样，所有的方法都不能有代码实现，并且所有继承这个抽象类的子类，都要实现这些方法。从语法特性上来看，这个抽象类就相当于一个接口。</p><p>不过，如果你熟悉的既不是Java，也不是C++，而是现在比较流行的动态编程语言，比如Python、Ruby等，你可能还会有疑问：在这些动态语言中，不仅没有接口的概念，也没有类似abstract、virtual这样的关键字来定义抽象类，那该如何实现上面的讲到的Filter、Logger的设计思路呢？实际上，除了用抽象类来模拟接口之外，我们还可以用普通类来模拟接口。具体的Java代码实现如下所示。</p><pre><code>public class MockInteface {\n  protected MockInteface() {}\n  public void funcA() {\n    throw new MethodUnSupportedException();\n  }\n}\n</code></pre><p>我们知道类中的方法必须包含实现，这个不符合接口的定义。但是，我们可以让类中的方法抛出MethodUnSupportedException异常，来模拟不包含实现的接口，并且能强迫子类在继承这个父类的时候，都去主动实现父类的方法，否则就会在运行时抛出异常。我们将构造函数设置成protected属性的，这样就能避免非同包下的类去实例化MockInterface。不过，这样还是无法避免同包中的类去实例化MockInterface。为了解决这个问题，我们可以学习Google Guava中@VisibleForTesting注解的做法，自定义一个注解，人为表明不可实例化。</p><p>刚刚我们讲了如何用抽象类来模拟接口，以及如何用普通类来模拟接口，那如何用普通类来模拟抽象类呢？这个问题留给你自己思考，你可以留言说说你的实现方法。</p><p>实际上，对于动态编程语言来说，还有一种对接口支持的策略，那就是duck-typing。我们在上一节课中讲到多态的时候也有讲过，你可以再回忆一下。</p><h2>如何决定该用抽象类还是接口？</h2><p>刚刚的讲解可能有些偏理论，现在，我们就从真实项目开发的角度来看一下，在代码设计、编程开发的时候，什么时候该用抽象类？什么时候该用接口？</p><p>实际上，判断的标准很简单。如果我们要表示一种is-a的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示\b一种has-a关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。</p><p>从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。</p><h2>重点回顾</h2><p>好了，今天内容就讲完了，我们一块来总结回顾一下，你需要掌握的重点内容。</p><p><strong>1.抽象类和接口的语法特性</strong></p><p>抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。</p><p><strong>2.抽象类和接口存在的意义</strong></p><p>抽象类是对成员变量和方法的抽象，是一种is-a关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种has-a关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。</p><p><strong>3.抽象类和接口的应用场景区别</strong></p><p>什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。如果要表示一种is-a的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示\b一种has-a关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。</p><h2>课堂讨论</h2><ol>\n<li>你熟悉的编程语言，是否有现成的语法支持接口和抽象类呢？具体是如何定义的呢？</li>\n<li>前面我们提到，接口和抽象类是两个经常在面试中被问到的概念。学习完今天的内容之后，你是否对抽象类和接口有一个新的认识呢？如果面试官再让你聊聊接口和抽象类，你会如何回答呢？</li>\n</ol><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":153223,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1574203100,"is_pvip":true,"discussion_count":30,"race_medal":0,"score":"1393143607004","product_id":100039001,"comment_content":"如果让我聊聊接口和抽象类，我会这么聊：定义、区别（是什么），存在意义（从哪来），应用（到哪去）。<br>1、定义：<br>抽象类：不允许实例化，只能被继承；可包含属性和方法，包含抽象方法；子类继承抽象类必须重写抽象方法。<br>接口：不允许实例化，只能被实现；不包含属性和普通方法，包含抽象方法、静态方法、default 方法；类实现接口时，必须实现抽象方法。<br>2、意义：<br>抽象类：解决复用问题，适用于is-a的关系。<br>接口：解决抽象问题，适用于has-a的关系。<br>3、应用：<br>例如：<br>解决复用问题：java中的子类FileInputStream和PipeInputStream等继承抽象类InputStream。重写了read(source)方法，InputStream 中还包含其他方法，FileInputStream继承抽象类复用了父类的其他方法。<br>解决抽象问题：抽象类InputStream实现了Closeable接口，该接口中包含close()抽象方法。Closeable这个接口还在很多其他类中实现了，例如Channel，Socket中都有close() 关闭这个功能，但具体实现每个类又各有不同的实现，这个就是抽象。<br><br>4、补充知识点（语法）：<br>Java接口中可以定义静态方法、default方法，枚举类型，接口中还可以定义接口（嵌套）。<br>public interface ILog {<br>  enum Type {<br>    LOW,<br>    MEDIUM,<br>    HIGH<br>  }<br>  interface InILog{<br>    void initInLog();<br>  }<br>  default void init() {<br>    Type t = Type.LOW;<br>    System.out.println(t.ordinal());<br>  }<br>  static void OS() {<br>System.out.println(System.getProperty(&quot;os.name&quot;, &quot;linux&quot;));<br>  }<br>  void log(OutputStream out);<br>}<br>class ConsoleLog implements ILog {<br>  @Override<br>  public void log(OutputStream out) {<br>    System.out.println(&quot;ConsoleLog...&quot;);<br>  }<br>}<br>","like_count":325,"discussions":[{"author":{"id":1322366,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2d/7e/335a9b9d.jpg","nickname":"🐝null","note":"","ucode":"16F5E4965F8D5D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313214,"discussion_content":"我觉得接口和抽象类都可以解决复用和抽象的问题。谁说抽象问题就要用接口不能用抽象类呢，复用问题就要用抽象类不能用接口呢？\n文中也说了很多语言没有接口的概念，JAVA也可以用抽象类来模拟接口。 把抽象类理解成接口也没有毛病。\n两者的区别关键在于抽象类表示的is-a关系，例如FileInputStearm和PipleInputStearm都是InputStearm。\n而接口表示的是has-a，也就是具有某种能力，例如Compareable接口表示可排序，Serializable接口表示可序列化。\n为什么接口可以实现多个，而抽象类不行？我认为接口has-a表示的是具有某种能力或功能，是更细粒度的。比如某个抽象类同时实现Compareable和Serializable表示这个类同时具有两种能力。","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1603003392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1691500,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/6c/87faa554.jpg","nickname":"MoeRookie","note":"","ucode":"E860D73EE91F00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1322366,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2d/7e/335a9b9d.jpg","nickname":"🐝null","note":"","ucode":"16F5E4965F8D5D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322842,"discussion_content":"流弊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604828644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":313214,"ip_address":""},"score":322842,"extra":""},{"author":{"id":1211244,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/6c/4b814030.jpg","nickname":"秋叶","note":"","ucode":"09E44247A0962B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1322366,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2d/7e/335a9b9d.jpg","nickname":"🐝null","note":"","ucode":"16F5E4965F8D5D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350860,"discussion_content":"就好像技能可以有很多种，但爸爸只能有一个(๑˃̵ᴗ˂̵)","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1614053109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":313214,"ip_address":""},"score":350860,"extra":""},{"author":{"id":2475056,"avatar":"https://static001.geekbang.org/account/avatar/00/25/c4/30/711b03e5.jpg","nickname":"Geek_Candice","note":"","ucode":"0F2CBCF624F905","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1211244,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/6c/4b814030.jpg","nickname":"秋叶","note":"","ucode":"09E44247A0962B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405655,"discussion_content":"妙啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634613172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":350860,"ip_address":""},"score":405655,"extra":""}]},{"author":{"id":1912872,"avatar":"","nickname":"雨做的云","note":"","ucode":"93C3EB71B79B70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230819,"discussion_content":"你说的对，作者的的文章是基于JDK1.8之前的版本，default是1.8以后才有的，另外静态方法、接口嵌套、枚举都没错，是允许的；实现类只需要实现接口所有的抽象方法，而非所有的方法，因为default方法是不需要强制实现的","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1586774972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2043699,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/2f/33/e4c24b31.jpg","nickname":"第三人称","note":"","ucode":"5A8245FF04CA63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329005,"discussion_content":"接口可以实例化","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1606296572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/14/cb118a61.jpg","nickname":"键舞飞扬","note":"","ucode":"4EC7A8D2E7AC78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342062,"discussion_content":"C#接口可以包含属性","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610589269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1811277,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a3/4d/59390ba9.jpg","nickname":"排骨","note":"","ucode":"A413CF46211E1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1200660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/14/cb118a61.jpg","nickname":"键舞飞扬","note":"","ucode":"4EC7A8D2E7AC78","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586883,"discussion_content":"c#的属性实则方法吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662554095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":342062,"ip_address":"中国香港"},"score":586883,"extra":""}]},{"author":{"id":1145502,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJdUGdEj3R25CrYqibPibYibibRicqUfyL4aTTPbMagyywjKMhXGZE37RTe7lEdvC4DibvtYpzg8zXvt9HQ/132","nickname":"Fun","note":"","ucode":"5D89BA4C678785","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55338,"discussion_content":"# day 10\n继续学习抽象类和接口的概念。放到C语言的话，抽象类和结构体都只能通过函数指针来实现，多态的话就指针强转吧。初步的直接理解，晚点下班再重新学习一遍。先打卡占座。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574350372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53821,"discussion_content":"接口里所有的方法都在public的吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574221915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53829,"discussion_content":"是的，可以不用写public，默认就是public","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574222883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53821,"ip_address":""},"score":53829,"extra":""},{"author":{"id":1359518,"avatar":"https://static001.geekbang.org/account/avatar/00/14/be/9e/3a542996.jpg","nickname":"liuxing5","note":"","ucode":"C2ED58AF619585","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":304939,"discussion_content":"默认是default，包内可以访问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599718274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53829,"ip_address":""},"score":304939,"extra":""},{"author":{"id":1598067,"avatar":"https://static001.geekbang.org/account/avatar/00/18/62/73/3a0caacc.jpg","nickname":"倔强知足","note":"","ucode":"4178E2AC4DA964","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1359518,"avatar":"https://static001.geekbang.org/account/avatar/00/14/be/9e/3a542996.jpg","nickname":"liuxing5","note":"","ucode":"C2ED58AF619585","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317755,"discussion_content":"是public,接口中的默认和普通类中的默认不一样","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603597445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304939,"ip_address":""},"score":317755,"extra":""}]},{"author":{"id":1237399,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/97/fec494f2.jpg","nickname":"大大。","note":"","ucode":"A6716E46264AC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53718,"discussion_content":"我有一个问题哈，inputstream和socket都有close方法，就算没有closeable接口，他们两个类都实现close方法，这样影响什么呢？或者说你抽出来一个close方法有什么意义？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574211737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1161200,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b7/f0/a570f68a.jpg","nickname":"wang","note":"","ucode":"5D569805C6A923","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1237399,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/97/fec494f2.jpg","nickname":"大大。","note":"","ucode":"A6716E46264AC4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53770,"discussion_content":"接口是规范，就是强制你必须实现close方法，还有基于接口编程的好处就是， jdk7的 try-with-resource ","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1574214650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53718,"ip_address":""},"score":53770,"extra":""},{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1237399,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/97/fec494f2.jpg","nickname":"大大。","note":"","ucode":"A6716E46264AC4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53789,"discussion_content":"首先，谢谢你提的问题！我的回答也可能不准确，希望大家多多补充。\n第一、close一般要做释放资源之类的工作。自己实现一个类如链接、读写、操作流，自己实现close方法时，可能会忘了写这个方法，进而没有释放资源。\n第二、java中closeable接口继承于java1.7之后的autocolseable接口。支持try-with-resource语法。如果我们自己实现这个方法的话，就会不支持这种语法。需要手动的做关闭释放资源？那么岂不是要写更多的代码？\n第三、历史原因：java中closeable接口是一个旧的接口，如果我们要实现一个close功能建议实现autocolseable接口，它抛出的是Exception异常，比closeable接口抛出的IOException更宽泛。\n第四、抽象层面：什么行为定义成接口中的方法，或者抽象类中的方法这个涉及到对面向对象的理解，人和人可能不一样。这个方面我没有什么设计经验，希望各位补充。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574216456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53718,"ip_address":""},"score":53789,"extra":""},{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1161200,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b7/f0/a570f68a.jpg","nickname":"wang","note":"","ucode":"5D569805C6A923","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53791,"discussion_content":"谢谢补充！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574216538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53770,"ip_address":""},"score":53791,"extra":""}]},{"author":{"id":1042114,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLu7SYgsvC9IY5AicAlCtoMGj7znhgo6IZu51XTFxPasFrJr3WPPqusBBicC0rJ3U2la6JRd3qWse1w/132","nickname":"dragon","note":"","ucode":"FC8AB417A9E110","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576644,"discussion_content":"优秀的课代表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655721733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2699218,"avatar":"","nickname":"Geek_279849","note":"","ucode":"FC6A3514FC955C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552813,"discussion_content":"嵌套的接口啥时候会实现呢？jdk有具体例子吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645602765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2029129,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f6/49/e4284e3c.jpg","nickname":"马鹏威","note":"","ucode":"802589E800C098","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290317,"discussion_content":"课代表，总结的好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594424501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1327497,"avatar":"https://static001.geekbang.org/account/avatar/00/14/41/89/77d3e613.jpg","nickname":"bookchan","note":"","ucode":"6C40EEAC767E25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221539,"discussion_content":"作者说：接口不能包含属性（也就是成员变量）。\n接口只能声明方法，方法不能包含代码实现。\n类实现接口的时候，必须实现接口中声明的所有方法。  你说的是必须抽象方法，这里有出入吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586013236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2028943,"avatar":"","nickname":"Geek9625","note":"","ucode":"8110B0DE0432E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1327497,"avatar":"https://static001.geekbang.org/account/avatar/00/14/41/89/77d3e613.jpg","nickname":"bookchan","note":"","ucode":"6C40EEAC767E25","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299478,"discussion_content":"这个我查过文档，我理解所有未被实现的方法都是可以叫做抽象方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597714854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":221539,"ip_address":""},"score":299478,"extra":""}]},{"author":{"id":1476696,"avatar":"https://static001.geekbang.org/account/avatar/00/16/88/58/3e19586a.jpg","nickname":"晓双","note":"","ucode":"59CA9DB77697D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209808,"discussion_content":"这种嵌套定义有什么含义？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584674583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1759533,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d9/2d/8d6c496c.jpg","nickname":"哈蜜瓜","note":"","ucode":"80D12AA70A9DCC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64149,"discussion_content":"考虑换岗么😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574939281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1759533,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d9/2d/8d6c496c.jpg","nickname":"哈蜜瓜","note":"","ucode":"80D12AA70A9DCC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64257,"discussion_content":"我现在是研三的学生，找工作ing","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1574943440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":64149,"ip_address":""},"score":64257,"extra":""}]},{"author":{"id":1237399,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/97/fec494f2.jpg","nickname":"大大。","note":"","ucode":"A6716E46264AC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53721,"discussion_content":"就算不实现closeable接口，两个类自己实现close方法，又有什么弊端？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574211804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1441908,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIA11wHDEjzm6TypVhPnp4QJRX65a5JRibYFG2NSicvEFZzZ9hUKMic7zsLcZIKbU4Rwk9viciaLibuAQrQ/132","nickname":"liujianyu","note":"","ucode":"F65D5C09B9F583","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1237399,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/97/fec494f2.jpg","nickname":"大大。","note":"","ucode":"A6716E46264AC4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56534,"discussion_content":"如果自己实现在需要使用close方法的地方就会耦合到具体的实现上，通过接口定义的话就可以使用多态的特性，不会耦合到具体的实现上，扩展性更强","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574495543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53721,"ip_address":""},"score":56534,"extra":""},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1237399,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/97/fec494f2.jpg","nickname":"大大。","note":"","ucode":"A6716E46264AC4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85432,"discussion_content":"实现closeable接口是显示标明子类可以被close，好处有：1. 配合里式替换原则，可以写出低耦合实现的代码 2.可以轻易筛选出所有支持被close的类，DI时非常有用 3.通过closeable接口就可得知被close时的行为准则是什么，这里是close方法，而且实现类强制要实现，避免了遗漏 4. 消除二义性，比如两个子类都要实现close方法，但方法签名是什么？返回类型是什么？有了接口，访问限定符、返回值、方法名、参数列表都已经定死了，不能篡改，这样就没有了二义性","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1576546274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53721,"ip_address":""},"score":85432,"extra":""}]}]},{"had_liked":false,"id":153863,"user_name":"Maurice","can_delete":false,"product_type":"c1","uid":1729796,"ip_address":"","ucode":"A35112AA415C67","user_header":"","comment_is_top":false,"comment_ctime":1574321574,"is_pvip":false,"discussion_count":16,"race_medal":0,"score":"697359023526","product_id":100039001,"comment_content":"嗯，刚刚看了一下评论区，小弟给大家初学设计模式以及刚刚接触项目的同学一些建议，其实在学这一章更以及往后正式的20多种设计模式时候更加锻炼的是一种抽象思维，以我个人的一点经验，就像老师一开始说的，在学习的时候，不要总是类比生活中的一些阿猫啊狗的例子，没错初次是很好理解，而且你会感觉好像懂了，但是实际上你还是不懂（可能是以为我笨），建议大家没学习一种模式的时候，思考一下现在在做的项目中那些业务可以进行优化，如果可以的话，可以进行重构，这样对你的学习才有很大的帮助；举个栗子，例如策略模式，我们在代码是不是经常调用第三方接口，每个接口都有它的规范之类的，如果你按照low 的方式就是按照规范组织一些报文请求，但是这个时候，你可以用的你的抽象思维，比如,在这类业务中，无外乎就是，1、构建报文，2、请求结构，3、解析返回，那么我就可以这样设计：<br>    &#47;**<br>     * 请求统一接口<br>     *&#47;<br>    public interface Fun&lt;T&gt; {<br>        &#47;**<br>         * 发送请求报文<br>         *&#47;<br>        String constructionRequest();<br>        &#47;**<br>         * 请求报文<br>         *&#47;<br>        String doPost(String request);<br>        &#47;**<br>         * 解析回执报文<br>         *&#47;<br>        T resolveResponse(String responseText);<br>    }<br>然后再写一个策略的算法簇（应该是这么叫）<br>&#47;**<br> * 统一实现接口<br> *&#47;<br>public class DealWithHandle {<br>    <br>    &#47;**<br>     * 描述 create.<br>     *<br>     * @param &lt;T&gt; the type parameter<br>     * @param fun the fun<br>     * @return the t<br>     * @author Maurice Mao<br>     * @created 2018 -07-13 10:58:32 Handle t.<br>     *&#47;<br>    public static &lt;T&gt; T handle(Fun&lt;T&gt; fun) {<br>        <br>        String request = fun.constructionRequest();<br>        <br>        String response = fun.doPost(request);<br>        <br>        T t = fun.resolveResponse(response);<br>        <br>        return t;<br><br>    }<br>}<br>这个时候，假设你做支付宝扫码支付的时候（或者微信以及第三方支付），是不是可以这么调用：<br>public class OfficialAliScan {<br><br>    private static Logger logger = LoggerFactory.getLogger(OfficialAliScan.class);<br><br>    public static ApiTradeResultDto operate(final TradeOrderDO orderDO, final SubMerchatAuthDO subMerchatAuthDO, final String authCode) {<br>        return DealwithHandle.handle(new DealwithHandle.Fun&lt;ApiTradeResultDto&gt;() {<br>            @Override<br>            public String constructionRequest() {<br>                  &#47;&#47;&#47;todo<br>            }<br><br>            @Override<br>            public String doPost(String bizContent) {<br>                &#47;&#47;&#47;todo<br>            }<br><br>            @Override<br>            public ApiTradeResultDto resolveResponse(String responseTxt) {<br>                &#47;&#47;&#47;todo<br>            }<br>        });<br>    }<br>这样的话，你的业务代码组织的就很清晰，也便于调试维护<br>","like_count":163,"discussions":[{"author":{"id":1206066,"avatar":"https://static001.geekbang.org/account/avatar/00/12/67/32/b402f3c5.jpg","nickname":"eve","note":"","ucode":"1C439CB1703118","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":106477,"discussion_content":"你这个不是策略模式，而且这个场景用模板模式更好一些","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1577537755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1744062,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq69BUSktQUY0dhQIoFxSAic0r3ElUUUL1uFtpFnKSpCAJYEsOfibU3Ja701L8UmbrPVS2ZAIreRLtA/132","nickname":"Liscoal","note":"","ucode":"8A6A0DBD60847F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1206066,"avatar":"https://static001.geekbang.org/account/avatar/00/12/67/32/b402f3c5.jpg","nickname":"eve","note":"","ucode":"1C439CB1703118","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249323,"discussion_content":"他这个例子里面,public static <T> T handle(Fun<T> fun);方法的确体现出了策略模式. Fun<T>是抽象策略，其子类是具体策略，而DealWithHandle类则是环境(Context)。\n我个人也赞同你说的这个场景采用模板方法模式会更好.因为这三个步骤1.发送请求报文 2.请求报文 3.解析回执报文的实现细节根据不同业务方差异通常是比较大的，最好还是由不同的子类去实现。\n策略模式比较常见的场景是对过多的if eles优化.","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1587915438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":106477,"ip_address":""},"score":249323,"extra":""},{"author":{"id":1112490,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","nickname":"龙猫","note":"","ucode":"FD726CC969EF9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1744062,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq69BUSktQUY0dhQIoFxSAic0r3ElUUUL1uFtpFnKSpCAJYEsOfibU3Ja701L8UmbrPVS2ZAIreRLtA/132","nickname":"Liscoal","note":"","ucode":"8A6A0DBD60847F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296138,"discussion_content":"都是大佬，学习了，血赚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596459789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":249323,"ip_address":""},"score":296138,"extra":""}]},{"author":{"id":2130462,"avatar":"https://static001.geekbang.org/account/avatar/00/20/82/1e/f3cb3d57.jpg","nickname":"超越自我","note":"","ucode":"8A55D972EEFADA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299586,"discussion_content":"这个应该是模板方法模式","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1597741183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1916100,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/3c/c4/27305e34.jpg","nickname":"Atom","note":"","ucode":"A5204FC1C13A9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285497,"discussion_content":"看了github很多几k star写的设计模式，确实都是用阿猫阿狗来类比，初次容易理解，但是后头就又忘了，实际生产时又想不出来得用什么，为什么用，怎么用","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1592844121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2396269,"avatar":"https://static001.geekbang.org/account/avatar/00/24/90/6d/705f3874.jpg","nickname":"大雄","note":"","ucode":"BABD97EBBB1394","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342486,"discussion_content":"最快的学习方法就是自己在项目里面想着这个功能可以用那种设计模式，及时不需要用，你也去尝试着用，后面就慢慢的理解这种设计模式是什么，怎么用才好，看阿猫阿狗确实看了就忘，不能真正理解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610696106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501018,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/5a/9578215e.jpg","nickname":"蔡晓亮","note":"","ucode":"48C043DE389595","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318286,"discussion_content":"开源项目这种写法比较多，学习了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603698313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103353,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d5/f9/1f9a2c3c.jpg","nickname":"磨砖做镜","note":"","ucode":"D8B8196AE1ED98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250674,"discussion_content":"手机看代码不方便。。这评论区应该支持md","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588035426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1597071,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLe9iavda8ia7vNkbMVEHsCKs43l6U6HGWibiaxxKd9PuiaYu5wRedicC96PLicZ9VIh0ic5Jg8YHPrta3IAQ/132","nickname":"Geek_00e01b","note":"","ucode":"BC76A83B53D0EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1103353,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d5/f9/1f9a2c3c.jpg","nickname":"磨砖做镜","note":"","ucode":"D8B8196AE1ED98","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312114,"discussion_content":"电脑看也不方便，这种没有格式的根本不想看","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602584895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":250674,"ip_address":""},"score":312114,"extra":""}]},{"author":{"id":2707023,"avatar":"https://static001.geekbang.org/account/avatar/00/29/4e/4f/acc26a87.jpg","nickname":"Luffy","note":"","ucode":"ECF5402610FE72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590442,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665741333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2807969,"avatar":"","nickname":"Geek_7ce555","note":"","ucode":"5ED7DD4FF41E26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583089,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659922331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2415448,"avatar":"https://static001.geekbang.org/account/avatar/00/24/db/58/a7a0a85b.jpg","nickname":"二饼","note":"","ucode":"48120565D135F7","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579927,"discussion_content":"厉害，谢谢分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657777269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2349845,"avatar":"","nickname":"Geek_5b71f3","note":"","ucode":"104CB5C80FFF8D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331792,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606978100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1112490,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","nickname":"龙猫","note":"","ucode":"FD726CC969EF9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296136,"discussion_content":"66666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596459770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242573,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","nickname":"小川","note":"","ucode":"D462222DDBB978","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":89912,"discussion_content":"- - 我.. 我也想加","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576764285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131687,"avatar":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","nickname":"啦啦啦","note":"","ucode":"6B12EC90A62525","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82080,"discussion_content":"不错，老兄对设计模式理解的很好，可以加个微信交流一下不","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576317631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153228,"user_name":"NoAsk","can_delete":false,"product_type":"c1","uid":1122412,"ip_address":"","ucode":"71CA29776B4F68","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/6c/e4966364.jpg","comment_is_top":false,"comment_ctime":1574205289,"is_pvip":false,"discussion_count":10,"race_medal":0,"score":"620049495913","product_id":100039001,"comment_content":"Java使用abstract表示抽象类，interface表示接口。<br>老师讲的很好，我补充一下使用；<br>1.java中抽象类是类，而java不支持多继承，当想要实现多继承的时候只能使用表示has-a的接口来实现。<br>2.在java8之前，定义的接口不能有具体实现，这会导致在后续维护的时候如果想要在接口中新增一个方法，必须在所有实现类中都实现一遍，并且只有几个新的实现类可能要去具体实现，其他的都只是加上默认实现，这样比较麻烦。在java8中接口可以用使用关键字default，来实现一个默认方法，这样就解决了上述的麻烦。","like_count":144,"discussions":[{"author":{"id":1330147,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/e3/77410a44.jpg","nickname":"清风明月","note":"","ucode":"45E8660C58A393","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84707,"discussion_content":"接口可以多继承","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576504926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2791265,"avatar":"","nickname":"Geek2694","note":"","ucode":"4355B60D1F58C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1330147,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/e3/77410a44.jpg","nickname":"清风明月","note":"","ucode":"45E8660C58A393","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530369,"discussion_content":"接口叫做实现 不叫继承\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637061699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":84707,"ip_address":""},"score":530369,"extra":"{\"user_type\":1}"}]},{"author":{"id":1676932,"avatar":"https://static001.geekbang.org/account/avatar/00/19/96/84/b07940bc.jpg","nickname":"Android开发","note":"","ucode":"BBED8220445D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412054,"discussion_content":"新的Java语言才支持","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636072451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1743060,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8xHGabhfnPnK7gN3hVJ0n3wia5qIaay7IOQaGJ4ia0kB1CKywjbJNeGjM7DKexk6TZl88f6um4pqw/132","nickname":"早早凡","note":"","ucode":"E70B0306637482","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305869,"discussion_content":"两个接口有同名默认方法，实现类会调用哪个？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600097745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":2109939,"avatar":"https://static001.geekbang.org/account/avatar/00/20/31/f3/22d6ed22.jpg","nickname":"杰西","note":"","ucode":"542B3A9716AA71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1743060,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8xHGabhfnPnK7gN3hVJ0n3wia5qIaay7IOQaGJ4ia0kB1CKywjbJNeGjM7DKexk6TZl88f6um4pqw/132","nickname":"早早凡","note":"","ucode":"E70B0306637482","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306613,"discussion_content":"实现的多个接口不能包含同名的默认方法","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1600330561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305869,"ip_address":""},"score":306613,"extra":""},{"author":{"id":1003487,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4f/df/f24f5dbc.jpg","nickname":"Geek_21ade8","note":"","ucode":"9FCC988B256181","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1743060,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8xHGabhfnPnK7gN3hVJ0n3wia5qIaay7IOQaGJ4ia0kB1CKywjbJNeGjM7DKexk6TZl88f6um4pqw/132","nickname":"早早凡","note":"","ucode":"E70B0306637482","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308675,"discussion_content":"编译会报错","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601026543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305869,"ip_address":""},"score":308675,"extra":""},{"author":{"id":1220273,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9e/b1/758f2fe7.jpg","nickname":"香","note":"","ucode":"121D6CECECEEC3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1743060,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8xHGabhfnPnK7gN3hVJ0n3wia5qIaay7IOQaGJ4ia0kB1CKywjbJNeGjM7DKexk6TZl88f6um4pqw/132","nickname":"早早凡","note":"","ucode":"E70B0306637482","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336336,"discussion_content":"这种情况下，实现类必须要实现该方法，否则编译会报错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608552772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305869,"ip_address":""},"score":336336,"extra":""}]},{"author":{"id":1323102,"avatar":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","nickname":"Younger Ku","note":"","ucode":"D157DC38BDB515","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304014,"discussion_content":"nice","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599449276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153245,"user_name":"Jimbol","can_delete":false,"product_type":"c1","uid":1178008,"ip_address":"","ucode":"8D9190B3B3E08B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/98/95b13446.jpg","comment_is_top":false,"comment_ctime":1574207889,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"212027605393","product_id":100039001,"comment_content":"接口强调具有什么能力(has-a)，<br>抽象类强调是什么(is-a)。","like_count":50},{"had_liked":false,"id":153877,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1574324132,"is_pvip":false,"replies":[{"id":"59157","content":"好像我写的是有点问题，稍后更正下，多谢指出","user_name":"作者回复","comment_id":153877,"uid":"1190123","ip_address":"","utype":1,"ctime":1574377806,"user_name_real":"王争"}],"discussion_count":17,"race_medal":0,"score":"151898179492","product_id":100039001,"comment_content":"『那又如何避免这个类被实例化呢？实际上很简单，我们只需要将这个类的构造函数声明为 protected 访问权限就可以了。』当把一个类的构造方法声明为protected后，在同一个包的其他类中还是可以new这个类的对象的。老师，是我想错了吗？请老师指正","like_count":35,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475305,"discussion_content":"好像我写的是有点问题，稍后更正下，多谢指出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574377806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2162521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MaX06SRk19zM2lAaymYylpXD6LMtIPFlDyxZKgRhmZCjhNE4nIdDGBmh08razhebVCgAv54xialYBBIIwmleBew/132","nickname":"Geek_6d1382","note":"","ucode":"B61E65CFEB684F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307645,"discussion_content":"这个直接在公共构造方法当中抛异常如何？这样也能避免实例化","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1600702435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2195178,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/aaWpgv6exm7wPOQ73dtsJ7sia4FEyibbyGgSKJmCChkAACHDBOff2enL6Nv5DhyXJibcic0nNErcO0fTkT4AqlbGwQ/132","nickname":"Geek_6cf3b2","note":"","ucode":"F9D6B16AC4EA91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329827,"discussion_content":"一年之后依然没改","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606465635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1071601,"avatar":"https://static001.geekbang.org/account/avatar/00/10/59/f1/8909b9e0.jpg","nickname":"叉歪叉","note":"","ucode":"2C1AFC6335FF0E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298719,"discussion_content":"public class SimulatorInterface {\n\n    protected SimulatorInterface() {\n        check();\n    }\n\n    public void check() {\n        throw new IllegalStateException(&#34;&#34;);\n    }\n}\n\npublic class SubClassA extends SimulatorInterface {\n    @Override\n    public void check() {\n    }\n}\n\n---------\n这样不知道可不可以，捂脸","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597387646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1732780,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","nickname":"面向百度编程","note":"","ucode":"8FE04A019D71D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216454,"discussion_content":"还好我看了一下评论，自己并没有错","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585452830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1035963,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ce/bb/e6c353a1.jpg","nickname":"jaxz","note":"","ucode":"9971305B1CEFEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341652,"discussion_content":"依然没改","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610497404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1766127,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/f2/ef/014389c5.jpg","nickname":"李明威","note":"","ucode":"199C95F3A4C1A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320668,"discussion_content":"我说怎么感觉有点问题呢，之前都是写private","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604448795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438470,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f3/06/8da1bf0c.jpg","nickname":"Fredo","note":"","ucode":"681D6692617DAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157365,"discussion_content":"看到这里我也愣了一下，但之后就过去了，这里是个问题。多谢指出！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580474392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2277251,"avatar":"https://static001.geekbang.org/account/avatar/00/22/bf/83/c83be5a3.jpg","nickname":"eHackyd","note":"","ucode":"E6E7994FBDF0A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378761,"discussion_content":"其实能不能实例化是根据访问限定符来看的，自己思考下就知道了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623394076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188793,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/b9/8d182f13.jpg","nickname":"起风了","note":"","ucode":"9A8A2E51E198EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307806,"discussion_content":"啊，还好我看了评论。没学过java，不然就当正确的记成笔记了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600763429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1624574,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/fe/874b172b.jpg","nickname":"benxiong","note":"","ucode":"F6498059D439D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281503,"discussion_content":"还没有改","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591753946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1862936,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/6d/18/e05f72ee.jpg","nickname":"冰原的苍蓝星","note":"","ucode":"84120EC31A63AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255168,"discussion_content":"还没有改？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588383665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1056982,"avatar":"https://static001.geekbang.org/account/avatar/00/10/20/d6/b9513db0.jpg","nickname":"kingcall","note":"","ucode":"508884DC684B5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215727,"discussion_content":"应该是解决不了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585375993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121284,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1c/04/b26b665e.jpg","nickname":"孙杏","note":"","ucode":"F0221C3F8D4C77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157176,"discussion_content":"所以这块正确的表达方式应该是什么呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580450828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1638878,"avatar":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","nickname":"慌张而黑糖","note":"","ucode":"B4416885A301C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102811,"discussion_content":"这里我也有个问题，如果构造函数声明为私有的了，那还能被继承吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577365237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1242373,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/05/d6547381.jpg","nickname":"才才","note":"","ucode":"94D76106261987","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1638878,"avatar":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","nickname":"慌张而黑糖","note":"","ucode":"B4416885A301C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199840,"discussion_content":"如果有一个公共构造函数就可以继承","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583631818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":102811,"ip_address":""},"score":199840,"extra":""}]},{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87142,"discussion_content":"好像还没有改？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576646833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153211,"user_name":"Daiver","can_delete":false,"product_type":"c1","uid":1466447,"ip_address":"","ucode":"9B1A03AFBC79BC","user_header":"https://static001.geekbang.org/account/avatar/00/16/60/4f/db0e62b3.jpg","comment_is_top":false,"comment_ctime":1574182314,"is_pvip":false,"discussion_count":11,"race_medal":0,"score":"104653397418","product_id":100039001,"comment_content":"go和java 都有接口设计，但go的设计是飞入侵入性（duck type），而java必须显式实现该借口，这一点go做的真的好了。","like_count":24,"discussions":[{"author":{"id":1429627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","nickname":"Kevin","note":"","ucode":"9DFFD6E3960CF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53922,"discussion_content":"动态一时爽  重构火葬场","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1574235458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1134761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","nickname":"冰糕不冰","note":"","ucode":"B754FE464BA426","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1429627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","nickname":"Kevin","note":"","ucode":"9DFFD6E3960CF7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54005,"discussion_content":"这跟动态扯不上关系吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574250045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53922,"ip_address":""},"score":54005,"extra":""},{"author":{"id":1356120,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b1/58/7d4f968f.jpg","nickname":"plasmatium","note":"","ucode":"1564F6A20186AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1429627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","nickname":"Kevin","note":"","ucode":"9DFFD6E3960CF7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68947,"discussion_content":"动态运行时才会报错，go是根本编译不过去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575247153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53922,"ip_address":""},"score":68947,"extra":""},{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1429627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","nickname":"Kevin","note":"","ucode":"9DFFD6E3960CF7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157659,"discussion_content":"有时对实现了哪些接口，压根没有个很直观的结果。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1580486091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53922,"ip_address":""},"score":157659,"extra":""}]},{"author":{"id":1200660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/14/cb118a61.jpg","nickname":"键舞飞扬","note":"","ucode":"4EC7A8D2E7AC78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342067,"discussion_content":" 因go不用声明实现了什么接口，当你读别人写的复杂的代码时，你就很难看出类与类之间的关系，你得去对比它们是不是定义了相同结构的方法。可读性与维护性难度大大增加。就为了少定义一个接口？","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1610589664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1298139,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ce/db/bb1821b3.jpg","nickname":"王      慈","note":"","ucode":"EACC3D086674D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":155954,"discussion_content":"Go这种也存在实现非预期接口的问题, 可能存在隐患. 但总体来讲确实是舒服一些.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580306511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1519521,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2f/a1/5f32ada6.jpg","nickname":"大姨夫斯基","note":"","ucode":"79989AC4DD36FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54128,"discussion_content":"go我认为是更好的  java在动手前要付出很多努力去规划好整个体系的继承结构 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574261440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1200650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/0a/65976e95.jpg","nickname":"kougazhang","note":"","ucode":"E9AD678FCEC75D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1519521,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2f/a1/5f32ada6.jpg","nickname":"大姨夫斯基","note":"","ucode":"79989AC4DD36FE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533983,"discussion_content":"不费力气规划更容易腐化","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638057964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54128,"ip_address":""},"score":533983,"extra":""}]},{"author":{"id":1079425,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/81/f6229358.jpg","nickname":"fresh meat","note":"","ucode":"6AC5A69F80ECE7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54072,"discussion_content":"显示实现有什么侵入性？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574257284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1466447,"avatar":"https://static001.geekbang.org/account/avatar/00/16/60/4f/db0e62b3.jpg","nickname":"Daiver","note":"","ucode":"9B1A03AFBC79BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1079425,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/81/f6229358.jpg","nickname":"fresh meat","note":"","ucode":"6AC5A69F80ECE7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54073,"discussion_content":"java 你需要 implements 接口","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574257493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54072,"ip_address":""},"score":54073,"extra":""},{"author":{"id":1274117,"avatar":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","nickname":"👽","note":"","ucode":"D313AF941B412D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1466447,"avatar":"https://static001.geekbang.org/account/avatar/00/16/60/4f/db0e62b3.jpg","nickname":"Daiver","note":"","ucode":"9B1A03AFBC79BC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58373,"discussion_content":"不可以默认实现么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574672100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54073,"ip_address":""},"score":58373,"extra":""}]}]},{"had_liked":false,"id":153971,"user_name":"五岳寻仙","can_delete":false,"product_type":"c1","uid":1247467,"ip_address":"","ucode":"88A46A4E1832CE","user_header":"https://static001.geekbang.org/account/avatar/00/13/08/eb/594e9e6c.jpg","comment_is_top":false,"comment_ctime":1574339250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"96063619762","product_id":100039001,"comment_content":"<br>Python中抽象类是通过 abc 模块中的 abstractmethod 和 ABCMeta<br><br>from abc import abstractmethod, ABCMeta<br><br>class BaseClass(metaclass=ABCMeta):<br>    @abstractmethod<br>    def fun(self, x): pass<br><br>因为 Python 需要天然支持多继承，所以可以直接用上述的抽象类实现接口","like_count":22},{"had_liked":false,"id":153599,"user_name":"张飞online","can_delete":false,"product_type":"c1","uid":1249136,"ip_address":"","ucode":"C9787E4B35888C","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","comment_is_top":false,"comment_ctime":1574264816,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"87473610736","product_id":100039001,"comment_content":"谈谈c吧，linux内核的设备驱动总线模型，就但说设备吧，<br><br>抽象类:<br>首先来个通用设备结构体，到了具体设备把通用设备结构体包含了，这是典型的抽象类思想，提炼公共部分做基类，提高复用度。<br>接口，接口实现就是函数指针，不管你的驱动如何实现，接口不变，你就按照函数指针的定义实现函数，任何人都要受控这个函数定义协议。<br>","like_count":21,"discussions":[{"author":{"id":1712043,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/1f/ab/42fc8571.jpg","nickname":"Little Bird","note":"","ucode":"CF310EF87749DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578425,"discussion_content":"著名的 VFS(Virtual File System) 也可以看到抽象类 &amp; 接口的影子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656733284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292251,"discussion_content":"那请问接口在这个例子中是如何解耦的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595155708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153226,"user_name":"熊斌","can_delete":false,"product_type":"c1","uid":1026280,"ip_address":"","ucode":"24D0C32F397113","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/e8/bc84c47d.jpg","comment_is_top":false,"comment_ctime":1574205223,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"74588649255","product_id":100039001,"comment_content":"举个例子吧，附件上传服务端实现<br><br>需求：支持上传、下载、删除以及文件的存储，存储的话需要支持存本地和云端，涉及附件上传的业务点有十几个。<br><br>设计思路：<br>1、接口设计：上传、下载、删除是公共行为，抽象到接口中<br><br>2、存储方法是一大块公共代码，写到抽象类里面<br><br>3、每个业务的附件上传子类实现接口、继承抽象类","like_count":17,"discussions":[{"author":{"id":1330141,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/dd/41614582.jpg","nickname":"HomeyLiu","note":"","ucode":"EF4CCB92C369B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533913,"discussion_content":"存储也应该用接口,因为支持存本地和云端","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638020693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438470,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f3/06/8da1bf0c.jpg","nickname":"Fredo","note":"","ucode":"681D6692617DAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157369,"discussion_content":"支持存本地和云端，是否需要加个策略模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580474724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1325282,"avatar":"https://static001.geekbang.org/account/avatar/00/14/38/e2/28aa8e6c.jpg","nickname":"会玩code","note":"","ucode":"9220B072AF68C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53786,"discussion_content":"你好，请问下这跟直接把接口换成抽象类里的抽象方法不也一样吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574216224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1026280,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/e8/bc84c47d.jpg","nickname":"熊斌","note":"","ucode":"24D0C32F397113","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1325282,"avatar":"https://static001.geekbang.org/account/avatar/00/14/38/e2/28aa8e6c.jpg","nickname":"会玩code","note":"","ucode":"9220B072AF68C7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53803,"discussion_content":"你好，我认为不一样。原因有下\n\n系统范围内十几个业务需要使用附件接口，它们需要三个行为 上传、下载、删除，抽象成接口，是约定了附件接口的使用协议，告诉那些业务功能的实现着，你们都需要按照这样来开发\n\n抽象类中的抽象方法我认为一般写的是对于业务是公共方法、但对于调用方是不必关心的，像Java里面抽象方法一般都是protected的。\n\n总结一下，接口是约定规范的、对调用者是开放的；而抽象类包含接口的部分，又比接口更近一步能写实现，一般把子类重复代码抽象到里面，对外是不可见的。\n\n如果非要做成抽象方法行不行？\n答案是可以的，但不优雅。\n","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1574217963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53786,"ip_address":""},"score":53803,"extra":""}]}]},{"had_liked":false,"id":215289,"user_name":"InfoQ_6fbe5db36682","can_delete":false,"product_type":"c1","uid":1903946,"ip_address":"","ucode":"FE315CB67AF508","user_header":"","comment_is_top":false,"comment_ctime":1588948764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53128556316","product_id":100039001,"comment_content":"本文讲述用抽象类模拟接口举的C++例子有个小问题，Strategy接口的析构函数忘记了virtual关键字，没有这个关键字delete一个基类指针将导致部分析构。下面的代码可以用来验证这个问题：<br><br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>class Strategy {<br>public:<br>    ~Strategy() = default;<br>    virtual void algorithm() = 0;<br><br>protected:<br>    Strategy() = default;<br>};<br><br>class DestructIndicator {<br>public:<br>    ~DestructIndicator() {<br>        std::cout &lt;&lt; &quot;DestructIndicator destructed.\\n&quot;;<br>    }<br>};<br><br>class Abc : public Strategy {<br>private:<br>    DestructIndicator indicator;<br><br>public:<br>    void algorithm() override {}<br>};<br><br>int main() {<br>    Strategy *instance = new Abc;<br>    delete instance;<br>    return 0;<br>}<br><br>在~Strategy前面加上virtual关键字就可以看到DestructIndicator destructed输出了。<br><br>唉，C++这个玩意坑多的很。。。<br>","like_count":12},{"had_liked":false,"id":155269,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1574672738,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"48819312994","product_id":100039001,"comment_content":"个人认为，jdk8中，接口的默认实现之后。接口和抽象的区别渐渐模糊了。接口，从一定程度上也可以当抽象类使用。而且最主要的是，支持多实现，但不支持多继承。<br>并且，我认为，多实现也是接口和抽象类最主要的区别，没有之一！<br><br>我的理解：<br>抽象类：描述整个类的一个概况。（举例来说，抽象类，爬行动物）<br>接口： 描述的是需要具备的能力。（举例来说，飞行，游泳）<br><br>乌龟，在类上，应该继承爬行动物。因为属于爬行动物（说实话不确定是不是爬行动物），但是乌龟同时也会游泳。会游泳，就只能是乌龟实现的接口。如果，有一天，乌龟长翅膀会飞了（致敬超级马里奥），那这时候，实现会飞行接口就可以了。<br><br>在使用到这个接口的角度，某个游戏，需要十个飞行的小怪。以前是十个各种鸟类。但是现在需要十一个了，于是乎给乌龟安上了翅膀（实现飞行接口），拿来充当飞行小怪使用。<br>","like_count":12,"discussions":[{"author":{"id":2277251,"avatar":"https://static001.geekbang.org/account/avatar/00/22/bf/83/c83be5a3.jpg","nickname":"eHackyd","note":"","ucode":"E6E7994FBDF0A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378725,"discussion_content":"你要从接口和抽象类在java1中的语法去理解它们最原始的意义，java8之后的修改是补充，但并不能作为对概念的理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623374124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335303,"discussion_content":"抽象类可以有不允许重写的方法，接口不可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608164377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153225,"user_name":"Uncle.席","can_delete":false,"product_type":"c1","uid":1635218,"ip_address":"","ucode":"2A23428FBBAFF0","user_header":"https://static001.geekbang.org/account/avatar/00/18/f3/92/96fe653f.jpg","comment_is_top":false,"comment_ctime":1574204749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48818845005","product_id":100039001,"comment_content":"接口强调某一方面的统一，抽象强调共性的复用","like_count":11},{"had_liked":false,"id":153590,"user_name":"nelson","can_delete":false,"product_type":"c1","uid":1271183,"ip_address":"","ucode":"773BE75A23C1C9","user_header":"","comment_is_top":false,"comment_ctime":1574263842,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40228969506","product_id":100039001,"comment_content":"抽象类 Strategy 没有定义任何属性，并且所有的方法都声明为 virtual 类型（等同于 Java 中的 abstract 关键字）<br>这里关于C++的说明有点问题，virtual是虚函数和abstract没有对应关系，换句话说，java中成员函数都是virtual的。Java中的abstract关键字对应“virtual void algorithm()=0”当中的“=0”，也就是所谓的纯虚函数，即在本类中没有实现，派生类必须实现","like_count":9,"discussions":[{"author":{"id":1619597,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er6OV33jHia3U9LYlZEx2HrpsELeh3KMlqFiaKpSAaaZeBttXRAVvDXUgcufpqJ60bJWGYGNpT7752w/132","nickname":"dog_brother","note":"","ucode":"9F64D3C6D815FB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408341,"discussion_content":"是的，纯虚函数才是所谓的接口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635230931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153237,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1574207108,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"40228912772","product_id":100039001,"comment_content":"关于抽象类和接口有一个疑问，也可能是对业务模型不够了解，同一件事其实可以表达成is a也可以表达成has a，这个就看你的语言描述到底是个名词还是行为。<br>举例说明：<br>宠物猫和宠物狗都是宠物。<br>宠物猫和宠物狗都有会被宠。<br>is a基类定义：宠物类<br>has a  接口定义：可被宠的<br>如果取决于需求的语言阐述，感觉就太依赖个人表达习惯了，这不是一个团队持续迭代好项目的方式吧<br>希望老师可以帮忙解惑","like_count":9,"discussions":[{"author":{"id":1773160,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/0e/68/a41730c8.jpg","nickname":"峰回路转","note":"","ucode":"A2874C7392C452","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":94440,"discussion_content":"我也这样认为，所有的接口同样可以表述为is a,再加上java8之后接口也可以有方法实现，所以我觉得目前来看两个的区别主要是属性的继承，如果只是行为继承可以使用接口，如果继承的行为涉及到公共属性可能就要用继承了，具体看侧重点了。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576943659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/14/cb118a61.jpg","nickname":"键舞飞扬","note":"","ucode":"4EC7A8D2E7AC78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342069,"discussion_content":"一个表示是什么，一个表示能做什么！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610589882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1664641,"avatar":"https://static001.geekbang.org/account/avatar/00/19/66/81/a5da0b99.jpg","nickname":"null","note":"","ucode":"7FF909352F786E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53703,"discussion_content":"那你得看看，你需要的到底是 is-a 还是 has-a 的特性了。is-a 不仅有方法的复用，还有类属性的复用；抽象类还支持默认的方法实现，这个你又是否需要？\n所以我认为，这样的疑问，从业务需求出发，就可以做出选择了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574210581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153215,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1574190863,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27343994639","product_id":100039001,"comment_content":"Python有抽象类吧？abc不是可以定义抽象类么","like_count":6,"discussions":[{"author":{"id":1489957,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","nickname":"tt","note":"","ucode":"7753B79AD5A9AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54026,"discussion_content":"我的理解，ABC也是PYTHON为了从更基础的层面提供抽象类的支持而产生的特性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574252508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504506,"avatar":"http://thirdwx.qlogo.cn/mmopen/KFgDEHIEpnTMtKn1eiasiaqFvbYZCO4rj2vDxC5OmQiaMHibpJk1zsq9sIZXFUjSyYIZKEoQAOWsy1EoGtPyN4ibuVNIXgsoG505S/132","nickname":"Geek_6c778e","note":"","ucode":"527237E4648AF0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53740,"discussion_content":"不是基础语法，是通过装饰器实现的，而且可以实例化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574212552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154480,"user_name":"bigtom","can_delete":false,"product_type":"c1","uid":1127131,"ip_address":"","ucode":"EF5780DAB3A749","user_header":"https://static001.geekbang.org/account/avatar/00/11/32/db/8541b844.jpg","comment_is_top":false,"comment_ctime":1574439105,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23049275585","product_id":100039001,"comment_content":"is-a 和 has-a 的地方我觉得有点问题。应该说 is-a 是继承（Inheritance），has-a 是组合（Composition）。所以我感觉无论接口还是抽象类都是继承，所以都是 is-a 的关系呀。","like_count":5,"discussions":[{"author":{"id":1200660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/14/cb118a61.jpg","nickname":"键舞飞扬","note":"","ucode":"4EC7A8D2E7AC78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342071,"discussion_content":"一个表示是什么，一个表示能做什么！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610589946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":251715,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1601805912,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18781675096","product_id":100039001,"comment_content":"1、Java中接口和抽象类的区别是什么？什么时候用接口？什么时候用抽象类？抽象类和接口存在的意义是什么？能解决哪些编程问题？<br>1）类关键字修饰符：<br>抽象类使用abstract修饰，含有抽象方法（使用abstract关键字修饰的方法）的类是抽象类，必须使用abstract关键字修饰；<br>接口使用interface修饰<br><br>2）实例化：<br>抽象类和接口均不能实例化<br>若想实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象<br><br>3）实现：<br>一个类只能实现一个抽象类；<br>一个类可以实现多个接口，接口自己本身可以通过extends 关键字扩展多个接口，如果一个类实现多个接口，多个接口有相同default方法，则子类必须重写该方法<br><br>4）访问级别关键字修饰符：<br>JDK 1.8以前，接口中的方法必须是public的<br>JDK 1.8时，接口中的方法可以是public的，也可以是default的<br>JDK 1.9时，接口中的方法可以是private的<br>JDK 1.8以前，抽象类的方法默认访问权限为protected<br>JDK 1.8时，抽象类的方法默认访问权限变为default<br><br>5）方法：<br>抽象类可以含有抽象方法，也可以不包含抽象方法，抽象类中可以有具体的方法，抽象类中的抽象方法只有方法体没有具体实现；<br>接口中的方法均为抽象方法，接口中不能包含实例或静态方法<br><br>6）变量<br>接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定<br>7）设计层面：<br>抽象是对类的抽象，是一种模板设计；接口是对行为的抽象，是一种行为的规范<br>8）继承层次<br>抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。<br>而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。<br><br>8）使用场景：<br>使用抽象类是为了代码的复用，<br>接口是对行为的抽象，而使用接口的动机是为了实现多态性,侧重于抽象和解耦；<br>接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。<br><br>具体代表：<br>抽象类-模板模式(把不变的流程抽象到父类的模板方法中，将可变的部分留给子类实现）<br>eg.<br>JDK的InputStream、OutputStream、Reader、Writer;<br>AbstractList中的AddAll是模板方法，add、get、set均抛出异常异常没法正常使用需要子类重写<br>HttpServlet中的service方法是模板方法，doGet和doPost可以是子类重写定制的部分。<br><br>接口：<br>eg.<br>Spring的BeanFactory，BeanFactory是IOC容器的核心接口，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。BeanFactory只是个接口，并不是IOC容器的具体实现，但是Spring容器给出了很多种实现，如DefaultListableBeanFactory、XmlBeanFactory、ApplicationContext等，其中XmlBeanFactory就是常用的一个，该实现将以XML方式描述组成应用的对象及对象间的依赖关系","like_count":4},{"had_liked":false,"id":153414,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1574232292,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18754101476","product_id":100039001,"comment_content":"1. 目前学习的就是Java余元，所以有了一套线程的支持接口和抽象类的东西。其实刚入门的时候，确实对这两个不是很理解，而且很多时候都不知道如何运用，那时候是靠《疯狂Java讲义》学会了区别，并且通过一些面试题了解到其中的一些区别和使用方式。<br>2. 通过今天老师的讲解，我又结合了《疯狂Java讲义》、面试题、以及自己项目中的代码实现，来重新梳理这两个的区别。为什么我的业务代码是使用接口而不是抽象类，为什么有些API是用了抽象类而不是接口，是基于某方面的考虑，是处于什么方式的考虑，或是基于哪个设计模式。不过这些都还需要消化，沉淀，会用只是一方面，会思考，会架构才是更好的方式。","like_count":4},{"had_liked":false,"id":153283,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1574210667,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18754079851","product_id":100039001,"comment_content":"抽象类 vs 接口<br><br>\t\t\t抽象类    接口<br>实例化\t\t    否\t      否<br>属性\t\t    是               否<br>方法                    是               是<br>实现                    是               否<br>目的                 复用          扩展<br>意义                  is-a           has-a","like_count":4,"discussions":[{"author":{"id":1507189,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ff/75/9c1b2ece.jpg","nickname":"wind","note":"","ucode":"5EC77AEB18130E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72833,"discussion_content":"纠正一点，接口是可以定义成员变量的，定义的默认为常量","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575533751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153234,"user_name":"水银","can_delete":false,"product_type":"c1","uid":1045948,"ip_address":"","ucode":"0FD9C79590E484","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/bc/63be02b6.jpg","comment_is_top":false,"comment_ctime":1574206815,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18754075999","product_id":100039001,"comment_content":"Java语言接口和抽象的用法老师已经在文中讲了，但在后来的语法规则里，接口也可以由default修饰符来构造默认的接口方法逻辑了，这样在实现接口的时候可以不用必须实现包含被标记为default的方法了，这样的设计是否也是因为接口中如果包含了通用的方法逻辑，可以不用每个接口都实现一遍，避免方法逻辑冗余呢？也是复用的一种思想？","like_count":4,"discussions":[{"author":{"id":1261636,"avatar":"https://static001.geekbang.org/account/avatar/00/13/40/44/0d0dc06c.jpg","nickname":"okeyja","note":"","ucode":"D83D78C6ACFEBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332072,"discussion_content":"至此可以说，完全丢掉abstract不是梦，Java又向CPP买进了一步。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607055748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153219,"user_name":"香蕉派2号","can_delete":false,"product_type":"c1","uid":1587685,"ip_address":"","ucode":"1BB5A449B6EA5E","user_header":"https://static001.geekbang.org/account/avatar/00/18/39/e5/53b1f697.jpg","comment_is_top":false,"comment_ctime":1574200214,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"18754069398","product_id":100039001,"comment_content":"问题1:<br>c#接口两种实现方式：<br>&#47;&#47; 直接实现接口<br>interface IAttack<br>{<br>    void Attck();<br>}<br>class Gun : IAttack<br>{<br>    public void Attck()<br>    {<br>        throw new NotImplementedException();<br>    }<br>}<br>class Rifle : IAttack<br>{<br>    public void Attck()<br>    {<br>        throw new NotImplementedException();<br>    }<br>}<br><br>&#47;&#47; 显示实现接口（当多个接口的中需要实现的方法名称一样的时候）<br>interface IAttack<br>{<br>    void Attack();<br>}<br>interface ISpecialAttack<br>{<br>    void Attack();<br>}<br>class Gun : IAttack, ISpecialAttack<br>{<br>    public void Attack()<br>    {<br>        Console.WriteLine(&quot;普通攻击&quot;);<br>        throw new NotImplementedException();<br>    }<br>    void ISpecialAttack.Attack() &#47;&#47; 接口的显示实现<br>    {<br>        Console.WriteLine(&quot;特殊攻击&quot;);<br>        throw new NotImplementedException();<br>    }<br>}<br>class Rifle : IAttack, ISpecialAttack<br>{<br>    public void Attack()<br>    {<br>        Console.WriteLine(&quot;普通攻击&quot;);<br>        throw new NotImplementedException();<br>    }<br>    void ISpecialAttack.Attack() &#47;&#47; 接口的显示实现<br>    {<br>        Console.WriteLine(&quot;特殊攻击&quot;);<br>        throw new NotImplementedException();<br>    }<br>}<br>public class TestWeapons<br>{<br>    public void TestMethod()<br>    {<br>        ISpecialAttack desertEagle = new Gun();<br>        desertEagle.Attack();<br><br>        IAttack rifle = new Rifle();<br>        rifle.Attack();<br>    }<br>}<br><br><br>c#抽象类定义以及实现：<br>abstract class Weapon{<br>    public float attackRange;<br>    public float damage;<br>    public virtual void Attack(Enemy enmey)<br>    {<br>        enmey.health -= damage;<br>        Console.WriteLine(&quot;attack...&quot;);<br>    }<br>}<br><br>class Gun: Weapon<br>{<br>    public override void Attack(Enemy enmey)<br>    {<br>        base.Attack(enmey);<br>    }<br>}<br><br>public class TestWeapon02<br>{<br>    public static void main02(string[] args)<br>    {<br>        Enemy enemy = new Enemy();<br>        Weapon gun = new Gun()<br>        {<br>            damage = 5,<br>            attackRange = 100,<br>        };<br>        gun.Attack(enemy);<br>        Console.WriteLine(&quot;enemy health: &quot; + enemy.health);<br>    }<br>}<br><br>问题2:<br>总的来说，抽象类就是类别上的总称；接口就是行为上的规范<br><br>","like_count":4,"discussions":[{"author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292693,"discussion_content":"显示实现和隐式实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595309984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042983,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/27/a3737d61.jpg","nickname":"Shanks-王冲","note":"","ucode":"C4B90A17850E20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59539,"discussion_content":"建议分享一个gist link用于存放代码，避免直接分享代码；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574690437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154807,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1574569849,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14459471737","product_id":100039001,"comment_content":"Swift支持接口，不支持抽象类。<br>protocol SomeDelegate {<br>    func doSomething()<br>}<br><br>接口是对一组行为的抽象，目的是将约定和实现相分离，提高代码的灵活性和可扩展性<br>抽象类的主要目的和普通父类一样，是为了代码的可复用性，但可读性和可维护性要更好，因为不用专门定义空方法以供重写，而是使用抽象方法","like_count":3},{"had_liked":false,"id":153517,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1574251668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14459153556","product_id":100039001,"comment_content":"思想最重要，用什么工具都可以实现特定的思想。<br>抽象类体现了IS-A关系，接口体现了HAS-A关系，体现了协议，也即为了解耦行为和实现。<br><br>同时，抽象类和接口也体现了方法论，一个是自底向上，一个是自顶向下。<br><br>学完这节课，确实对它们的却别和联系更加清楚了。","like_count":3},{"had_liked":false,"id":153514,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1574251057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14459152945","product_id":100039001,"comment_content":"设计模式_08<br>1. 文中讲到用Java普通类实现抽象类，抽象类的限制比接口少，所以在接口的基础上添加一些普通类的功能即可。<br>public class MockAbstractClass {<br>  protected MockAbstractClass() {}<br>  public void funcAbstract() {<br>    throw new MethodUnSupportedException();<br>  }<br>  public void Object field;<br>  public void funcImpl() {<br>    &#47;&#47;function implement code<br>  }<br>}<br>2. 今天的内容，印象最深刻的就是**is-a ==&gt; 抽象类， has-a ==&gt; 接口**，坦白讲，之前不是很清楚，看感觉来使用抽象类和方法。","like_count":3},{"had_liked":false,"id":153311,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1574213992,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"14459115880","product_id":100039001,"comment_content":"1.普通类模拟抽象类方法：<br>私有构造器，protected修饰的方法和成员变量，模拟抽象方法的时候在实现体内直接抛出异常并写好交由子类具体实现的注释说明<br>2.用的JAVA。天然支持，abstract和interface<br>3.抽象类：<br>不支持多继承，为了解决代码复用问题而产生，他可以内部定义方法实现、公用属性以及需要子类各自实现的抽象方法，应用场景最典型的就是模板模式，is a的关系。爸爸儿子的关系。<br>接口：<br>支持多继承，为了让代码更加解耦合，更加灵活而产生，他所定义的方法都是抽象的，has a的关系，好比一种协议，一种规范，应用场景贼广泛，比如各大设计模式，设计原则。再比如责任链模式","like_count":3,"discussions":[{"author":{"id":1018370,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","nickname":"Frank","note":"","ucode":"7A488CC6FE15E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54111,"discussion_content":"请问普通类模拟抽象类，如果将构造器私有，子类怎么继承？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574260063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1018370,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","nickname":"Frank","note":"","ucode":"7A488CC6FE15E7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54125,"discussion_content":"很抱歉，之前没有想到这个，我的回答有误，抱歉了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574260909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54111,"ip_address":""},"score":54125,"extra":""},{"author":{"id":1018370,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","nickname":"Frank","note":"","ucode":"7A488CC6FE15E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54133,"discussion_content":"没事儿~~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574261791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54125,"ip_address":""},"score":54133,"extra":""}]}]},{"had_liked":false,"id":153205,"user_name":"玄兴梦影","can_delete":false,"product_type":"c1","uid":1364855,"ip_address":"","ucode":"D9EDBBC61317E9","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/77/fb38ccf1.jpg","comment_is_top":false,"comment_ctime":1574180985,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14459082873","product_id":100039001,"comment_content":"在学Java时，我一直在疑惑什么时候用抽象类，什么时候用接口。现在学完对此有一点理解，也明白他们之间的关系及用法。下来需要多实践与学习。","like_count":3},{"had_liked":false,"id":156634,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1574927415,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10164862007","product_id":100039001,"comment_content":"抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对一系列行为的一种抽象，不要去管其它的那种类似变量、多余方法之类杂七杂八的东西<br>接口：interface修饰，不能有属性，只能有抽象的方法，实现接口的时候必须实现所有的方法。如果要表示一种 里面东西全部都要的is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类<br>抽象：abstract修饰，其它的反过来。如果要表示一种 只要里面一部分的has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口","like_count":2},{"had_liked":false,"id":155080,"user_name":"小乙哥","can_delete":false,"product_type":"c1","uid":1063308,"ip_address":"","ucode":"C77E79BEA0C325","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","comment_is_top":false,"comment_ctime":1574643656,"is_pvip":false,"replies":[{"id":"60027","content":"那是故意那么写的😂，因为那两行代码放到那里并不合适","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574853315,"ip_address":"","comment_id":155080,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10164578248","product_id":100039001,"comment_content":"接口举例的地方，添加实例Filter的地方被注释掉了","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475656,"discussion_content":"那是故意那么写的😂，因为那两行代码放到那里并不合适","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574853315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154431,"user_name":"王加武","can_delete":false,"product_type":"c1","uid":1665471,"ip_address":"","ucode":"DDCFE578C6C428","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/bf/50a824a4.jpg","comment_is_top":false,"comment_ctime":1574428857,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10164363449","product_id":100039001,"comment_content":"接口和抽象类的区别<br>1，接口中的所有的方法必须是抽象方法，而抽象类中的方法可以是普通方法<br>2，抽象类使用abstract来修饰，接口使用的是interface来修饰<br>3，在实现接口的所有的类中，接口的方法都必须被实现，而抽象类的话只有子类继承了抽象的父类，父类没有被实现的抽象方法才需要被实现<br>4，接口可以实现多继承，接口是一种规则，一种契约<br>5，抽象类是不可以被new的，即它的构造方法不能new<br>6,抽象类更多的是用于继承的场景的，而接口则是更多的以组合的方式来使用<br><br>学习了王老师的这节课，我对接口和抽象类的认识又加深了<br>什么时候使用抽象类——<br>当所涉及的关系是一种is - a的关系，并且需要实现代码的复用，那么就使用抽象类<br>什么时候使用的接口——<br>当所涉及的关系是一种has - a的关系，并且需要组合的使用和实现抽象的场景，那么就用接口<br><br>抽象类是一种自下而上的设计思想，即只用子类需要然后才去考虑父类，<br>接口是一种自上而下的设计思想，所有的子类都必须要实现接口中的所有的方法<br>","like_count":2},{"had_liked":false,"id":154223,"user_name":"undefined","can_delete":false,"product_type":"c1","uid":1587803,"ip_address":"","ucode":"867405CA5A9FB7","user_header":"https://static001.geekbang.org/account/avatar/00/18/3a/5b/ce1724ca.jpg","comment_is_top":false,"comment_ctime":1574392788,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10164327380","product_id":100039001,"comment_content":"public class MockClass {<br>    protected MockClass() {}<br>    public void funcA() {<br>    }<br><br>    public static void main(String[] args) {<br>        new MockClass();<br>    }<br>}<br><br>这段代码是可以编译通过的诶，普通类无法模拟无法实例化的特性","like_count":2,"discussions":[{"author":{"id":1042983,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/27/a3737d61.jpg","nickname":"Shanks-王冲","note":"","ucode":"C4B90A17850E20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59565,"discussion_content":"+1，怀疑自己学了假的Java，IntelJ Idea中实测，形如MockClass貌似可以实例化😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574690807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154002,"user_name":"我爱布丁","can_delete":false,"product_type":"c1","uid":1575522,"ip_address":"","ucode":"660B495D34CD39","user_header":"","comment_is_top":false,"comment_ctime":1574345804,"is_pvip":false,"replies":[{"id":"59162","content":"可以使用抽象类。但也可以使用组合来实现代码复用。后面会讲到","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574384228,"ip_address":"","comment_id":154002,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10164280396","product_id":100039001,"comment_content":"老师举的Filter接口的例子可以用抽象类实现吗？<br><br>我觉得可以说 AuthencationFilter is a Filter, RateLimitFilter is a Filter. 如果两个Filters在doFilter里会预先做一些通用的对于RpcRequest的validation工作，或者有一些shared states，那么这样是不是就应该用抽象类实现呢？<br><br>","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475348,"discussion_content":"可以使用抽象类。但也可以使用组合来实现代码复用。后面会讲到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574384228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153667,"user_name":"阿玛铭","can_delete":false,"product_type":"c1","uid":1100703,"ip_address":"","ucode":"DBF948D82ACBE3","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","comment_is_top":false,"comment_ctime":1574295551,"is_pvip":false,"replies":[{"id":"59159","content":"😂 没研究过响应式编程 帮不上你了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574378179,"ip_address":"","comment_id":153667,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10164230143","product_id":100039001,"comment_content":"问句题外话：老师对响应式编程有研究吗？想要一门这样的课程。理由：1.josh long打造，可以代表开发技术的趋势。 2.了解的不够，高并发，类似nety 3.语言隔阂短时间无法突破。<br>还有一个重要的理由是我觉得老师你讲内容的思路容易理解和接受。","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475242,"discussion_content":"😂 没研究过响应式编程 帮不上你了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574378179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","nickname":"阿玛铭","note":"","ucode":"DBF948D82ACBE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55761,"discussion_content":"问题不大。谷歌翻译……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574395867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153446,"user_name":"Yo nací para quererte.","can_delete":false,"product_type":"c1","uid":1664572,"ip_address":"","ucode":"8B6E9B8B3D007C","user_header":"https://static001.geekbang.org/account/avatar/00/19/66/3c/2d563488.jpg","comment_is_top":false,"comment_ctime":1574237152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10164171744","product_id":100039001,"comment_content":"记录一下C#的抽象类和接口：<br>C#中既有virtual关键字（用于定义虚方法）也有abstract关键字（用于定义抽象类或抽象方法）也有interface关键字（用于定义接口）。<br>子类可以使用new关键字覆盖父类方法，可以使用override关键字重写父类方法。<br>总结：<br>1. 不管重写还是覆盖都不会影响父类自身的功能（除非父类代码被改变）<br>2. 当用子类创建父类对象时，如Animal animal = new Cat();。重写会改变父类的功能，即调用子类的方法，而覆盖不会，扔调用父类方法。<br>3. 虚方法和实方法都可以被覆盖（new），抽象方法和接口不可以。<br>4. 抽象方法和接口和虚方法可以被重写（override），实方法不可以。<br>5. 重写使用的频率比较高，用于实现多态；覆盖用的频率比较低，用于对以前无法修改的类进行继承的时候。","like_count":2},{"had_liked":false,"id":153252,"user_name":"Paper","can_delete":false,"product_type":"c1","uid":1305388,"ip_address":"","ucode":"7EE26C2E892899","user_header":"https://static001.geekbang.org/account/avatar/00/13/eb/2c/ab72fda4.jpg","comment_is_top":false,"comment_ctime":1574208431,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"10164143023","product_id":100039001,"comment_content":"js 中也没有接口定义，也只能通过上述类似检测抛异常的方式实现，但是上了ts之后就没有问题了。","like_count":2},{"had_liked":false,"id":153241,"user_name":"cc","can_delete":false,"product_type":"c1","uid":1592092,"ip_address":"","ucode":"FF41E5D87BAD76","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/1c/5eb03a91.jpg","comment_is_top":false,"comment_ctime":1574207480,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10164142072","product_id":100039001,"comment_content":"按照重点回顾的三个小点来回答抽象类和接口的面试问题。","like_count":2},{"had_liked":false,"id":321045,"user_name":"MONSTER","can_delete":false,"product_type":"c1","uid":2839715,"ip_address":"","ucode":"6B1D38BA7F1717","user_header":"https://static001.geekbang.org/account/avatar/00/2b/54/a3/f188a152.jpg","comment_is_top":false,"comment_ctime":1636630961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5931598257","product_id":100039001,"comment_content":"接口可以有成员变量，只不过是public static final的","like_count":1},{"had_liked":false,"id":306739,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1628686972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5923654268","product_id":100039001,"comment_content":"1.c++支持抽象类，实现方式是含有纯虚函数的类就是抽象类；c++不直接提供接口的支持，但是可以通过抽象类来模拟接口，具体而言就是抽象类中全都定义纯虚函数（构造函数除外），并且不定义属性。<br><br>2.接口和抽象类的区别：（1）接口中含有的都是抽象方法，而不包含属性，而抽象类可以包含属性；（2）抽象类是is a关系，解决的是代码复用问题，接口是has a关系，解决的是抽象问题，可以实现约定和实现分离","like_count":1},{"had_liked":false,"id":247562,"user_name":"WilliamVector","can_delete":false,"product_type":"c1","uid":1898112,"ip_address":"","ucode":"E0D3C3D4FCB7C9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/80/85ec2c2a.jpg","comment_is_top":false,"comment_ctime":1599742245,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5894709541","product_id":100039001,"comment_content":"【要点】<br>1、抽象类和接口的语法特性。抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。<br>2、抽象类和接口存在的意义。抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。对于接口，有一个更加形象的叫法，那就是协议（contract）。<br>3、抽象类和接口的应用场景区别。什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示\b一种 has-a关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。<br>【思考】<br>1、Java语言定义抽象类：<br>public abstract class AbstractDemo {<br>\tprivate int number;<br>\t<br>\tpublic AbstractDemo () {}<br>\t<br>\tpublic AbstractDemo (int number) {<br>\t\tthis.number = number;<br>\t}<br>\t<br>\tpublic int getNumber() {<br>\t\treturn this.number;<br>\t}<br>\t<br>\tpublic abstract int optNumber();<br>}<br>public interface InterfaceDemo {<br>\tpublic int add();<br>\tpublic int mul();<br>}<br>2、从抽象类和接口的语法特性和应用场景两个方面回答，最好能再举一个例子说明：<br>(1)语法特性：抽象类不允许被实例化，只能继承。可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的叫抽象方法。子类继承抽象类，必须实现抽象类的抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。对于接口，有一个更加形象的叫法，那就是协议。<br>(2)应用场景：如果表示一种is-a关系，并且为了解决代码的复用问题，就使用抽象类；如果表示一种has-a关系，并且为了解决抽象而非代码复用问题，就用接口，接口是通常是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。","like_count":1},{"had_liked":false,"id":218232,"user_name":"buggetout","can_delete":false,"product_type":"c1","uid":1880582,"ip_address":"","ucode":"63A948EF415FDD","user_header":"https://static001.geekbang.org/account/avatar/00/1c/b2/06/2086d76d.jpg","comment_is_top":false,"comment_ctime":1589763542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884730838","product_id":100039001,"comment_content":"抽象类和接口的区别:<br>1.抽象类用于表示is-a关系，常用于代码复用。接口类用于表示has-a关系，常用于抽象，或者表示对象有某些行为。<br>2.抽象类中能够定义属性<br>3.java8之后接口支持default方法<br>4.接口能够实现函数式编程","like_count":1},{"had_liked":false,"id":217382,"user_name":"anders","can_delete":false,"product_type":"c1","uid":1153592,"ip_address":"","ucode":"610C80D742C331","user_header":"https://static001.geekbang.org/account/avatar/00/11/9a/38/118a890c.jpg","comment_is_top":false,"comment_ctime":1589472506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884439802","product_id":100039001,"comment_content":"关于抽象类和接口的理解，从本质上说:<br>抽象类: 编程中自下向上的需要，如果用其他方式模拟不是不行，而是维护成本高。因此对于这样常见的编程范式来说，添加语法支持（约束），能够大大的使用范式的成本。本质上是语法糖。<br><br>接口: 同理，提供一个语法糖，方便低成本的实现 has-a 的问题<br><br>总的说，编程语言的大部分特性，或者是设计模式，都是从编程实际需求出发而演变出来的。理解熟悉这些演变过程，能够让我们举一反三。<br><br>另外，很多动态语言犹豫缺乏大量的这些特性: 接口，抽象类，抽象方法等。使得开发成本。维护成本是相对高的。这也就导致了动态需要开发大型项目艰难的问题。<br><br>可以看看 js 社区这几年的激烈演进，ts 的大流行，也是因为有了大型项目的需求，尝到了 ts 的各项语法特性的甜头。<br><br><br>设计模式也大抵如此，放在小型项目的时候，并不能体现出多大作用。因为设计模式的出现，就是为了对抗，处理复杂度的。","like_count":1},{"had_liked":false,"id":197946,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585404514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880371810","product_id":100039001,"comment_content":"Logger 可以被实例化，换句话说，我们可以 new 一个 Logger 出来，并且调用空的 log() 方法。这也增加了类被误用的风险。当然，这个问题可以通过设置私有的构造函数的方式来解决。不过，显然没有通过抽象类来的优雅。我觉得这句话有问题，如果私有化，还谈什么继承，这已经脱离了问题本身，我们讨论的是父类的空方法可以有效解决继承，但是你私有化解决调用空方法，但是我们讨论的不是这个，还谈什么多肽，继承呢","like_count":1},{"had_liked":false,"id":180444,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1582282086,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5877249382","product_id":100039001,"comment_content":"其实我们可以换个角度思考一下：当我们在说抽象类和接口到底在说什么？以Java为例，为什么要支持抽象类，自然是为了表示面向对象编程中is-a的关系，即A是B，那么B自然也是一个Object，那么自然就有属性和方法（行为）。再来，为什么药支持接口，是为了表示面向对象编程中has-a的关系，就是你拥有什么能力，能力对应行为（方法），那么自然就只有方法，当然也可以有属性，但是一定是常量，想下为什么只能是常量而不能是变量呢？如果有变量那就意味着实现A和实现B是可以互相修改的，这违反了接口的定义。继续延伸下，为什么jdk8要支持默认方法呢？举个例子你就知道了，A和B都需要C的能力z，但C还提供能力y，但是只有A是需要y的，那么B只需要默认的y能力就好了。","like_count":1},{"had_liked":false,"id":169066,"user_name":"天空只能仰望？","can_delete":false,"product_type":"c1","uid":1102357,"ip_address":"","ucode":"D87BF6A57DAB42","user_header":"https://static001.geekbang.org/account/avatar/00/10/d2/15/4d43d05a.jpg","comment_is_top":false,"comment_ctime":1578270352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5873237648","product_id":100039001,"comment_content":"接口自上而下设计，便于解偶，抽象类自下而上设计，便于代码复用！","like_count":1},{"had_liked":false,"id":158799,"user_name":"longslee","can_delete":false,"product_type":"c1","uid":1465986,"ip_address":"","ucode":"C24E32E5B1B6F5","user_header":"https://static001.geekbang.org/account/avatar/00/16/5e/82/438c8534.jpg","comment_is_top":false,"comment_ctime":1575453675,"is_pvip":false,"replies":[{"id":"61145","content":"只能包含静态常量吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1575897867,"ip_address":"","comment_id":158799,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5870420971","product_id":100039001,"comment_content":"咦，老师，“接口不能包含属性（也就是成员变量）”，是怎么回事？可以的呀","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476852,"discussion_content":"只能包含静态常量吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575897867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153980,"user_name":"王喜春","can_delete":false,"product_type":"c1","uid":1022349,"ip_address":"","ucode":"436E91FDED1B30","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/8d/4d5dbfc5.jpg","comment_is_top":false,"comment_ctime":1574341436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869308732","product_id":100039001,"comment_content":"早些年，刚接触C++和Java时，无意间想到C++中的一个定义方式跟Java中的Interface意图一样。还记得当时跟别人聊这个感觉， 大多数人都没有同感，就放下了。现在再看这个，很是亲切。","like_count":1},{"had_liked":false,"id":153764,"user_name":"胖🐯","can_delete":false,"product_type":"c1","uid":1732966,"ip_address":"","ucode":"FB6EA96A335846","user_header":"https://static001.geekbang.org/account/avatar/00/1a/71/66/087de1c6.jpg","comment_is_top":false,"comment_ctime":1574303859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869271155","product_id":100039001,"comment_content":"构造函数设置成protected，还是可以被同包下的其他类实例化","like_count":1},{"had_liked":false,"id":153761,"user_name":"胖🐯","can_delete":false,"product_type":"c1","uid":1732966,"ip_address":"","ucode":"FB6EA96A335846","user_header":"https://static001.geekbang.org/account/avatar/00/1a/71/66/087de1c6.jpg","comment_is_top":false,"comment_ctime":1574303570,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869270866","product_id":100039001,"comment_content":"C++的virtual关键字表示虚函数，虚函数才有多态性，这个关键字跟abstract没有任何关系啦🙂","like_count":1},{"had_liked":false,"id":153576,"user_name":"段启超","can_delete":false,"product_type":"c1","uid":1258209,"ip_address":"","ucode":"164CF3018071B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/32/e1/c9aacb37.jpg","comment_is_top":false,"comment_ctime":1574261929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869229225","product_id":100039001,"comment_content":"接口和抽象类的相同点和不同点：<br>相同点： 都是抽象机制，都可以存在抽象方法，都不能被实例化<br>不同点： 抽象类中可以存在成员变量，接口中不允许，<br>              抽象类中可以存在具体的方法实现，接口中不允许。<br>             抽象类的设计原则是is-a ，接口的设计原则是has-a 或者是can-do <br>反思：<br>SSM 的这种三层结构横行多年，造成的结果就是设计模式几乎没有用武之地，基于贫血模型的面条代码，没有任何面向对象的设计元素可言，抽象类，接口的意义很多时候就停留在了面试中。","like_count":1},{"had_liked":false,"id":153512,"user_name":"胡子高兴了","can_delete":false,"product_type":"c1","uid":1596868,"ip_address":"","ucode":"A32AE341E3683D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/YJHQDzuLavGFmwunybBiaBrrU1aOib7Siam0fJrWIaHfdT0p2GicsRT42d9bhRNO324wewDtic8RiaokAFkUyO3YRF0g/132","comment_is_top":false,"comment_ctime":1574250660,"is_pvip":false,"replies":[{"id":"59170","content":"可以的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574385163,"ip_address":"","comment_id":153512,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5869217956","product_id":100039001,"comment_content":"老师，接口中可以定义静态成员变量吗？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475195,"discussion_content":"可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574385163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153471,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1574239827,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869207123","product_id":100039001,"comment_content":"java抽象类与接口区别<br>1、前者可以包含成员属性和方法实现，后者不可以<br>2、is-a与has-a区别<br>3、前者单继承，后者多实现","like_count":1},{"had_liked":false,"id":153386,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1574227879,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869195175","product_id":100039001,"comment_content":"一般面试问抽象类跟接口的问题我都会把java8特性也带上一起说 比如接口也可以有方法体（default关键字）lambda表达式在改变我们现有的设计模式等等 希望老师加餐说一下现在函数式编程的编码规范及优雅写法","like_count":1},{"had_liked":false,"id":153365,"user_name":"李新天","can_delete":false,"product_type":"c1","uid":1506036,"ip_address":"","ucode":"8BBAA3D96FD2A5","user_header":"https://static001.geekbang.org/account/avatar/00/16/fa/f4/4aa8fe24.jpg","comment_is_top":false,"comment_ctime":1574223440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869190736","product_id":100039001,"comment_content":"我搞js的，一脸懵逼","like_count":1},{"had_liked":false,"id":153363,"user_name":"LYy","can_delete":false,"product_type":"c1","uid":1102062,"ip_address":"","ucode":"8D5C39B9531E71","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/ee/f5c5e191.jpg","comment_is_top":false,"comment_ctime":1574223232,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5869190528","product_id":100039001,"comment_content":"类的可继承性解决用来解决复用性问题 接口的可实现性用来解决扩展性(多态)问题<br>而抽象类 其实是用来兼顾多态与继承两个特性的产物<br>是否实现抽象类 其实也体现了语言设计者关于OO(面向对象)特性的思考与trade-off","like_count":1},{"had_liked":false,"id":153286,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1574211024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869178320","product_id":100039001,"comment_content":"抽象类主要是继承，代码复用，类中可以定义属性和方法，方法有普通方法和抽象方法，不可以被实例化，继承抽象类的子类必须实现类中所有的抽象方法，是一种自下而上的模式，所有的子类都实现具体方法，抽象类进行抽象，接口是一种自上而下的模式，定义好需要实现哪些方法，接口不可以定义属性，接口的方法必须被实现类所实现，接口中的方法必需被定义为public模式的，继承抽象类的子类实现的方法的权限必须必抽象类宽松，比如抽象类中的抽象方法被定义为protected，则实现该抽象方法的方法不能定义为private，只能定义成protected或public，抽象类是is_a，接口是has_a。","like_count":1},{"had_liked":false,"id":153285,"user_name":"2018","can_delete":false,"product_type":"c1","uid":1107371,"ip_address":"","ucode":"4C2CD47AD70177","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/ab/6fab2492.jpg","comment_is_top":false,"comment_ctime":1574210792,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5869178088","product_id":100039001,"comment_content":"熟悉的Java和go语言，Java天然支持抽象类和接口，go语言对于接口的实现是用了一种ducking type的方式","like_count":1},{"had_liked":false,"id":153276,"user_name":"董小容","can_delete":false,"product_type":"c1","uid":1714216,"ip_address":"","ucode":"A856333452BA08","user_header":"https://static001.geekbang.org/account/avatar/00/1a/28/28/be35565d.jpg","comment_is_top":false,"comment_ctime":1574210390,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"5869177686","product_id":100039001,"comment_content":"还是没看懂为什么有了继承，还需要抽象类","like_count":1,"discussions":[{"author":{"id":1570088,"avatar":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","nickname":"deepz","note":"","ucode":"4BD23A44CDB384","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53771,"discussion_content":"个人理解抽象类定义抽象方法就是逼着实现类去重写实现，否则编译报错，而继承的话，虽然继承下来了，但是如果不重写的话，那么调用的时候跑的是父类的。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574214706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1570088,"avatar":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","nickname":"deepz","note":"","ucode":"4BD23A44CDB384","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":54190,"discussion_content":"而且基类还可以被实例化造成误用","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574265194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53771,"ip_address":""},"score":54190,"extra":""}]},{"author":{"id":1637228,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fb/6c/12fdc372.jpg","nickname":"迈向架构师","note":"","ucode":"2476594CF76001","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53826,"discussion_content":"重新看下这段：    这个设计思路能用，但是，它显然没有之前通过抽象类的实现思路优雅。我为什么这么说呢？主要有以下几点原因。 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574222332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53794,"discussion_content":"抽象更符合面向对象思维，更优雅的实现了多态，抽象类不允许实例化更好的降低程序员在编程中的错误。其他好处暂时想不到","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574216963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016594,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/83/12/4ba82798.jpg","nickname":"我是智障","note":"","ucode":"ED9D959423E024","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53815,"discussion_content":"再看一遍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574221154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153274,"user_name":"好吃不贵","can_delete":false,"product_type":"c1","uid":1316993,"ip_address":"","ucode":"6576E2BECE4F7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/18/81/83b6ade2.jpg","comment_is_top":false,"comment_ctime":1574210320,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5869177616","product_id":100039001,"comment_content":"抽象类自下而上，是is a关系，防止重复代码。接口类是自上而下，是has a关系，为了实现具体功能接口。","like_count":1},{"had_liked":false,"id":153262,"user_name":"Flash","can_delete":false,"product_type":"c1","uid":1236163,"ip_address":"","ucode":"E285075C9E0B02","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/c3/e4ba51d5.jpg","comment_is_top":false,"comment_ctime":1574209297,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869176593","product_id":100039001,"comment_content":"课后思考:<br>2.抽象类是解决代码复用问题的，是自下而上设计的，先有子类，再抽取可以复用的代码到父类抽象中；再是一种is-a关系，是这种继承关系的话就用抽象类。<br>接口是提高代码扩展性的，解耦，隔离约定和实现，是自上而下设计的，先定义接口有什么功能，再由子类具体实现；是一种has-a关系，是这种拥有关系的话就用接口。","like_count":1},{"had_liked":false,"id":153242,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1574207587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869174883","product_id":100039001,"comment_content":"打卡","like_count":1},{"had_liked":false,"id":153227,"user_name":"熊斌","can_delete":false,"product_type":"c1","uid":1026280,"ip_address":"","ucode":"24D0C32F397113","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/e8/bc84c47d.jpg","comment_is_top":false,"comment_ctime":1574205252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869172548","product_id":100039001,"comment_content":"Java jdk1.8支持接口中有实现","like_count":1},{"had_liked":false,"id":356738,"user_name":"wanggd","can_delete":false,"product_type":"c1","uid":3174267,"ip_address":"山东","ucode":"ED3928635D7CE3","user_header":"https://static001.geekbang.org/account/avatar/00/30/6f/7b/4be464d2.jpg","comment_is_top":false,"comment_ctime":1662541276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662541276","product_id":100039001,"comment_content":"随着jdk版本的更新，一些定义和规则已经变了，像是接口interface，能更新一下吗？如果使用原来的知识点去总结一些内容有些不妥。当然在当时的那个时间点是可以的。","like_count":0},{"had_liked":false,"id":356568,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"浙江","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1662425427,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1662425427","product_id":100039001,"comment_content":"抽象类是自下而上的，先走具体类的实现，发现方法可复用，又是可以抽象出父子关系，就用到抽象类，它可以有属性，有实现的方法，也有待子类实现的方法，如果没有后者就是普通类了。对于子类继承而言就是is a的关系。如果是接口，更是自上而下的，一开始就是为了解藕，定义接口和实现分离，是has a  的关系！","like_count":0},{"had_liked":false,"id":356367,"user_name":"Sherk","can_delete":false,"product_type":"c1","uid":2156245,"ip_address":"重庆","ucode":"AFE3E7F158258D","user_header":"https://static001.geekbang.org/account/avatar/00/20/e6/d5/4f1fc074.jpg","comment_is_top":false,"comment_ctime":1662202591,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662202591","product_id":100039001,"comment_content":"思考题： 2. 会从定义，设计上进行区分。<br>     定义上： <br>             抽象类可以有自己的属性，且可以实现自己的方法，但是不能new 一个新对象。<br>             接口： 只能定义一些方法，且不能实现方法。<br>     设计上： <br>             抽象类主要是为了代码复用，设计方式是自下而上的，如果子类中有重复的代码，则将重复的代码提取到上层父类，是is-a的关系；<br>              接口从上而下的设计方式，先思考有什么功能，一组行为的特性， 不去考虑具体实现。 是has-a的关系。<br><br>本章节主要讲了什么： what - why -how <br>      what:  什么是抽象类，接口。<br>         抽象类： 定义一组属性和相关抽象方法，可以实现相关方法，不能实例化的类。是为了解决代码复用的。<br>         接口：  只包含方法，不能有属性。为是为了解耦合的。<br><br>  why:<br>       抽象类： 解决代码复用。<br>       接口： 解决代码耦合。<br>how：<br>      如果业务场景是is-a关系可以考虑抽象类。<br>      如果是has-a关系可以考虑接口， 比如serializable 代表类具有序列化的能力。Iterable接口等。<br>        接口：<br>    ","like_count":0},{"had_liked":false,"id":356056,"user_name":"Stay_Gold","can_delete":false,"product_type":"c1","uid":1119904,"ip_address":"北京","ucode":"ACB8DCD2EF8F95","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRCtuJkpyy2NTTABPFibg2k9tZscOOKx9wu80a85d5HspCorO9Nibj7Z7q9v1icPTVm5ia52r0RCzEaA/132","comment_is_top":false,"comment_ctime":1661938534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661938534","product_id":100039001,"comment_content":"总结今天的学习，同时也是回答第二个课后问题<br>抽象类和接口的定义<br>抽象类特性：1.不能实例化  2.可以有属性和方法实现，对于没有实现的方法，即是抽象方法  3.子类必须实现对应的抽象方法。<br>接口特性：相对于抽象类来说1.不能有属性  2.不能有方法实现  3.继承接口的类必须实现接口所有的方法。<br>抽象类和接口存在的意义：<br>抽象类能更好的实现代码复用，而且能更加优雅的实现代码的可扩展性和灵活性。<br>接口更加偏重于行为本身，偏重于代码的解耦。通过面向接口，能使代码的灵活性更高。<br>什么时候使用抽象类，什么时候使用接口？<br>抽象类更加偏重复用，偏重has-a的这种关系。<br>接口更加偏重行为本身，可以更方便的实现解耦，是一种has-a关系。<br><br>问题<br>你熟悉的编程语言，是否有现成的语法支持接口和抽象类呢？具体是如何定义的呢？<br>熟悉C# JAVA 实现基本跟文中意义的abstract和interface","like_count":0},{"had_liked":false,"id":351005,"user_name":"SICUN","can_delete":false,"product_type":"c1","uid":1254261,"ip_address":"","ucode":"22A384904EB9E9","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/75/2b599841.jpg","comment_is_top":false,"comment_ctime":1657448152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657448152","product_id":100039001,"comment_content":"1. 接口：interface，抽象类：abstract class<br>2.确实对于接口和抽象类认识更深了一些，做项目顶层设计时可能会倾向于用接口，实际开发过程中如果有些对象共性比较稳定，可以服用则考虑将接口退化为抽象类。<br>","like_count":0},{"had_liked":false,"id":348683,"user_name":"coley wu","can_delete":false,"product_type":"c1","uid":1082095,"ip_address":"","ucode":"B2C0AD8F970981","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/ef/0badf9dc.jpg","comment_is_top":false,"comment_ctime":1655300545,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655300545","product_id":100039001,"comment_content":"代码复用性可通过普通继承或组合解决，不允许实例化和抽象方法可以在构造方法和普通方法中抛出异常解决。<br>抽象类还有个最大的作用在于提高了代码的可读性，明确的告诉调用方，当前类的定义是个半成品不能被直接使用，必须实现我定义行为规则之后才能使用。<br>","like_count":0},{"had_liked":false,"id":345169,"user_name":"杜威","can_delete":false,"product_type":"c1","uid":1294908,"ip_address":"","ucode":"CF49380E27467F","user_header":"https://static001.geekbang.org/account/avatar/00/13/c2/3c/a82d4ed0.jpg","comment_is_top":false,"comment_ctime":1652088754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652088754","product_id":100039001,"comment_content":"关于抽象类和接口我的理解是，抽象类是业务逻辑表达完整的模块，能够完整的描述模块的业务，通过开放抽象方法，可以扩展不同的业务细节实现。接口则只能提供业务的抽象，不能表达业务逻辑。","like_count":0},{"had_liked":false,"id":343965,"user_name":"seven#羊啾啾JK","can_delete":false,"product_type":"c1","uid":2160692,"ip_address":"","ucode":"B3F1BF6F2F08B2","user_header":"https://static001.geekbang.org/account/avatar/00/20/f8/34/1c260560.jpg","comment_is_top":false,"comment_ctime":1651146359,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651146359","product_id":100039001,"comment_content":"接口（1,无成员属性，2，实现接口必须实现接口中所有方法3，接口只能申明方法，不能代码实现）表示一种 Has-a的关系，为了解决抽象而非代码复用的问题。抽象类表示Is-a 的关系，解决代码复用。认真回答问题，好处多多","like_count":0},{"had_liked":false,"id":342513,"user_name":"gaooakenshield","can_delete":false,"product_type":"c1","uid":2153598,"ip_address":"","ucode":"D5F3E2A12DE6D1","user_header":"https://static001.geekbang.org/account/avatar/00/20/dc/7e/4315166d.jpg","comment_is_top":false,"comment_ctime":1650298712,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650298712","product_id":100039001,"comment_content":"我觉得has a换成can do会更容易理解","like_count":0},{"had_liked":false,"id":338985,"user_name":"Geek_783504","can_delete":false,"product_type":"c1","uid":2743789,"ip_address":"","ucode":"549D3F0549743C","user_header":"https://static001.geekbang.org/account/avatar/00/29/dd/ed/f6c5432b.jpg","comment_is_top":false,"comment_ctime":1647849936,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647849936","product_id":100039001,"comment_content":"第二个问题，首先从两者的概念出发，<br>两者重点关注哪一方面，抽象，他关注的是代码复用，使用继承的方式对抽象方法进行复用，他注重同一类这种关系，接口，更像是一种协议，一种编程规范，我不关注方法本身，我只需要知道方法的用途，他的具体实现由他的实现类去处理，实现类与他的关系更像是一种有的关系，及有这个功能。<br>其次，从他们的区别和共同点说起，都不能被new出来，都能包含抽象方法和静态常量，但是抽象可以包含成员变量和普通方法供子类调用。<br>第三，他们具体使用场景，is-a，和has-a","like_count":0},{"had_liked":false,"id":336947,"user_name":"Sam.张朝","can_delete":false,"product_type":"c1","uid":1132448,"ip_address":"","ucode":"FB20554D94B250","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/a0/f12115b7.jpg","comment_is_top":false,"comment_ctime":1646485392,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646485392","product_id":100039001,"comment_content":"抽象：is-a  ; 自下而上；多态；代码复用<br>接口：has-a; 自上而下；抽象行为","like_count":0},{"had_liked":false,"id":336730,"user_name":"壹号黑土猪","can_delete":false,"product_type":"c1","uid":2278578,"ip_address":"","ucode":"E144567EFB668C","user_header":"https://static001.geekbang.org/account/avatar/00/22/c4/b2/cc4865c2.jpg","comment_is_top":false,"comment_ctime":1646322249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646322249","product_id":100039001,"comment_content":"接口可以实现多个，￼￼抽象例子可以实现一个继承","like_count":0},{"had_liked":false,"id":332937,"user_name":"笑","can_delete":false,"product_type":"c1","uid":2855454,"ip_address":"","ucode":"011F910551FD48","user_header":"https://static001.geekbang.org/account/avatar/00/2b/92/1e/b5f83cde.jpg","comment_is_top":false,"comment_ctime":1643856744,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643856744","product_id":100039001,"comment_content":"抽象类更多是为了代码复用，而接口是为了解耦。<br><br>首先从应用场景来讲，如果是 is-a 并且考虑到代码复用的话，用抽象类，如果是 has-a 并且不考虑代码复用，使用接口。<br><br>接口不允许包含代码的具体实现，不可以包含属性（成员变量），实现类需要实现接口的全部方法。<br><br>接口是对行为的一种抽象，相当于一组契约或协议<br>抽象类不能实例化，只能被继承，可以包含变量和方法。<br><br>抽象类的方法可以包含代码实现，也可以不包含，不包含代码实现的方法叫做抽象方法。<br><br>任何子类需要重写父类的抽象方法，除非子类也是抽象类。<br><br>从类的继承上来看，抽象类更像是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类），而接口是自上而下的设计思路，我们在编程的时候，一般都是先设计好接口，再去考虑具体的实现。","like_count":0},{"had_liked":false,"id":324310,"user_name":"王智","can_delete":false,"product_type":"c1","uid":1337016,"ip_address":"","ucode":"37D2AD591C1AEC","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/b8/ece79234.jpg","comment_is_top":false,"comment_ctime":1638366942,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638366942","product_id":100039001,"comment_content":"第一题：<br>java支持。接口用interface关键字；抽象类用abstract关键字。<br>第二题：<br>* 是的。新认知主要是啥时候用接口，啥时候用抽象类上。<br>* 从定义区别、使用针对场景区别、普通类模拟三个角度来说。","like_count":0},{"had_liked":false,"id":322703,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1637558836,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1637558836","product_id":100039001,"comment_content":"继承是 is-a 的关系，接口是 has-a 的关系，继承是自下而上的，而接口是自上而下的。由 C++ 转 Go，目前在考虑 Go + Rust 的组合，老师讲解的抽象类和接口，让我回忆起刚开始工作时候的面试题，好久都没有这种熟悉的感觉了。Go 强调组合关系，Rust 引入了 trait，目前还在不断适应中。","like_count":0},{"had_liked":false,"id":316318,"user_name":"keep_it_real","can_delete":false,"product_type":"c1","uid":2055554,"ip_address":"","ucode":"F5057CAF752FF3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5d/82/81b2ba91.jpg","comment_is_top":false,"comment_ctime":1634267891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634267891","product_id":100039001,"comment_content":"接口是否是抽象类的衍生物？在职责方面来看的话二者是有重叠的部分，那就是抽象方法（接口中声明的方法就是抽象方法）。而当初Java摒弃了C++的多继承的特性，增加了接口，而接口是可以多实现的。是否可以认为，接口是摒弃多继承后的一种补充？","like_count":0},{"had_liked":false,"id":315502,"user_name":"跳跳","can_delete":false,"product_type":"c1","uid":2771298,"ip_address":"","ucode":"8999B46CF6D197","user_header":"https://static001.geekbang.org/account/avatar/00/2a/49/62/db480ab6.jpg","comment_is_top":false,"comment_ctime":1633914589,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1633914589","product_id":100039001,"comment_content":"不喜欢接口不能包含属性这句话，因为属性也是一组 get()&#47;set() 方法。使用 C# 8.0 语法的小伙伴会很傲娇的。","like_count":0},{"had_liked":false,"id":312446,"user_name":"黄乔鑫","can_delete":false,"product_type":"c1","uid":1863174,"ip_address":"","ucode":"CBD0A8E5E99427","user_header":"https://static001.geekbang.org/account/avatar/00/1c/6e/06/bb43e716.jpg","comment_is_top":false,"comment_ctime":1631804827,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631804827","product_id":100039001,"comment_content":"抽象类与接口<br>\t抽象类不能被实例化，只能被子类继承，表达is-a的关系<br>\t\t实现代码复用功能<br>\t\t编译器强制要求实现Override抽象方法<br>\t而接口表达has-a关系，表示具有某种功能，表达协议（contract）<br>\t\t侧重于解耦，对行为的一种抽象，表达一组协议或者契约（比如说Cloneable）<br>","like_count":0},{"had_liked":false,"id":310056,"user_name":"Geek_9302c2","can_delete":false,"product_type":"c1","uid":2709278,"ip_address":"","ucode":"42641A1CA55A4F","user_header":"","comment_is_top":false,"comment_ctime":1630472866,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1630472866","product_id":100039001,"comment_content":"FileLogger logger = new FileLogger(&quot;access-log&quot;, true, Level.WARN, &quot;&#47;users&#47;wangzheng&#47;access.log&quot;); logger.log(Level.ERROR, &quot;This is a test log message.&quot;); 这样不就可以了吗？不是学java的，求解答，这样写有什么弊端吗","like_count":0},{"had_liked":false,"id":308517,"user_name":"Geek_7ed5e9","can_delete":false,"product_type":"c1","uid":2572349,"ip_address":"","ucode":"124EFF40E15E6A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Xia3ZAGK5zB9cBbOxAY0dI3JuglaHCtvCI9R2JvJB8ECuu0Ys8tMWGN9HicMl2KxDibqGO2fr9cJGjlOIcKSUdqUA/132","comment_is_top":false,"comment_ctime":1629674971,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1629674971","product_id":100039001,"comment_content":"接口：<br>抽象出某一系列行为，是一种has-a关系，通过接口可以将实现和接口相分离，先定义接口再去实现<br>抽象类：<br>实现公有方法，抽象个性方法 是一种is-a关系，为了代码复用","like_count":0},{"had_liked":false,"id":308037,"user_name":"Geek_6865f5","can_delete":false,"product_type":"c1","uid":2741599,"ip_address":"","ucode":"0367AC106E742F","user_header":"","comment_is_top":false,"comment_ctime":1629364222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629364222","product_id":100039001,"comment_content":"抽象类：","like_count":0},{"had_liked":false,"id":303428,"user_name":"N。","can_delete":false,"product_type":"c1","uid":1647830,"ip_address":"","ucode":"8EE55D4A24004A","user_header":"https://static001.geekbang.org/account/avatar/00/19/24/d6/c65a71b3.jpg","comment_is_top":false,"comment_ctime":1626784033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626784033","product_id":100039001,"comment_content":"狗  人  猫  都会游泳    那就得用接口实现  不能继承","like_count":0},{"had_liked":false,"id":302178,"user_name":"Geek_325846","can_delete":false,"product_type":"c1","uid":2696006,"ip_address":"","ucode":"30BC2FB97C5B42","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DR4kWgpzu27N1Hu6RFVEDxvk1MRBxaB9btc1U82Fo35peVuQDOfUoqia1RU6reH3sXWlxAtvicABiaotibllSnwgmw/132","comment_is_top":false,"comment_ctime":1626106459,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626106459","product_id":100039001,"comment_content":"纠正一点小错误，接口是可以有属性的，并且默认是public static final","like_count":0},{"had_liked":false,"id":296628,"user_name":"奋斗","can_delete":false,"product_type":"c1","uid":2047392,"ip_address":"","ucode":"C84C2D030ACA51","user_header":"https://static001.geekbang.org/account/avatar/00/1f/3d/a0/acf6b165.jpg","comment_is_top":false,"comment_ctime":1623072423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623072423","product_id":100039001,"comment_content":"文中使用 c++ 实现接口的代码中， 析构函数前面应该加 virtual。","like_count":0},{"had_liked":false,"id":296081,"user_name":"mate30","can_delete":false,"product_type":"c1","uid":2636851,"ip_address":"","ucode":"84AF59DD8152A3","user_header":"https://static001.geekbang.org/account/avatar/00/28/3c/33/9958dca6.jpg","comment_is_top":false,"comment_ctime":1622735073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622735073","product_id":100039001,"comment_content":"老师，我有个问题，在项目开发中经常有在接口中使用泛型，那泛型在接口中用作变量（不知道这样描述是否有问题，有错请纠正），是属于成员变量吗","like_count":0},{"had_liked":false,"id":295610,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1622512398,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1622512398","product_id":100039001,"comment_content":"抽象类解决复用问题，表示is-a关系，一般自底向上设计;接口解决抽象问题，表示has-a关系，一般自顶向下设计。","like_count":0},{"had_liked":false,"id":290378,"user_name":"Helios","can_delete":false,"product_type":"c1","uid":1380758,"ip_address":"","ucode":"BE6B98EE8F0D09","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJrOl63enWXCRxN0SoucliclBme0qrRb19ATrWIOIvibKIz8UAuVgicBMibIVUznerHnjotI4dm6ibODA/132","comment_is_top":false,"comment_ctime":1619519094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619519094","product_id":100039001,"comment_content":"抽象类能包含属性和方法，接口不行。<br>抽象类是is a的关系，接口是has a的关系","like_count":0},{"had_liked":false,"id":289392,"user_name":"时光流逝x","can_delete":false,"product_type":"c1","uid":1695455,"ip_address":"","ucode":"D7334E717D9ED0","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqUMEsVYklTc7akT2e6pfytu4jTQ88EVe1H6L2eHdXC6G8sbKCvfrnSDUIRq229M2Wt419LX2q8SQ/132","comment_is_top":false,"comment_ctime":1618995911,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618995911","product_id":100039001,"comment_content":"1.抽象类<br>       定义: 不能被实例化,可以包含普通方法，普通属性和特有的抽象方法抽象方法只能由子类继承且必须全部实现,一个类可以实现多个接口。<br>      * 抽象方法:只是定义一个协议(入参,出参),不考虑具体实现,并且子类必须按照协议内容去实现。<br>2.接口<br>     定义:作为代码间进行数据传输的一个个协议,和抽象方法一样需要定义入参和出参且要求实现接口的类必须做出对应的实现接口本身不允许实例化.一个子类只能继承一个父类(抽象类&#47;普通类).<br><br>两者的共同点和不同点:<br>    1.首先接口本身只包含抽象方法,虽然java可以在接口内使用static或default方法去做一些方法的实现,但是作用应仅限于做补救措施,不是接口的主要用法,接口实际上就是一组定义好的协议里面规定了协议内容（入参,出参），具体做哪些实现接口不关心。<br>      抽象类应该说是在类的基础上增加了接口的特性,普通的类继承后子类可以选择性的去重写一些父类方法,有的时候不应该使用这种模棱两可的做法就使用抽象方法来规范子类的实现,并且由于抽象类具有类的特性，那么除了规范子类以外还可以抽离一些子类之间一些相同的方法进行复用。<br>      所以,接口由于自身就是一组协议重点以抽象方法为主。而抽象类则是普通类的基础上拓展了抽象方法来规范子类实现,抽象方法作为辅助,而重点在于方法的复用。<br>      <br>       <br>","like_count":0},{"had_liked":false,"id":279802,"user_name":"DreamHeng","can_delete":false,"product_type":"c1","uid":1599490,"ip_address":"","ucode":"5562BFD8375138","user_header":"https://static001.geekbang.org/account/avatar/00/18/68/02/2d394d89.jpg","comment_is_top":false,"comment_ctime":1613966925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613966925","product_id":100039001,"comment_content":"从面向对象的角度来看，接口（has-a）是行为、动作的抽象，抽象类（is-a）是对象的抽象，抽象类的对象又不实指某一个对象，而是某一类对象","like_count":0},{"had_liked":false,"id":278772,"user_name":"Geek_e61474","can_delete":false,"product_type":"c1","uid":1433693,"ip_address":"","ucode":"9EE2A63C0CFC7C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2Cudic6gESQc9ibYcBOiazT13hDUaVs4fWlpwsAfvbjazXHMiaibR90TbWtF4Wcujj31Jqiah9TzX8FUlia6A1LibicVhibg/132","comment_is_top":false,"comment_ctime":1613311662,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1613311662","product_id":100039001,"comment_content":"boolean loggable = enabled &amp;&amp; (minPermittedLevel.intValue() &lt;=Level.OFF.intValue() );<br>应该是表达这个意思吧<br>Level.OFF的value 为 MAX_VALUE","like_count":0},{"had_liked":false,"id":276176,"user_name":"世杰","can_delete":false,"product_type":"c1","uid":2415102,"ip_address":"","ucode":"6BC305EF6D525B","user_header":"https://static001.geekbang.org/account/avatar/00/24/d9/fe/7b151abf.jpg","comment_is_top":false,"comment_ctime":1611821961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611821961","product_id":100039001,"comment_content":"实现效果：通过配置动态生成需要的对象，修改需求，只需要修改配置文件，不需要修改代码。<br>对domain对象的调整：<br>&#47;&#47; ImageStore的使用举例<br>public class ImageProcessingJob {<br>    private static final String BUCKET_NAME = &quot;ai_images_bucket&quot;;<br>    private String code;<br>    private ImageSotreManager imageSotreManager;<br><br>    &#47;&#47; 通过外部传的code来动态获取对象，code放在配置文件中<br>    public ImageProcessingJob(String code, ImageSotreManager imageSotreManager) {<br>        this.code = code;<br>        this.imageSotreManager = imageSotreManager;<br>    }<br>    &#47;&#47;...省略其他无关代码...<br><br>    public void process() {<br>        Image image = null;&#47;&#47;处理图片，并封装为Image对象<br>        ImageSotre imageStore = imageSotreManager.getImageStore(code);<br>        imageStore.upload(image, BUCKET_NAME);<br>    }<br>}<br>完整代码地址：https:&#47;&#47;gitee.com&#47;fengzhili123_admin&#47;design_parttern&#47;tree&#47;master&#47;src&#47;main&#47;java&#47;com&#47;wangzheng&#47;image","like_count":0},{"had_liked":false,"id":274258,"user_name":"刘立嘉","can_delete":false,"product_type":"c1","uid":2414637,"ip_address":"","ucode":"1241140EBE7FE3","user_header":"https://static001.geekbang.org/account/avatar/00/24/d8/2d/6ec3760c.jpg","comment_is_top":false,"comment_ctime":1610943548,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610943548","product_id":100039001,"comment_content":"接口是真正的面向对象的存在物，它定义了类于类之间的has-a关系，所有实现了该接口的类，都具有共同性，即都需要实现接口中定义的方法，使得这些类都具有了共同点，那么在声明类实例的时候，可以是&lt;接口类&gt; variable = new &lt;实现类&gt;, 这种方法最开始定义接口时，毫不关心每个方法的实现，只看我想要这些类具有什么共同特性。","like_count":0},{"had_liked":false,"id":268245,"user_name":"Hi Young","can_delete":false,"product_type":"c1","uid":1548645,"ip_address":"","ucode":"E1E9C88399F3C2","user_header":"https://static001.geekbang.org/account/avatar/00/17/a1/65/44853770.jpg","comment_is_top":false,"comment_ctime":1608111775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608111775","product_id":100039001,"comment_content":"接口vs抽象类，准备面试的可以瞅瞅，一个小表格<br><br>https:&#47;&#47;www.yuque.com&#47;zhaohaiyang&#47;notes&#47;pragkx#i8kyM","like_count":0},{"had_liked":false,"id":263619,"user_name":"初学者","can_delete":false,"product_type":"c1","uid":2331845,"ip_address":"","ucode":"A6B5DDB0FCD5EC","user_header":"https://static001.geekbang.org/account/avatar/00/23/94/c5/67fa8668.jpg","comment_is_top":false,"comment_ctime":1606199281,"is_pvip":false,"replies":[{"id":"96089","content":"没错","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700707,"ip_address":"","comment_id":263619,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606199281","product_id":100039001,"comment_content":"抽象类做于代码复用，接口做于代码扩展","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510250,"discussion_content":"没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261513,"user_name":"刘永超","can_delete":false,"product_type":"c1","uid":2066121,"ip_address":"","ucode":"94CCA30F9E1567","user_header":"https://static001.geekbang.org/account/avatar/00/1f/86/c9/456f803d.jpg","comment_is_top":false,"comment_ctime":1605368513,"is_pvip":false,"replies":[{"id":"96142","content":"嗯嗯 是的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606701411,"ip_address":"","comment_id":261513,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605368513","product_id":100039001,"comment_content":"从语法特性区分抽象类和接口是比较实在的，对于语法特性，不能死记，但是理解记忆是必须的。也许对于高手来讲，语法太浅显了，但对于刚入门的人来说，语法是重要的基础。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509505,"discussion_content":"嗯嗯 是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606701411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255854,"user_name":"Jupiter","can_delete":false,"product_type":"c1","uid":2125382,"ip_address":"","ucode":"072E5C34CDE8AC","user_header":"https://static001.geekbang.org/account/avatar/00/20/6e/46/a612177a.jpg","comment_is_top":false,"comment_ctime":1603444395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603444395","product_id":100039001,"comment_content":"四年没写Java了，当老师说到interface不能定义属性时，我突然想到自己每天写的interface都是在定义属性，因为用的语言是Typescript. 在Typescript里面， interface 是用来定义 data shape的，感觉也就是属性。感觉Typescript 应该把interface 换个名字， 哈哈","like_count":0},{"had_liked":false,"id":252158,"user_name":"俄国的一盘桃子","can_delete":false,"product_type":"c1","uid":2220264,"ip_address":"","ucode":"DB9BFB35A54377","user_header":"https://static001.geekbang.org/account/avatar/00/21/e0/e8/a2d033fa.jpg","comment_is_top":false,"comment_ctime":1602150807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602150807","product_id":100039001,"comment_content":"我总感觉接口不能归属为has-a，组合的表现才更能说明has-a","like_count":0},{"had_liked":false,"id":251323,"user_name":"微末凡尘","can_delete":false,"product_type":"c1","uid":1099525,"ip_address":"","ucode":"25EDFD0914D0F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","comment_is_top":false,"comment_ctime":1601463778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601463778","product_id":100039001,"comment_content":"还记得有一次做支付相关的需求，用到了模板设计模式，问领导为什么非要用接口，用抽象不行么，当时也没有说出一个所以然来，看了这篇文章，真的是醍醐灌顶了，以后再也不用纠结用抽象类还是接口类了，抽象类是为了解决代码复用的问题，是is-a的关系，而接口是为了解决抽象的问题，是has-a的关系。","like_count":0},{"had_liked":false,"id":249676,"user_name":"朱月俊","can_delete":false,"product_type":"c1","uid":1017707,"ip_address":"","ucode":"4DA0728B862FBD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/6b/0b6cd39a.jpg","comment_is_top":false,"comment_ctime":1600755129,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600755129","product_id":100039001,"comment_content":"go语言。<br>直接支持interface。<br>没有继承特性，会用组合特性来实现继承，也能解决代码复用的问题。","like_count":0},{"had_liked":false,"id":248660,"user_name":"染指青春的狮子","can_delete":false,"product_type":"c1","uid":2162391,"ip_address":"","ucode":"DE439965EF135C","user_header":"https://static001.geekbang.org/account/avatar/00/20/fe/d7/f89c1f1a.jpg","comment_is_top":false,"comment_ctime":1600255495,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600255495","product_id":100039001,"comment_content":"C++中不能实现的类成员函数应该是纯虚函数。C++primer 5th，15章抽象基类有讲，抽象基类负责定义接口","like_count":0},{"had_liked":false,"id":245745,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599039800,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599039800","product_id":100039001,"comment_content":"问题一：<br>java，有<br>abstract class BaseA<br>interface InterB<br>问题二：<br>从is-a和has-a的角度去回答。为了复用还是为了解耦，降低复杂性。<br>","like_count":0},{"had_liked":false,"id":241123,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1597196741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597196741","product_id":100039001,"comment_content":"何时使用\t表达关系\t解决问题\t设计思路<br>抽象类\tis-a\t\t代码复用\t自下而上<br>接口\t\thas-a\t抽象解耦\t自上而下<br>","like_count":0},{"had_liked":false,"id":240370,"user_name":"Ilearning99","can_delete":false,"product_type":"c1","uid":1989119,"ip_address":"","ucode":"7901836A2C47EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/qOdqzmC507sibL6sichNSDaVmyoMKibEIqHWpic4CftgOQnoA3QKeRPwic9j1Ha8MLtzzqzfSRavR9GWMju09SMADUg/132","comment_is_top":false,"comment_ctime":1596878328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596878328","product_id":100039001,"comment_content":"1 C# abstract抽象类 interface接口<br>2 抽象类表示has-a 是一种代码复用，接口是is-a关系，不能定义属性和实现函数。","like_count":0},{"had_liked":false,"id":239895,"user_name":"Q罗","can_delete":false,"product_type":"c1","uid":1792098,"ip_address":"","ucode":"E797378F4DA1F4","user_header":"https://static001.geekbang.org/account/avatar/00/1b/58/62/346dd248.jpg","comment_is_top":false,"comment_ctime":1596686599,"is_pvip":false,"replies":[{"id":"89228","content":"������ 你说的没错","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1597412065,"ip_address":"","comment_id":239895,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596686599","product_id":100039001,"comment_content":"子类继承抽象类，如果这个子类也是一个抽象类，那这个子类就不是必须实现父类的抽象方法了吧？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503269,"discussion_content":"������ 你说的没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597412065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238330,"user_name":"yangcnb","can_delete":false,"product_type":"c1","uid":1762110,"ip_address":"","ucode":"063DC9D9670D4C","user_header":"","comment_is_top":false,"comment_ctime":1596122897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596122897","product_id":100039001,"comment_content":"这个专栏对于我这种机缘巧合晋升为后端负责人，对代码质量把控无从下手的人来说，简直是天降神兵，文章所有的不好做法全部命中，哈哈。","like_count":0},{"had_liked":false,"id":238184,"user_name":"owen","can_delete":false,"product_type":"c1","uid":1902116,"ip_address":"","ucode":"0E79DA9080A085","user_header":"https://static001.geekbang.org/account/avatar/00/1d/06/24/c2ee3b16.jpg","comment_is_top":false,"comment_ctime":1596091275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596091275","product_id":100039001,"comment_content":"接口只定义不实现好比一种协议要用我的必须先遵巡协议实现方法<br>抽象类好比一种功能每个继承的对象都有类似的功能，但是也可以自定义这个功能","like_count":0},{"had_liked":false,"id":237988,"user_name":"汉江","can_delete":false,"product_type":"c1","uid":1788647,"ip_address":"","ucode":"01622D984B8F9B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","comment_is_top":false,"comment_ctime":1596022988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596022988","product_id":100039001,"comment_content":"我觉得抽象就是抽出共性，留下扩展，而且扩展一般都是子类必须实现的，接口是某的行为规范，是所有子类必须遵循的","like_count":0},{"had_liked":false,"id":237960,"user_name":"ʸᵉ ᶠᵉᶮᵍ","can_delete":false,"product_type":"c1","uid":1280969,"ip_address":"","ucode":"BD6B8B01F78A21","user_header":"https://static001.geekbang.org/account/avatar/00/13/8b/c9/4281a2a3.jpg","comment_is_top":false,"comment_ctime":1596014544,"is_pvip":false,"replies":[{"id":"88022","content":"嗯嗯 你的表述更准确些","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1596109659,"ip_address":"","comment_id":237960,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1596014544","product_id":100039001,"comment_content":"老师老师，我想补充一下，什么时候使用抽象类这个问题。文章中说如果要is-a关系就用抽象类，感觉这个答案有点不标准，is-a关系也可以用普通类来实现代码复用问题。更标准的答案是不是如果既有代码复用问题，子类又一定要实现多态关系的时候才用抽象类。这个答案是不是准确，请老师指点一下。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502599,"discussion_content":"嗯嗯 你的表述更准确些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596109659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384694,"discussion_content":"专栏都完结了，老师还能答复，👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626702057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384693,"discussion_content":"专栏都完结了，老师还能答复，👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626702038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235967,"user_name":"Apologize","can_delete":false,"product_type":"c1","uid":1503320,"ip_address":"","ucode":"F2F179241EDA4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/f0/58/87104eab.jpg","comment_is_top":false,"comment_ctime":1595257689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595257689","product_id":100039001,"comment_content":"1、使用的是Java编程语言，Java对抽象类和接口有完整的支持，分别通过关键字abstract和interface实现。<br>2、如果是回答面试官的问题，考虑从以下几个方面：<br>     1）、抽象类和接口的定义<br>     2）、抽象类和接口出现的目的<br>     3）、两者语义上的差别以及使用的场景。","like_count":0},{"had_liked":false,"id":232527,"user_name":"雨天的七毫米","can_delete":false,"product_type":"c1","uid":1865908,"ip_address":"","ucode":"963BBAFE8EF97B","user_header":"https://static001.geekbang.org/account/avatar/00/1c/78/b4/af163d12.jpg","comment_is_top":false,"comment_ctime":1594028210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594028210","product_id":100039001,"comment_content":"这一节让我很受启发，接口和抽象类的区别当然是显而易见的，使用接口+类的等效替代=抽象类，他们的区别就需要好好想想了","like_count":0},{"had_liked":false,"id":230084,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1593253616,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593253616","product_id":100039001,"comment_content":"接口表达的是has a的关系，即有哪些能力。<br>而抽象类表示的是is a的关系。<br>抽象类解决的是能力复用问题，接口是解决扩展性问题。","like_count":0},{"had_liked":false,"id":228736,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1592796686,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592796686","product_id":100039001,"comment_content":"抽象类是is-a，接口是has-a关系。<br>抽象类存在属性和实现方法和抽象方法。继承的非抽象类必须实现抽象方法。目的是代码复用，而抽象方法实现了多态的概念。<br>接口不存在属性，只有没有实现的方法。可以理解为对外协议。解耦代码实现和定义。","like_count":0},{"had_liked":false,"id":228313,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1592639879,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592639879","product_id":100039001,"comment_content":"我觉得接口在聚合方面也有优势，相比抽象类，聚合条件更加宽松，更能体现出协议的优势。","like_count":0},{"had_liked":false,"id":227393,"user_name":"学斌","can_delete":false,"product_type":"c1","uid":1137880,"ip_address":"","ucode":"ED3432D8EDC327","user_header":"https://static001.geekbang.org/account/avatar/00/11/5c/d8/dfe1d4dc.jpg","comment_is_top":false,"comment_ctime":1592371001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592371001","product_id":100039001,"comment_content":"接口：无状态的行为的抽像<br>抽象类：有状态的行为抽象<br>比如<br>抽象类：人 ,子类：（男人，女人）（黄种人，黑人，白人）<br>性格接口   ：懒惰，勤奋 ，暴躁.....","like_count":0},{"had_liked":false,"id":226530,"user_name":"Chris Zou","can_delete":false,"product_type":"c1","uid":1897148,"ip_address":"","ucode":"B6DFC71C1DD8B7","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f2/bc/ffc7ad67.jpg","comment_is_top":false,"comment_ctime":1592129393,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592129393","product_id":100039001,"comment_content":"C++语言；抽象类通过包含纯虚函数的类来实现，也就是该方法只有接口没有实现，需要子类来继承实现；接口没有直接的语法，可以用一个只包含纯虚函数的类来实现。","like_count":0},{"had_liked":false,"id":226051,"user_name":"HoSalt","can_delete":false,"product_type":"c1","uid":1156074,"ip_address":"","ucode":"610B03E2A002D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","comment_is_top":false,"comment_ctime":1591936629,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591936629","product_id":100039001,"comment_content":"<br>Logger logger = new FileLogger(&quot;access-log&quot;, true, Level.WARN, &quot;&#47;users&#47;wangzheng&#47;access.log&quot;);<br>logger.log(Level.ERROR, &quot;This is a test log message.&quot;);<br>这代码为什么会出错（没学过java），不是只做了实例化的操作吗？log不是实现在子类上吗，难道不行?","like_count":0},{"had_liked":false,"id":225558,"user_name":"DY","can_delete":false,"product_type":"c1","uid":1459006,"ip_address":"","ucode":"55536A524A99B4","user_header":"https://static001.geekbang.org/account/avatar/00/16/43/3e/960d12cb.jpg","comment_is_top":false,"comment_ctime":1591785471,"is_pvip":false,"replies":[{"id":"84977","content":"在某些场景下，接口更好用，更能表达业务含义。这就类似，吃馒头能吃饱，为啥还要吃肉一个道理，更香！","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1593310957,"ip_address":"","comment_id":225558,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591785471","product_id":100039001,"comment_content":"既然接口能实现的功能抽象类都能实现， 为什么还要用接口？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497895,"discussion_content":"在某些场景下，接口更好用，更能表达业务含义。这就类似，吃馒头能吃饱，为啥还要吃肉一个道理，更香！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593310957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216974,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1589379496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589379496","product_id":100039001,"comment_content":"1、抽象类<br><br>抽象类是通过abstract关键字修饰的类，抽象类不能被实例化，不能被final修饰之外和普通类没有区别，可以拥有属性和普通方法。<br><br>抽象方法是通过abstract关键字修饰的方法，抽象方法不被static修饰。<br><br>抽象类可以没有抽象方法，但是抽象方法必须属于抽象类。<br><br>没有抽象方法的抽象类的作用是防止实例化。<br><br>抽象类的子类如果不是抽象类，那么必须重写父类中所有抽象方法。<br><br><br><br>作用：<br><br>（1）抽象类也能被继承，所以首先抽象类可用于代码复用。比起普通类来说抽象类可以强制子类进行重写抽象方法，因此可以避免子类忘记重写导致的bug。抽象类常用语模板模式。<br><br>（2）当我们希望某些类不能实例化时，就需要使用抽闲类，防止类被错误的实例化。<br><br><br><br>2、接口<br><br>接口不能包含属性，只能声明方法，1.8以后可有default方法。<br><br>接口实现类必须实现所有非default方法。<br><br>接口是为了解耦，是对具体实现的一种抽象，可以降低代码之间的耦合，提高代码的可读性。<br><br><br><br>3、该用接口还是抽象类<br><br>抽象类实际就是类，只是这种类只能继承不能被实例化，抽象类和子类也是一种is a 的关系，为的是代码复用。<br><br>接口或者说是协议，表示实现类拥有什么能力，是一种has a的关系，或者behaive like，为的是代码解耦。","like_count":0},{"had_liked":false,"id":216337,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1589244358,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589244358","product_id":100039001,"comment_content":"抽象和接口<br>1，是什么：<br>①两者都是特殊的类<br>②抽象类可以有成员变量，普通方法，抽象方法<br>③接口只能有为被实现的方法，java8中增加了一个默认方法<br>2 为什么<br>①：抽象类是为了解决代码复用的问题<br>②：接口是为了解决抽象的问题<br><br>3 何时用<br>如果要解决代码复用的问题可以优先考虑抽象类<br>如果要解决代码抽象问题可以考虑使用接口<br><br>抽象类是一种自底向上的思考方法，而接口是自顶向下的思考","like_count":0},{"had_liked":false,"id":214495,"user_name":"大圣代","can_delete":false,"product_type":"c1","uid":1003080,"ip_address":"","ucode":"8A59114C8345C8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/48/bb0136d1.jpg","comment_is_top":false,"comment_ctime":1588758345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588758345","product_id":100039001,"comment_content":"抽象类是自下而上的 -&gt; 先有子类的具体实现然后从中抽出公共固定行为、公共可变行为，构成了抽象类。<br>接口是自上而下的-&gt; 先定义统一行为，将可变部分转化为固定方法，然后在具体实现。","like_count":0},{"had_liked":false,"id":212505,"user_name":"Doctor Lau","can_delete":false,"product_type":"c1","uid":1018266,"ip_address":"","ucode":"4B685CF1582BC4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/9a/51e87979.jpg","comment_is_top":false,"comment_ctime":1588138660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588138660","product_id":100039001,"comment_content":"到底实现接口是is a还是has a这是个问题，可能要看场景吧，功能性接口才勉强能算has a关系吧","like_count":0},{"had_liked":false,"id":208164,"user_name":"carl","can_delete":false,"product_type":"c1","uid":1593385,"ip_address":"","ucode":"7C725C7D69855F","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqD7goM3NZGb77qicnUHX8qdrXpIH89Ziaul2475ko5VMpFxiajbQsJhv2aG0HxmX8vgswfz9WkvElBg/132","comment_is_top":false,"comment_ctime":1587287679,"is_pvip":false,"replies":[{"id":"86633","content":"新版本的可以！","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594785934,"ip_address":"","comment_id":208164,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587287679","product_id":100039001,"comment_content":"Java 中接口可以有属性的吧？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492364,"discussion_content":"新版本的可以！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594785934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207303,"user_name":"geosmart","can_delete":false,"product_type":"c1","uid":1435611,"ip_address":"","ucode":"7DCBA2F120442D","user_header":"https://static001.geekbang.org/account/avatar/00/15/e7/db/1ad86e94.jpg","comment_is_top":false,"comment_ctime":1587044732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587044732","product_id":100039001,"comment_content":"自下而上思考是-重构abstract抽象类，自上而下表达-设计interface协议","like_count":0},{"had_liked":false,"id":203161,"user_name":"酸辣土豆丝","can_delete":false,"product_type":"c1","uid":1751234,"ip_address":"","ucode":"0E3E4AFB31E1E6","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b8/c2/d1904d74.jpg","comment_is_top":false,"comment_ctime":1586145975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586145975","product_id":100039001,"comment_content":"会从定义，应用场景，为什么会存在，三个方面讲；Python语言确实没有抽象类和接口的相关语法，不过可以从各自的定义形式上进行模拟","like_count":0},{"had_liked":false,"id":202690,"user_name":"技术骨干","can_delete":false,"product_type":"c1","uid":1098720,"ip_address":"","ucode":"8FCF8DE6D29201","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/e0/3db22579.jpg","comment_is_top":false,"comment_ctime":1586053848,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586053848","product_id":100039001,"comment_content":"抽象类：描述的是一种is-a 的关系<br>接口：描述的是一种通用行为的能力，多用在行为设计模式当中。","like_count":0},{"had_liked":false,"id":201809,"user_name":"王坤祥","can_delete":false,"product_type":"c1","uid":1003327,"ip_address":"","ucode":"FB988B9F381A33","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4f/3f/6f62f982.jpg","comment_is_top":false,"comment_ctime":1585839738,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585839738","product_id":100039001,"comment_content":"变化的代码实现，比如一些变量（非常量），就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。<br><br>对修改关闭，对扩展（不同的实现implements）开放，接口是对开闭原则的一种体现。","like_count":0},{"had_liked":false,"id":200078,"user_name":"Marvichov","can_delete":false,"product_type":"c1","uid":1111835,"ip_address":"","ucode":"7482099415C41C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","comment_is_top":false,"comment_ctime":1585540368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585540368","product_id":100039001,"comment_content":"Pure virtual function是可以有default实现的。在子类实现的时候，可以explicitly调用。这种设计思路是提供一个common default，但是client继承的时候得explicit声明。","like_count":0},{"had_liked":false,"id":199851,"user_name":"Go","can_delete":false,"product_type":"c1","uid":1238222,"ip_address":"","ucode":"A5EFBE288C9A54","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/ce/6af1bf02.jpg","comment_is_top":false,"comment_ctime":1585496957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585496957","product_id":100039001,"comment_content":"知其然知其所以然😊","like_count":0},{"had_liked":false,"id":198460,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585452749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585452749","product_id":100039001,"comment_content":"你确定用protected关键字能够防止被实例化么，在模拟接口那里","like_count":0},{"had_liked":false,"id":197733,"user_name":"白杨","can_delete":false,"product_type":"c1","uid":1743868,"ip_address":"","ucode":"B56DD94706F80B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9b/fc/a3abbe53.jpg","comment_is_top":false,"comment_ctime":1585395769,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585395769","product_id":100039001,"comment_content":" 那么面向接口编程，广义上也应该包括面向抽象类编程吧，而不应该是为了使用接口而强制抽象类必须实现一个接口，对吧老师。","like_count":0},{"had_liked":false,"id":196853,"user_name":"猎手","can_delete":false,"product_type":"c1","uid":1802509,"ip_address":"","ucode":"438C14B0045387","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJYQ2t5vVmVJxT0icdu7fhWXb9Ln7IM9PgOMnFyzrRZELBk7Cv79kBEqaCJDzg4evEicT7MsLx9BKYg/132","comment_is_top":false,"comment_ctime":1585318496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585318496","product_id":100039001,"comment_content":"as a,has a经典","like_count":0},{"had_liked":false,"id":195623,"user_name":"改名不换人","can_delete":false,"product_type":"c1","uid":1118242,"ip_address":"","ucode":"7E25577829FA0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/22/910f705c.jpg","comment_is_top":false,"comment_ctime":1585206190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585206190","product_id":100039001,"comment_content":"做个笔记：<br>1 接口：不能被实例化，不能有属性和被实现的方法，只能拥有方法定义（jdk8 以后可以通过default定义一个有实现的默认方法），实现交给实现类去完成，是一类行为的抽象，用于解耦合。<br>2 抽象类：不能被实例化，可以有属性和被实现的方法，也可以有方法定义(抽象方法)，子类必须实现抽象类中的抽象方法，用于解决代码复用的问题。","like_count":0},{"had_liked":false,"id":194841,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1585109634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585109634","product_id":100039001,"comment_content":"我是一个菜鸡前端，说实话，没太看懂。可能在 TS 有接口和抽象类的概念，但是我现在不是很了解。<br><br>只记住了一点接口是为了解耦代码，抽象类是为了复用代码<br>","like_count":0},{"had_liked":false,"id":193149,"user_name":"永胜","can_delete":false,"product_type":"c1","uid":1364971,"ip_address":"","ucode":"EF6E8E80F67D9E","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/eb/f941509f.jpg","comment_is_top":false,"comment_ctime":1584884886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584884886","product_id":100039001,"comment_content":"加深了接口和抽象的原理，在具体某个开发语言下还是需要活学活用","like_count":0},{"had_liked":false,"id":193091,"user_name":"InfoQ_94b11bfe2807","can_delete":false,"product_type":"c1","uid":1296312,"ip_address":"","ucode":"644EAA4032D323","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKibEUVoa39YOVxTbcORR8XK7rB7CiadBRFgUENuggRViaYRkj2SyEib64QmNQOm9or6QZDaszzqX9DTw/132","comment_is_top":false,"comment_ctime":1584883717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584883717","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":190250,"user_name":"索旭东","can_delete":false,"product_type":"c1","uid":1139039,"ip_address":"","ucode":"BFD07BCD8C8CAE","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/5f/b279daaf.jpg","comment_is_top":false,"comment_ctime":1584622539,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584622539","product_id":100039001,"comment_content":"抽象类就是一个类中可以有些抽象方法","like_count":0},{"had_liked":false,"id":189437,"user_name":"治慧","can_delete":false,"product_type":"c1","uid":1245904,"ip_address":"","ucode":"47C331EF63EDC6","user_header":"https://static001.geekbang.org/account/avatar/00/13/02/d0/8abab63f.jpg","comment_is_top":false,"comment_ctime":1584515937,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584515937","product_id":100039001,"comment_content":"其实工作中定义接口还是定义抽象方法,给人的感觉是当我们要暴露的时候用接口,比如rpc接口给其他服务来进行远程调用  抽象方法的感觉是我们将一些相识的类的共同属性进行向上抽取出来一个类叫抽象类","like_count":0},{"had_liked":false,"id":185382,"user_name":"yan","can_delete":false,"product_type":"c1","uid":1667264,"ip_address":"","ucode":"BA33B672798AEE","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/c0/b365a317.jpg","comment_is_top":false,"comment_ctime":1583571046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583571046","product_id":100039001,"comment_content":"抽象类是一种自下而上的设计思路，一般用来解决代码复用问题（发现代码可以复用--&gt;提取公共父类）；接口是一种自上而下的设计思路，一般用来解决抽象而非代码复用的问题（设计接口--&gt;实现接口）。","like_count":0},{"had_liked":false,"id":184995,"user_name":"Mark","can_delete":false,"product_type":"c1","uid":1054152,"ip_address":"","ucode":"0DF6D68131F79B","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/c8/65ed960c.jpg","comment_is_top":false,"comment_ctime":1583464411,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583464411","product_id":100039001,"comment_content":"Jdk8<br>接口可以有成员变量 和  实现方法","like_count":0},{"had_liked":false,"id":184602,"user_name":"新的起点，新的开始^_^","can_delete":false,"product_type":"c1","uid":1262068,"ip_address":"","ucode":"9C0810F472AC93","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/f4/5df17eff.jpg","comment_is_top":false,"comment_ctime":1583369994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583369994","product_id":100039001,"comment_content":"争哥，我有个这样的想法，不知道对不对，在我们的java开发中，我设计一个basicService接口,里面只有四个方法，insert(Object object),以及delete，update和query,然后项目中的所有实现类都实现这个接口，在重写的方法中去强转pojo类，然后各自再实现自己特有的接口，这样怎么样呢？<br>第一点，肯定会有这种情况，并不是所有的实现类都需要curd，但实现类中也必须得重写了","like_count":0},{"had_liked":false,"id":184068,"user_name":"彭汤宇","can_delete":false,"product_type":"c1","uid":1160325,"ip_address":"","ucode":"72BDD100CB373A","user_header":"https://static001.geekbang.org/account/avatar/00/11/b4/85/e21fc61b.jpg","comment_is_top":false,"comment_ctime":1583217557,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583217557","product_id":100039001,"comment_content":"接口只能声明方法，方法不能包含代码实现。<br>老师，在JDK8后是可以在接口中包含带有具体实现的方法，我觉得这块还是要区分一下。","like_count":0},{"had_liked":false,"id":183455,"user_name":"空白昵称","can_delete":false,"product_type":"c1","uid":1433815,"ip_address":"","ucode":"91F50CA25102AB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","comment_is_top":false,"comment_ctime":1583044859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583044859","product_id":100039001,"comment_content":"Swift中的协议相当于“包含了”抽象类和接口的概念。可以关联类型，然后添加方法、属性。且可以通过extension扩展默认实现方法。从而达到代码复用和抽象解藕的目的。通也必须通过类遵循协议才能使用。","like_count":0},{"had_liked":false,"id":182992,"user_name":"ladidili","can_delete":false,"product_type":"c1","uid":1217498,"ip_address":"","ucode":"38886C1908DE6B","user_header":"https://static001.geekbang.org/account/avatar/00/12/93/da/0e47c76e.jpg","comment_is_top":false,"comment_ctime":1582903135,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582903135","product_id":100039001,"comment_content":"感觉就是没有了多继承，所以需要一个东西来做抽象，就是接口。而且接口当做协议确实好理解一些。我实现一个大功能，可能需要组合实现不同的接口协议，才能完成一个大功能。可以组合遵守不同的协议实现不同的功能","like_count":0},{"had_liked":false,"id":182720,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1582855773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582855773","product_id":100039001,"comment_content":"从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。抽象类可以在后续重构中使用。所以可以不上来就使用抽象类。看看变化在调整。接口与抽象类在代码设计过程中也可以相互转换","like_count":0},{"had_liked":false,"id":180828,"user_name":"Warming","can_delete":false,"product_type":"c1","uid":1024679,"ip_address":"","ucode":"BD1283D003F5BC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a2/a7/37cbf5f7.jpg","comment_is_top":false,"comment_ctime":1582423428,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582423428","product_id":100039001,"comment_content":"抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。<br>当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。","like_count":0},{"had_liked":false,"id":180781,"user_name":"Geek_33785c","can_delete":false,"product_type":"c1","uid":1487529,"ip_address":"","ucode":"CF1ABC5F962EC8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7nnI7sIWC91S5BvdBTLUApySCKdALjklLWGuXFJQ9Wyu1l5gMk6dgu2CVOtYicb3iaUNxV4ghUb4dMryDJgOXCbH/132","comment_is_top":false,"comment_ctime":1582385637,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1582385637","product_id":100039001,"comment_content":"Typescript 的接口为什么就可以包含属性呢","like_count":0},{"had_liked":false,"id":180627,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1582354741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582354741","product_id":100039001,"comment_content":"接口和抽象类：1、首先是有各自的语意特性；2、抽象是为了代码复用，可以做到优雅；接口是定义协议，隔离接口和实现，为了解偶；<br>第一感觉是迷糊的，自己做一下笔记感觉又清晰了一些，最后觉得还是没吃透","like_count":0},{"had_liked":false,"id":179709,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582081799,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582081799","product_id":100039001,"comment_content":"对于问题一来说,因为一种用的是Java,提供了抽象类和接口的概念,可以直接使用,其中抽象类使用了关键字abstarct,接口使用了关键字interface<br>对于问题二,经过这几天的学习,有了一个新的认识,一般的web开发,我们都是用的MVC三层框架,基本上写出的代码都是贫血模型的,getter&#47;setter滥用,而且没有真正的去进行抽象化,虽然Spring提供了依赖注入的概念,但是我们书写的抽象类一是命名不规范,二是抽象类和实现等值挂钩,经常出现没有复用性的问题,为了一点小改动而重写接口类,一个抽象类直接对应着一个实现,没有利用多态的思想,写出来的都是面向过程的语言,希望可以在整个课程结束之后,让自己的代码水平有所上升吧","like_count":0},{"had_liked":false,"id":179288,"user_name":"junmawang","can_delete":false,"product_type":"c1","uid":1763466,"ip_address":"","ucode":"977E9E25CE6C94","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e8/8a/803a42e0.jpg","comment_is_top":false,"comment_ctime":1581952599,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581952599","product_id":100039001,"comment_content":"抽象类（abstract)<br>\t1、抽象类不允许被事例化，只能被继承，直接new编译出错。<br>\t2、抽象类可以包含属性和方法，可以有普通发放和抽象方法。<br>\t3、子类继承抽象类，必须实现抽象类中的所有抽象方法。<br>\t4、抽象类继承关系是一种 is-a 的关系<br>接口(inteface)<br>\t1、接口不能包含属性。<br>\t2、接口除了声明方法也可以有default实现方法。<br>\t3、类实现接口，必须实现接口中声明的所有方法。<br>\t4、接口表示一种 has-a 关系，表示具有某些功能<br>\t<br>抽象类解决问题<br>\t1、代码复用<br>接口解决问题<br>接口就更侧重于解耦，接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。","like_count":0},{"had_liked":false,"id":178317,"user_name":"syz","can_delete":false,"product_type":"c1","uid":1174704,"ip_address":"","ucode":"54AF17ACD72645","user_header":"https://static001.geekbang.org/account/avatar/00/11/ec/b0/4e22819f.jpg","comment_is_top":false,"comment_ctime":1581660886,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581660886","product_id":100039001,"comment_content":"接口在开发中往往是开发前自上而下定义的，而抽象类是开发中自下而上提取重复代码生成的。","like_count":0},{"had_liked":false,"id":176050,"user_name":"阳光很轻","can_delete":false,"product_type":"c1","uid":1619031,"ip_address":"","ucode":"73408E2DA4F10D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKE7VtDBFkSht6VgE4UZL82SlUrDXKVaGVibJSNXsVhfrPTNQ2OfrrOGu7ugMxwa0osyZibRqZjh5KQ/132","comment_is_top":false,"comment_ctime":1580919463,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580919463","product_id":100039001,"comment_content":"强调这两种语法特征的主要区别点：抽象类是对一个完整类的抽象概括，是一种自下而上的设计;而接口更加强调某一种分支概念的抽象，所以更容易被用到某个类的组合中去，是一种先定义后实现的自上而下的设计思路。","like_count":0},{"had_liked":false,"id":174963,"user_name":"ypy","can_delete":false,"product_type":"c1","uid":1112050,"ip_address":"","ucode":"4BEAA42E9975C2","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/f2/83aee314.jpg","comment_is_top":false,"comment_ctime":1580480858,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1580480858","product_id":100039001,"comment_content":"OC 里面的 procotol 相当于接口了，但是 OC 里面没有抽象类的概念。但是 OC 的接口和作者说的接口也不完全一致，因为它可以有 optional 的方法，也就是子类可以不用实现的方法。灵活性更好一些，子类可以根据需要来实现某些接口方法。感觉这种设计更多的是使用场景中提出来的需求。猜测是因为 OC 的主要应用场景是 macOS 和 iOS 的 UI 编程，其中用的较多的是 delegate 方法，将 UI 的一些生命周期通过代理回调，很多时候并不是所有的使用者都关心这些生命周期，所以就有了这种 optional 的设计","like_count":0,"discussions":[{"author":{"id":1506399,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fc/5f/439a96cd.jpg","nickname":"karisli","note":"","ucode":"14E9118FAA3327","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214297,"discussion_content":"iOS中没有抽象类的接口，但是按照老师刚才的说法，可以通过普通类来实现：.h中声明&#34;抽象方法&#34;，.m中实现的时候throw exception，编译的时候如果子类如果没有实现这个方法就会抛出异常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585176460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174793,"user_name":"贺宇","can_delete":false,"product_type":"c1","uid":1445040,"ip_address":"","ucode":"55854825CC4AD2","user_header":"https://static001.geekbang.org/account/avatar/00/16/0c/b0/26c0e53f.jpg","comment_is_top":false,"comment_ctime":1580389065,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1580389065","product_id":100039001,"comment_content":"接口可以有属性啊，只不过不能修改","like_count":0,"discussions":[{"author":{"id":1358045,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b8/dd/37726c34.jpg","nickname":"小马哥","note":"","ucode":"B2C0FF38F8C9BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386516,"discussion_content":"默认是public static final修饰的属性, 所以是类属性, 新版本具有的.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627624922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174405,"user_name":"Canva","can_delete":false,"product_type":"c1","uid":1461560,"ip_address":"","ucode":"F29E71D9553763","user_header":"https://static001.geekbang.org/account/avatar/00/16/4d/38/74aedf50.jpg","comment_is_top":false,"comment_ctime":1580195082,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580195082","product_id":100039001,"comment_content":"接口中定义的属性，不能算成员属性是因为是共用属性吗？还有JDK8接口引入默认实现，是为了向下兼容吗？","like_count":0},{"had_liked":false,"id":174055,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1579931479,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1579931479","product_id":100039001,"comment_content":"老师，接口也是需要被实现的，比如您举例的Filter，RateLimateFilter，所以我觉得类和接口也是is a关系","like_count":0,"discussions":[{"author":{"id":1358045,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b8/dd/37726c34.jpg","nickname":"小马哥","note":"","ucode":"B2C0FF38F8C9BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386517,"discussion_content":"接口这个定义来源于硬件, 硬件之间连接, 接口是一种协议, 匹配才能正常工作; 在编程中, 接口同样规定了使用和定义接口的两个地方要匹配, 这个匹配即定义了接口的实现具备什么行为, 所以是has-a的关系.\n于是\nLogger logger(抽象) = new FileLogger();(实现)\nlogger.log(); 这里面向接口编程\n日后,需求变了, 需要将日志发送到消息队列, 换一个新的实现过来就了;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627625247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173558,"user_name":"好饿早知道送外卖了","can_delete":false,"product_type":"c1","uid":1132304,"ip_address":"","ucode":"AED22DB5BF8FC7","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","comment_is_top":false,"comment_ctime":1579596492,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1579596492","product_id":100039001,"comment_content":"#### 抽象类<br>&gt; 抽象类实际上就是类，只不过是一种特殊的类，这种类不能被实例化为对象，只能被子类继承。和类一样，抽象类也表示一种 is-a 的关系。<br><br>- 抽象类不允许被实例化，需要使用它的子类，并实现它的抽象方法<br><br>以一个上报系统为例，他分为TCP和HTTP两种上报方式：<br>抽象类中实现了可复用的主要逻辑（比如新增、格式化、存储、切割），子类中实现需要定制其关键步骤的抽象方法具体如何实现（比如TCP&#47;HTTP发送）。<br><br>同样我们可以把上报的模块抽离出来，作为参数传递给manager进行不同的上报动作。这种方式又叫多态。<br><br>&gt; 可以看出，抽象类（继承）的主要目的是为了代码的复用。<br><br>#### 接口（协议）<br>&gt; 接口表示一种 has-a 关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议（contract）。<br><br>- 接口只能声明方法，方法不能包含代码实现<br>- 类实现接口的时候，必须实现接口中声明的所有方法<br><br>**以公司为例：**<br>每个参加工作的个体都有不同，可能继承自不同的父母。但是我们可以抽象出上班、打卡、996等等一系列协议。一旦一个类想要来工作，只要实现这一套协议，随时来公司修福报。<br><br>其实也可以用多态实现这一系列流程，但是相对于多态，协议更加解耦和灵活。<br>因为它对类没有父类的要求，只要实现了协议任何类都可以接入系统。一个类实现了多套协议，完全可以接入多个系统（比如我既要996，剩下一天还得带娃）。<br><br>&gt; 可以看出接口主要在于解耦、扩展和灵活性。","like_count":0},{"had_liked":false,"id":173452,"user_name":"🍃","can_delete":false,"product_type":"c1","uid":1337052,"ip_address":"","ucode":"D1E4560C49139A","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/dc/fdffbc96.jpg","comment_is_top":false,"comment_ctime":1579565780,"is_pvip":false,"replies":[{"id":"67728","content":"动态语言我不大了解~","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1580115399,"ip_address":"","comment_id":173452,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1579565780","product_id":100039001,"comment_content":"对于动态编程语言来说，还有一种对接口支持的策略，那就是 duck-typing<br><br>老师, 这个能举个例子吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482071,"discussion_content":"动态语言我不大了解~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580115399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269213,"discussion_content":"在第5讲，有个简单的例子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589879586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173014,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1579409096,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579409096","product_id":100039001,"comment_content":"越看越有味道了","like_count":0},{"had_liked":false,"id":168146,"user_name":"赵小样","can_delete":false,"product_type":"c1","uid":1238131,"ip_address":"","ucode":"49E95C1E96B2BD","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/73/d8291f76.jpg","comment_is_top":false,"comment_ctime":1578019204,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578019204","product_id":100039001,"comment_content":"NativeAd nativeAd = new NativeAd() {<br>            @Override<br>            protected void testAbstract() {<br><br>            }<br>        };<br>        iAdListener.onAdLoaded(nativeAd);<br><br>类似这种的，NativeAd是抽象类。","like_count":0},{"had_liked":false,"id":168141,"user_name":"赵小样","can_delete":false,"product_type":"c1","uid":1238131,"ip_address":"","ucode":"49E95C1E96B2BD","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/73/d8291f76.jpg","comment_is_top":false,"comment_ctime":1578018769,"is_pvip":false,"replies":[{"id":"65963","content":"&quot;重写抽象类的方法就可以了&quot; 那你创建的还是抽象类吗？😂 ","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1578490729,"ip_address":"","comment_id":168141,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578018769","product_id":100039001,"comment_content":"老师，使用AndroidStudio开发的时候，抽象类是可以被创建实例的，编译器不会报错，重写抽象类的抽象方法就可以了，抽象类的对象也可以正常调用。那这个是语法问题吧，跟编译器应该没有关系，那说明抽象类是可以被实例化的。能麻烦老师解释一下吗？感谢！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480149,"discussion_content":"&amp;quot;重写抽象类的方法就可以了&amp;quot; 那你创建的还是抽象类吗？😂 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578490729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168064,"user_name":"氧气🌙 🐟 🌺","can_delete":false,"product_type":"c1","uid":1591015,"ip_address":"","ucode":"8E23C210A9F09E","user_header":"https://static001.geekbang.org/account/avatar/00/18/46/e7/e20279ea.jpg","comment_is_top":false,"comment_ctime":1578010062,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578010062","product_id":100039001,"comment_content":"普通类模拟抽象类，就是用protected修饰构造函数<br>public class MockInteface {<br>  &#47;&#47; protected 避免类被实例化<br>  protected MockInteface() {}<br>  public void funcA() {<br>    &#47;&#47; 具体实现<br>  }<br>}","like_count":0},{"had_liked":false,"id":166711,"user_name":"fly","can_delete":false,"product_type":"c1","uid":1025992,"ip_address":"","ucode":"D1F6938C9CE15D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a7/c8/5608cbdb.jpg","comment_is_top":false,"comment_ctime":1577550427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577550427","product_id":100039001,"comment_content":"接口：不能实例化；不包含属性；方法不能包含实现<br>抽象类：不能实例化；可以包含方法和属性；方法可以包含代码实现，也可以不包含代码实现<br>接口侧重于解耦，体现的是灵活性和可扩展性的设计思想。<br>抽象类侧重于代码复用，体现的是继承的特性，常用于模板设计模式。","like_count":0},{"had_liked":false,"id":165947,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1577348665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577348665","product_id":100039001,"comment_content":"打卡Day4：今天学习了【08 | 理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口？】<br><br>一、抽象类和接口的语法特性<br>抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也不可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。<br><br>二、抽象类和接口能解决什么编程问题？<br>1.抽象类不能被实例化，只能被继承，所以，抽象类也是为代码复用而生的。如果一个方法在父类中没有任何意义，只有在两个子类中才有具体的实现，还要达到多态的效果，使用抽象类作为父类比普通类作为父类要优雅很多。用普通类作为父类可能会忘记重写那个方法，抽象类编译器会强制要求重写抽象方法，普通类可以被实例化，没有任何意义的方法会被调用。<br>2.接口偏重于解耦，相当于一组协议或者契约，调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。<br><br>三、如何模拟抽象类和接口<br>1.某个类只要没有成员变量，只有方法声明，没有方法实现，继承某个类必须实现某个类中的所有方法。只要满足这几点就可以叫作接口。<br>让类中的方法抛出MethodUnSupportedException 异常，来模拟不包含实现的接口，子类继承这个父类的时候，都去主动实现父类的方法，否则就会抛出异常。<br>但是并不能保证被实例化，因为Java中私有化构造方法就不能被继承了，要的只是模拟，并不是和接口一模一样。<br>2.模拟抽象类的思想同上。<br><br>四、如何决定该用抽象类还是接口<br>1.如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示\b一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。<br>2.抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。","like_count":0},{"had_liked":false,"id":164814,"user_name":"黄政","can_delete":false,"product_type":"c1","uid":1345630,"ip_address":"","ucode":"9076A1BF7BB051","user_header":"https://static001.geekbang.org/account/avatar/00/14/88/5e/cc916a2b.jpg","comment_is_top":false,"comment_ctime":1577094650,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1577094650","product_id":100039001,"comment_content":"1.我熟悉的是C++，当前默认是支持抽象类，接口的话使用虚函数也可以实现<br>2.接口：存在方式，特性，应用<br>抽象类：特点，优点","like_count":0},{"had_liked":false,"id":164769,"user_name":"程序猿大叔文海","can_delete":false,"product_type":"c1","uid":1241846,"ip_address":"","ucode":"BB6D82C93EFCC5","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/f6/27cc6133.jpg","comment_is_top":false,"comment_ctime":1577088737,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577088737","product_id":100039001,"comment_content":"Java 中JDK8 接口里面有默认实现，还有static方法都是有方法体的。 <br>还有Java 接口里面是可以有属性的，不过很少有人这么玩，默认是public static final 修饰的。","like_count":0},{"had_liked":false,"id":164256,"user_name":"Next","can_delete":false,"product_type":"c1","uid":1748213,"ip_address":"","ucode":"D5ADDF248A9504","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ac/f5/2f97e279.jpg","comment_is_top":false,"comment_ctime":1576917271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576917271","product_id":100039001,"comment_content":"接口，只是一种通用行为描述。实现接口的类，表示该类具有接口描述的行为(has-a)。可以很好的支持多态，提升扩展性！<br>抽象类，是一种抽象概念描述，有特征，有行为，但没有具体的存在（实例）。继承抽象类（is-a），可以提高代码复用，优雅的实现子类，提升可维护性！","like_count":0},{"had_liked":false,"id":164240,"user_name":"Attract","can_delete":false,"product_type":"c1","uid":1112638,"ip_address":"","ucode":"DEB10AF9AB5A41","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/3e/92d74b38.jpg","comment_is_top":false,"comment_ctime":1576913587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576913587","product_id":100039001,"comment_content":"抽象类如果只有抽象方法，其实就约等于接口了","like_count":0},{"had_liked":false,"id":164058,"user_name":"东流","can_delete":false,"product_type":"c1","uid":1738147,"ip_address":"","ucode":"2715BC6E87BD83","user_header":"https://static001.geekbang.org/account/avatar/00/1a/85/a3/7e078442.jpg","comment_is_top":false,"comment_ctime":1576852195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576852195","product_id":100039001,"comment_content":"我觉得如果类与类之间有属性共有的话，就用抽象类，如果没有只有行为的话用接口","like_count":0},{"had_liked":false,"id":163906,"user_name":"睁眼看世界","can_delete":false,"product_type":"c1","uid":1206388,"ip_address":"","ucode":"F94CF34BC5B2AC","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/74/461b202d.jpg","comment_is_top":false,"comment_ctime":1576823698,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576823698","product_id":100039001,"comment_content":"老师，java的接口中也可以定义属性，不过默认是常量而已。","like_count":0},{"had_liked":false,"id":163048,"user_name":"tong467","can_delete":false,"product_type":"c1","uid":1560667,"ip_address":"","ucode":"544F6FB2C5A936","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJjw7KXibCGnibOm3O73xCGyCzdmgKuc017X8IQZCdNvAWxoWxHSgMTLgd7rGs1LCBPaU5oHbO16F0A/132","comment_is_top":false,"comment_ctime":1576647536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576647536","product_id":100039001,"comment_content":"java抽象类的子类也不要求必须实现所有抽象方法，如果他的子类也是一个抽象类就可不实现所有抽象方法，只有子类是个普通类才要求实现所有抽象方法；<br>1.8中 java 的接口有默认方法。即接口也可以有带实现的方法。","like_count":0},{"had_liked":false,"id":162559,"user_name":"海罗沃德","can_delete":false,"product_type":"c1","uid":1165364,"ip_address":"","ucode":"8704F1D6980FA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c8/34/fb871b2c.jpg","comment_is_top":false,"comment_ctime":1576554798,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576554798","product_id":100039001,"comment_content":"JDK 8中接口中可以存在包含default關鍵字的有具體實現的方法，這樣是不是破壞了原本接口has-a的定義？","like_count":0},{"had_liked":false,"id":162255,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1518880,"ip_address":"","ucode":"69655C3AF0976B","user_header":"https://static001.geekbang.org/account/avatar/00/17/2d/20/feeb9ffc.jpg","comment_is_top":false,"comment_ctime":1576487587,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576487587","product_id":100039001,"comment_content":"想提个问题，我是写scala的，java也写过但是不是那么精通，在讲抽象类里logger的例子里我有点疑惑：为什么要把这个logger的类型设置成抽象类logger？为什么不能直接是 FileLogger filelogger = new FileLogger, 它明明是一个FileLogger类型并且它可以直接使用FileLogger自己的log方法，为什么还要把这个变量类型设置成Logger呢<br><br>Logger logger = new FileLogger(&quot;access-log&quot;, true, Level.WARN, &quot;&#47;users&#47;wangzheng&#47;access.log&quot;);<br>logger.log(Level.ERROR, &quot;This is a test log message.&quot;);","like_count":0,"discussions":[{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128250,"discussion_content":"我的理解是主要是为了演示抽象类可以使用多态这个特性。\n在平时的生产上，我们会把log方法封装成一个公共接口或者方法，接受参数为Log类型的对象，例如:\nvoid log(Log log){\n      log.log;\n}\n然后在使用时，根据具体的业务场景，传入不同的实现了Log的对象，从而完成不同的操作。以后应该会讲到这个策略模式。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578623347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161895,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1576395290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576395290","product_id":100039001,"comment_content":"文章关于抽象类和普通父类嗯区别，我觉得只有能不能被实例化这一点。因为普通父类也可以分别有log和doLog方法，然后log调用doLog，doLod方法不做任何事情。这样子类重写doLog方法就可以了，也支持多态。","like_count":0},{"had_liked":false,"id":161843,"user_name":"乘坐Tornado的线程魔法师","can_delete":false,"product_type":"c1","uid":1132661,"ip_address":"","ucode":"C4C9915866E769","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","comment_is_top":false,"comment_ctime":1576376709,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576376709","product_id":100039001,"comment_content":"接口不能包含属性（也就是成员变量）。这句话是否可以更细化。我查阅后发现static final的成员变量是可以定义在接口中的。只不过需要在声明时赋值。就相当于单例模式中的饿汉型。","like_count":0},{"had_liked":false,"id":160252,"user_name":"alls well","can_delete":false,"product_type":"c1","uid":1072439,"ip_address":"","ucode":"8E3EB5A3DF6E0D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5d/37/8261fc68.jpg","comment_is_top":false,"comment_ctime":1575899323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575899323","product_id":100039001,"comment_content":"C再怎么玩，也脱离不了结构体和指针","like_count":0},{"had_liked":false,"id":159363,"user_name":"马建华","can_delete":false,"product_type":"c1","uid":1185974,"ip_address":"","ucode":"928189590259AB","user_header":"https://static001.geekbang.org/account/avatar/00/12/18/b6/f3f68a39.jpg","comment_is_top":false,"comment_ctime":1575606650,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575606650","product_id":100039001,"comment_content":"再提个问题：<br>1. 老师用普通父类实现的打印日志代码中，说在Logger中定义了空的log()方法，影响了可读性，可是第一种抽象类打印日志代码中，dolog()不也是空的方法吗？这个是不是也影响了可读性？<br>2. 老师说抽象类打印日志代码中，编译器会强制要求子类重写log()方法，我怎么觉得强制重写的只有doLog()方法呢？<br>请老师指正","like_count":0},{"had_liked":false,"id":158908,"user_name":"马建华","can_delete":false,"product_type":"c1","uid":1185974,"ip_address":"","ucode":"928189590259AB","user_header":"https://static001.geekbang.org/account/avatar/00/12/18/b6/f3f68a39.jpg","comment_is_top":false,"comment_ctime":1575476521,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1575476521","product_id":100039001,"comment_content":"请教一下老师，为何第一段Logger代码中的34行，不是写为this.fileWriter.write(...)而是fileWriter.write(...)呢？<br><br>this.fileWriter = new FileWriter(filepath); } <br>@Override public void doLog(Level level, String mesage) { <br>&#47;&#47; 格式化level和message,输出到日志文件 <br>fileWriter.write(...); }","like_count":0,"discussions":[{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128257,"discussion_content":"构造参数里面用this，是为了声明是给类中的属性赋值，在老师的构造器代码中，这个this不写也可以。在一个类的方法体中，一般是不会主动声明this的，除非传入参数中存在同样的参数名或者方法体中创建了同名的局部变量，这时候才会特意使用this。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578623793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158410,"user_name":"言","can_delete":false,"product_type":"c1","uid":1714156,"ip_address":"","ucode":"483EE23D2EA2E6","user_header":"https://static001.geekbang.org/account/avatar/00/1a/27/ec/9f6e999d.jpg","comment_is_top":false,"comment_ctime":1575365171,"is_pvip":false,"replies":[{"id":"60691","content":"那个异常可以是自定义的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1575424785,"ip_address":"","comment_id":158410,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1575365171","product_id":100039001,"comment_content":"MethodUnSupportedException  这个异常没有找到，protected MockInteface() {}  这个类为啥不能被实例化","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476711,"discussion_content":"那个异常可以是自定义的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575424785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1714156,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/27/ec/9f6e999d.jpg","nickname":"言","note":"","ucode":"483EE23D2EA2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71493,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575425386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158005,"user_name":"greg","can_delete":false,"product_type":"c1","uid":1189197,"ip_address":"","ucode":"BEE952C7ED2C84","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/0o2FEeJiav8lK9Y49JUOBretDypyHic2FL9dSZYnweBPZ5ibm3vgfm3q7kgXmQEOGOLJFgPEcMweVFj5QTrt4Vb4g/132","comment_is_top":false,"comment_ctime":1575296807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575296807","product_id":100039001,"comment_content":"接口和抽象类的区别，接口是has a的关系，比如，读书时一个接口，可以读书的有男同学和女同学。那么男同学和女同学都可以实现这个接口。抽象类是is a的关系，从下向上设计，相同的特性可以放到抽象类中","like_count":0},{"had_liked":false,"id":157969,"user_name":"程浩","can_delete":false,"product_type":"c1","uid":1660225,"ip_address":"","ucode":"B178C4BF5965D3","user_header":"https://static001.geekbang.org/account/avatar/00/19/55/41/f4c22a44.jpg","comment_is_top":false,"comment_ctime":1575290978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575290978","product_id":100039001,"comment_content":"我觉得抽象类是继承和抽象的合体。为了代码复用，将复用的代码定义在抽象类，子类可以直接使用。为了抽象，在抽象类中定义标准或者说是功能方法，子类中必须实现以达到想要的功能。而接口只有抽象这一功能，单纯的抽象可以代码解耦。而代码复用的功能可以放在Utils类中实现。","like_count":0},{"had_liked":false,"id":157679,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1575246537,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575246537","product_id":100039001,"comment_content":"从抽象类为了复用，接口为了解藕，推论语法特性更加容易记忆与理解","like_count":0},{"had_liked":false,"id":157611,"user_name":"张德","can_delete":false,"product_type":"c1","uid":1101929,"ip_address":"","ucode":"31FE63E8725EFC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","comment_is_top":false,"comment_ctime":1575212499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575212499","product_id":100039001,"comment_content":"老师能不能讲一下用接口到底好在哪？？  感觉一直在用  但是确一直不知道 接口解耦有什么好处  不解耦又会怎么样 感觉一个类中注入另一个类也未尝不可  能不能讲几个用接口非常巧妙的例子 让学生们开开眼界  谢谢老师","like_count":0},{"had_liked":false,"id":157373,"user_name":"禅若静水","can_delete":false,"product_type":"c1","uid":1266038,"ip_address":"","ucode":"5028D28106963C","user_header":"https://static001.geekbang.org/account/avatar/00/13/51/76/ad8115b0.jpg","comment_is_top":false,"comment_ctime":1575124124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575124124","product_id":100039001,"comment_content":"接口和抽象类区别与联系：<br>1、定义：<br>抽象类：不允许实例化，只能被继承；可包含属性和方法，包含抽象方法；子类继承抽象类必须重写抽象方法。<br>接口：不允许实例化，只能被实现；不包含属性和普通方法，包含抽象方法、静态方法、类实现接口时，必须实现抽象方法。<br>2、意义：<br>抽象类：解决复用问题，适用于is-a的关系。<br>接口：解决抽象问题，适用于has-a的关系。<br><br>从定义和意义来说，都是为了合理提高代码质量方法论，具体使用还是以天时（规范开发）地利（团队成员一致认可这些方法论）人和（个人技能素养），来决定的","like_count":0},{"had_liked":false,"id":157256,"user_name":"随风","can_delete":false,"product_type":"c1","uid":1437618,"ip_address":"","ucode":"7D243B6946E08D","user_header":"https://static001.geekbang.org/account/avatar/00/15/ef/b2/5064e98a.jpg","comment_is_top":false,"comment_ctime":1575098895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575098895","product_id":100039001,"comment_content":"还望争哥解惑：<br>这个设计思路虽然达到了代码复用的目的，但是无法使用多态特性了<br>1.这句话中的“多态特性”说的是其父类丧失了多态的特性？<br>2.如果写成以下这样：<br>logger = new FileLogger(&quot;access-log&quot;, true, Level.WARN, &quot;&#47;users&#47;wangzheng&#47;access.log&quot;);<br>logger.log(Level.ERROR, &quot;This is a test log message.&quot;);<br>编译就不会有错误了，您的这个” Logger logger =“代码中书写的Logger，是为了什么？","like_count":0},{"had_liked":false,"id":157242,"user_name":"江中猴姑饼干","can_delete":false,"product_type":"c1","uid":1238992,"ip_address":"","ucode":"4F288845CC70FA","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/d0/d145c11f.jpg","comment_is_top":false,"comment_ctime":1575095611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575095611","product_id":100039001,"comment_content":"使用抽象类3个理由正好证明它的鸡肋😂","like_count":0},{"had_liked":false,"id":156784,"user_name":"零度","can_delete":false,"product_type":"c1","uid":1071119,"ip_address":"","ucode":"C121285CD9D999","user_header":"https://static001.geekbang.org/account/avatar/00/10/58/0f/8ed4be99.jpg","comment_is_top":false,"comment_ctime":1574955652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574955652","product_id":100039001,"comment_content":"都有对实际场景的抽象<br>抽象类自下而上设计，适用于is_a的场景，从各个类中抽象出一部分共性作为这一类的共性，实现代码复用。<br>抽象类作为一个类型所以不能实例只能继承，抽象类可以包含属性和方法，有具体实现的方法是普通方法，没有具体实现的是抽象方法，抽象方法必须要在子类中重写。<br>接口自上而下设计，适用于has_a的场景，内部不能有属性只能包含方法，且方法必须是抽象方法(没有具体实现)，由子类实现。使用于包含某些功能，并强制这些功能(方法)必须由各子类自主实现，完成了代码解藕。<br>比如一个通过继承抽象类继承某些基本特性，然后又调用接口(接口组合)，这样又获取了某些能力","like_count":0},{"had_liked":false,"id":156659,"user_name":"Cest La Vie🤩","can_delete":false,"product_type":"c1","uid":1177849,"ip_address":"","ucode":"EDABE70BB796AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/f9/5d983b88.jpg","comment_is_top":false,"comment_ctime":1574931988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574931988","product_id":100039001,"comment_content":"现在1.8之后，接口不是可以加default了么","like_count":0},{"had_liked":false,"id":156410,"user_name":"我能走多远","can_delete":false,"product_type":"c1","uid":1240465,"ip_address":"","ucode":"07DF5D5DADFA3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/91/1d332031.jpg","comment_is_top":false,"comment_ctime":1574867525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574867525","product_id":100039001,"comment_content":"我是学习C语言的。没有使用过抽象和接口的概念。这个理解起来有点吃力。就是不知道区别和用法","like_count":0},{"had_liked":false,"id":156095,"user_name":"岁月如歌","can_delete":false,"product_type":"c1","uid":1428828,"ip_address":"","ucode":"1AEBD6F79941B7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QFE00aXGzaS6ibbfJSJsDrpIkqs0OrIYjzZv6L9vZmMhOlut2j24iaeZb0MCQazToE6FRXN960nNiaTrsmw09YjGw/132","comment_is_top":false,"comment_ctime":1574819100,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574819100","product_id":100039001,"comment_content":"1、java中利用抽象类实现代码复用很常见。类似哈希表实现中 Map为最顶层规范，而AbstractMap抽象出哈希表公用的代码实现重用，基础的HashMap就是继承AbstractMap实现具体逻辑。同样可以继承AbstractMap定制化哈希表。<br><br>2、抽象类和接口要从多方面比较<br>定义、区别、适用场景 <br>借用 @辣么大 描述： <br>2.1、定义：<br>抽象类：不允许实例化，只能被继承；可包含属性和方法，包含抽象方法；子类继承抽象类必须重写抽象方法。<br>接口：不允许实例化，只能被实现；不包含属性和普通方法，包含抽象方法、静态方法、default 方法；类实现接口时，必须实现抽象方法。<br><br>2.2、意义 和 适用场景：<br>抽象类：解决复用问题，适用于is-a的关系。<br>接口：解决抽象问题，或者描述为一种协议和规范，适用于has-a的关系。<br>","like_count":0},{"had_liked":false,"id":155938,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1574780385,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574780385","product_id":100039001,"comment_content":"接口和抽象类算是两个不同维度的抽象，前者是行为的抽象，非常彻底，即只定义行为，然后交由具体的对象去实现，设计上来看是自上而下的（这里其实有点疑问，实际代码开发中，这个设计和类是一个维度的，也就可以理解为一种先有上层抽象，再有相关实现），后者说到底还是一个类，相比较于传统的父类多了一个安全方便的多态特性","like_count":0},{"had_liked":false,"id":155890,"user_name":"睡不醒","can_delete":false,"product_type":"c1","uid":1718863,"ip_address":"","ucode":"50B60045AA2627","user_header":"https://static001.geekbang.org/account/avatar/00/1a/3a/4f/737fed25.jpg","comment_is_top":false,"comment_ctime":1574774927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574774927","product_id":100039001,"comment_content":"日常用python，学完此课明白了抽象类相比普通父类的优势：可读性好，对开发者有约束。<br><br>但仍有两点不明：<br>1. 还是不太明白接口和抽象类应用场景的区别。为什么Filter是has a不是is a呢？不可以理解为is a Filter，is a XXFilter吗？<br><br>2. 文中提到抽象类是自下而上，先有重复代码再抽象出抽象类，而接口是预先设计的。可是我设计程序时常常会先想好会有哪些父类，开发中慢慢写子类，这种设计思路是不合适的吗？<br><br>","like_count":0},{"had_liked":false,"id":155685,"user_name":"黄振宇","can_delete":false,"product_type":"c1","uid":1686397,"ip_address":"","ucode":"976BC7B46DA419","user_header":"https://static001.geekbang.org/account/avatar/00/19/bb/7d/26340713.jpg","comment_is_top":false,"comment_ctime":1574736210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574736210","product_id":100039001,"comment_content":"老师，有没有情况是两用都用到的。再实现一个类的时候，他同时继承了他的父类，也需要实现一个接口。我现在遇到类似的情况。如果不能同时使用，是不是得舍弃一个，二者不可同时得兼","like_count":0},{"had_liked":false,"id":155656,"user_name":"Morse","can_delete":false,"product_type":"c1","uid":1624157,"ip_address":"","ucode":"B09A716D79AE3B","user_header":"https://static001.geekbang.org/account/avatar/00/18/c8/5d/1e3685e6.jpg","comment_is_top":false,"comment_ctime":1574733341,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574733341","product_id":100039001,"comment_content":"我们知道类中的方法必须包含实现，这个不符合接口的定义。但是，我们可以让类中的方法抛出 MethodUnSupportedException 异常，来模拟不包含实现的接口，并且能强迫子类在继承这个父类的时候，都去主动实现父类的方法，否则就会在运行时抛出异常。<br>这一段这么理解呢？","like_count":0},{"had_liked":false,"id":155532,"user_name":"Juntíng","can_delete":false,"product_type":"c1","uid":1039290,"ip_address":"","ucode":"F6A3B528D6F3FD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/ba/304a9a4a.jpg","comment_is_top":false,"comment_ctime":1574695944,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574695944","product_id":100039001,"comment_content":"我在思考，JavaScript 怎么来实现？😭","like_count":0},{"had_liked":false,"id":155178,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1574657054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574657054","product_id":100039001,"comment_content":"又要达到代码复用，又想使用多态就用抽象类","like_count":0},{"had_liked":false,"id":155148,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1574652081,"is_pvip":false,"replies":[{"id":"60022","content":"可以，但是必须用public final static修饰，或者默认这样<br>这样的属性就是常量了<br>不过正常很少这样做","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574852951,"ip_address":"","comment_id":155148,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574652081","product_id":100039001,"comment_content":"Java中的接口不是可以有属性吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475673,"discussion_content":"可以，但是必须用public final static修饰，或者默认这样\n这样的属性就是常量了\n不过正常很少这样做","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574852951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155129,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1574649632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574649632","product_id":100039001,"comment_content":"public class MockAbstract {<br>    &#47;**<br>     * 抽象类不能被实例化，只能被继承，所以是构造函数<br>     *&#47;<br>    protected MockAbstract() {<br><br>    }<br><br>    public void funcA() {<br>        throw new UnsupportedOperationException();<br>    }<br><br>    public void funcB() {<br>        System.out.println(&quot;funcB operation&quot;);<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":155061,"user_name":"研木","can_delete":false,"product_type":"c1","uid":1063371,"ip_address":"","ucode":"850DEFD2FCB371","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/cb/73628dfd.jpg","comment_is_top":false,"comment_ctime":1574642627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574642627","product_id":100039001,"comment_content":"抽象类是is-a的关系，接口是has-a，抽象类很多时候是在后面实现的时候，慢慢抽象出来的，把一些可复用的实现下沉到抽象类中；接口更关注的是隔离，将定义和实现分开，还有在提供对外的服务时，一般是先定义好接口，约定好对应功能方法，再具体实现功能","like_count":0},{"had_liked":false,"id":154782,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1574563391,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574563391","product_id":100039001,"comment_content":"1.java支持接口和抽象类<br>2.接口:<br>#没有属性<br>#强制子类实现，并且没有实现<br>#has a 的能力<br>#多继承的能力提供<br>#抽象的提取<br>3.抽象类<br>#有属性<br>#可以有方法的实现和抽象方法<br>#is a的描述<br>#是重复功能的提取。<br>","like_count":0},{"had_liked":false,"id":154731,"user_name":"Fun","can_delete":false,"product_type":"c1","uid":1145502,"ip_address":"","ucode":"5D89BA4C678785","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJdUGdEj3R25CrYqibPibYibibRicqUfyL4aTTPbMagyywjKMhXGZE37RTe7lEdvC4DibvtYpzg8zXvt9HQ/132","comment_is_top":false,"comment_ctime":1574524664,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574524664","product_id":100039001,"comment_content":"# day 13<br>今晚重新学习理论五，抽象类和接口。几个点：<br>1，抽象类和接口语法知识，重新了解学习；<br>2，意义，抽象类表示is-a的关系，接口表示has-a的关系。linux设备驱动框架完全适用这一套。同一类设备驱动可以区分到个体差异，这个共性的就是通过抽象出来的，这里可以类比抽象类；所有的设备驱动中都提供I&#47;O接口，这个I&#47;O接口就可以类比接口，实现差异应用层不感知。<br>3，应用场景，个人理解，抽象类是对同类事物的抽象，接口是对同类事物同种能力的抽象。","like_count":0},{"had_liked":false,"id":154663,"user_name":"PENG","can_delete":false,"product_type":"c1","uid":1239106,"ip_address":"","ucode":"28615BA561202D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/42/6061aefa.jpg","comment_is_top":false,"comment_ctime":1574502909,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574502909","product_id":100039001,"comment_content":"日常使用java开发语言。通过abstract和interface关键字实现抽象类和接口的定义。<br>抽象类：解决代码复用问题。<br>接口：解决抽象问题。","like_count":0},{"had_liked":false,"id":154595,"user_name":"zhou","can_delete":false,"product_type":"c1","uid":1087243,"ip_address":"","ucode":"E1CE8575B3F106","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","comment_is_top":false,"comment_ctime":1574488389,"is_pvip":false,"discussion_count":2,"race_medal":3,"score":"1574488389","product_id":100039001,"comment_content":"我还是没明白is a和has a的根本区别","like_count":0,"discussions":[{"author":{"id":1358045,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b8/dd/37726c34.jpg","nickname":"小马哥","note":"","ucode":"B2C0FF38F8C9BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386518,"discussion_content":"is-a是抽取相同的东西到父类, 自下而上;\nhas-a是按照接口定义, 必须在子类或者实现中实现约定的行为, 自上而下;\n前者要求共同点抽取, 后者要求必须满足.仅此而已, 体会一下抽象类和接口的存在意义, 而不用扣字面意思.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627625504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128260,"discussion_content":"我的理解是is a主要针对属性的继承，has a 代表着功能的声明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578624263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154558,"user_name":"条","can_delete":false,"product_type":"c1","uid":1203836,"ip_address":"","ucode":"6F8679175256E3","user_header":"https://static001.geekbang.org/account/avatar/00/12/5e/7c/94af3f5e.jpg","comment_is_top":false,"comment_ctime":1574479831,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574479831","product_id":100039001,"comment_content":"1.熟悉语言：java<br>  接口支持：    interface关键字，不能被实例化，定义了的接口应该被实现，接口中的方法只能声 <br>                       明、不能有实现，不能有属性。<br>  抽象类支持：abstract关键字，不能被实例化，应该被继承，可以有属性，可以包含有实现的方法，需 <br>                      要被重写的方法应该定义成抽象的，需要被实现才能用。<br>2.接口中定义的一些方法(一些行为)，主要是为了解耦，隔离了消费者和生产者，提高了代码的复性。 <br>   抽象类主要是为了解决代码复用的问题，也可以作为一个模板，定义一些必须要有的行为，这些行为 <br>   应该声明成抽象的，需要使用模板的人去实现。","like_count":0},{"had_liked":false,"id":154482,"user_name":"Tom.G","can_delete":false,"product_type":"c1","uid":1206034,"ip_address":"","ucode":"7929B45C1A51F8","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/12/5c6eb568.jpg","comment_is_top":false,"comment_ctime":1574440292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574440292","product_id":100039001,"comment_content":"接口不能定义属性，实现方法，只能定义契约，用于面向接口编程，起解耦作用，has-a关系使用接口，解决抽象而非代码复用问题<br>抽象类可以定义属性方法，不能实例化，继承后必须实现所有抽象方法或者子类也是抽象类，如果对象是is-a关系，使用抽象类，解决代码复用问题","like_count":0},{"had_liked":false,"id":154419,"user_name":"汤小高","can_delete":false,"product_type":"c1","uid":1555565,"ip_address":"","ucode":"D4AB7766273D52","user_header":"https://static001.geekbang.org/account/avatar/00/17/bc/6d/f6f0a442.jpg","comment_is_top":false,"comment_ctime":1574425796,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574425796","product_id":100039001,"comment_content":"抽象类解决代码复用，是is a关系<br>接口解决代码解耦，是 has a 关系， 是定义功能，或者规范（协议） ，而对外隐藏具体实现","like_count":0},{"had_liked":false,"id":154298,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1574405807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574405807","product_id":100039001,"comment_content":"想要表示一种is-a的关系，并且是为了解决代码复用的问题<br>\t自下而上的设计思路<br>想要表示一种has-a的关系，并且是为了解决抽象、解耦的问题<br>\t自上而下的设计思路","like_count":0},{"had_liked":false,"id":154169,"user_name":"teddytyy","can_delete":false,"product_type":"c1","uid":1268738,"ip_address":"","ucode":"E1569D81A4154E","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/02/e7af1750.jpg","comment_is_top":false,"comment_ctime":1574386926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574386926","product_id":100039001,"comment_content":"普通类模拟抽象类：<br>第一，构造函数私有<br>第二，抽象类抽象方法抛出异常","like_count":0},{"had_liked":false,"id":154164,"user_name":"看山","can_delete":false,"product_type":"c1","uid":1014260,"ip_address":"","ucode":"F030DD58D0BDC3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/79/f4/d85e7e58.jpg","comment_is_top":false,"comment_ctime":1574386112,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574386112","product_id":100039001,"comment_content":"重新学习接口和抽象类的定义，感觉醍醐灌顶。<br>1. 想请教一个问题，jdk8之后，接口可以提供default方法实现，是不是接口和抽象类之间的界限模糊了？<br>2. 附上几年前关于接口中定义常量的反模式行为的一篇短文 https:&#47;&#47;www.howardliu.cn&#47;constant-interface-anti-pattern&#47; 请大神斧正","like_count":0},{"had_liked":false,"id":154141,"user_name":"hong","can_delete":false,"product_type":"c1","uid":1110639,"ip_address":"","ucode":"1A826195907C71","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/6f/5680dc30.jpg","comment_is_top":false,"comment_ctime":1574384547,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574384547","product_id":100039001,"comment_content":"实际上从Java8开始，接口已经有了默认方法，那么为什么要这么设计呢","like_count":0,"discussions":[{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128262,"discussion_content":"《Java8 实战》中的观点是为了在我们给接口添加方法时，不会给之前继承的类造成影响（例如你继承了第三方的某个接口，提供第三方接口的人在修改对应的接口时，肯定是希望他修改以后对你没有影响）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578624494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154138,"user_name":"IOT..Yang","can_delete":false,"product_type":"c1","uid":1240343,"ip_address":"","ucode":"11589D83B67FE9","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/17/c3eb014f.jpg","comment_is_top":false,"comment_ctime":1574384233,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574384233","product_id":100039001,"comment_content":"我是一名Android开发者，所以使用比较多的是java，抽象类关键字为abstract，接口的关键字为interface，在平时的开发中一般都会创建一个Base抽象类，然后把一些公共UI，打点等，都写到该类，把需要传入的布局id，需要创建的对象都写成一个抽象方法让子类实现，给我的感觉，主要是为了实现复用，而接口是一种协议，暴露给其他类使用的，可以不用关心接口的实现，反正可以通过这些方法拿到所需要的。","like_count":0},{"had_liked":false,"id":154087,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1574380505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574380505","product_id":100039001,"comment_content":"继承是加法，接口是乘法。加法简单直观，但潜力有限，乘法是正交","like_count":0},{"had_liked":false,"id":154044,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1574353357,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1574353357","product_id":100039001,"comment_content":"我感觉普通类是相对纯粹的 is-a 关系，描述行为过程，解决代码复用。接口是相对纯粹的 has-a 关系，定义规范协议。抽象类是两头都占一点，既有行为过程，又有规范。普通类和抽象类都可以实现接口，“实现&#47;继承”接口的规范协议。<br>PS: 想问下老师 jdk8 接口的 default 方法的意义和场景有哪些呢？","like_count":0,"discussions":[{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128266,"discussion_content":"要给一个旧的接口添加方法是很麻烦的事，因为其他实现该接口必须实现新增的接口。如果是发布给其他人用的接口，那这对有些用户来说就是个灾难。而且接口中只能添加方法签名，不能想抽象类一样提供部分方法的实现，因此引入了默认方法。可以看一下《Java8 实战》中专门将默认方法的那一章。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578624642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1153455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","nickname":"饭粒","note":"","ucode":"4C3220B0D43997","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129341,"discussion_content":"感谢🙏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578674174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":128266,"ip_address":""},"score":129341,"extra":""}]}]},{"had_liked":false,"id":154026,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1574349935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574349935","product_id":100039001,"comment_content":"普通类来模拟抽象类<br>public class Test2 {<br>    protected Test2() {}<br>    &#47;&#47;抽象类具体实现方法<br>    public void fun() {}<br>    &#47;&#47;抽象方法<br>    public void fun2() {throw new MethodUnSupportedException();}<br>}","like_count":0},{"had_liked":false,"id":153988,"user_name":"鱿鱼先森","can_delete":false,"product_type":"c1","uid":1694627,"ip_address":"","ucode":"543FB3F2AA852B","user_header":"https://wx.qlogo.cn/mmopen/vi_32/ox4nIqvFdt77xSW2rm5QJcYPj0r10up6etUXohw47B50Giby7wexBksrpcSu3n9n7iaqGFCGt2STMkJlJgKaTzvg/132","comment_is_top":false,"comment_ctime":1574342991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574342991","product_id":100039001,"comment_content":"普通类模拟抽象类：构造方法设为protect，每一个方法里最后都throw methodunsurpportedexcept即可","like_count":0},{"had_liked":false,"id":153949,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1574335579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574335579","product_id":100039001,"comment_content":"打卡：<br>抽象类是自下而上的设计思路，现有代码复用然后抽象出父类，之后进行代码复用，当然这其中也有抽象的部分或是约定（抽象方法）；而接口是自上而下的设计思路，先是对功能进行抽象和约束，之后再确定具体的实现。","like_count":0},{"had_liked":false,"id":153929,"user_name":"JavaGuide","can_delete":false,"product_type":"c1","uid":1184210,"ip_address":"","ucode":"246D2EAEA0ACEC","user_header":"https://static001.geekbang.org/account/avatar/00/12/11/d2/fb38b86f.jpg","comment_is_top":false,"comment_ctime":1574333480,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574333480","product_id":100039001,"comment_content":"不论是作者精彩的文章，还是文章下面精彩的评论，都很棒！！！赞！","like_count":0,"discussions":[{"author":{"id":1450486,"avatar":"https://static001.geekbang.org/account/avatar/00/16/21/f6/16bc9c24.jpg","nickname":"李达龙","note":"","ucode":"F5702E69D90B7F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270385,"discussion_content":"印象比较深刻的是，抽象类是因为复用抽取子类共性，自下而上产生的。接口强调具有一种能力的契约，自上而下产生。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589990620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153908,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1574328562,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574328562","product_id":100039001,"comment_content":"C++有现成的语法支持抽象类（有成员函数为纯虚函数）， 至于接口，完全可以用没有成员变量，成员函数全部是纯虚函数的抽象类代替<br>实际开发中我们也是这么用的， 抽象出来父类为了解决代码复用， 先定义接口，为了提供功能<br><br>普通类实现接口，可以把构造函数设为protect或private 权限， 接口类的接口实现上抛出异常，强制子类实现相应方法<br>","like_count":0},{"had_liked":false,"id":153903,"user_name":"AllenGFLiu","can_delete":false,"product_type":"c1","uid":1221991,"ip_address":"","ucode":"90FA8A619A2629","user_header":"https://static001.geekbang.org/account/avatar/00/12/a5/67/bf286335.jpg","comment_is_top":false,"comment_ctime":1574328316,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574328316","product_id":100039001,"comment_content":"用普通类实现抽象类的时候，为了防止生成实例，老师说只要把构造函数设置为protected 就可以了，这是为什么？哪位大牛帮忙解释下，我不会Java啊！","like_count":0,"discussions":[{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128268,"discussion_content":"被protected 修饰的构造函数只允许可以被子类，或同package下类使用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578624731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153883,"user_name":"学好习，做好人","can_delete":false,"product_type":"c1","uid":1205294,"ip_address":"","ucode":"C991643DB458E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/2e/e70a317a.jpg","comment_is_top":false,"comment_ctime":1574325061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574325061","product_id":100039001,"comment_content":"接口是对行为的抽象，封装了或者定义，约束了实现类的行为，接口最大的作用就是封装隔离，即解决调用与具体实现的隔离，调用者不需要知道内部具体的实现细节，但是接口的定义也应该遵循一定的规范，那就是定义内部聚合高的行为--单一职责原则，这样的接口才是有意义的  抽象类是对子类公共行为的一种封装，比如某件事情有相同的行为或者相同的作用但是内部实现细节不一样，应该用抽象类，模板模式是对抽象类最好的应用，定义子类的公共行为，将不通的具体实现延迟到子类中进行","like_count":0},{"had_liked":false,"id":153867,"user_name":"🐾","can_delete":false,"product_type":"c1","uid":1087256,"ip_address":"","ucode":"D0AD0260351C31","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/18/a5218104.jpg","comment_is_top":false,"comment_ctime":1574322980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574322980","product_id":100039001,"comment_content":"接口可以包含成员变量吧，不过接口中的成员变量只能是 public static final 类型的。","like_count":0},{"had_liked":false,"id":153831,"user_name":"大胃王","can_delete":false,"product_type":"c1","uid":1120238,"ip_address":"","ucode":"17072DCDB4C7FC","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/ee/b123e7bc.jpg","comment_is_top":false,"comment_ctime":1574314482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574314482","product_id":100039001,"comment_content":"个人理解<br>抽象类：说来说去本质上还是一个类，接口则只是操作规范<br>","like_count":0},{"had_liked":false,"id":153790,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1574307815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574307815","product_id":100039001,"comment_content":"普通父类和抽象类对比的案例，可以在普通父类中实现一个log方法；","like_count":0},{"had_liked":false,"id":153751,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1574302302,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574302302","product_id":100039001,"comment_content":"抽象类案例在开发中会使用贫血模式,然后定义一个借口两个实现类.","like_count":0},{"had_liked":false,"id":153732,"user_name":"lmdcx","can_delete":false,"product_type":"c1","uid":1334409,"ip_address":"","ucode":"F2CDD0091ADFD7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjRETqRjvLESLDZkNTjIiaSibtNYBaS1o8WMUicOFn3ycF3Mgh6LRJibqSBjVBjiaO2ibW0gHkafATb21A/132","comment_is_top":false,"comment_ctime":1574300846,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574300846","product_id":100039001,"comment_content":"个人理解：<br>我喜欢这样描述接口的意义：接口用来描述需求，定义规格（隔壁的许式伟老师总是喜欢用规格这个词），“不关心”多态（即子类具体实现的差异，比如IO接口的抽象不关心是网络IO还是各种本地IO）。  <br>（当然怎么组织语言其实和老师表达的意思都是一致的）<br>我理解的抽象类其实还便于快速构建思路，快速实现简单方法，对于复杂方法可以先定义出接口，从而快速的完成整体逻辑。我见过在很多抽象类都会在本垒实现的方法中调用定义的抽象方法（尽管他们不是出于我说的目的而是为了留给子类实现）。  <br>我理解的里氏替换原则里的父类是指接口类，而不是抽象类，或者实体类。因为抽象类和实体类都会对子类有束缚（不能多重继承），而接口不会有这种副作用。  <br><br>疑问：<br>1. “基于接口而非实现编程” 的程度（或者说边界）怎么把控？  <br>  在贫血模型的MVC（上一章我已经中弹好几次）中，我们一般对于&quot;数据对象&quot;（我自己起的名字）不做接口定义，一般对于&quot;行为对象&quot;（比如 Service Repository&#47;DAO）会做接口定义。<br>  在实际的开源项目中，一般都会建议依赖接口，而我在看 SpringSecurity 的时候，发现他的“数据对象”也会定义为接口，比如 principal 。  <br>2. 那么什么情况下定义接口，什么情况下不用定义接口？  <br>  （我认为应该在模块边缘定义接口，但是如何确定模块边缘？是需要学学隔壁的DDD课程才能解决吗？）  <br>3. 如果“于接口而非实现编程”会不会导致接口数量的爆炸？（我其实也担心学了隔壁DDD，会导致定义类的数量爆炸）如果会造成接口数量膨胀，这是难以避免的繁琐，还是有可权衡的规则？  <br>","like_count":0,"discussions":[{"author":{"id":1334409,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjRETqRjvLESLDZkNTjIiaSibtNYBaS1o8WMUicOFn3ycF3Mgh6LRJibqSBjVBjiaO2ibW0gHkafATb21A/132","nickname":"lmdcx","note":"","ucode":"F2CDD0091ADFD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55465,"discussion_content":"老师的答案在下一篇啊 (＾▽＾) 。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574380943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153682,"user_name":"疯狂的石头","can_delete":false,"product_type":"c1","uid":1179676,"ip_address":"","ucode":"E14331FAA436EE","user_header":"https://static001.geekbang.org/account/avatar/00/12/00/1c/d39cdabd.jpg","comment_is_top":false,"comment_ctime":1574297119,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574297119","product_id":100039001,"comment_content":"在logger定义为抽象类的时候，子类继承它，不会强制重写log方法吧，因为他不是抽象方法。","like_count":0},{"had_liked":false,"id":153680,"user_name":"云","can_delete":false,"product_type":"c1","uid":1066629,"ip_address":"","ucode":"138F855329C281","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/85/6090b202.jpg","comment_is_top":false,"comment_ctime":1574296855,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574296855","product_id":100039001,"comment_content":"老师总结的很好","like_count":0},{"had_liked":false,"id":153673,"user_name":"李皮皮皮皮皮","can_delete":false,"product_type":"c1","uid":1200281,"ip_address":"","ucode":"3BF1DEE4A12359","user_header":"https://static001.geekbang.org/account/avatar/00/12/50/99/44378317.jpg","comment_is_top":false,"comment_ctime":1574296036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574296036","product_id":100039001,"comment_content":"关于c++部分的描述有个小问题，virtual只是为了实现多态和抽象没关系，=0声明纯虚函数才是子类必须实现的风。另外c++中，析构函数加上virtual是最佳实践，为了防止delete父类对象调用不到字累的析构导致子类有内存或资源泄漏","like_count":0},{"had_liked":false,"id":153663,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1574295076,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574295076","product_id":100039001,"comment_content":"java8已经支持default关键对接口方法添加默认实现了","like_count":0},{"had_liked":false,"id":153622,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1574282941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574282941","product_id":100039001,"comment_content":"个人以为动态语言没有必要定义接口和抽象类，只要用duck-typing即可，毕竟这种实现更贴近于动态语言的设计。如果模拟了抽象类和接口，要定义辅助类和继承，但是得不到静态语言编译期检查的好处，投入产出不成比例。","like_count":0},{"had_liked":false,"id":153621,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1574282595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574282595","product_id":100039001,"comment_content":"我一般不用抽象类，所以也就没有选择的烦恼。上面那个用抽象类的例子Logger，我会定义一个类，例如LogConfig来共享代码，另外定义一个接口明确调用的协议和实现多态。我个人以为用到抽象类地方一般都可以用接口拆分，达到协议和实现的分离。请王老师点评一下对这种编程风格（尽量用接口+包含替代抽象类），多谢。","like_count":0},{"had_liked":false,"id":153611,"user_name":"Last丶","can_delete":false,"product_type":"c1","uid":1234142,"ip_address":"","ucode":"43443006ECF176","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/de/086d79e4.jpg","comment_is_top":false,"comment_ctime":1574268852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574268852","product_id":100039001,"comment_content":"接口类子类要实现方法  抽象类子类也可以自己再实现这样用继承的方法来重写父类的方法 不同的场景就可以做不同的事  这个也是多态","like_count":0},{"had_liked":false,"id":153595,"user_name":"啦啦","can_delete":false,"product_type":"c1","uid":1084028,"ip_address":"","ucode":"B9D8DE2A5AB873","user_header":"","comment_is_top":false,"comment_ctime":1574264314,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574264314","product_id":100039001,"comment_content":"Scala支持抽象类，也支持接口Trait，换了名字而已<br>","like_count":0},{"had_liked":false,"id":153579,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1574262254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574262254","product_id":100039001,"comment_content":"1. 不知道文章中关于接口有一个描述：“接口不能包含属性”，是该如何理解？在java中，接口是可以定义public、static、final类型的属性的，属性必须被显示初始化。<br>2. 感觉普通类模拟抽象类，也只能将构造器声明为protected, 将需要子类重写的的方法抛出异常。不知道还有没有其他好的思路。","like_count":0},{"had_liked":false,"id":153575,"user_name":"追风筝的人","can_delete":false,"product_type":"c1","uid":1488020,"ip_address":"","ucode":"2993D60F94C396","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg","comment_is_top":false,"comment_ctime":1574261860,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574261860","product_id":100039001,"comment_content":"抽象类是向上抽象的，接口是自上而下抽象的","like_count":0},{"had_liked":false,"id":153571,"user_name":"Lifelong Learning","can_delete":false,"product_type":"c1","uid":1173517,"ip_address":"","ucode":"3E39BED3E13FB4","user_header":"https://static001.geekbang.org/account/avatar/00/11/e8/0d/fcd95db8.jpg","comment_is_top":false,"comment_ctime":1574260972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574260972","product_id":100039001,"comment_content":"1.抽象类中可以有成员变量和方法,方法也可以有具体的实现,但是抽象类不能被实例化,继承抽象类的子类必须要实现抽象类中所有抽象方法,抽象类主要体现的是“is-a”,主要用于代码复用<br>2.接口其实也是一种类而已,暂且定义为“接口类”,接口中不能有称有变量但是可以有以final static修饰的静态字面量,而方法不能有具体的实现,其他类在实现接口时,实现接口的类必须将接口中所有的方法实现一遍,接口主要体现的是“has-a”,主要用于问题的抽象.","like_count":0},{"had_liked":false,"id":153565,"user_name":"醉比","can_delete":false,"product_type":"c1","uid":1248399,"ip_address":"","ucode":"79E65F62BE7809","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/8f/4ebd303a.jpg","comment_is_top":false,"comment_ctime":1574259376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574259376","product_id":100039001,"comment_content":"如果有面试官再问我这种题的话，我想我会这么回答：抽象类是一种is-a的关系，一般是自下而上进行设计，可以帮我们解决代码复用的问题与增加代码的规范。接口则是一中has-a的关系，是为了解决解耦问题，制定接口是自上而下的。先答这么多，小争哥今天对接口的规范讲的相对少一些，等之后重点讲接口的时候我再重新补充。今天起码对抽象类有了更深的认识了~","like_count":0},{"had_liked":false,"id":153549,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1574257222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574257222","product_id":100039001,"comment_content":"我用的编程语言 java 支持接口和抽象类的语法, 接口重点在实现 解耦 抽象类代码复用, ","like_count":0},{"had_liked":false,"id":153541,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1574256401,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574256401","product_id":100039001,"comment_content":"接口与抽象类有什么不同?<br>先说语法上<br>1.接口不允许有方法体,抽象类可以有方法体;<br>2.接口可以被实现,抽象类可以被继承;<br>3.子类方法必须实现接口的所有方法,抽象类的非抽象方法则不需要实现;<br>再说功能上<br>1.抽象类可以复用代码,提高可读性,同时解决在开发中误用父类实例,忘记重写子类方法的问题;<br>2.面向接口编程则可以使我们关注功能而不需要关注具体实现,同时提高代码可扩展性;<br>举例说明:<br>抽象类:\t在tomcat源码中,server,service,connector,等组件底的父类LifecycleBase实现了init,start,stop等生命周期相关的方法,实现了代码复用,同时体现了设计模式中的模板方法模式<br>在spring源码中,抽象类运用的同样频繁<br>抽象类和接口在源码框架中更多是同时出现,一个类通常会继承一个抽象类,这个抽象类实现一个接口,接口定义动作,抽象类实现具体的行为,子类根据需求来确定是否重写父类方法<br>比如,我们常常以注解配置的方式启动springboot,我们用到的AnnotationConfigApplicationContext的依赖关系中有  <br>ConfigurableApplicationContext(接口)<br>↑实现<br>AbstractApplicationContext (抽象类)<br>↑继承<br>GenericApplicationContext (普通类)<br>↑继承<br>AnnotationConfigApplicationContext(普通类)<br>接口:不论我们使用什么数据库,mySQL,orcale,postgreSQL还是SQLServer,都可以用一套JDBC搞定,这就是面向接口编程的好处","like_count":0},{"had_liked":false,"id":153508,"user_name":"moqifei","can_delete":false,"product_type":"c1","uid":1358410,"ip_address":"","ucode":"E0A6C858B78A3A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLGovXf8jNP5ZqHsDKLwajjicbFwpX9on1xiaJDR4CgWaWP2KcfOdneasBfKFo3dO3dwQyGG6WjK40w/132","comment_is_top":false,"comment_ctime":1574249393,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574249393","product_id":100039001,"comment_content":"java 8 接口支持defualt method；java 9 接口支持private method","like_count":0},{"had_liked":false,"id":153479,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1574242914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574242914","product_id":100039001,"comment_content":"question1: 你熟悉的编程语言，是否有现成的语法支持接口和抽象类呢？具体是如何定义的呢？<br><br>answer1: Java中<br>&#47;&#47;抽象类的定义方式<br>public abstract class AbsObj{<br>protected abstract void onHandle();<br>}<br><br>&#47;&#47;接口的定义方式<br>public interface Listener{<br>    void onHandle();<br>}<br><br><br>question2: 前面我们提到，接口和抽象类是两个经常在面试中被问到的概念。学习完今天的内容之后，你是否对抽象类和接口有一个新的认识呢？如果面试官再让你聊聊接口和抽象类，你会如何回答呢？<br><br>抽象类与衍生类是is-a关系,抽象类解决代码复用问题,在程序设计中通常是多个子类中有代码重复,提取到抽象类,抽象类的产生是一个自下而上的过程;<br>接口与实现类是has-a的关系,接口解决解耦问题,在程序设计中通常是首先抽象业务,定义接口,再编写实现类.接口的产生是一个自上而下的过程.<br><br>抽象类与接口都是为了赋予实现类的功能而存在,这是抽象类与接口的同一性.<br>在程序设计中,要尽可能使用接口,少使用抽象类.<br><br>question3:如何用普通类模拟抽象类?<br><br>answer3:  普通类的所有方法均采用空实现,并抛出MethodUnsupportedException.","like_count":0},{"had_liked":false,"id":153458,"user_name":"大悲","can_delete":false,"product_type":"c1","uid":1341085,"ip_address":"","ucode":"3A7865964B0159","user_header":"https://static001.geekbang.org/account/avatar/00/14/76/9d/bfcdbdda.jpg","comment_is_top":false,"comment_ctime":1574238656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574238656","product_id":100039001,"comment_content":"我个人觉得类是is a的表示， 类中的属性是has a的表示， 接口理解为can do的表示更贴切。简单的说，类是现实生活中的名词，接口是一个动词或者形容词。请老师指正。","like_count":0},{"had_liked":false,"id":153449,"user_name":"gogo","can_delete":false,"product_type":"c1","uid":1003104,"ip_address":"","ucode":"E8F0F3B000020A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/60/0d5aa340.jpg","comment_is_top":false,"comment_ctime":1574237400,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574237400","product_id":100039001,"comment_content":"java接口是可以定义属性的，只不过默认是常量","like_count":0},{"had_liked":false,"id":153435,"user_name":"Zzz","can_delete":false,"product_type":"c1","uid":1536612,"ip_address":"","ucode":"5BDFF04D19442F","user_header":"https://static001.geekbang.org/account/avatar/00/17/72/64/a4890092.jpg","comment_is_top":false,"comment_ctime":1574235670,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574235670","product_id":100039001,"comment_content":"有一个疑问：java8后接口支持default方法，作用就更抽象类的代码复用差不多，但是接口是可以多实现的，同一个类实现多个接口，且接口中有default方法冲突的时候，会编译报错。java为了避免这种情况，类不能多继承，然后使用接口，现在接口出现了default方法，是不是设计的也不太合理","like_count":0},{"had_liked":false,"id":153417,"user_name":"曾经瘦过","can_delete":false,"product_type":"c1","uid":1240106,"ip_address":"","ucode":"57C32575A1C1FD","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/2a/b11d5ad8.jpg","comment_is_top":false,"comment_ctime":1574232802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574232802","product_id":100039001,"comment_content":"主要使用的是java 语言  <br>对于抽象类和接口主要牢记住两者的侧重点就可以了     抽象类侧重于方法复用   接口侧重于解耦   ","like_count":0},{"had_liked":false,"id":153413,"user_name":"流鶴粱","can_delete":false,"product_type":"c1","uid":1007252,"ip_address":"","ucode":"534EE37E96378C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/94/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1574232240,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574232240","product_id":100039001,"comment_content":"Swift中的协议，除了有接口的特性以外，还能定义属性，实现方法，所以Swift中的协议也是抽象类吗？","like_count":0},{"had_liked":false,"id":153410,"user_name":"流鶴粱","can_delete":false,"product_type":"c1","uid":1007252,"ip_address":"","ucode":"534EE37E96378C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/94/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1574231948,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574231948","product_id":100039001,"comment_content":"抽象类 vs swift中的接口<br><br>实例化\t否\t否<br>属性\t        是     是<br>方法          是     是<br>实现          是      是<br>目的         复用  扩展和复用?<br>意义          is-a   has-a?<br>抽象类能做的  swift中的接口也都能做,  所以swift中的接口也可以说是抽象类?","like_count":0},{"had_liked":false,"id":153404,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1257099,"ip_address":"","ucode":"9662D56F5EA546","user_header":"https://static001.geekbang.org/account/avatar/00/13/2e/8b/ea0a1585.jpg","comment_is_top":false,"comment_ctime":1574230804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574230804","product_id":100039001,"comment_content":"对为什么要有抽象类，理解的更深了","like_count":0},{"had_liked":false,"id":153402,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1574230734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574230734","product_id":100039001,"comment_content":"抽象类是为了解决代码复用的问题，是 is-a的关系。<br><br>接口是为了解耦，将定义和具体实现分开，提高代码的扩展性，是 has-a的关系。<br><br>接口是比抽象类更加抽象的一种设计方法。在实际中，我们设计具体的业务问题时，先考虑更加上层的（也就是更加抽象的），来定义一些规范或协议（其实就是我们的接口），然后再去考虑具体的各种实现。<br><br>比如，在Java中的List接口就会先定义一些方法size()、isEmpty()、add()、remove()等等。然后在AbstractList抽象类中对这些公有方法进行实现。最后在ArrayList、LinkedList等实际应用的类中添加自己的一些方法。","like_count":0},{"had_liked":false,"id":153370,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1574225375,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574225375","product_id":100039001,"comment_content":"看到都知道，自己说可能就没有组织的这么好，梳理成体系的感觉很赞","like_count":0},{"had_liked":false,"id":153369,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1574225046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574225046","product_id":100039001,"comment_content":"1.抽象类是某一类东西的公共模板。接口是某一类东西的行为抽象。<br>2.用组合加接口的方式也能很好的实现抽象类。但显然没有直接继承抽象类优雅。不过java只能单继承，所以抽象类相对于组合加接口的模式显得不够灵活（毕竟接口可以多实现，组合可以多组合）。","like_count":0},{"had_liked":false,"id":153349,"user_name":"pines","can_delete":false,"product_type":"c1","uid":1200708,"ip_address":"","ucode":"7B925605B36B4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/44/de7f2b98.jpg","comment_is_top":false,"comment_ctime":1574220804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574220804","product_id":100039001,"comment_content":"1.Go只有接口方式，type Reader interface{<br>        func read()([]byte,error)<br>}<br><br>2.从语法上抽象类必须由子类继承并实现方法，所有从语义上最好也是从属的关系（比如抽象类动物，子类鸭子，就是老师说的isa的问题）。接口的实现有的语言要求实例类中需要加implement，有的不需要。并且不需要有此类从属关系（例如有一个接口方法只有一个work(),那么实例类只要实现work方法，就实现了接口。就是老师说的hasa的问题）","like_count":0},{"had_liked":false,"id":153343,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1574220327,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574220327","product_id":100039001,"comment_content":"打卡，个人主要编程语言是PHP，有些地方很相近，有些地方又不甚清楚，总体上读两遍有收获 \\smile","like_count":0},{"had_liked":false,"id":153337,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1574219886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574219886","product_id":100039001,"comment_content":"最近也在学习go语言 恰好有一个就是接口的概念  通过今天的学习 对接口的理解更深刻了","like_count":0},{"had_liked":false,"id":153336,"user_name":"努力努力再努力m","can_delete":false,"product_type":"c1","uid":1644369,"ip_address":"","ucode":"9DD9E9C2988FFC","user_header":"https://static001.geekbang.org/account/avatar/00/19/17/51/3e13dc0c.jpg","comment_is_top":false,"comment_ctime":1574219842,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574219842","product_id":100039001,"comment_content":"在平常的mvc web项目开发中，更多的是使用接口，抽象类反而用的很少。看了这篇文章后，对抽象类和接口的适用场景和特性更加了解了。","like_count":0},{"had_liked":false,"id":153335,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1574219811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574219811","product_id":100039001,"comment_content":"通过今天的学习我才了解到抽象类和接口的真正含义 以前连函数和接口都是模糊的。。。。","like_count":0},{"had_liked":false,"id":153324,"user_name":"塔兹米","can_delete":false,"product_type":"c1","uid":1425252,"ip_address":"","ucode":"1A58C81EF9B0A4","user_header":"https://static001.geekbang.org/account/avatar/00/15/bf/64/c9a0e913.jpg","comment_is_top":false,"comment_ctime":1574217394,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574217394","product_id":100039001,"comment_content":"打卡，<br>Java 是单继承，通过接口可以实现 单继承多实现。如 ：Runnable 接口","like_count":0},{"had_liked":false,"id":153315,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1574214314,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574214314","product_id":100039001,"comment_content":"我感觉，<br>1. 在抽象类的目的，更多的是将子类的公共代码给抽象出来，然后在抽象类中执行。不同的逻辑在子类中执行。<br>2. 接口是先定义我们需要的接口，在不同子类中进行对应的功能实现。<br>总结：所以在抽象类和接口中，抽象是将公共部分抽象到父类，这样就有了抽象的概念。抽象类注重抽象的过程，接口类注重接口。所以在不同语言实现的时候，把握住不同的侧重点，就可以模拟出对应的抽象类和接口的样子。细想起来 其实接口和抽象类没有很明显的区别。","like_count":0},{"had_liked":false,"id":153307,"user_name":"Kang","can_delete":false,"product_type":"c1","uid":1237655,"ip_address":"","ucode":"088A8DA0A16BDE","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/97/dfadcc92.jpg","comment_is_top":false,"comment_ctime":1574213559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574213559","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":153306,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1574213459,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574213459","product_id":100039001,"comment_content":"抽象类为了代码复用，像文章中提到的模板模式就是非常典型的例子，接口类是为了抽象，同时屏蔽具体实现，达到封装的效果。","like_count":0},{"had_liked":false,"id":153303,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1574213090,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574213090","product_id":100039001,"comment_content":"接口中可以定义static final","like_count":0},{"had_liked":false,"id":153302,"user_name":"不与三季人说","can_delete":false,"product_type":"c1","uid":1693164,"ip_address":"","ucode":"A3F03832309FDD","user_header":"https://static001.geekbang.org/account/avatar/00/19/d5/ec/3d6e7ea7.jpg","comment_is_top":false,"comment_ctime":1574213088,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574213088","product_id":100039001,"comment_content":"终于出了抽象类的接口的文章，看到题目很兴奋。因为我面试曾被问过，但是我知道特性却不知道什么时候用抽象类，我的印象中好像很少用到抽象类，接口用的比较多，看了文章后发现也还是没有搞清楚什么时候要用抽象类，可能在高标准的开发环境下 ，会强制把一些类用成抽象类，然后通过继承，但我们平时开发不注意那么多 ，几乎直接用继承的比较多，不会考虑用抽象类的情况。","like_count":0},{"had_liked":false,"id":153288,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1574211169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574211169","product_id":100039001,"comment_content":"重新温习，并更加深入理解了抽象与接口的含义，讲的不错，分析透彻。","like_count":0},{"had_liked":false,"id":153239,"user_name":"grey927","can_delete":false,"product_type":"c1","uid":1202782,"ip_address":"","ucode":"833E02ED835B4A","user_header":"https://static001.geekbang.org/account/avatar/00/12/5a/5e/a897cb0d.jpg","comment_is_top":false,"comment_ctime":1574207267,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"1574207267","product_id":100039001,"comment_content":"jdk8中接口方法已经支持存在默认实现了，是不是意味着可以完全替代抽象类","like_count":0,"discussions":[{"author":{"id":1181647,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/cf/b0d6fe74.jpg","nickname":"L.","note":"","ucode":"46A2F679C094E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53953,"discussion_content":"只能说可以替代Adapter适配器模式~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574240876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1027798,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ae/d6/fbb8236d.jpg","nickname":"DebugDog","note":"","ucode":"1664D37CE03B9D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53779,"discussion_content":"完全替代不会吧，接口中还是没有成员变量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574215667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1100703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","nickname":"阿玛铭","note":"","ucode":"DBF948D82ACBE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1027798,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ae/d6/fbb8236d.jpg","nickname":"DebugDog","note":"","ucode":"1664D37CE03B9D","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":53859,"discussion_content":"java8中的接口可以定义常量","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574225634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53779,"ip_address":""},"score":53859,"extra":""},{"author":{"id":1202782,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5a/5e/a897cb0d.jpg","nickname":"grey927","note":"","ucode":"833E02ED835B4A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1027798,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ae/d6/fbb8236d.jpg","nickname":"DebugDog","note":"","ucode":"1664D37CE03B9D","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":53919,"discussion_content":"java接口中一直都可以定义常量呀","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574234912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53779,"ip_address":""},"score":53919,"extra":""},{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1100703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","nickname":"阿玛铭","note":"","ucode":"DBF948D82ACBE3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128282,"discussion_content":"常量跟变量不一样啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578625969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53859,"ip_address":""},"score":128282,"extra":""}]}]},{"had_liked":false,"id":153233,"user_name":"ismind","can_delete":false,"product_type":"c1","uid":1138710,"ip_address":"","ucode":"7AADD673ED3BC4","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/16/d1dd4972.jpg","comment_is_top":false,"comment_ctime":1574206410,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"1574206410","product_id":100039001,"comment_content":"为什么自己测试，将这个类的构造函数声明为 protected，然后再另一个类中new这个类，依然可以呢？","like_count":0,"discussions":[{"author":{"id":1435246,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e6/6e/062da5e4.jpg","nickname":"肥而不腻","note":"","ucode":"3E6786A82A6DD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53714,"discussion_content":"Protected范围是同一个package","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574211328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258209,"avatar":"https://static001.geekbang.org/account/avatar/00/13/32/e1/c9aacb37.jpg","nickname":"段启超","note":"","ucode":"164CF3018071B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54114,"discussion_content":"我觉得如果要在其他的任何一个类中都不能new这个类，这个类的构造方法应该写成private 的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574260334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1587803,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3a/5b/ce1724ca.jpg","nickname":"undefined","note":"","ucode":"867405CA5A9FB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1258209,"avatar":"https://static001.geekbang.org/account/avatar/00/13/32/e1/c9aacb37.jpg","nickname":"段启超","note":"","ucode":"164CF3018071B2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55734,"discussion_content":"emm，private 也能运行额。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574392908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54114,"ip_address":""},"score":55734,"extra":""}]},{"author":{"id":1237399,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/97/fec494f2.jpg","nickname":"大大。","note":"","ucode":"A6716E46264AC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53738,"discussion_content":"楼上说的对\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574212316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153223,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1574203100,"is_pvip":true,"discussion_count":30,"race_medal":0,"score":"1393143607004","product_id":100039001,"comment_content":"如果让我聊聊接口和抽象类，我会这么聊：定义、区别（是什么），存在意义（从哪来），应用（到哪去）。<br>1、定义：<br>抽象类：不允许实例化，只能被继承；可包含属性和方法，包含抽象方法；子类继承抽象类必须重写抽象方法。<br>接口：不允许实例化，只能被实现；不包含属性和普通方法，包含抽象方法、静态方法、default 方法；类实现接口时，必须实现抽象方法。<br>2、意义：<br>抽象类：解决复用问题，适用于is-a的关系。<br>接口：解决抽象问题，适用于has-a的关系。<br>3、应用：<br>例如：<br>解决复用问题：java中的子类FileInputStream和PipeInputStream等继承抽象类InputStream。重写了read(source)方法，InputStream 中还包含其他方法，FileInputStream继承抽象类复用了父类的其他方法。<br>解决抽象问题：抽象类InputStream实现了Closeable接口，该接口中包含close()抽象方法。Closeable这个接口还在很多其他类中实现了，例如Channel，Socket中都有close() 关闭这个功能，但具体实现每个类又各有不同的实现，这个就是抽象。<br><br>4、补充知识点（语法）：<br>Java接口中可以定义静态方法、default方法，枚举类型，接口中还可以定义接口（嵌套）。<br>public interface ILog {<br>  enum Type {<br>    LOW,<br>    MEDIUM,<br>    HIGH<br>  }<br>  interface InILog{<br>    void initInLog();<br>  }<br>  default void init() {<br>    Type t = Type.LOW;<br>    System.out.println(t.ordinal());<br>  }<br>  static void OS() {<br>System.out.println(System.getProperty(&quot;os.name&quot;, &quot;linux&quot;));<br>  }<br>  void log(OutputStream out);<br>}<br>class ConsoleLog implements ILog {<br>  @Override<br>  public void log(OutputStream out) {<br>    System.out.println(&quot;ConsoleLog...&quot;);<br>  }<br>}<br>","like_count":325,"discussions":[{"author":{"id":1718863,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/3a/4f/737fed25.jpg","nickname":"睡不醒","note":"","ucode":"50B60045AA2627","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530964,"discussion_content":"我也想问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637197271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1252813,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1d/cd/3819726f.jpg","nickname":"徐同学呀","note":"","ucode":"03383EE820514D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383538,"discussion_content":"参数搞成一个类，这个参数类的构建不适用builder的话同样面临问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626152027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153863,"user_name":"Maurice","can_delete":false,"product_type":"c1","uid":1729796,"ip_address":"","ucode":"A35112AA415C67","user_header":"","comment_is_top":false,"comment_ctime":1574321574,"is_pvip":false,"discussion_count":16,"race_medal":0,"score":"697359023526","product_id":100039001,"comment_content":"嗯，刚刚看了一下评论区，小弟给大家初学设计模式以及刚刚接触项目的同学一些建议，其实在学这一章更以及往后正式的20多种设计模式时候更加锻炼的是一种抽象思维，以我个人的一点经验，就像老师一开始说的，在学习的时候，不要总是类比生活中的一些阿猫啊狗的例子，没错初次是很好理解，而且你会感觉好像懂了，但是实际上你还是不懂（可能是以为我笨），建议大家没学习一种模式的时候，思考一下现在在做的项目中那些业务可以进行优化，如果可以的话，可以进行重构，这样对你的学习才有很大的帮助；举个栗子，例如策略模式，我们在代码是不是经常调用第三方接口，每个接口都有它的规范之类的，如果你按照low 的方式就是按照规范组织一些报文请求，但是这个时候，你可以用的你的抽象思维，比如,在这类业务中，无外乎就是，1、构建报文，2、请求结构，3、解析返回，那么我就可以这样设计：<br>    &#47;**<br>     * 请求统一接口<br>     *&#47;<br>    public interface Fun&lt;T&gt; {<br>        &#47;**<br>         * 发送请求报文<br>         *&#47;<br>        String constructionRequest();<br>        &#47;**<br>         * 请求报文<br>         *&#47;<br>        String doPost(String request);<br>        &#47;**<br>         * 解析回执报文<br>         *&#47;<br>        T resolveResponse(String responseText);<br>    }<br>然后再写一个策略的算法簇（应该是这么叫）<br>&#47;**<br> * 统一实现接口<br> *&#47;<br>public class DealWithHandle {<br>    <br>    &#47;**<br>     * 描述 create.<br>     *<br>     * @param &lt;T&gt; the type parameter<br>     * @param fun the fun<br>     * @return the t<br>     * @author Maurice Mao<br>     * @created 2018 -07-13 10:58:32 Handle t.<br>     *&#47;<br>    public static &lt;T&gt; T handle(Fun&lt;T&gt; fun) {<br>        <br>        String request = fun.constructionRequest();<br>        <br>        String response = fun.doPost(request);<br>        <br>        T t = fun.resolveResponse(response);<br>        <br>        return t;<br><br>    }<br>}<br>这个时候，假设你做支付宝扫码支付的时候（或者微信以及第三方支付），是不是可以这么调用：<br>public class OfficialAliScan {<br><br>    private static Logger logger = LoggerFactory.getLogger(OfficialAliScan.class);<br><br>    public static ApiTradeResultDto operate(final TradeOrderDO orderDO, final SubMerchatAuthDO subMerchatAuthDO, final String authCode) {<br>        return DealwithHandle.handle(new DealwithHandle.Fun&lt;ApiTradeResultDto&gt;() {<br>            @Override<br>            public String constructionRequest() {<br>                  &#47;&#47;&#47;todo<br>            }<br><br>            @Override<br>            public String doPost(String bizContent) {<br>                &#47;&#47;&#47;todo<br>            }<br><br>            @Override<br>            public ApiTradeResultDto resolveResponse(String responseTxt) {<br>                &#47;&#47;&#47;todo<br>            }<br>        });<br>    }<br>这样的话，你的业务代码组织的就很清晰，也便于调试维护<br>","like_count":163},{"had_liked":false,"id":153228,"user_name":"NoAsk","can_delete":false,"product_type":"c1","uid":1122412,"ip_address":"","ucode":"71CA29776B4F68","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/6c/e4966364.jpg","comment_is_top":false,"comment_ctime":1574205289,"is_pvip":false,"discussion_count":10,"race_medal":0,"score":"620049495913","product_id":100039001,"comment_content":"Java使用abstract表示抽象类，interface表示接口。<br>老师讲的很好，我补充一下使用；<br>1.java中抽象类是类，而java不支持多继承，当想要实现多继承的时候只能使用表示has-a的接口来实现。<br>2.在java8之前，定义的接口不能有具体实现，这会导致在后续维护的时候如果想要在接口中新增一个方法，必须在所有实现类中都实现一遍，并且只有几个新的实现类可能要去具体实现，其他的都只是加上默认实现，这样比较麻烦。在java8中接口可以用使用关键字default，来实现一个默认方法，这样就解决了上述的麻烦。","like_count":144,"discussions":[{"author":{"id":1330147,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/e3/77410a44.jpg","nickname":"清风明月","note":"","ucode":"45E8660C58A393","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84707,"discussion_content":"接口可以多继承","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576504926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2791265,"avatar":"","nickname":"Geek2694","note":"","ucode":"4355B60D1F58C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1330147,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/e3/77410a44.jpg","nickname":"清风明月","note":"","ucode":"45E8660C58A393","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530369,"discussion_content":"接口叫做实现 不叫继承\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637061699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":84707,"ip_address":""},"score":530369,"extra":"{\"user_type\":1}"}]},{"author":{"id":1676932,"avatar":"https://static001.geekbang.org/account/avatar/00/19/96/84/b07940bc.jpg","nickname":"Android开发","note":"","ucode":"BBED8220445D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412054,"discussion_content":"新的Java语言才支持","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636072451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1743060,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8xHGabhfnPnK7gN3hVJ0n3wia5qIaay7IOQaGJ4ia0kB1CKywjbJNeGjM7DKexk6TZl88f6um4pqw/132","nickname":"早早凡","note":"","ucode":"E70B0306637482","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305869,"discussion_content":"两个接口有同名默认方法，实现类会调用哪个？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600097745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":2109939,"avatar":"https://static001.geekbang.org/account/avatar/00/20/31/f3/22d6ed22.jpg","nickname":"杰西","note":"","ucode":"542B3A9716AA71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1743060,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8xHGabhfnPnK7gN3hVJ0n3wia5qIaay7IOQaGJ4ia0kB1CKywjbJNeGjM7DKexk6TZl88f6um4pqw/132","nickname":"早早凡","note":"","ucode":"E70B0306637482","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306613,"discussion_content":"实现的多个接口不能包含同名的默认方法","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1600330561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305869,"ip_address":""},"score":306613,"extra":""},{"author":{"id":1003487,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4f/df/f24f5dbc.jpg","nickname":"Geek_21ade8","note":"","ucode":"9FCC988B256181","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1743060,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8xHGabhfnPnK7gN3hVJ0n3wia5qIaay7IOQaGJ4ia0kB1CKywjbJNeGjM7DKexk6TZl88f6um4pqw/132","nickname":"早早凡","note":"","ucode":"E70B0306637482","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308675,"discussion_content":"编译会报错","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601026543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305869,"ip_address":""},"score":308675,"extra":""},{"author":{"id":1220273,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9e/b1/758f2fe7.jpg","nickname":"香","note":"","ucode":"121D6CECECEEC3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1743060,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8xHGabhfnPnK7gN3hVJ0n3wia5qIaay7IOQaGJ4ia0kB1CKywjbJNeGjM7DKexk6TZl88f6um4pqw/132","nickname":"早早凡","note":"","ucode":"E70B0306637482","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336336,"discussion_content":"这种情况下，实现类必须要实现该方法，否则编译会报错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608552772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305869,"ip_address":""},"score":336336,"extra":""}]},{"author":{"id":1323102,"avatar":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","nickname":"Younger Ku","note":"","ucode":"D157DC38BDB515","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304014,"discussion_content":"nice","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599449276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153245,"user_name":"Jimbol","can_delete":false,"product_type":"c1","uid":1178008,"ip_address":"","ucode":"8D9190B3B3E08B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/98/95b13446.jpg","comment_is_top":false,"comment_ctime":1574207889,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"212027605393","product_id":100039001,"comment_content":"接口强调具有什么能力(has-a)，<br>抽象类强调是什么(is-a)。","like_count":50},{"had_liked":false,"id":153877,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1574324132,"is_pvip":false,"replies":[{"id":"59157","content":"好像我写的是有点问题，稍后更正下，多谢指出","user_name":"作者回复","comment_id":153877,"uid":"1190123","ip_address":"","utype":1,"ctime":1574377806,"user_name_real":"王争"}],"discussion_count":17,"race_medal":0,"score":"151898179492","product_id":100039001,"comment_content":"『那又如何避免这个类被实例化呢？实际上很简单，我们只需要将这个类的构造函数声明为 protected 访问权限就可以了。』当把一个类的构造方法声明为protected后，在同一个包的其他类中还是可以new这个类的对象的。老师，是我想错了吗？请老师指正","like_count":35},{"had_liked":false,"id":153211,"user_name":"Daiver","can_delete":false,"product_type":"c1","uid":1466447,"ip_address":"","ucode":"9B1A03AFBC79BC","user_header":"https://static001.geekbang.org/account/avatar/00/16/60/4f/db0e62b3.jpg","comment_is_top":false,"comment_ctime":1574182314,"is_pvip":false,"discussion_count":11,"race_medal":0,"score":"104653397418","product_id":100039001,"comment_content":"go和java 都有接口设计，但go的设计是飞入侵入性（duck type），而java必须显式实现该借口，这一点go做的真的好了。","like_count":24},{"had_liked":false,"id":153971,"user_name":"五岳寻仙","can_delete":false,"product_type":"c1","uid":1247467,"ip_address":"","ucode":"88A46A4E1832CE","user_header":"https://static001.geekbang.org/account/avatar/00/13/08/eb/594e9e6c.jpg","comment_is_top":false,"comment_ctime":1574339250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"96063619762","product_id":100039001,"comment_content":"<br>Python中抽象类是通过 abc 模块中的 abstractmethod 和 ABCMeta<br><br>from abc import abstractmethod, ABCMeta<br><br>class BaseClass(metaclass=ABCMeta):<br>    @abstractmethod<br>    def fun(self, x): pass<br><br>因为 Python 需要天然支持多继承，所以可以直接用上述的抽象类实现接口","like_count":22},{"had_liked":false,"id":153599,"user_name":"张飞online","can_delete":false,"product_type":"c1","uid":1249136,"ip_address":"","ucode":"C9787E4B35888C","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","comment_is_top":false,"comment_ctime":1574264816,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"87473610736","product_id":100039001,"comment_content":"谈谈c吧，linux内核的设备驱动总线模型，就但说设备吧，<br><br>抽象类:<br>首先来个通用设备结构体，到了具体设备把通用设备结构体包含了，这是典型的抽象类思想，提炼公共部分做基类，提高复用度。<br>接口，接口实现就是函数指针，不管你的驱动如何实现，接口不变，你就按照函数指针的定义实现函数，任何人都要受控这个函数定义协议。<br>","like_count":21,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509599,"discussion_content":"不错！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606701259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153226,"user_name":"熊斌","can_delete":false,"product_type":"c1","uid":1026280,"ip_address":"","ucode":"24D0C32F397113","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/e8/bc84c47d.jpg","comment_is_top":false,"comment_ctime":1574205223,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"74588649255","product_id":100039001,"comment_content":"举个例子吧，附件上传服务端实现<br><br>需求：支持上传、下载、删除以及文件的存储，存储的话需要支持存本地和云端，涉及附件上传的业务点有十几个。<br><br>设计思路：<br>1、接口设计：上传、下载、删除是公共行为，抽象到接口中<br><br>2、存储方法是一大块公共代码，写到抽象类里面<br><br>3、每个业务的附件上传子类实现接口、继承抽象类","like_count":17,"discussions":[{"author":{"id":1252813,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1d/cd/3819726f.jpg","nickname":"徐同学呀","note":"","ucode":"03383EE820514D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383539,"discussion_content":"参数校验放在set的会有一个问题，就是无法强制调用者调用set","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626152135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215289,"user_name":"InfoQ_6fbe5db36682","can_delete":false,"product_type":"c1","uid":1903946,"ip_address":"","ucode":"FE315CB67AF508","user_header":"","comment_is_top":false,"comment_ctime":1588948764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53128556316","product_id":100039001,"comment_content":"本文讲述用抽象类模拟接口举的C++例子有个小问题，Strategy接口的析构函数忘记了virtual关键字，没有这个关键字delete一个基类指针将导致部分析构。下面的代码可以用来验证这个问题：<br><br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>class Strategy {<br>public:<br>    ~Strategy() = default;<br>    virtual void algorithm() = 0;<br><br>protected:<br>    Strategy() = default;<br>};<br><br>class DestructIndicator {<br>public:<br>    ~DestructIndicator() {<br>        std::cout &lt;&lt; &quot;DestructIndicator destructed.\\n&quot;;<br>    }<br>};<br><br>class Abc : public Strategy {<br>private:<br>    DestructIndicator indicator;<br><br>public:<br>    void algorithm() override {}<br>};<br><br>int main() {<br>    Strategy *instance = new Abc;<br>    delete instance;<br>    return 0;<br>}<br><br>在~Strategy前面加上virtual关键字就可以看到DestructIndicator destructed输出了。<br><br>唉，C++这个玩意坑多的很。。。<br>","like_count":12},{"had_liked":false,"id":155269,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1574672738,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"48819312994","product_id":100039001,"comment_content":"个人认为，jdk8中，接口的默认实现之后。接口和抽象的区别渐渐模糊了。接口，从一定程度上也可以当抽象类使用。而且最主要的是，支持多实现，但不支持多继承。<br>并且，我认为，多实现也是接口和抽象类最主要的区别，没有之一！<br><br>我的理解：<br>抽象类：描述整个类的一个概况。（举例来说，抽象类，爬行动物）<br>接口： 描述的是需要具备的能力。（举例来说，飞行，游泳）<br><br>乌龟，在类上，应该继承爬行动物。因为属于爬行动物（说实话不确定是不是爬行动物），但是乌龟同时也会游泳。会游泳，就只能是乌龟实现的接口。如果，有一天，乌龟长翅膀会飞了（致敬超级马里奥），那这时候，实现会飞行接口就可以了。<br><br>在使用到这个接口的角度，某个游戏，需要十个飞行的小怪。以前是十个各种鸟类。但是现在需要十一个了，于是乎给乌龟安上了翅膀（实现飞行接口），拿来充当飞行小怪使用。<br>","like_count":12,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502980,"discussion_content":"那就要用builder模式了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597454216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306679,"discussion_content":"提示：两个set之间的时间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600346776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2152325,"avatar":"","nickname":"Geek_0a07ba","note":"","ucode":"3513FE1600CC6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305804,"discussion_content":"争哥这个有点答非所问啊。题主问的是为啥对象处于无效状态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600089174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153225,"user_name":"Uncle.席","can_delete":false,"product_type":"c1","uid":1635218,"ip_address":"","ucode":"2A23428FBBAFF0","user_header":"https://static001.geekbang.org/account/avatar/00/18/f3/92/96fe653f.jpg","comment_is_top":false,"comment_ctime":1574204749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48818845005","product_id":100039001,"comment_content":"接口强调某一方面的统一，抽象强调共性的复用","like_count":11},{"had_liked":false,"id":153590,"user_name":"nelson","can_delete":false,"product_type":"c1","uid":1271183,"ip_address":"","ucode":"773BE75A23C1C9","user_header":"","comment_is_top":false,"comment_ctime":1574263842,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40228969506","product_id":100039001,"comment_content":"抽象类 Strategy 没有定义任何属性，并且所有的方法都声明为 virtual 类型（等同于 Java 中的 abstract 关键字）<br>这里关于C++的说明有点问题，virtual是虚函数和abstract没有对应关系，换句话说，java中成员函数都是virtual的。Java中的abstract关键字对应“virtual void algorithm()=0”当中的“=0”，也就是所谓的纯虚函数，即在本类中没有实现，派生类必须实现","like_count":9,"discussions":[{"author":{"id":1252813,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1d/cd/3819726f.jpg","nickname":"徐同学呀","note":"","ucode":"03383EE820514D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383543,"discussion_content":"一般 mvc中，controller 接口  接收参数过多时，可以用一个类来接收，但是其他地方如果一个必填参数很多，构建一个参数类又是一个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626152374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153237,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1574207108,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"40228912772","product_id":100039001,"comment_content":"关于抽象类和接口有一个疑问，也可能是对业务模型不够了解，同一件事其实可以表达成is a也可以表达成has a，这个就看你的语言描述到底是个名词还是行为。<br>举例说明：<br>宠物猫和宠物狗都是宠物。<br>宠物猫和宠物狗都有会被宠。<br>is a基类定义：宠物类<br>has a  接口定义：可被宠的<br>如果取决于需求的语言阐述，感觉就太依赖个人表达习惯了，这不是一个团队持续迭代好项目的方式吧<br>希望老师可以帮忙解惑","like_count":9,"discussions":[{"author":{"id":1773160,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/0e/68/a41730c8.jpg","nickname":"峰回路转","note":"","ucode":"A2874C7392C452","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":94440,"discussion_content":"我也这样认为，所有的接口同样可以表述为is a,再加上java8之后接口也可以有方法实现，所以我觉得目前来看两个的区别主要是属性的继承，如果只是行为继承可以使用接口，如果继承的行为涉及到公共属性可能就要用继承了，具体看侧重点了。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576943659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/14/cb118a61.jpg","nickname":"键舞飞扬","note":"","ucode":"4EC7A8D2E7AC78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342069,"discussion_content":"一个表示是什么，一个表示能做什么！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610589882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1664641,"avatar":"https://static001.geekbang.org/account/avatar/00/19/66/81/a5da0b99.jpg","nickname":"null","note":"","ucode":"7FF909352F786E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53703,"discussion_content":"那你得看看，你需要的到底是 is-a 还是 has-a 的特性了。is-a 不仅有方法的复用，还有类属性的复用；抽象类还支持默认的方法实现，这个你又是否需要？\n所以我认为，这样的疑问，从业务需求出发，就可以做出选择了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574210581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153215,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1574190863,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27343994639","product_id":100039001,"comment_content":"Python有抽象类吧？abc不是可以定义抽象类么","like_count":6,"discussions":[{"author":{"id":1489957,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","nickname":"tt","note":"","ucode":"7753B79AD5A9AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54026,"discussion_content":"我的理解，ABC也是PYTHON为了从更基础的层面提供抽象类的支持而产生的特性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574252508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504506,"avatar":"http://thirdwx.qlogo.cn/mmopen/KFgDEHIEpnTMtKn1eiasiaqFvbYZCO4rj2vDxC5OmQiaMHibpJk1zsq9sIZXFUjSyYIZKEoQAOWsy1EoGtPyN4ibuVNIXgsoG505S/132","nickname":"Geek_6c778e","note":"","ucode":"527237E4648AF0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53740,"discussion_content":"不是基础语法，是通过装饰器实现的，而且可以实例化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574212552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154480,"user_name":"bigtom","can_delete":false,"product_type":"c1","uid":1127131,"ip_address":"","ucode":"EF5780DAB3A749","user_header":"https://static001.geekbang.org/account/avatar/00/11/32/db/8541b844.jpg","comment_is_top":false,"comment_ctime":1574439105,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23049275585","product_id":100039001,"comment_content":"is-a 和 has-a 的地方我觉得有点问题。应该说 is-a 是继承（Inheritance），has-a 是组合（Composition）。所以我感觉无论接口还是抽象类都是继承，所以都是 is-a 的关系呀。","like_count":5,"discussions":[{"author":{"id":1200660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/14/cb118a61.jpg","nickname":"键舞飞扬","note":"","ucode":"4EC7A8D2E7AC78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342071,"discussion_content":"一个表示是什么，一个表示能做什么！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610589946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":251715,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1601805912,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18781675096","product_id":100039001,"comment_content":"1、Java中接口和抽象类的区别是什么？什么时候用接口？什么时候用抽象类？抽象类和接口存在的意义是什么？能解决哪些编程问题？<br>1）类关键字修饰符：<br>抽象类使用abstract修饰，含有抽象方法（使用abstract关键字修饰的方法）的类是抽象类，必须使用abstract关键字修饰；<br>接口使用interface修饰<br><br>2）实例化：<br>抽象类和接口均不能实例化<br>若想实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象<br><br>3）实现：<br>一个类只能实现一个抽象类；<br>一个类可以实现多个接口，接口自己本身可以通过extends 关键字扩展多个接口，如果一个类实现多个接口，多个接口有相同default方法，则子类必须重写该方法<br><br>4）访问级别关键字修饰符：<br>JDK 1.8以前，接口中的方法必须是public的<br>JDK 1.8时，接口中的方法可以是public的，也可以是default的<br>JDK 1.9时，接口中的方法可以是private的<br>JDK 1.8以前，抽象类的方法默认访问权限为protected<br>JDK 1.8时，抽象类的方法默认访问权限变为default<br><br>5）方法：<br>抽象类可以含有抽象方法，也可以不包含抽象方法，抽象类中可以有具体的方法，抽象类中的抽象方法只有方法体没有具体实现；<br>接口中的方法均为抽象方法，接口中不能包含实例或静态方法<br><br>6）变量<br>接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定<br>7）设计层面：<br>抽象是对类的抽象，是一种模板设计；接口是对行为的抽象，是一种行为的规范<br>8）继承层次<br>抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。<br>而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。<br><br>8）使用场景：<br>使用抽象类是为了代码的复用，<br>接口是对行为的抽象，而使用接口的动机是为了实现多态性,侧重于抽象和解耦；<br>接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。<br><br>具体代表：<br>抽象类-模板模式(把不变的流程抽象到父类的模板方法中，将可变的部分留给子类实现）<br>eg.<br>JDK的InputStream、OutputStream、Reader、Writer;<br>AbstractList中的AddAll是模板方法，add、get、set均抛出异常异常没法正常使用需要子类重写<br>HttpServlet中的service方法是模板方法，doGet和doPost可以是子类重写定制的部分。<br><br>接口：<br>eg.<br>Spring的BeanFactory，BeanFactory是IOC容器的核心接口，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。BeanFactory只是个接口，并不是IOC容器的具体实现，但是Spring容器给出了很多种实现，如DefaultListableBeanFactory、XmlBeanFactory、ApplicationContext等，其中XmlBeanFactory就是常用的一个，该实现将以XML方式描述组成应用的对象及对象间的依赖关系","like_count":4},{"had_liked":false,"id":153414,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1574232292,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18754101476","product_id":100039001,"comment_content":"1. 目前学习的就是Java余元，所以有了一套线程的支持接口和抽象类的东西。其实刚入门的时候，确实对这两个不是很理解，而且很多时候都不知道如何运用，那时候是靠《疯狂Java讲义》学会了区别，并且通过一些面试题了解到其中的一些区别和使用方式。<br>2. 通过今天老师的讲解，我又结合了《疯狂Java讲义》、面试题、以及自己项目中的代码实现，来重新梳理这两个的区别。为什么我的业务代码是使用接口而不是抽象类，为什么有些API是用了抽象类而不是接口，是基于某方面的考虑，是处于什么方式的考虑，或是基于哪个设计模式。不过这些都还需要消化，沉淀，会用只是一方面，会思考，会架构才是更好的方式。","like_count":4},{"had_liked":false,"id":153283,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1574210667,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18754079851","product_id":100039001,"comment_content":"抽象类 vs 接口<br><br>\t\t\t抽象类    接口<br>实例化\t\t    否\t      否<br>属性\t\t    是               否<br>方法                    是               是<br>实现                    是               否<br>目的                 复用          扩展<br>意义                  is-a           has-a","like_count":4,"discussions":[{"author":{"id":1507189,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ff/75/9c1b2ece.jpg","nickname":"wind","note":"","ucode":"5EC77AEB18130E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72833,"discussion_content":"纠正一点，接口是可以定义成员变量的，定义的默认为常量","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575533751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153234,"user_name":"水银","can_delete":false,"product_type":"c1","uid":1045948,"ip_address":"","ucode":"0FD9C79590E484","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/bc/63be02b6.jpg","comment_is_top":false,"comment_ctime":1574206815,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18754075999","product_id":100039001,"comment_content":"Java语言接口和抽象的用法老师已经在文中讲了，但在后来的语法规则里，接口也可以由default修饰符来构造默认的接口方法逻辑了，这样在实现接口的时候可以不用必须实现包含被标记为default的方法了，这样的设计是否也是因为接口中如果包含了通用的方法逻辑，可以不用每个接口都实现一遍，避免方法逻辑冗余呢？也是复用的一种思想？","like_count":4},{"had_liked":false,"id":153219,"user_name":"香蕉派2号","can_delete":false,"product_type":"c1","uid":1587685,"ip_address":"","ucode":"1BB5A449B6EA5E","user_header":"https://static001.geekbang.org/account/avatar/00/18/39/e5/53b1f697.jpg","comment_is_top":false,"comment_ctime":1574200214,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"18754069398","product_id":100039001,"comment_content":"问题1:<br>c#接口两种实现方式：<br>&#47;&#47; 直接实现接口<br>interface IAttack<br>{<br>    void Attck();<br>}<br>class Gun : IAttack<br>{<br>    public void Attck()<br>    {<br>        throw new NotImplementedException();<br>    }<br>}<br>class Rifle : IAttack<br>{<br>    public void Attck()<br>    {<br>        throw new NotImplementedException();<br>    }<br>}<br><br>&#47;&#47; 显示实现接口（当多个接口的中需要实现的方法名称一样的时候）<br>interface IAttack<br>{<br>    void Attack();<br>}<br>interface ISpecialAttack<br>{<br>    void Attack();<br>}<br>class Gun : IAttack, ISpecialAttack<br>{<br>    public void Attack()<br>    {<br>        Console.WriteLine(&quot;普通攻击&quot;);<br>        throw new NotImplementedException();<br>    }<br>    void ISpecialAttack.Attack() &#47;&#47; 接口的显示实现<br>    {<br>        Console.WriteLine(&quot;特殊攻击&quot;);<br>        throw new NotImplementedException();<br>    }<br>}<br>class Rifle : IAttack, ISpecialAttack<br>{<br>    public void Attack()<br>    {<br>        Console.WriteLine(&quot;普通攻击&quot;);<br>        throw new NotImplementedException();<br>    }<br>    void ISpecialAttack.Attack() &#47;&#47; 接口的显示实现<br>    {<br>        Console.WriteLine(&quot;特殊攻击&quot;);<br>        throw new NotImplementedException();<br>    }<br>}<br>public class TestWeapons<br>{<br>    public void TestMethod()<br>    {<br>        ISpecialAttack desertEagle = new Gun();<br>        desertEagle.Attack();<br><br>        IAttack rifle = new Rifle();<br>        rifle.Attack();<br>    }<br>}<br><br><br>c#抽象类定义以及实现：<br>abstract class Weapon{<br>    public float attackRange;<br>    public float damage;<br>    public virtual void Attack(Enemy enmey)<br>    {<br>        enmey.health -= damage;<br>        Console.WriteLine(&quot;attack...&quot;);<br>    }<br>}<br><br>class Gun: Weapon<br>{<br>    public override void Attack(Enemy enmey)<br>    {<br>        base.Attack(enmey);<br>    }<br>}<br><br>public class TestWeapon02<br>{<br>    public static void main02(string[] args)<br>    {<br>        Enemy enemy = new Enemy();<br>        Weapon gun = new Gun()<br>        {<br>            damage = 5,<br>            attackRange = 100,<br>        };<br>        gun.Attack(enemy);<br>        Console.WriteLine(&quot;enemy health: &quot; + enemy.health);<br>    }<br>}<br><br>问题2:<br>总的来说，抽象类就是类别上的总称；接口就是行为上的规范<br><br>","like_count":4,"discussions":[{"author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292693,"discussion_content":"显示实现和隐式实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595309984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042983,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/27/a3737d61.jpg","nickname":"Shanks-王冲","note":"","ucode":"C4B90A17850E20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59539,"discussion_content":"建议分享一个gist link用于存放代码，避免直接分享代码；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574690437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154807,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1574569849,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14459471737","product_id":100039001,"comment_content":"Swift支持接口，不支持抽象类。<br>protocol SomeDelegate {<br>    func doSomething()<br>}<br><br>接口是对一组行为的抽象，目的是将约定和实现相分离，提高代码的灵活性和可扩展性<br>抽象类的主要目的和普通父类一样，是为了代码的可复用性，但可读性和可维护性要更好，因为不用专门定义空方法以供重写，而是使用抽象方法","like_count":3},{"had_liked":false,"id":153517,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1574251668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14459153556","product_id":100039001,"comment_content":"思想最重要，用什么工具都可以实现特定的思想。<br>抽象类体现了IS-A关系，接口体现了HAS-A关系，体现了协议，也即为了解耦行为和实现。<br><br>同时，抽象类和接口也体现了方法论，一个是自底向上，一个是自顶向下。<br><br>学完这节课，确实对它们的却别和联系更加清楚了。","like_count":3},{"had_liked":false,"id":153514,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1574251057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14459152945","product_id":100039001,"comment_content":"设计模式_08<br>1. 文中讲到用Java普通类实现抽象类，抽象类的限制比接口少，所以在接口的基础上添加一些普通类的功能即可。<br>public class MockAbstractClass {<br>  protected MockAbstractClass() {}<br>  public void funcAbstract() {<br>    throw new MethodUnSupportedException();<br>  }<br>  public void Object field;<br>  public void funcImpl() {<br>    &#47;&#47;function implement code<br>  }<br>}<br>2. 今天的内容，印象最深刻的就是**is-a ==&gt; 抽象类， has-a ==&gt; 接口**，坦白讲，之前不是很清楚，看感觉来使用抽象类和方法。","like_count":3},{"had_liked":false,"id":153311,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1574213992,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"14459115880","product_id":100039001,"comment_content":"1.普通类模拟抽象类方法：<br>私有构造器，protected修饰的方法和成员变量，模拟抽象方法的时候在实现体内直接抛出异常并写好交由子类具体实现的注释说明<br>2.用的JAVA。天然支持，abstract和interface<br>3.抽象类：<br>不支持多继承，为了解决代码复用问题而产生，他可以内部定义方法实现、公用属性以及需要子类各自实现的抽象方法，应用场景最典型的就是模板模式，is a的关系。爸爸儿子的关系。<br>接口：<br>支持多继承，为了让代码更加解耦合，更加灵活而产生，他所定义的方法都是抽象的，has a的关系，好比一种协议，一种规范，应用场景贼广泛，比如各大设计模式，设计原则。再比如责任链模式","like_count":3},{"had_liked":false,"id":153205,"user_name":"玄兴梦影","can_delete":false,"product_type":"c1","uid":1364855,"ip_address":"","ucode":"D9EDBBC61317E9","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/77/fb38ccf1.jpg","comment_is_top":false,"comment_ctime":1574180985,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14459082873","product_id":100039001,"comment_content":"在学Java时，我一直在疑惑什么时候用抽象类，什么时候用接口。现在学完对此有一点理解，也明白他们之间的关系及用法。下来需要多实践与学习。","like_count":3},{"had_liked":false,"id":156634,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1574927415,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10164862007","product_id":100039001,"comment_content":"抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对一系列行为的一种抽象，不要去管其它的那种类似变量、多余方法之类杂七杂八的东西<br>接口：interface修饰，不能有属性，只能有抽象的方法，实现接口的时候必须实现所有的方法。如果要表示一种 里面东西全部都要的is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类<br>抽象：abstract修饰，其它的反过来。如果要表示一种 只要里面一部分的has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口","like_count":2},{"had_liked":false,"id":155080,"user_name":"小乙哥","can_delete":false,"product_type":"c1","uid":1063308,"ip_address":"","ucode":"C77E79BEA0C325","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","comment_is_top":false,"comment_ctime":1574643656,"is_pvip":false,"replies":[{"id":"60027","content":"那是故意那么写的😂，因为那两行代码放到那里并不合适","user_name":"作者回复","comment_id":155080,"uid":"1190123","ip_address":"","utype":1,"ctime":1574853315,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"10164578248","product_id":100039001,"comment_content":"接口举例的地方，添加实例Filter的地方被注释掉了","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475656,"discussion_content":"那是故意那么写的😂，因为那两行代码放到那里并不合适","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574853315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154431,"user_name":"王加武","can_delete":false,"product_type":"c1","uid":1665471,"ip_address":"","ucode":"DDCFE578C6C428","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/bf/50a824a4.jpg","comment_is_top":false,"comment_ctime":1574428857,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10164363449","product_id":100039001,"comment_content":"接口和抽象类的区别<br>1，接口中的所有的方法必须是抽象方法，而抽象类中的方法可以是普通方法<br>2，抽象类使用abstract来修饰，接口使用的是interface来修饰<br>3，在实现接口的所有的类中，接口的方法都必须被实现，而抽象类的话只有子类继承了抽象的父类，父类没有被实现的抽象方法才需要被实现<br>4，接口可以实现多继承，接口是一种规则，一种契约<br>5，抽象类是不可以被new的，即它的构造方法不能new<br>6,抽象类更多的是用于继承的场景的，而接口则是更多的以组合的方式来使用<br><br>学习了王老师的这节课，我对接口和抽象类的认识又加深了<br>什么时候使用抽象类——<br>当所涉及的关系是一种is - a的关系，并且需要实现代码的复用，那么就使用抽象类<br>什么时候使用的接口——<br>当所涉及的关系是一种has - a的关系，并且需要组合的使用和实现抽象的场景，那么就用接口<br><br>抽象类是一种自下而上的设计思想，即只用子类需要然后才去考虑父类，<br>接口是一种自上而下的设计思想，所有的子类都必须要实现接口中的所有的方法<br>","like_count":2},{"had_liked":false,"id":154223,"user_name":"undefined","can_delete":false,"product_type":"c1","uid":1587803,"ip_address":"","ucode":"867405CA5A9FB7","user_header":"https://static001.geekbang.org/account/avatar/00/18/3a/5b/ce1724ca.jpg","comment_is_top":false,"comment_ctime":1574392788,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10164327380","product_id":100039001,"comment_content":"public class MockClass {<br>    protected MockClass() {}<br>    public void funcA() {<br>    }<br><br>    public static void main(String[] args) {<br>        new MockClass();<br>    }<br>}<br><br>这段代码是可以编译通过的诶，普通类无法模拟无法实例化的特性","like_count":2,"discussions":[{"author":{"id":1095445,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b7/15/6a2b6b83.jpg","nickname":"董宗磊","note":"","ucode":"D7005A328BC2EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179812,"discussion_content":"长方形需要两个set（set 长 set 宽），第一个set 刚刚 set 长，还没set 宽，肯定是个无效的长方形","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582254714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154002,"user_name":"我爱布丁","can_delete":false,"product_type":"c1","uid":1575522,"ip_address":"","ucode":"660B495D34CD39","user_header":"","comment_is_top":false,"comment_ctime":1574345804,"is_pvip":false,"replies":[{"id":"59162","content":"可以使用抽象类。但也可以使用组合来实现代码复用。后面会讲到","user_name":"作者回复","comment_id":154002,"uid":"1190123","ip_address":"","utype":1,"ctime":1574384228,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"10164280396","product_id":100039001,"comment_content":"老师举的Filter接口的例子可以用抽象类实现吗？<br><br>我觉得可以说 AuthencationFilter is a Filter, RateLimitFilter is a Filter. 如果两个Filters在doFilter里会预先做一些通用的对于RpcRequest的validation工作，或者有一些shared states，那么这样是不是就应该用抽象类实现呢？<br><br>","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475348,"discussion_content":"可以使用抽象类。但也可以使用组合来实现代码复用。后面会讲到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574384228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153667,"user_name":"阿玛铭","can_delete":false,"product_type":"c1","uid":1100703,"ip_address":"","ucode":"DBF948D82ACBE3","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","comment_is_top":false,"comment_ctime":1574295551,"is_pvip":false,"replies":[{"id":"59159","content":"😂 没研究过响应式编程 帮不上你了","user_name":"作者回复","comment_id":153667,"uid":"1190123","ip_address":"","utype":1,"ctime":1574378179,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"10164230143","product_id":100039001,"comment_content":"问句题外话：老师对响应式编程有研究吗？想要一门这样的课程。理由：1.josh long打造，可以代表开发技术的趋势。 2.了解的不够，高并发，类似nety 3.语言隔阂短时间无法突破。<br>还有一个重要的理由是我觉得老师你讲内容的思路容易理解和接受。","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475242,"discussion_content":"😂 没研究过响应式编程 帮不上你了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574378179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","nickname":"阿玛铭","note":"","ucode":"DBF948D82ACBE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55761,"discussion_content":"问题不大。谷歌翻译……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574395867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153446,"user_name":"Yo nací para quererte.","can_delete":false,"product_type":"c1","uid":1664572,"ip_address":"","ucode":"8B6E9B8B3D007C","user_header":"https://static001.geekbang.org/account/avatar/00/19/66/3c/2d563488.jpg","comment_is_top":false,"comment_ctime":1574237152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10164171744","product_id":100039001,"comment_content":"记录一下C#的抽象类和接口：<br>C#中既有virtual关键字（用于定义虚方法）也有abstract关键字（用于定义抽象类或抽象方法）也有interface关键字（用于定义接口）。<br>子类可以使用new关键字覆盖父类方法，可以使用override关键字重写父类方法。<br>总结：<br>1. 不管重写还是覆盖都不会影响父类自身的功能（除非父类代码被改变）<br>2. 当用子类创建父类对象时，如Animal animal = new Cat();。重写会改变父类的功能，即调用子类的方法，而覆盖不会，扔调用父类方法。<br>3. 虚方法和实方法都可以被覆盖（new），抽象方法和接口不可以。<br>4. 抽象方法和接口和虚方法可以被重写（override），实方法不可以。<br>5. 重写使用的频率比较高，用于实现多态；覆盖用的频率比较低，用于对以前无法修改的类进行继承的时候。","like_count":2},{"had_liked":false,"id":153252,"user_name":"Paper","can_delete":false,"product_type":"c1","uid":1305388,"ip_address":"","ucode":"7EE26C2E892899","user_header":"https://static001.geekbang.org/account/avatar/00/13/eb/2c/ab72fda4.jpg","comment_is_top":false,"comment_ctime":1574208431,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"10164143023","product_id":100039001,"comment_content":"js 中也没有接口定义，也只能通过上述类似检测抛异常的方式实现，但是上了ts之后就没有问题了。","like_count":2},{"had_liked":false,"id":153241,"user_name":"cc","can_delete":false,"product_type":"c1","uid":1592092,"ip_address":"","ucode":"FF41E5D87BAD76","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/1c/5eb03a91.jpg","comment_is_top":false,"comment_ctime":1574207480,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10164142072","product_id":100039001,"comment_content":"按照重点回顾的三个小点来回答抽象类和接口的面试问题。","like_count":2},{"had_liked":false,"id":321045,"user_name":"MONSTER","can_delete":false,"product_type":"c1","uid":2839715,"ip_address":"","ucode":"6B1D38BA7F1717","user_header":"https://static001.geekbang.org/account/avatar/00/2b/54/a3/f188a152.jpg","comment_is_top":false,"comment_ctime":1636630961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5931598257","product_id":100039001,"comment_content":"接口可以有成员变量，只不过是public static final的","like_count":1},{"had_liked":false,"id":306739,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1628686972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5923654268","product_id":100039001,"comment_content":"1.c++支持抽象类，实现方式是含有纯虚函数的类就是抽象类；c++不直接提供接口的支持，但是可以通过抽象类来模拟接口，具体而言就是抽象类中全都定义纯虚函数（构造函数除外），并且不定义属性。<br><br>2.接口和抽象类的区别：（1）接口中含有的都是抽象方法，而不包含属性，而抽象类可以包含属性；（2）抽象类是is a关系，解决的是代码复用问题，接口是has a关系，解决的是抽象问题，可以实现约定和实现分离","like_count":1},{"had_liked":false,"id":247562,"user_name":"WilliamVector","can_delete":false,"product_type":"c1","uid":1898112,"ip_address":"","ucode":"E0D3C3D4FCB7C9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/80/85ec2c2a.jpg","comment_is_top":false,"comment_ctime":1599742245,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5894709541","product_id":100039001,"comment_content":"【要点】<br>1、抽象类和接口的语法特性。抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。<br>2、抽象类和接口存在的意义。抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。对于接口，有一个更加形象的叫法，那就是协议（contract）。<br>3、抽象类和接口的应用场景区别。什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示\b一种 has-a关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。<br>【思考】<br>1、Java语言定义抽象类：<br>public abstract class AbstractDemo {<br>\tprivate int number;<br>\t<br>\tpublic AbstractDemo () {}<br>\t<br>\tpublic AbstractDemo (int number) {<br>\t\tthis.number = number;<br>\t}<br>\t<br>\tpublic int getNumber() {<br>\t\treturn this.number;<br>\t}<br>\t<br>\tpublic abstract int optNumber();<br>}<br>public interface InterfaceDemo {<br>\tpublic int add();<br>\tpublic int mul();<br>}<br>2、从抽象类和接口的语法特性和应用场景两个方面回答，最好能再举一个例子说明：<br>(1)语法特性：抽象类不允许被实例化，只能继承。可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的叫抽象方法。子类继承抽象类，必须实现抽象类的抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。对于接口，有一个更加形象的叫法，那就是协议。<br>(2)应用场景：如果表示一种is-a关系，并且为了解决代码的复用问题，就使用抽象类；如果表示一种has-a关系，并且为了解决抽象而非代码复用问题，就用接口，接口是通常是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。","like_count":1},{"had_liked":false,"id":218232,"user_name":"buggetout","can_delete":false,"product_type":"c1","uid":1880582,"ip_address":"","ucode":"63A948EF415FDD","user_header":"https://static001.geekbang.org/account/avatar/00/1c/b2/06/2086d76d.jpg","comment_is_top":false,"comment_ctime":1589763542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884730838","product_id":100039001,"comment_content":"抽象类和接口的区别:<br>1.抽象类用于表示is-a关系，常用于代码复用。接口类用于表示has-a关系，常用于抽象，或者表示对象有某些行为。<br>2.抽象类中能够定义属性<br>3.java8之后接口支持default方法<br>4.接口能够实现函数式编程","like_count":1},{"had_liked":false,"id":217382,"user_name":"anders","can_delete":false,"product_type":"c1","uid":1153592,"ip_address":"","ucode":"610C80D742C331","user_header":"https://static001.geekbang.org/account/avatar/00/11/9a/38/118a890c.jpg","comment_is_top":false,"comment_ctime":1589472506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884439802","product_id":100039001,"comment_content":"关于抽象类和接口的理解，从本质上说:<br>抽象类: 编程中自下向上的需要，如果用其他方式模拟不是不行，而是维护成本高。因此对于这样常见的编程范式来说，添加语法支持（约束），能够大大的使用范式的成本。本质上是语法糖。<br><br>接口: 同理，提供一个语法糖，方便低成本的实现 has-a 的问题<br><br>总的说，编程语言的大部分特性，或者是设计模式，都是从编程实际需求出发而演变出来的。理解熟悉这些演变过程，能够让我们举一反三。<br><br>另外，很多动态语言犹豫缺乏大量的这些特性: 接口，抽象类，抽象方法等。使得开发成本。维护成本是相对高的。这也就导致了动态需要开发大型项目艰难的问题。<br><br>可以看看 js 社区这几年的激烈演进，ts 的大流行，也是因为有了大型项目的需求，尝到了 ts 的各项语法特性的甜头。<br><br><br>设计模式也大抵如此，放在小型项目的时候，并不能体现出多大作用。因为设计模式的出现，就是为了对抗，处理复杂度的。","like_count":1},{"had_liked":false,"id":197946,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585404514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880371810","product_id":100039001,"comment_content":"Logger 可以被实例化，换句话说，我们可以 new 一个 Logger 出来，并且调用空的 log() 方法。这也增加了类被误用的风险。当然，这个问题可以通过设置私有的构造函数的方式来解决。不过，显然没有通过抽象类来的优雅。我觉得这句话有问题，如果私有化，还谈什么继承，这已经脱离了问题本身，我们讨论的是父类的空方法可以有效解决继承，但是你私有化解决调用空方法，但是我们讨论的不是这个，还谈什么多肽，继承呢","like_count":1},{"had_liked":false,"id":180444,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1582282086,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5877249382","product_id":100039001,"comment_content":"其实我们可以换个角度思考一下：当我们在说抽象类和接口到底在说什么？以Java为例，为什么要支持抽象类，自然是为了表示面向对象编程中is-a的关系，即A是B，那么B自然也是一个Object，那么自然就有属性和方法（行为）。再来，为什么药支持接口，是为了表示面向对象编程中has-a的关系，就是你拥有什么能力，能力对应行为（方法），那么自然就只有方法，当然也可以有属性，但是一定是常量，想下为什么只能是常量而不能是变量呢？如果有变量那就意味着实现A和实现B是可以互相修改的，这违反了接口的定义。继续延伸下，为什么jdk8要支持默认方法呢？举个例子你就知道了，A和B都需要C的能力z，但C还提供能力y，但是只有A是需要y的，那么B只需要默认的y能力就好了。","like_count":1},{"had_liked":false,"id":169066,"user_name":"天空只能仰望？","can_delete":false,"product_type":"c1","uid":1102357,"ip_address":"","ucode":"D87BF6A57DAB42","user_header":"https://static001.geekbang.org/account/avatar/00/10/d2/15/4d43d05a.jpg","comment_is_top":false,"comment_ctime":1578270352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5873237648","product_id":100039001,"comment_content":"接口自上而下设计，便于解偶，抽象类自下而上设计，便于代码复用！","like_count":1},{"had_liked":false,"id":158799,"user_name":"longslee","can_delete":false,"product_type":"c1","uid":1465986,"ip_address":"","ucode":"C24E32E5B1B6F5","user_header":"https://static001.geekbang.org/account/avatar/00/16/5e/82/438c8534.jpg","comment_is_top":false,"comment_ctime":1575453675,"is_pvip":false,"replies":[{"id":"61145","content":"只能包含静态常量吧","user_name":"作者回复","comment_id":158799,"uid":"1190123","ip_address":"","utype":1,"ctime":1575897867,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5870420971","product_id":100039001,"comment_content":"咦，老师，“接口不能包含属性（也就是成员变量）”，是怎么回事？可以的呀","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476852,"discussion_content":"只能包含静态常量吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575897867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153980,"user_name":"王喜春","can_delete":false,"product_type":"c1","uid":1022349,"ip_address":"","ucode":"436E91FDED1B30","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/8d/4d5dbfc5.jpg","comment_is_top":false,"comment_ctime":1574341436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869308732","product_id":100039001,"comment_content":"早些年，刚接触C++和Java时，无意间想到C++中的一个定义方式跟Java中的Interface意图一样。还记得当时跟别人聊这个感觉， 大多数人都没有同感，就放下了。现在再看这个，很是亲切。","like_count":1},{"had_liked":false,"id":153764,"user_name":"胖🐯","can_delete":false,"product_type":"c1","uid":1732966,"ip_address":"","ucode":"FB6EA96A335846","user_header":"https://static001.geekbang.org/account/avatar/00/1a/71/66/087de1c6.jpg","comment_is_top":false,"comment_ctime":1574303859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869271155","product_id":100039001,"comment_content":"构造函数设置成protected，还是可以被同包下的其他类实例化","like_count":1},{"had_liked":false,"id":153761,"user_name":"胖🐯","can_delete":false,"product_type":"c1","uid":1732966,"ip_address":"","ucode":"FB6EA96A335846","user_header":"https://static001.geekbang.org/account/avatar/00/1a/71/66/087de1c6.jpg","comment_is_top":false,"comment_ctime":1574303570,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869270866","product_id":100039001,"comment_content":"C++的virtual关键字表示虚函数，虚函数才有多态性，这个关键字跟abstract没有任何关系啦🙂","like_count":1},{"had_liked":false,"id":153576,"user_name":"段启超","can_delete":false,"product_type":"c1","uid":1258209,"ip_address":"","ucode":"164CF3018071B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/32/e1/c9aacb37.jpg","comment_is_top":false,"comment_ctime":1574261929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869229225","product_id":100039001,"comment_content":"接口和抽象类的相同点和不同点：<br>相同点： 都是抽象机制，都可以存在抽象方法，都不能被实例化<br>不同点： 抽象类中可以存在成员变量，接口中不允许，<br>              抽象类中可以存在具体的方法实现，接口中不允许。<br>             抽象类的设计原则是is-a ，接口的设计原则是has-a 或者是can-do <br>反思：<br>SSM 的这种三层结构横行多年，造成的结果就是设计模式几乎没有用武之地，基于贫血模型的面条代码，没有任何面向对象的设计元素可言，抽象类，接口的意义很多时候就停留在了面试中。","like_count":1},{"had_liked":false,"id":153512,"user_name":"胡子高兴了","can_delete":false,"product_type":"c1","uid":1596868,"ip_address":"","ucode":"A32AE341E3683D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/YJHQDzuLavGFmwunybBiaBrrU1aOib7Siam0fJrWIaHfdT0p2GicsRT42d9bhRNO324wewDtic8RiaokAFkUyO3YRF0g/132","comment_is_top":false,"comment_ctime":1574250660,"is_pvip":false,"replies":[{"id":"59170","content":"可以的","user_name":"作者回复","comment_id":153512,"uid":"1190123","ip_address":"","utype":1,"ctime":1574385163,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5869217956","product_id":100039001,"comment_content":"老师，接口中可以定义静态成员变量吗？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475195,"discussion_content":"可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574385163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153471,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1574239827,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869207123","product_id":100039001,"comment_content":"java抽象类与接口区别<br>1、前者可以包含成员属性和方法实现，后者不可以<br>2、is-a与has-a区别<br>3、前者单继承，后者多实现","like_count":1},{"had_liked":false,"id":153386,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1574227879,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869195175","product_id":100039001,"comment_content":"一般面试问抽象类跟接口的问题我都会把java8特性也带上一起说 比如接口也可以有方法体（default关键字）lambda表达式在改变我们现有的设计模式等等 希望老师加餐说一下现在函数式编程的编码规范及优雅写法","like_count":1},{"had_liked":false,"id":153365,"user_name":"李新天","can_delete":false,"product_type":"c1","uid":1506036,"ip_address":"","ucode":"8BBAA3D96FD2A5","user_header":"https://static001.geekbang.org/account/avatar/00/16/fa/f4/4aa8fe24.jpg","comment_is_top":false,"comment_ctime":1574223440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869190736","product_id":100039001,"comment_content":"我搞js的，一脸懵逼","like_count":1},{"had_liked":false,"id":153363,"user_name":"LYy","can_delete":false,"product_type":"c1","uid":1102062,"ip_address":"","ucode":"8D5C39B9531E71","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/ee/f5c5e191.jpg","comment_is_top":false,"comment_ctime":1574223232,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5869190528","product_id":100039001,"comment_content":"类的可继承性解决用来解决复用性问题 接口的可实现性用来解决扩展性(多态)问题<br>而抽象类 其实是用来兼顾多态与继承两个特性的产物<br>是否实现抽象类 其实也体现了语言设计者关于OO(面向对象)特性的思考与trade-off","like_count":1},{"had_liked":false,"id":153286,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1574211024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869178320","product_id":100039001,"comment_content":"抽象类主要是继承，代码复用，类中可以定义属性和方法，方法有普通方法和抽象方法，不可以被实例化，继承抽象类的子类必须实现类中所有的抽象方法，是一种自下而上的模式，所有的子类都实现具体方法，抽象类进行抽象，接口是一种自上而下的模式，定义好需要实现哪些方法，接口不可以定义属性，接口的方法必须被实现类所实现，接口中的方法必需被定义为public模式的，继承抽象类的子类实现的方法的权限必须必抽象类宽松，比如抽象类中的抽象方法被定义为protected，则实现该抽象方法的方法不能定义为private，只能定义成protected或public，抽象类是is_a，接口是has_a。","like_count":1},{"had_liked":false,"id":153285,"user_name":"2018","can_delete":false,"product_type":"c1","uid":1107371,"ip_address":"","ucode":"4C2CD47AD70177","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/ab/6fab2492.jpg","comment_is_top":false,"comment_ctime":1574210792,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5869178088","product_id":100039001,"comment_content":"熟悉的Java和go语言，Java天然支持抽象类和接口，go语言对于接口的实现是用了一种ducking type的方式","like_count":1},{"had_liked":false,"id":153276,"user_name":"董小容","can_delete":false,"product_type":"c1","uid":1714216,"ip_address":"","ucode":"A856333452BA08","user_header":"https://static001.geekbang.org/account/avatar/00/1a/28/28/be35565d.jpg","comment_is_top":false,"comment_ctime":1574210390,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"5869177686","product_id":100039001,"comment_content":"还是没看懂为什么有了继承，还需要抽象类","like_count":1,"discussions":[{"author":{"id":1570088,"avatar":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","nickname":"deepz","note":"","ucode":"4BD23A44CDB384","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53771,"discussion_content":"个人理解抽象类定义抽象方法就是逼着实现类去重写实现，否则编译报错，而继承的话，虽然继承下来了，但是如果不重写的话，那么调用的时候跑的是父类的。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574214706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1570088,"avatar":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","nickname":"deepz","note":"","ucode":"4BD23A44CDB384","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":54190,"discussion_content":"而且基类还可以被实例化造成误用","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574265194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53771,"ip_address":""},"score":54190,"extra":""}]},{"author":{"id":1637228,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fb/6c/12fdc372.jpg","nickname":"迈向架构师","note":"","ucode":"2476594CF76001","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53826,"discussion_content":"重新看下这段：    这个设计思路能用，但是，它显然没有之前通过抽象类的实现思路优雅。我为什么这么说呢？主要有以下几点原因。 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574222332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53794,"discussion_content":"抽象更符合面向对象思维，更优雅的实现了多态，抽象类不允许实例化更好的降低程序员在编程中的错误。其他好处暂时想不到","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574216963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016594,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/83/12/4ba82798.jpg","nickname":"我是智障","note":"","ucode":"ED9D959423E024","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53815,"discussion_content":"再看一遍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574221154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153274,"user_name":"好吃不贵","can_delete":false,"product_type":"c1","uid":1316993,"ip_address":"","ucode":"6576E2BECE4F7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/18/81/83b6ade2.jpg","comment_is_top":false,"comment_ctime":1574210320,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5869177616","product_id":100039001,"comment_content":"抽象类自下而上，是is a关系，防止重复代码。接口类是自上而下，是has a关系，为了实现具体功能接口。","like_count":1},{"had_liked":false,"id":153262,"user_name":"Flash","can_delete":false,"product_type":"c1","uid":1236163,"ip_address":"","ucode":"E285075C9E0B02","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/c3/e4ba51d5.jpg","comment_is_top":false,"comment_ctime":1574209297,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869176593","product_id":100039001,"comment_content":"课后思考:<br>2.抽象类是解决代码复用问题的，是自下而上设计的，先有子类，再抽取可以复用的代码到父类抽象中；再是一种is-a关系，是这种继承关系的话就用抽象类。<br>接口是提高代码扩展性的，解耦，隔离约定和实现，是自上而下设计的，先定义接口有什么功能，再由子类具体实现；是一种has-a关系，是这种拥有关系的话就用接口。","like_count":1},{"had_liked":false,"id":153242,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1574207587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869174883","product_id":100039001,"comment_content":"打卡","like_count":1},{"had_liked":false,"id":153227,"user_name":"熊斌","can_delete":false,"product_type":"c1","uid":1026280,"ip_address":"","ucode":"24D0C32F397113","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/e8/bc84c47d.jpg","comment_is_top":false,"comment_ctime":1574205252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869172548","product_id":100039001,"comment_content":"Java jdk1.8支持接口中有实现","like_count":1},{"had_liked":false,"id":356738,"user_name":"wanggd","can_delete":false,"product_type":"c1","uid":3174267,"ip_address":"山东","ucode":"ED3928635D7CE3","user_header":"https://static001.geekbang.org/account/avatar/00/30/6f/7b/4be464d2.jpg","comment_is_top":false,"comment_ctime":1662541276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662541276","product_id":100039001,"comment_content":"随着jdk版本的更新，一些定义和规则已经变了，像是接口interface，能更新一下吗？如果使用原来的知识点去总结一些内容有些不妥。当然在当时的那个时间点是可以的。","like_count":0},{"had_liked":false,"id":356568,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"浙江","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1662425427,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1662425427","product_id":100039001,"comment_content":"抽象类是自下而上的，先走具体类的实现，发现方法可复用，又是可以抽象出父子关系，就用到抽象类，它可以有属性，有实现的方法，也有待子类实现的方法，如果没有后者就是普通类了。对于子类继承而言就是is a的关系。如果是接口，更是自上而下的，一开始就是为了解藕，定义接口和实现分离，是has a  的关系！","like_count":0},{"had_liked":false,"id":356367,"user_name":"Sherk","can_delete":false,"product_type":"c1","uid":2156245,"ip_address":"重庆","ucode":"AFE3E7F158258D","user_header":"https://static001.geekbang.org/account/avatar/00/20/e6/d5/4f1fc074.jpg","comment_is_top":false,"comment_ctime":1662202591,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662202591","product_id":100039001,"comment_content":"思考题： 2. 会从定义，设计上进行区分。<br>     定义上： <br>             抽象类可以有自己的属性，且可以实现自己的方法，但是不能new 一个新对象。<br>             接口： 只能定义一些方法，且不能实现方法。<br>     设计上： <br>             抽象类主要是为了代码复用，设计方式是自下而上的，如果子类中有重复的代码，则将重复的代码提取到上层父类，是is-a的关系；<br>              接口从上而下的设计方式，先思考有什么功能，一组行为的特性， 不去考虑具体实现。 是has-a的关系。<br><br>本章节主要讲了什么： what - why -how <br>      what:  什么是抽象类，接口。<br>         抽象类： 定义一组属性和相关抽象方法，可以实现相关方法，不能实例化的类。是为了解决代码复用的。<br>         接口：  只包含方法，不能有属性。为是为了解耦合的。<br><br>  why:<br>       抽象类： 解决代码复用。<br>       接口： 解决代码耦合。<br>how：<br>      如果业务场景是is-a关系可以考虑抽象类。<br>      如果是has-a关系可以考虑接口， 比如serializable 代表类具有序列化的能力。Iterable接口等。<br>        接口：<br>    ","like_count":0},{"had_liked":false,"id":356056,"user_name":"Stay_Gold","can_delete":false,"product_type":"c1","uid":1119904,"ip_address":"北京","ucode":"ACB8DCD2EF8F95","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRCtuJkpyy2NTTABPFibg2k9tZscOOKx9wu80a85d5HspCorO9Nibj7Z7q9v1icPTVm5ia52r0RCzEaA/132","comment_is_top":false,"comment_ctime":1661938534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661938534","product_id":100039001,"comment_content":"总结今天的学习，同时也是回答第二个课后问题<br>抽象类和接口的定义<br>抽象类特性：1.不能实例化  2.可以有属性和方法实现，对于没有实现的方法，即是抽象方法  3.子类必须实现对应的抽象方法。<br>接口特性：相对于抽象类来说1.不能有属性  2.不能有方法实现  3.继承接口的类必须实现接口所有的方法。<br>抽象类和接口存在的意义：<br>抽象类能更好的实现代码复用，而且能更加优雅的实现代码的可扩展性和灵活性。<br>接口更加偏重于行为本身，偏重于代码的解耦。通过面向接口，能使代码的灵活性更高。<br>什么时候使用抽象类，什么时候使用接口？<br>抽象类更加偏重复用，偏重has-a的这种关系。<br>接口更加偏重行为本身，可以更方便的实现解耦，是一种has-a关系。<br><br>问题<br>你熟悉的编程语言，是否有现成的语法支持接口和抽象类呢？具体是如何定义的呢？<br>熟悉C# JAVA 实现基本跟文中意义的abstract和interface","like_count":0},{"had_liked":false,"id":351005,"user_name":"SICUN","can_delete":false,"product_type":"c1","uid":1254261,"ip_address":"","ucode":"22A384904EB9E9","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/75/2b599841.jpg","comment_is_top":false,"comment_ctime":1657448152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657448152","product_id":100039001,"comment_content":"1. 接口：interface，抽象类：abstract class<br>2.确实对于接口和抽象类认识更深了一些，做项目顶层设计时可能会倾向于用接口，实际开发过程中如果有些对象共性比较稳定，可以服用则考虑将接口退化为抽象类。<br>","like_count":0},{"had_liked":false,"id":348683,"user_name":"coley wu","can_delete":false,"product_type":"c1","uid":1082095,"ip_address":"","ucode":"B2C0AD8F970981","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/ef/0badf9dc.jpg","comment_is_top":false,"comment_ctime":1655300545,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655300545","product_id":100039001,"comment_content":"代码复用性可通过普通继承或组合解决，不允许实例化和抽象方法可以在构造方法和普通方法中抛出异常解决。<br>抽象类还有个最大的作用在于提高了代码的可读性，明确的告诉调用方，当前类的定义是个半成品不能被直接使用，必须实现我定义行为规则之后才能使用。<br>","like_count":0},{"had_liked":false,"id":345169,"user_name":"杜威","can_delete":false,"product_type":"c1","uid":1294908,"ip_address":"","ucode":"CF49380E27467F","user_header":"https://static001.geekbang.org/account/avatar/00/13/c2/3c/a82d4ed0.jpg","comment_is_top":false,"comment_ctime":1652088754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652088754","product_id":100039001,"comment_content":"关于抽象类和接口我的理解是，抽象类是业务逻辑表达完整的模块，能够完整的描述模块的业务，通过开放抽象方法，可以扩展不同的业务细节实现。接口则只能提供业务的抽象，不能表达业务逻辑。","like_count":0},{"had_liked":false,"id":343965,"user_name":"seven#羊啾啾JK","can_delete":false,"product_type":"c1","uid":2160692,"ip_address":"","ucode":"B3F1BF6F2F08B2","user_header":"https://static001.geekbang.org/account/avatar/00/20/f8/34/1c260560.jpg","comment_is_top":false,"comment_ctime":1651146359,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651146359","product_id":100039001,"comment_content":"接口（1,无成员属性，2，实现接口必须实现接口中所有方法3，接口只能申明方法，不能代码实现）表示一种 Has-a的关系，为了解决抽象而非代码复用的问题。抽象类表示Is-a 的关系，解决代码复用。认真回答问题，好处多多","like_count":0},{"had_liked":false,"id":342513,"user_name":"gaooakenshield","can_delete":false,"product_type":"c1","uid":2153598,"ip_address":"","ucode":"D5F3E2A12DE6D1","user_header":"https://static001.geekbang.org/account/avatar/00/20/dc/7e/4315166d.jpg","comment_is_top":false,"comment_ctime":1650298712,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650298712","product_id":100039001,"comment_content":"我觉得has a换成can do会更容易理解","like_count":0},{"had_liked":false,"id":338985,"user_name":"Geek_783504","can_delete":false,"product_type":"c1","uid":2743789,"ip_address":"","ucode":"549D3F0549743C","user_header":"https://static001.geekbang.org/account/avatar/00/29/dd/ed/f6c5432b.jpg","comment_is_top":false,"comment_ctime":1647849936,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647849936","product_id":100039001,"comment_content":"第二个问题，首先从两者的概念出发，<br>两者重点关注哪一方面，抽象，他关注的是代码复用，使用继承的方式对抽象方法进行复用，他注重同一类这种关系，接口，更像是一种协议，一种编程规范，我不关注方法本身，我只需要知道方法的用途，他的具体实现由他的实现类去处理，实现类与他的关系更像是一种有的关系，及有这个功能。<br>其次，从他们的区别和共同点说起，都不能被new出来，都能包含抽象方法和静态常量，但是抽象可以包含成员变量和普通方法供子类调用。<br>第三，他们具体使用场景，is-a，和has-a","like_count":0},{"had_liked":false,"id":336947,"user_name":"Sam.张朝","can_delete":false,"product_type":"c1","uid":1132448,"ip_address":"","ucode":"FB20554D94B250","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/a0/f12115b7.jpg","comment_is_top":false,"comment_ctime":1646485392,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646485392","product_id":100039001,"comment_content":"抽象：is-a  ; 自下而上；多态；代码复用<br>接口：has-a; 自上而下；抽象行为","like_count":0},{"had_liked":false,"id":336730,"user_name":"壹号黑土猪","can_delete":false,"product_type":"c1","uid":2278578,"ip_address":"","ucode":"E144567EFB668C","user_header":"https://static001.geekbang.org/account/avatar/00/22/c4/b2/cc4865c2.jpg","comment_is_top":false,"comment_ctime":1646322249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646322249","product_id":100039001,"comment_content":"接口可以实现多个，￼￼抽象例子可以实现一个继承","like_count":0},{"had_liked":false,"id":332937,"user_name":"笑","can_delete":false,"product_type":"c1","uid":2855454,"ip_address":"","ucode":"011F910551FD48","user_header":"https://static001.geekbang.org/account/avatar/00/2b/92/1e/b5f83cde.jpg","comment_is_top":false,"comment_ctime":1643856744,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643856744","product_id":100039001,"comment_content":"抽象类更多是为了代码复用，而接口是为了解耦。<br><br>首先从应用场景来讲，如果是 is-a 并且考虑到代码复用的话，用抽象类，如果是 has-a 并且不考虑代码复用，使用接口。<br><br>接口不允许包含代码的具体实现，不可以包含属性（成员变量），实现类需要实现接口的全部方法。<br><br>接口是对行为的一种抽象，相当于一组契约或协议<br>抽象类不能实例化，只能被继承，可以包含变量和方法。<br><br>抽象类的方法可以包含代码实现，也可以不包含，不包含代码实现的方法叫做抽象方法。<br><br>任何子类需要重写父类的抽象方法，除非子类也是抽象类。<br><br>从类的继承上来看，抽象类更像是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类），而接口是自上而下的设计思路，我们在编程的时候，一般都是先设计好接口，再去考虑具体的实现。","like_count":0},{"had_liked":false,"id":324310,"user_name":"王智","can_delete":false,"product_type":"c1","uid":1337016,"ip_address":"","ucode":"37D2AD591C1AEC","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/b8/ece79234.jpg","comment_is_top":false,"comment_ctime":1638366942,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638366942","product_id":100039001,"comment_content":"第一题：<br>java支持。接口用interface关键字；抽象类用abstract关键字。<br>第二题：<br>* 是的。新认知主要是啥时候用接口，啥时候用抽象类上。<br>* 从定义区别、使用针对场景区别、普通类模拟三个角度来说。","like_count":0},{"had_liked":false,"id":322703,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1637558836,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1637558836","product_id":100039001,"comment_content":"继承是 is-a 的关系，接口是 has-a 的关系，继承是自下而上的，而接口是自上而下的。由 C++ 转 Go，目前在考虑 Go + Rust 的组合，老师讲解的抽象类和接口，让我回忆起刚开始工作时候的面试题，好久都没有这种熟悉的感觉了。Go 强调组合关系，Rust 引入了 trait，目前还在不断适应中。","like_count":0},{"had_liked":false,"id":316318,"user_name":"keep_it_real","can_delete":false,"product_type":"c1","uid":2055554,"ip_address":"","ucode":"F5057CAF752FF3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5d/82/81b2ba91.jpg","comment_is_top":false,"comment_ctime":1634267891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634267891","product_id":100039001,"comment_content":"接口是否是抽象类的衍生物？在职责方面来看的话二者是有重叠的部分，那就是抽象方法（接口中声明的方法就是抽象方法）。而当初Java摒弃了C++的多继承的特性，增加了接口，而接口是可以多实现的。是否可以认为，接口是摒弃多继承后的一种补充？","like_count":0},{"had_liked":false,"id":315502,"user_name":"跳跳","can_delete":false,"product_type":"c1","uid":2771298,"ip_address":"","ucode":"8999B46CF6D197","user_header":"https://static001.geekbang.org/account/avatar/00/2a/49/62/db480ab6.jpg","comment_is_top":false,"comment_ctime":1633914589,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1633914589","product_id":100039001,"comment_content":"不喜欢接口不能包含属性这句话，因为属性也是一组 get()&#47;set() 方法。使用 C# 8.0 语法的小伙伴会很傲娇的。","like_count":0},{"had_liked":false,"id":312446,"user_name":"黄乔鑫","can_delete":false,"product_type":"c1","uid":1863174,"ip_address":"","ucode":"CBD0A8E5E99427","user_header":"https://static001.geekbang.org/account/avatar/00/1c/6e/06/bb43e716.jpg","comment_is_top":false,"comment_ctime":1631804827,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631804827","product_id":100039001,"comment_content":"抽象类与接口<br>\t抽象类不能被实例化，只能被子类继承，表达is-a的关系<br>\t\t实现代码复用功能<br>\t\t编译器强制要求实现Override抽象方法<br>\t而接口表达has-a关系，表示具有某种功能，表达协议（contract）<br>\t\t侧重于解耦，对行为的一种抽象，表达一组协议或者契约（比如说Cloneable）<br>","like_count":0},{"had_liked":false,"id":310056,"user_name":"Geek_9302c2","can_delete":false,"product_type":"c1","uid":2709278,"ip_address":"","ucode":"42641A1CA55A4F","user_header":"","comment_is_top":false,"comment_ctime":1630472866,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1630472866","product_id":100039001,"comment_content":"FileLogger logger = new FileLogger(&quot;access-log&quot;, true, Level.WARN, &quot;&#47;users&#47;wangzheng&#47;access.log&quot;); logger.log(Level.ERROR, &quot;This is a test log message.&quot;); 这样不就可以了吗？不是学java的，求解答，这样写有什么弊端吗","like_count":0},{"had_liked":false,"id":308517,"user_name":"Geek_7ed5e9","can_delete":false,"product_type":"c1","uid":2572349,"ip_address":"","ucode":"124EFF40E15E6A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Xia3ZAGK5zB9cBbOxAY0dI3JuglaHCtvCI9R2JvJB8ECuu0Ys8tMWGN9HicMl2KxDibqGO2fr9cJGjlOIcKSUdqUA/132","comment_is_top":false,"comment_ctime":1629674971,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1629674971","product_id":100039001,"comment_content":"接口：<br>抽象出某一系列行为，是一种has-a关系，通过接口可以将实现和接口相分离，先定义接口再去实现<br>抽象类：<br>实现公有方法，抽象个性方法 是一种is-a关系，为了代码复用","like_count":0},{"had_liked":false,"id":308037,"user_name":"Geek_6865f5","can_delete":false,"product_type":"c1","uid":2741599,"ip_address":"","ucode":"0367AC106E742F","user_header":"","comment_is_top":false,"comment_ctime":1629364222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629364222","product_id":100039001,"comment_content":"抽象类：","like_count":0},{"had_liked":false,"id":303428,"user_name":"N。","can_delete":false,"product_type":"c1","uid":1647830,"ip_address":"","ucode":"8EE55D4A24004A","user_header":"https://static001.geekbang.org/account/avatar/00/19/24/d6/c65a71b3.jpg","comment_is_top":false,"comment_ctime":1626784033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626784033","product_id":100039001,"comment_content":"狗  人  猫  都会游泳    那就得用接口实现  不能继承","like_count":0},{"had_liked":false,"id":302178,"user_name":"Geek_325846","can_delete":false,"product_type":"c1","uid":2696006,"ip_address":"","ucode":"30BC2FB97C5B42","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DR4kWgpzu27N1Hu6RFVEDxvk1MRBxaB9btc1U82Fo35peVuQDOfUoqia1RU6reH3sXWlxAtvicABiaotibllSnwgmw/132","comment_is_top":false,"comment_ctime":1626106459,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626106459","product_id":100039001,"comment_content":"纠正一点小错误，接口是可以有属性的，并且默认是public static final","like_count":0},{"had_liked":false,"id":296628,"user_name":"奋斗","can_delete":false,"product_type":"c1","uid":2047392,"ip_address":"","ucode":"C84C2D030ACA51","user_header":"https://static001.geekbang.org/account/avatar/00/1f/3d/a0/acf6b165.jpg","comment_is_top":false,"comment_ctime":1623072423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623072423","product_id":100039001,"comment_content":"文中使用 c++ 实现接口的代码中， 析构函数前面应该加 virtual。","like_count":0},{"had_liked":false,"id":296081,"user_name":"mate30","can_delete":false,"product_type":"c1","uid":2636851,"ip_address":"","ucode":"84AF59DD8152A3","user_header":"https://static001.geekbang.org/account/avatar/00/28/3c/33/9958dca6.jpg","comment_is_top":false,"comment_ctime":1622735073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622735073","product_id":100039001,"comment_content":"老师，我有个问题，在项目开发中经常有在接口中使用泛型，那泛型在接口中用作变量（不知道这样描述是否有问题，有错请纠正），是属于成员变量吗","like_count":0},{"had_liked":false,"id":295610,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1622512398,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1622512398","product_id":100039001,"comment_content":"抽象类解决复用问题，表示is-a关系，一般自底向上设计;接口解决抽象问题，表示has-a关系，一般自顶向下设计。","like_count":0},{"had_liked":false,"id":290378,"user_name":"Helios","can_delete":false,"product_type":"c1","uid":1380758,"ip_address":"","ucode":"BE6B98EE8F0D09","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJrOl63enWXCRxN0SoucliclBme0qrRb19ATrWIOIvibKIz8UAuVgicBMibIVUznerHnjotI4dm6ibODA/132","comment_is_top":false,"comment_ctime":1619519094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619519094","product_id":100039001,"comment_content":"抽象类能包含属性和方法，接口不行。<br>抽象类是is a的关系，接口是has a的关系","like_count":0},{"had_liked":false,"id":289392,"user_name":"时光流逝x","can_delete":false,"product_type":"c1","uid":1695455,"ip_address":"","ucode":"D7334E717D9ED0","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqUMEsVYklTc7akT2e6pfytu4jTQ88EVe1H6L2eHdXC6G8sbKCvfrnSDUIRq229M2Wt419LX2q8SQ/132","comment_is_top":false,"comment_ctime":1618995911,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618995911","product_id":100039001,"comment_content":"1.抽象类<br>       定义: 不能被实例化,可以包含普通方法，普通属性和特有的抽象方法抽象方法只能由子类继承且必须全部实现,一个类可以实现多个接口。<br>      * 抽象方法:只是定义一个协议(入参,出参),不考虑具体实现,并且子类必须按照协议内容去实现。<br>2.接口<br>     定义:作为代码间进行数据传输的一个个协议,和抽象方法一样需要定义入参和出参且要求实现接口的类必须做出对应的实现接口本身不允许实例化.一个子类只能继承一个父类(抽象类&#47;普通类).<br><br>两者的共同点和不同点:<br>    1.首先接口本身只包含抽象方法,虽然java可以在接口内使用static或default方法去做一些方法的实现,但是作用应仅限于做补救措施,不是接口的主要用法,接口实际上就是一组定义好的协议里面规定了协议内容（入参,出参），具体做哪些实现接口不关心。<br>      抽象类应该说是在类的基础上增加了接口的特性,普通的类继承后子类可以选择性的去重写一些父类方法,有的时候不应该使用这种模棱两可的做法就使用抽象方法来规范子类的实现,并且由于抽象类具有类的特性，那么除了规范子类以外还可以抽离一些子类之间一些相同的方法进行复用。<br>      所以,接口由于自身就是一组协议重点以抽象方法为主。而抽象类则是普通类的基础上拓展了抽象方法来规范子类实现,抽象方法作为辅助,而重点在于方法的复用。<br>      <br>       <br>","like_count":0},{"had_liked":false,"id":279802,"user_name":"DreamHeng","can_delete":false,"product_type":"c1","uid":1599490,"ip_address":"","ucode":"5562BFD8375138","user_header":"https://static001.geekbang.org/account/avatar/00/18/68/02/2d394d89.jpg","comment_is_top":false,"comment_ctime":1613966925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613966925","product_id":100039001,"comment_content":"从面向对象的角度来看，接口（has-a）是行为、动作的抽象，抽象类（is-a）是对象的抽象，抽象类的对象又不实指某一个对象，而是某一类对象","like_count":0},{"had_liked":false,"id":278772,"user_name":"Geek_e61474","can_delete":false,"product_type":"c1","uid":1433693,"ip_address":"","ucode":"9EE2A63C0CFC7C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2Cudic6gESQc9ibYcBOiazT13hDUaVs4fWlpwsAfvbjazXHMiaibR90TbWtF4Wcujj31Jqiah9TzX8FUlia6A1LibicVhibg/132","comment_is_top":false,"comment_ctime":1613311662,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1613311662","product_id":100039001,"comment_content":"boolean loggable = enabled &amp;&amp; (minPermittedLevel.intValue() &lt;=Level.OFF.intValue() );<br>应该是表达这个意思吧<br>Level.OFF的value 为 MAX_VALUE","like_count":0},{"had_liked":false,"id":276176,"user_name":"世杰","can_delete":false,"product_type":"c1","uid":2415102,"ip_address":"","ucode":"6BC305EF6D525B","user_header":"https://static001.geekbang.org/account/avatar/00/24/d9/fe/7b151abf.jpg","comment_is_top":false,"comment_ctime":1611821961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611821961","product_id":100039001,"comment_content":"实现效果：通过配置动态生成需要的对象，修改需求，只需要修改配置文件，不需要修改代码。<br>对domain对象的调整：<br>&#47;&#47; ImageStore的使用举例<br>public class ImageProcessingJob {<br>    private static final String BUCKET_NAME = &quot;ai_images_bucket&quot;;<br>    private String code;<br>    private ImageSotreManager imageSotreManager;<br><br>    &#47;&#47; 通过外部传的code来动态获取对象，code放在配置文件中<br>    public ImageProcessingJob(String code, ImageSotreManager imageSotreManager) {<br>        this.code = code;<br>        this.imageSotreManager = imageSotreManager;<br>    }<br>    &#47;&#47;...省略其他无关代码...<br><br>    public void process() {<br>        Image image = null;&#47;&#47;处理图片，并封装为Image对象<br>        ImageSotre imageStore = imageSotreManager.getImageStore(code);<br>        imageStore.upload(image, BUCKET_NAME);<br>    }<br>}<br>完整代码地址：https:&#47;&#47;gitee.com&#47;fengzhili123_admin&#47;design_parttern&#47;tree&#47;master&#47;src&#47;main&#47;java&#47;com&#47;wangzheng&#47;image","like_count":0},{"had_liked":false,"id":274258,"user_name":"刘立嘉","can_delete":false,"product_type":"c1","uid":2414637,"ip_address":"","ucode":"1241140EBE7FE3","user_header":"https://static001.geekbang.org/account/avatar/00/24/d8/2d/6ec3760c.jpg","comment_is_top":false,"comment_ctime":1610943548,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610943548","product_id":100039001,"comment_content":"接口是真正的面向对象的存在物，它定义了类于类之间的has-a关系，所有实现了该接口的类，都具有共同性，即都需要实现接口中定义的方法，使得这些类都具有了共同点，那么在声明类实例的时候，可以是&lt;接口类&gt; variable = new &lt;实现类&gt;, 这种方法最开始定义接口时，毫不关心每个方法的实现，只看我想要这些类具有什么共同特性。","like_count":0},{"had_liked":false,"id":268245,"user_name":"Hi Young","can_delete":false,"product_type":"c1","uid":1548645,"ip_address":"","ucode":"E1E9C88399F3C2","user_header":"https://static001.geekbang.org/account/avatar/00/17/a1/65/44853770.jpg","comment_is_top":false,"comment_ctime":1608111775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608111775","product_id":100039001,"comment_content":"接口vs抽象类，准备面试的可以瞅瞅，一个小表格<br><br>https:&#47;&#47;www.yuque.com&#47;zhaohaiyang&#47;notes&#47;pragkx#i8kyM","like_count":0},{"had_liked":false,"id":263619,"user_name":"初学者","can_delete":false,"product_type":"c1","uid":2331845,"ip_address":"","ucode":"A6B5DDB0FCD5EC","user_header":"https://static001.geekbang.org/account/avatar/00/23/94/c5/67fa8668.jpg","comment_is_top":false,"comment_ctime":1606199281,"is_pvip":false,"replies":[{"id":"96089","content":"没错","user_name":"作者回复","comment_id":263619,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700707,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1606199281","product_id":100039001,"comment_content":"抽象类做于代码复用，接口做于代码扩展","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510250,"discussion_content":"没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261513,"user_name":"刘永超","can_delete":false,"product_type":"c1","uid":2066121,"ip_address":"","ucode":"94CCA30F9E1567","user_header":"https://static001.geekbang.org/account/avatar/00/1f/86/c9/456f803d.jpg","comment_is_top":false,"comment_ctime":1605368513,"is_pvip":false,"replies":[{"id":"96142","content":"嗯嗯 是的","user_name":"作者回复","comment_id":261513,"uid":"1190123","ip_address":"","utype":1,"ctime":1606701411,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1605368513","product_id":100039001,"comment_content":"从语法特性区分抽象类和接口是比较实在的，对于语法特性，不能死记，但是理解记忆是必须的。也许对于高手来讲，语法太浅显了，但对于刚入门的人来说，语法是重要的基础。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509505,"discussion_content":"嗯嗯 是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606701411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255854,"user_name":"Jupiter","can_delete":false,"product_type":"c1","uid":2125382,"ip_address":"","ucode":"072E5C34CDE8AC","user_header":"https://static001.geekbang.org/account/avatar/00/20/6e/46/a612177a.jpg","comment_is_top":false,"comment_ctime":1603444395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603444395","product_id":100039001,"comment_content":"四年没写Java了，当老师说到interface不能定义属性时，我突然想到自己每天写的interface都是在定义属性，因为用的语言是Typescript. 在Typescript里面， interface 是用来定义 data shape的，感觉也就是属性。感觉Typescript 应该把interface 换个名字， 哈哈","like_count":0},{"had_liked":false,"id":252158,"user_name":"俄国的一盘桃子","can_delete":false,"product_type":"c1","uid":2220264,"ip_address":"","ucode":"DB9BFB35A54377","user_header":"https://static001.geekbang.org/account/avatar/00/21/e0/e8/a2d033fa.jpg","comment_is_top":false,"comment_ctime":1602150807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602150807","product_id":100039001,"comment_content":"我总感觉接口不能归属为has-a，组合的表现才更能说明has-a","like_count":0},{"had_liked":false,"id":251323,"user_name":"微末凡尘","can_delete":false,"product_type":"c1","uid":1099525,"ip_address":"","ucode":"25EDFD0914D0F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","comment_is_top":false,"comment_ctime":1601463778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601463778","product_id":100039001,"comment_content":"还记得有一次做支付相关的需求，用到了模板设计模式，问领导为什么非要用接口，用抽象不行么，当时也没有说出一个所以然来，看了这篇文章，真的是醍醐灌顶了，以后再也不用纠结用抽象类还是接口类了，抽象类是为了解决代码复用的问题，是is-a的关系，而接口是为了解决抽象的问题，是has-a的关系。","like_count":0},{"had_liked":false,"id":249676,"user_name":"朱月俊","can_delete":false,"product_type":"c1","uid":1017707,"ip_address":"","ucode":"4DA0728B862FBD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/6b/0b6cd39a.jpg","comment_is_top":false,"comment_ctime":1600755129,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600755129","product_id":100039001,"comment_content":"go语言。<br>直接支持interface。<br>没有继承特性，会用组合特性来实现继承，也能解决代码复用的问题。","like_count":0},{"had_liked":false,"id":248660,"user_name":"染指青春的狮子","can_delete":false,"product_type":"c1","uid":2162391,"ip_address":"","ucode":"DE439965EF135C","user_header":"https://static001.geekbang.org/account/avatar/00/20/fe/d7/f89c1f1a.jpg","comment_is_top":false,"comment_ctime":1600255495,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600255495","product_id":100039001,"comment_content":"C++中不能实现的类成员函数应该是纯虚函数。C++primer 5th，15章抽象基类有讲，抽象基类负责定义接口","like_count":0},{"had_liked":false,"id":245745,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599039800,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599039800","product_id":100039001,"comment_content":"问题一：<br>java，有<br>abstract class BaseA<br>interface InterB<br>问题二：<br>从is-a和has-a的角度去回答。为了复用还是为了解耦，降低复杂性。<br>","like_count":0},{"had_liked":false,"id":241123,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1597196741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597196741","product_id":100039001,"comment_content":"何时使用\t表达关系\t解决问题\t设计思路<br>抽象类\tis-a\t\t代码复用\t自下而上<br>接口\t\thas-a\t抽象解耦\t自上而下<br>","like_count":0},{"had_liked":false,"id":240370,"user_name":"Ilearning99","can_delete":false,"product_type":"c1","uid":1989119,"ip_address":"","ucode":"7901836A2C47EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/qOdqzmC507sibL6sichNSDaVmyoMKibEIqHWpic4CftgOQnoA3QKeRPwic9j1Ha8MLtzzqzfSRavR9GWMju09SMADUg/132","comment_is_top":false,"comment_ctime":1596878328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596878328","product_id":100039001,"comment_content":"1 C# abstract抽象类 interface接口<br>2 抽象类表示has-a 是一种代码复用，接口是is-a关系，不能定义属性和实现函数。","like_count":0},{"had_liked":false,"id":239895,"user_name":"Q罗","can_delete":false,"product_type":"c1","uid":1792098,"ip_address":"","ucode":"E797378F4DA1F4","user_header":"https://static001.geekbang.org/account/avatar/00/1b/58/62/346dd248.jpg","comment_is_top":false,"comment_ctime":1596686599,"is_pvip":false,"replies":[{"id":"89228","content":"������ 你说的没错","user_name":"作者回复","comment_id":239895,"uid":"1190123","ip_address":"","utype":1,"ctime":1597412065,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1596686599","product_id":100039001,"comment_content":"子类继承抽象类，如果这个子类也是一个抽象类，那这个子类就不是必须实现父类的抽象方法了吧？","like_count":0,"discussions":[{"author":{"id":1476490,"avatar":"https://static001.geekbang.org/account/avatar/00/16/87/8a/07ab933c.jpg","nickname":"璀璨星空","note":"","ucode":"CE6324C4261A52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380586,"discussion_content":"多此一举了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624592757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133206,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4a/96/8756eaa2.jpg","nickname":"王也","note":"","ucode":"9EA69B51ECC99F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378201,"discussion_content":"没什么意义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623111347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1740368,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKhr1LrBZQTnn5PgyuHUtia6j6tiahZyk44BWeB5LQIqMgTDBdibGKVVopbJWbz83ZWvyVPz9fBl69rw/132","nickname":"Geek_b6e449","note":"","ucode":"8296078ED23637","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289546,"discussion_content":"是不需要的 比如你现在获取一条delete 一条insert 那么map先删除在新增 效果是一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594133100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238330,"user_name":"yangcnb","can_delete":false,"product_type":"c1","uid":1762110,"ip_address":"","ucode":"063DC9D9670D4C","user_header":"","comment_is_top":false,"comment_ctime":1596122897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596122897","product_id":100039001,"comment_content":"这个专栏对于我这种机缘巧合晋升为后端负责人，对代码质量把控无从下手的人来说，简直是天降神兵，文章所有的不好做法全部命中，哈哈。","like_count":0},{"had_liked":false,"id":238184,"user_name":"owen","can_delete":false,"product_type":"c1","uid":1902116,"ip_address":"","ucode":"0E79DA9080A085","user_header":"https://static001.geekbang.org/account/avatar/00/1d/06/24/c2ee3b16.jpg","comment_is_top":false,"comment_ctime":1596091275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596091275","product_id":100039001,"comment_content":"接口只定义不实现好比一种协议要用我的必须先遵巡协议实现方法<br>抽象类好比一种功能每个继承的对象都有类似的功能，但是也可以自定义这个功能","like_count":0},{"had_liked":false,"id":237988,"user_name":"汉江","can_delete":false,"product_type":"c1","uid":1788647,"ip_address":"","ucode":"01622D984B8F9B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","comment_is_top":false,"comment_ctime":1596022988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596022988","product_id":100039001,"comment_content":"我觉得抽象就是抽出共性，留下扩展，而且扩展一般都是子类必须实现的，接口是某的行为规范，是所有子类必须遵循的","like_count":0},{"had_liked":false,"id":237960,"user_name":"ʸᵉ ᶠᵉᶮᵍ","can_delete":false,"product_type":"c1","uid":1280969,"ip_address":"","ucode":"BD6B8B01F78A21","user_header":"https://static001.geekbang.org/account/avatar/00/13/8b/c9/4281a2a3.jpg","comment_is_top":false,"comment_ctime":1596014544,"is_pvip":false,"replies":[{"id":"88022","content":"嗯嗯 你的表述更准确些","user_name":"作者回复","comment_id":237960,"uid":"1190123","ip_address":"","utype":1,"ctime":1596109659,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"1596014544","product_id":100039001,"comment_content":"老师老师，我想补充一下，什么时候使用抽象类这个问题。文章中说如果要is-a关系就用抽象类，感觉这个答案有点不标准，is-a关系也可以用普通类来实现代码复用问题。更标准的答案是不是如果既有代码复用问题，子类又一定要实现多态关系的时候才用抽象类。这个答案是不是准确，请老师指点一下。","like_count":0,"discussions":[{"author":{"id":1744992,"avatar":"","nickname":"Geek_76616d","note":"","ucode":"809765A24C4E70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200317,"discussion_content":"为啥不常用，实际业务经常有类似场景啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583675354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108132,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e8/a4/0be8a8ca.jpg","nickname":"CAFEBABE","note":"","ucode":"01F6BC01A4EFE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202225,"discussion_content":"Spring的BeanUtils还是很方便、很常用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583888637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235967,"user_name":"Apologize","can_delete":false,"product_type":"c1","uid":1503320,"ip_address":"","ucode":"F2F179241EDA4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/f0/58/87104eab.jpg","comment_is_top":false,"comment_ctime":1595257689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595257689","product_id":100039001,"comment_content":"1、使用的是Java编程语言，Java对抽象类和接口有完整的支持，分别通过关键字abstract和interface实现。<br>2、如果是回答面试官的问题，考虑从以下几个方面：<br>     1）、抽象类和接口的定义<br>     2）、抽象类和接口出现的目的<br>     3）、两者语义上的差别以及使用的场景。","like_count":0},{"had_liked":false,"id":232527,"user_name":"雨天的七毫米","can_delete":false,"product_type":"c1","uid":1865908,"ip_address":"","ucode":"963BBAFE8EF97B","user_header":"https://static001.geekbang.org/account/avatar/00/1c/78/b4/af163d12.jpg","comment_is_top":false,"comment_ctime":1594028210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594028210","product_id":100039001,"comment_content":"这一节让我很受启发，接口和抽象类的区别当然是显而易见的，使用接口+类的等效替代=抽象类，他们的区别就需要好好想想了","like_count":0},{"had_liked":false,"id":230084,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1593253616,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593253616","product_id":100039001,"comment_content":"接口表达的是has a的关系，即有哪些能力。<br>而抽象类表示的是is a的关系。<br>抽象类解决的是能力复用问题，接口是解决扩展性问题。","like_count":0},{"had_liked":false,"id":228736,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1592796686,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592796686","product_id":100039001,"comment_content":"抽象类是is-a，接口是has-a关系。<br>抽象类存在属性和实现方法和抽象方法。继承的非抽象类必须实现抽象方法。目的是代码复用，而抽象方法实现了多态的概念。<br>接口不存在属性，只有没有实现的方法。可以理解为对外协议。解耦代码实现和定义。","like_count":0},{"had_liked":false,"id":228313,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1592639879,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592639879","product_id":100039001,"comment_content":"我觉得接口在聚合方面也有优势，相比抽象类，聚合条件更加宽松，更能体现出协议的优势。","like_count":0},{"had_liked":false,"id":227393,"user_name":"学斌","can_delete":false,"product_type":"c1","uid":1137880,"ip_address":"","ucode":"ED3432D8EDC327","user_header":"https://static001.geekbang.org/account/avatar/00/11/5c/d8/dfe1d4dc.jpg","comment_is_top":false,"comment_ctime":1592371001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592371001","product_id":100039001,"comment_content":"接口：无状态的行为的抽像<br>抽象类：有状态的行为抽象<br>比如<br>抽象类：人 ,子类：（男人，女人）（黄种人，黑人，白人）<br>性格接口   ：懒惰，勤奋 ，暴躁.....","like_count":0},{"had_liked":false,"id":226530,"user_name":"Chris Zou","can_delete":false,"product_type":"c1","uid":1897148,"ip_address":"","ucode":"B6DFC71C1DD8B7","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f2/bc/ffc7ad67.jpg","comment_is_top":false,"comment_ctime":1592129393,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592129393","product_id":100039001,"comment_content":"C++语言；抽象类通过包含纯虚函数的类来实现，也就是该方法只有接口没有实现，需要子类来继承实现；接口没有直接的语法，可以用一个只包含纯虚函数的类来实现。","like_count":0},{"had_liked":false,"id":226051,"user_name":"HoSalt","can_delete":false,"product_type":"c1","uid":1156074,"ip_address":"","ucode":"610B03E2A002D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","comment_is_top":false,"comment_ctime":1591936629,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591936629","product_id":100039001,"comment_content":"<br>Logger logger = new FileLogger(&quot;access-log&quot;, true, Level.WARN, &quot;&#47;users&#47;wangzheng&#47;access.log&quot;);<br>logger.log(Level.ERROR, &quot;This is a test log message.&quot;);<br>这代码为什么会出错（没学过java），不是只做了实例化的操作吗？log不是实现在子类上吗，难道不行?","like_count":0},{"had_liked":false,"id":225558,"user_name":"DY","can_delete":false,"product_type":"c1","uid":1459006,"ip_address":"","ucode":"55536A524A99B4","user_header":"https://static001.geekbang.org/account/avatar/00/16/43/3e/960d12cb.jpg","comment_is_top":false,"comment_ctime":1591785471,"is_pvip":false,"replies":[{"id":"84977","content":"在某些场景下，接口更好用，更能表达业务含义。这就类似，吃馒头能吃饱，为啥还要吃肉一个道理，更香！","user_name":"作者回复","comment_id":225558,"uid":"1190123","ip_address":"","utype":1,"ctime":1593310957,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1591785471","product_id":100039001,"comment_content":"既然接口能实现的功能抽象类都能实现， 为什么还要用接口？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497895,"discussion_content":"在某些场景下，接口更好用，更能表达业务含义。这就类似，吃馒头能吃饱，为啥还要吃肉一个道理，更香！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593310957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216974,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1589379496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589379496","product_id":100039001,"comment_content":"1、抽象类<br><br>抽象类是通过abstract关键字修饰的类，抽象类不能被实例化，不能被final修饰之外和普通类没有区别，可以拥有属性和普通方法。<br><br>抽象方法是通过abstract关键字修饰的方法，抽象方法不被static修饰。<br><br>抽象类可以没有抽象方法，但是抽象方法必须属于抽象类。<br><br>没有抽象方法的抽象类的作用是防止实例化。<br><br>抽象类的子类如果不是抽象类，那么必须重写父类中所有抽象方法。<br><br><br><br>作用：<br><br>（1）抽象类也能被继承，所以首先抽象类可用于代码复用。比起普通类来说抽象类可以强制子类进行重写抽象方法，因此可以避免子类忘记重写导致的bug。抽象类常用语模板模式。<br><br>（2）当我们希望某些类不能实例化时，就需要使用抽闲类，防止类被错误的实例化。<br><br><br><br>2、接口<br><br>接口不能包含属性，只能声明方法，1.8以后可有default方法。<br><br>接口实现类必须实现所有非default方法。<br><br>接口是为了解耦，是对具体实现的一种抽象，可以降低代码之间的耦合，提高代码的可读性。<br><br><br><br>3、该用接口还是抽象类<br><br>抽象类实际就是类，只是这种类只能继承不能被实例化，抽象类和子类也是一种is a 的关系，为的是代码复用。<br><br>接口或者说是协议，表示实现类拥有什么能力，是一种has a的关系，或者behaive like，为的是代码解耦。","like_count":0},{"had_liked":false,"id":216337,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1589244358,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589244358","product_id":100039001,"comment_content":"抽象和接口<br>1，是什么：<br>①两者都是特殊的类<br>②抽象类可以有成员变量，普通方法，抽象方法<br>③接口只能有为被实现的方法，java8中增加了一个默认方法<br>2 为什么<br>①：抽象类是为了解决代码复用的问题<br>②：接口是为了解决抽象的问题<br><br>3 何时用<br>如果要解决代码复用的问题可以优先考虑抽象类<br>如果要解决代码抽象问题可以考虑使用接口<br><br>抽象类是一种自底向上的思考方法，而接口是自顶向下的思考","like_count":0},{"had_liked":false,"id":214495,"user_name":"大圣代","can_delete":false,"product_type":"c1","uid":1003080,"ip_address":"","ucode":"8A59114C8345C8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/48/bb0136d1.jpg","comment_is_top":false,"comment_ctime":1588758345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588758345","product_id":100039001,"comment_content":"抽象类是自下而上的 -&gt; 先有子类的具体实现然后从中抽出公共固定行为、公共可变行为，构成了抽象类。<br>接口是自上而下的-&gt; 先定义统一行为，将可变部分转化为固定方法，然后在具体实现。","like_count":0,"discussions":[{"author":{"id":2085090,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","nickname":"写代码的","note":"","ucode":"F58186409A3D65","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300571,"discussion_content":"容器类不关心元素的结构，所以不用想都是浅拷贝","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598176367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2551566,"avatar":"https://static001.geekbang.org/account/avatar/00/26/ef/0e/bbc35830.jpg","nickname":"一杯绿绿","note":"","ucode":"1ADE60EAC76167","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2085090,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","nickname":"写代码的","note":"","ucode":"F58186409A3D65","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558809,"discussion_content":"jdk clone 的设计思想可能是：默认的 clone 不关心对象的结构，如果想实现深拷贝（关注对象的结构），则自己去实现 clone 做定制化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648475588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300571,"ip_address":""},"score":558809,"extra":""}]},{"author":{"id":1033240,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkwbyTYtSCx6Qc7cQPnnRWv38Jybh3etziaPmuP8gHcgS6FMxcdftrKgWiamH6fc2iciaicDKDVEwcEibQ/132","nickname":"sami","note":"","ucode":"9A66FCA00D8A37","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":195745,"discussion_content":"个人理解：copyonwrite在没有发生变化的时候只有一份数据，需要改变数据的时候才copy一份数据出来的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583303471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1147453,"avatar":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","nickname":"忆水寒","note":"","ucode":"E3F86BD8AA8903","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1033240,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkwbyTYtSCx6Qc7cQPnnRWv38Jybh3etziaPmuP8gHcgS6FMxcdftrKgWiamH6fc2iciaicDKDVEwcEibQ/132","nickname":"sami","note":"","ucode":"9A66FCA00D8A37","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":195795,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583309741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":195745,"ip_address":""},"score":195795,"extra":""}]},{"author":{"id":1212750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","nickname":"夏目","note":"","ucode":"67C075A01CF4D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":247782,"discussion_content":"上面有人说是浅拷贝，如果是浅拷贝那么copy之后修改数据不就是修改原数据了吗，读取就有问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587824703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1510495,"avatar":"https://static001.geekbang.org/account/avatar/00/17/0c/5f/4cbcbfb9.jpg","nickname":"hello","note":"","ucode":"C6FC61A90F202B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1212750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","nickname":"夏目","note":"","ucode":"67C075A01CF4D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269168,"discussion_content":"写时复制 应该是 没写之前浅拷贝，写的时候深拷贝。所以是两者的结合","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1589874362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":247782,"ip_address":""},"score":269168,"extra":""},{"author":{"id":1004264,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/e8/92a2e66d.jpg","nickname":"第二少","note":"","ucode":"4A09D1E7589F67","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1212750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","nickname":"夏目","note":"","ucode":"67C075A01CF4D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303834,"discussion_content":"可以采用本课讲的思路，先浅拷贝，修改时，不直接修改容器中的对象，而是先从容器中移除，再创建一个新对象，包含新数据，再把新对象放到容器中","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1599391401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":247782,"ip_address":""},"score":303834,"extra":""},{"author":{"id":1651664,"avatar":"https://static001.geekbang.org/account/avatar/00/19/33/d0/962ebe2e.jpg","nickname":"Buring","note":"","ucode":"0AAEA64C63C2F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1212750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","nickname":"夏目","note":"","ucode":"67C075A01CF4D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309520,"discussion_content":"你的思路我个人感觉其实不太适合CopyOnWriteList，首先它的读操作都没有加锁，是在底层array被修改之前，都是读的默认的共享内存数据（也就对应文中的先浅拷贝，意思差不多）。差异点主要在修改时，文中的删除原对象，再新建对象是为了解决版本差异化的。但是如果在CopyOnWriteList类里也这样做就违背了：迭代器迭代过程中其他线程修改原数组后，数据不一致性。因为目前CopyOnWriteList返回的迭代器里的next方法是没有做checkModificationException的，因为它依仗的就是写操作都是拷贝一份数据修改然后切换，那就是相当于一个没有做ConcurrentModificationException处理的快速失败机制程序！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601314048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":247782,"ip_address":""},"score":309520,"extra":""}]},{"author":{"id":1254493,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","nickname":"听雨","note":"","ucode":"252754F9FCFF0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218911,"discussion_content":"copy的时候是浅拷贝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585712979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203822,"discussion_content":"copyonwrite是浅拷贝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584087394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1086407,"avatar":"https://static001.geekbang.org/account/avatar/00/10/93/c7/86352ccc.jpg","nickname":"1024","note":"","ucode":"DCC31F6EC54F43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199208,"discussion_content":"是的\npublic boolean add(E e) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            Object[] elements = getArray();\n            int len = elements.length;\n            Object[] newElements = Arrays.copyOf(elements, len + 1);\n            newElements[len] = e;\n            setArray(newElements);\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583570484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212505,"user_name":"Doctor Lau","can_delete":false,"product_type":"c1","uid":1018266,"ip_address":"","ucode":"4B685CF1582BC4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/9a/51e87979.jpg","comment_is_top":false,"comment_ctime":1588138660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588138660","product_id":100039001,"comment_content":"到底实现接口是is a还是has a这是个问题，可能要看场景吧，功能性接口才勉强能算has a关系吧","like_count":0},{"had_liked":false,"id":208164,"user_name":"carl","can_delete":false,"product_type":"c1","uid":1593385,"ip_address":"","ucode":"7C725C7D69855F","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqD7goM3NZGb77qicnUHX8qdrXpIH89Ziaul2475ko5VMpFxiajbQsJhv2aG0HxmX8vgswfz9WkvElBg/132","comment_is_top":false,"comment_ctime":1587287679,"is_pvip":false,"replies":[{"id":"86633","content":"新版本的可以！","user_name":"作者回复","comment_id":208164,"uid":"1190123","ip_address":"","utype":1,"ctime":1594785934,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1587287679","product_id":100039001,"comment_content":"Java 中接口可以有属性的吧？","like_count":0,"discussions":[{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278823,"discussion_content":"表诉没有问题。你在多读读看。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1591238884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1517234,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epzA7E8kS3g2n4nTK2lcfbyR7kQJnsFZ6hw3RjfuDcicEDfyeavN2fVEtRPCLTn6NcdVjMfBLEibiauw/132","nickname":"Geek_anchor","note":"","ucode":"AC094AD2C4F9D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225416,"discussion_content":"没有问题的。有充分理由才推荐使用浅拷贝，一般情况下使用深拷贝。在生产环境下，使用浅拷贝可能出现同事误操作浅拷贝对象，导致正常运行的代码出现问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586357965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1459863,"avatar":"https://static001.geekbang.org/account/avatar/00/16/46/97/ddd4b05f.jpg","nickname":"爱上我们的微笑","note":"","ucode":"40CDB7AB0991CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385753,"discussion_content":"作者说的没问题。耗时非常久，推荐浅拷贝。评估风险收益","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627263400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207303,"user_name":"geosmart","can_delete":false,"product_type":"c1","uid":1435611,"ip_address":"","ucode":"7DCBA2F120442D","user_header":"https://static001.geekbang.org/account/avatar/00/15/e7/db/1ad86e94.jpg","comment_is_top":false,"comment_ctime":1587044732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587044732","product_id":100039001,"comment_content":"自下而上思考是-重构abstract抽象类，自上而下表达-设计interface协议","like_count":0},{"had_liked":false,"id":203161,"user_name":"酸辣土豆丝","can_delete":false,"product_type":"c1","uid":1751234,"ip_address":"","ucode":"0E3E4AFB31E1E6","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b8/c2/d1904d74.jpg","comment_is_top":false,"comment_ctime":1586145975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586145975","product_id":100039001,"comment_content":"会从定义，应用场景，为什么会存在，三个方面讲；Python语言确实没有抽象类和接口的相关语法，不过可以从各自的定义形式上进行模拟","like_count":0},{"had_liked":false,"id":202690,"user_name":"技术骨干","can_delete":false,"product_type":"c1","uid":1098720,"ip_address":"","ucode":"8FCF8DE6D29201","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/e0/3db22579.jpg","comment_is_top":false,"comment_ctime":1586053848,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586053848","product_id":100039001,"comment_content":"抽象类：描述的是一种is-a 的关系<br>接口：描述的是一种通用行为的能力，多用在行为设计模式当中。","like_count":0},{"had_liked":false,"id":201809,"user_name":"王坤祥","can_delete":false,"product_type":"c1","uid":1003327,"ip_address":"","ucode":"FB988B9F381A33","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4f/3f/6f62f982.jpg","comment_is_top":false,"comment_ctime":1585839738,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585839738","product_id":100039001,"comment_content":"变化的代码实现，比如一些变量（非常量），就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。<br><br>对修改关闭，对扩展（不同的实现implements）开放，接口是对开闭原则的一种体现。","like_count":0},{"had_liked":false,"id":200078,"user_name":"Marvichov","can_delete":false,"product_type":"c1","uid":1111835,"ip_address":"","ucode":"7482099415C41C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","comment_is_top":false,"comment_ctime":1585540368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585540368","product_id":100039001,"comment_content":"Pure virtual function是可以有default实现的。在子类实现的时候，可以explicitly调用。这种设计思路是提供一个common default，但是client继承的时候得explicit声明。","like_count":0},{"had_liked":false,"id":199851,"user_name":"Go","can_delete":false,"product_type":"c1","uid":1238222,"ip_address":"","ucode":"A5EFBE288C9A54","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/ce/6af1bf02.jpg","comment_is_top":false,"comment_ctime":1585496957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585496957","product_id":100039001,"comment_content":"知其然知其所以然😊","like_count":0},{"had_liked":false,"id":198460,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585452749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585452749","product_id":100039001,"comment_content":"你确定用protected关键字能够防止被实例化么，在模拟接口那里","like_count":0},{"had_liked":false,"id":197733,"user_name":"白杨","can_delete":false,"product_type":"c1","uid":1743868,"ip_address":"","ucode":"B56DD94706F80B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9b/fc/a3abbe53.jpg","comment_is_top":false,"comment_ctime":1585395769,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585395769","product_id":100039001,"comment_content":" 那么面向接口编程，广义上也应该包括面向抽象类编程吧，而不应该是为了使用接口而强制抽象类必须实现一个接口，对吧老师。","like_count":0},{"had_liked":false,"id":196853,"user_name":"猎手","can_delete":false,"product_type":"c1","uid":1802509,"ip_address":"","ucode":"438C14B0045387","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJYQ2t5vVmVJxT0icdu7fhWXb9Ln7IM9PgOMnFyzrRZELBk7Cv79kBEqaCJDzg4evEicT7MsLx9BKYg/132","comment_is_top":false,"comment_ctime":1585318496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585318496","product_id":100039001,"comment_content":"as a,has a经典","like_count":0},{"had_liked":false,"id":195623,"user_name":"改名不换人","can_delete":false,"product_type":"c1","uid":1118242,"ip_address":"","ucode":"7E25577829FA0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/22/910f705c.jpg","comment_is_top":false,"comment_ctime":1585206190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585206190","product_id":100039001,"comment_content":"做个笔记：<br>1 接口：不能被实例化，不能有属性和被实现的方法，只能拥有方法定义（jdk8 以后可以通过default定义一个有实现的默认方法），实现交给实现类去完成，是一类行为的抽象，用于解耦合。<br>2 抽象类：不能被实例化，可以有属性和被实现的方法，也可以有方法定义(抽象方法)，子类必须实现抽象类中的抽象方法，用于解决代码复用的问题。","like_count":0},{"had_liked":false,"id":194841,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1585109634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585109634","product_id":100039001,"comment_content":"我是一个菜鸡前端，说实话，没太看懂。可能在 TS 有接口和抽象类的概念，但是我现在不是很了解。<br><br>只记住了一点接口是为了解耦代码，抽象类是为了复用代码<br>","like_count":0},{"had_liked":false,"id":193149,"user_name":"永胜","can_delete":false,"product_type":"c1","uid":1364971,"ip_address":"","ucode":"EF6E8E80F67D9E","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/eb/f941509f.jpg","comment_is_top":false,"comment_ctime":1584884886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584884886","product_id":100039001,"comment_content":"加深了接口和抽象的原理，在具体某个开发语言下还是需要活学活用","like_count":0},{"had_liked":false,"id":193091,"user_name":"InfoQ_94b11bfe2807","can_delete":false,"product_type":"c1","uid":1296312,"ip_address":"","ucode":"644EAA4032D323","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKibEUVoa39YOVxTbcORR8XK7rB7CiadBRFgUENuggRViaYRkj2SyEib64QmNQOm9or6QZDaszzqX9DTw/132","comment_is_top":false,"comment_ctime":1584883717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584883717","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":190250,"user_name":"索旭东","can_delete":false,"product_type":"c1","uid":1139039,"ip_address":"","ucode":"BFD07BCD8C8CAE","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/5f/b279daaf.jpg","comment_is_top":false,"comment_ctime":1584622539,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584622539","product_id":100039001,"comment_content":"抽象类就是一个类中可以有些抽象方法","like_count":0},{"had_liked":false,"id":189437,"user_name":"治慧","can_delete":false,"product_type":"c1","uid":1245904,"ip_address":"","ucode":"47C331EF63EDC6","user_header":"https://static001.geekbang.org/account/avatar/00/13/02/d0/8abab63f.jpg","comment_is_top":false,"comment_ctime":1584515937,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584515937","product_id":100039001,"comment_content":"其实工作中定义接口还是定义抽象方法,给人的感觉是当我们要暴露的时候用接口,比如rpc接口给其他服务来进行远程调用  抽象方法的感觉是我们将一些相识的类的共同属性进行向上抽取出来一个类叫抽象类","like_count":0},{"had_liked":false,"id":185382,"user_name":"yan","can_delete":false,"product_type":"c1","uid":1667264,"ip_address":"","ucode":"BA33B672798AEE","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/c0/b365a317.jpg","comment_is_top":false,"comment_ctime":1583571046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583571046","product_id":100039001,"comment_content":"抽象类是一种自下而上的设计思路，一般用来解决代码复用问题（发现代码可以复用--&gt;提取公共父类）；接口是一种自上而下的设计思路，一般用来解决抽象而非代码复用的问题（设计接口--&gt;实现接口）。","like_count":0},{"had_liked":false,"id":184995,"user_name":"Mark","can_delete":false,"product_type":"c1","uid":1054152,"ip_address":"","ucode":"0DF6D68131F79B","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/c8/65ed960c.jpg","comment_is_top":false,"comment_ctime":1583464411,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583464411","product_id":100039001,"comment_content":"Jdk8<br>接口可以有成员变量 和  实现方法","like_count":0},{"had_liked":false,"id":184602,"user_name":"新的起点，新的开始^_^","can_delete":false,"product_type":"c1","uid":1262068,"ip_address":"","ucode":"9C0810F472AC93","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/f4/5df17eff.jpg","comment_is_top":false,"comment_ctime":1583369994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583369994","product_id":100039001,"comment_content":"争哥，我有个这样的想法，不知道对不对，在我们的java开发中，我设计一个basicService接口,里面只有四个方法，insert(Object object),以及delete，update和query,然后项目中的所有实现类都实现这个接口，在重写的方法中去强转pojo类，然后各自再实现自己特有的接口，这样怎么样呢？<br>第一点，肯定会有这种情况，并不是所有的实现类都需要curd，但实现类中也必须得重写了","like_count":0,"discussions":[{"author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189439,"discussion_content":"外部得到深拷贝对象A之后,如果对 A 修改, 并不会影响到内部的对象","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582882575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1738326,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","nickname":"守拙","note":"","ucode":"F594B2DA3F6D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":183326,"discussion_content":"如果你返回shallow copy的items, 调用者可以取出items中的一个, 进行修改.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582471706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184068,"user_name":"彭汤宇","can_delete":false,"product_type":"c1","uid":1160325,"ip_address":"","ucode":"72BDD100CB373A","user_header":"https://static001.geekbang.org/account/avatar/00/11/b4/85/e21fc61b.jpg","comment_is_top":false,"comment_ctime":1583217557,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583217557","product_id":100039001,"comment_content":"接口只能声明方法，方法不能包含代码实现。<br>老师，在JDK8后是可以在接口中包含带有具体实现的方法，我觉得这块还是要区分一下。","like_count":0},{"had_liked":false,"id":183455,"user_name":"空白昵称","can_delete":false,"product_type":"c1","uid":1433815,"ip_address":"","ucode":"91F50CA25102AB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","comment_is_top":false,"comment_ctime":1583044859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583044859","product_id":100039001,"comment_content":"Swift中的协议相当于“包含了”抽象类和接口的概念。可以关联类型，然后添加方法、属性。且可以通过extension扩展默认实现方法。从而达到代码复用和抽象解藕的目的。通也必须通过类遵循协议才能使用。","like_count":0},{"had_liked":false,"id":182992,"user_name":"ladidili","can_delete":false,"product_type":"c1","uid":1217498,"ip_address":"","ucode":"38886C1908DE6B","user_header":"https://static001.geekbang.org/account/avatar/00/12/93/da/0e47c76e.jpg","comment_is_top":false,"comment_ctime":1582903135,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582903135","product_id":100039001,"comment_content":"感觉就是没有了多继承，所以需要一个东西来做抽象，就是接口。而且接口当做协议确实好理解一些。我实现一个大功能，可能需要组合实现不同的接口协议，才能完成一个大功能。可以组合遵守不同的协议实现不同的功能","like_count":0},{"had_liked":false,"id":182720,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1582855773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582855773","product_id":100039001,"comment_content":"从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。抽象类可以在后续重构中使用。所以可以不上来就使用抽象类。看看变化在调整。接口与抽象类在代码设计过程中也可以相互转换","like_count":0},{"had_liked":false,"id":180828,"user_name":"Warming","can_delete":false,"product_type":"c1","uid":1024679,"ip_address":"","ucode":"BD1283D003F5BC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a2/a7/37cbf5f7.jpg","comment_is_top":false,"comment_ctime":1582423428,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582423428","product_id":100039001,"comment_content":"抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。<br>当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。","like_count":0},{"had_liked":false,"id":180781,"user_name":"Geek_33785c","can_delete":false,"product_type":"c1","uid":1487529,"ip_address":"","ucode":"CF1ABC5F962EC8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7nnI7sIWC91S5BvdBTLUApySCKdALjklLWGuXFJQ9Wyu1l5gMk6dgu2CVOtYicb3iaUNxV4ghUb4dMryDJgOXCbH/132","comment_is_top":false,"comment_ctime":1582385637,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1582385637","product_id":100039001,"comment_content":"Typescript 的接口为什么就可以包含属性呢","like_count":0},{"had_liked":false,"id":180627,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1582354741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582354741","product_id":100039001,"comment_content":"接口和抽象类：1、首先是有各自的语意特性；2、抽象是为了代码复用，可以做到优雅；接口是定义协议，隔离接口和实现，为了解偶；<br>第一感觉是迷糊的，自己做一下笔记感觉又清晰了一些，最后觉得还是没吃透","like_count":0},{"had_liked":false,"id":179709,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582081799,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582081799","product_id":100039001,"comment_content":"对于问题一来说,因为一种用的是Java,提供了抽象类和接口的概念,可以直接使用,其中抽象类使用了关键字abstarct,接口使用了关键字interface<br>对于问题二,经过这几天的学习,有了一个新的认识,一般的web开发,我们都是用的MVC三层框架,基本上写出的代码都是贫血模型的,getter&#47;setter滥用,而且没有真正的去进行抽象化,虽然Spring提供了依赖注入的概念,但是我们书写的抽象类一是命名不规范,二是抽象类和实现等值挂钩,经常出现没有复用性的问题,为了一点小改动而重写接口类,一个抽象类直接对应着一个实现,没有利用多态的思想,写出来的都是面向过程的语言,希望可以在整个课程结束之后,让自己的代码水平有所上升吧","like_count":0},{"had_liked":false,"id":179288,"user_name":"junmawang","can_delete":false,"product_type":"c1","uid":1763466,"ip_address":"","ucode":"977E9E25CE6C94","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e8/8a/803a42e0.jpg","comment_is_top":false,"comment_ctime":1581952599,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581952599","product_id":100039001,"comment_content":"抽象类（abstract)<br>\t1、抽象类不允许被事例化，只能被继承，直接new编译出错。<br>\t2、抽象类可以包含属性和方法，可以有普通发放和抽象方法。<br>\t3、子类继承抽象类，必须实现抽象类中的所有抽象方法。<br>\t4、抽象类继承关系是一种 is-a 的关系<br>接口(inteface)<br>\t1、接口不能包含属性。<br>\t2、接口除了声明方法也可以有default实现方法。<br>\t3、类实现接口，必须实现接口中声明的所有方法。<br>\t4、接口表示一种 has-a 关系，表示具有某些功能<br>\t<br>抽象类解决问题<br>\t1、代码复用<br>接口解决问题<br>接口就更侧重于解耦，接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。","like_count":0},{"had_liked":false,"id":178317,"user_name":"syz","can_delete":false,"product_type":"c1","uid":1174704,"ip_address":"","ucode":"54AF17ACD72645","user_header":"https://static001.geekbang.org/account/avatar/00/11/ec/b0/4e22819f.jpg","comment_is_top":false,"comment_ctime":1581660886,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581660886","product_id":100039001,"comment_content":"接口在开发中往往是开发前自上而下定义的，而抽象类是开发中自下而上提取重复代码生成的。","like_count":0},{"had_liked":false,"id":176050,"user_name":"阳光很轻","can_delete":false,"product_type":"c1","uid":1619031,"ip_address":"","ucode":"73408E2DA4F10D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKE7VtDBFkSht6VgE4UZL82SlUrDXKVaGVibJSNXsVhfrPTNQ2OfrrOGu7ugMxwa0osyZibRqZjh5KQ/132","comment_is_top":false,"comment_ctime":1580919463,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580919463","product_id":100039001,"comment_content":"强调这两种语法特征的主要区别点：抽象类是对一个完整类的抽象概括，是一种自下而上的设计;而接口更加强调某一种分支概念的抽象，所以更容易被用到某个类的组合中去，是一种先定义后实现的自上而下的设计思路。","like_count":0},{"had_liked":false,"id":174963,"user_name":"ypy","can_delete":false,"product_type":"c1","uid":1112050,"ip_address":"","ucode":"4BEAA42E9975C2","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/f2/83aee314.jpg","comment_is_top":false,"comment_ctime":1580480858,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1580480858","product_id":100039001,"comment_content":"OC 里面的 procotol 相当于接口了，但是 OC 里面没有抽象类的概念。但是 OC 的接口和作者说的接口也不完全一致，因为它可以有 optional 的方法，也就是子类可以不用实现的方法。灵活性更好一些，子类可以根据需要来实现某些接口方法。感觉这种设计更多的是使用场景中提出来的需求。猜测是因为 OC 的主要应用场景是 macOS 和 iOS 的 UI 编程，其中用的较多的是 delegate 方法，将 UI 的一些生命周期通过代理回调，很多时候并不是所有的使用者都关心这些生命周期，所以就有了这种 optional 的设计","like_count":0,"discussions":[{"author":{"id":1506399,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fc/5f/439a96cd.jpg","nickname":"karisli","note":"","ucode":"14E9118FAA3327","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214297,"discussion_content":"iOS中没有抽象类的接口，但是按照老师刚才的说法，可以通过普通类来实现：.h中声明&#34;抽象方法&#34;，.m中实现的时候throw exception，编译的时候如果子类如果没有实现这个方法就会抛出异常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585176460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174793,"user_name":"贺宇","can_delete":false,"product_type":"c1","uid":1445040,"ip_address":"","ucode":"55854825CC4AD2","user_header":"https://static001.geekbang.org/account/avatar/00/16/0c/b0/26c0e53f.jpg","comment_is_top":false,"comment_ctime":1580389065,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1580389065","product_id":100039001,"comment_content":"接口可以有属性啊，只不过不能修改","like_count":0,"discussions":[{"author":{"id":1358045,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b8/dd/37726c34.jpg","nickname":"小马哥","note":"","ucode":"B2C0FF38F8C9BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386516,"discussion_content":"默认是public static final修饰的属性, 所以是类属性, 新版本具有的.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627624922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174405,"user_name":"Canva","can_delete":false,"product_type":"c1","uid":1461560,"ip_address":"","ucode":"F29E71D9553763","user_header":"https://static001.geekbang.org/account/avatar/00/16/4d/38/74aedf50.jpg","comment_is_top":false,"comment_ctime":1580195082,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580195082","product_id":100039001,"comment_content":"接口中定义的属性，不能算成员属性是因为是共用属性吗？还有JDK8接口引入默认实现，是为了向下兼容吗？","like_count":0},{"had_liked":false,"id":174055,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1579931479,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1579931479","product_id":100039001,"comment_content":"老师，接口也是需要被实现的，比如您举例的Filter，RateLimateFilter，所以我觉得类和接口也是is a关系","like_count":0,"discussions":[{"author":{"id":1358045,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b8/dd/37726c34.jpg","nickname":"小马哥","note":"","ucode":"B2C0FF38F8C9BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386517,"discussion_content":"接口这个定义来源于硬件, 硬件之间连接, 接口是一种协议, 匹配才能正常工作; 在编程中, 接口同样规定了使用和定义接口的两个地方要匹配, 这个匹配即定义了接口的实现具备什么行为, 所以是has-a的关系.\n于是\nLogger logger(抽象) = new FileLogger();(实现)\nlogger.log(); 这里面向接口编程\n日后,需求变了, 需要将日志发送到消息队列, 换一个新的实现过来就了;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627625247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173558,"user_name":"好饿早知道送外卖了","can_delete":false,"product_type":"c1","uid":1132304,"ip_address":"","ucode":"AED22DB5BF8FC7","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","comment_is_top":false,"comment_ctime":1579596492,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1579596492","product_id":100039001,"comment_content":"#### 抽象类<br>&gt; 抽象类实际上就是类，只不过是一种特殊的类，这种类不能被实例化为对象，只能被子类继承。和类一样，抽象类也表示一种 is-a 的关系。<br><br>- 抽象类不允许被实例化，需要使用它的子类，并实现它的抽象方法<br><br>以一个上报系统为例，他分为TCP和HTTP两种上报方式：<br>抽象类中实现了可复用的主要逻辑（比如新增、格式化、存储、切割），子类中实现需要定制其关键步骤的抽象方法具体如何实现（比如TCP&#47;HTTP发送）。<br><br>同样我们可以把上报的模块抽离出来，作为参数传递给manager进行不同的上报动作。这种方式又叫多态。<br><br>&gt; 可以看出，抽象类（继承）的主要目的是为了代码的复用。<br><br>#### 接口（协议）<br>&gt; 接口表示一种 has-a 关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议（contract）。<br><br>- 接口只能声明方法，方法不能包含代码实现<br>- 类实现接口的时候，必须实现接口中声明的所有方法<br><br>**以公司为例：**<br>每个参加工作的个体都有不同，可能继承自不同的父母。但是我们可以抽象出上班、打卡、996等等一系列协议。一旦一个类想要来工作，只要实现这一套协议，随时来公司修福报。<br><br>其实也可以用多态实现这一系列流程，但是相对于多态，协议更加解耦和灵活。<br>因为它对类没有父类的要求，只要实现了协议任何类都可以接入系统。一个类实现了多套协议，完全可以接入多个系统（比如我既要996，剩下一天还得带娃）。<br><br>&gt; 可以看出接口主要在于解耦、扩展和灵活性。","like_count":0},{"had_liked":false,"id":173452,"user_name":"🍃","can_delete":false,"product_type":"c1","uid":1337052,"ip_address":"","ucode":"D1E4560C49139A","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/dc/fdffbc96.jpg","comment_is_top":false,"comment_ctime":1579565780,"is_pvip":false,"replies":[{"id":"67728","content":"动态语言我不大了解~","user_name":"作者回复","comment_id":173452,"uid":"1190123","ip_address":"","utype":1,"ctime":1580115399,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"1579565780","product_id":100039001,"comment_content":"对于动态编程语言来说，还有一种对接口支持的策略，那就是 duck-typing<br><br>老师, 这个能举个例子吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482071,"discussion_content":"动态语言我不大了解~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580115399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269213,"discussion_content":"在第5讲，有个简单的例子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589879586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173014,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1579409096,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579409096","product_id":100039001,"comment_content":"越看越有味道了","like_count":0},{"had_liked":false,"id":168146,"user_name":"赵小样","can_delete":false,"product_type":"c1","uid":1238131,"ip_address":"","ucode":"49E95C1E96B2BD","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/73/d8291f76.jpg","comment_is_top":false,"comment_ctime":1578019204,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578019204","product_id":100039001,"comment_content":"NativeAd nativeAd = new NativeAd() {<br>            @Override<br>            protected void testAbstract() {<br><br>            }<br>        };<br>        iAdListener.onAdLoaded(nativeAd);<br><br>类似这种的，NativeAd是抽象类。","like_count":0},{"had_liked":false,"id":168141,"user_name":"赵小样","can_delete":false,"product_type":"c1","uid":1238131,"ip_address":"","ucode":"49E95C1E96B2BD","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/73/d8291f76.jpg","comment_is_top":false,"comment_ctime":1578018769,"is_pvip":false,"replies":[{"id":"65963","content":"&quot;重写抽象类的方法就可以了&quot; 那你创建的还是抽象类吗？😂 ","user_name":"作者回复","comment_id":168141,"uid":"1190123","ip_address":"","utype":1,"ctime":1578490729,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1578018769","product_id":100039001,"comment_content":"老师，使用AndroidStudio开发的时候，抽象类是可以被创建实例的，编译器不会报错，重写抽象类的抽象方法就可以了，抽象类的对象也可以正常调用。那这个是语法问题吧，跟编译器应该没有关系，那说明抽象类是可以被实例化的。能麻烦老师解释一下吗？感谢！","like_count":0},{"had_liked":false,"id":168064,"user_name":"氧气🌙 🐟 🌺","can_delete":false,"product_type":"c1","uid":1591015,"ip_address":"","ucode":"8E23C210A9F09E","user_header":"https://static001.geekbang.org/account/avatar/00/18/46/e7/e20279ea.jpg","comment_is_top":false,"comment_ctime":1578010062,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578010062","product_id":100039001,"comment_content":"普通类模拟抽象类，就是用protected修饰构造函数<br>public class MockInteface {<br>  &#47;&#47; protected 避免类被实例化<br>  protected MockInteface() {}<br>  public void funcA() {<br>    &#47;&#47; 具体实现<br>  }<br>}","like_count":0},{"had_liked":false,"id":166711,"user_name":"fly","can_delete":false,"product_type":"c1","uid":1025992,"ip_address":"","ucode":"D1F6938C9CE15D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a7/c8/5608cbdb.jpg","comment_is_top":false,"comment_ctime":1577550427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577550427","product_id":100039001,"comment_content":"接口：不能实例化；不包含属性；方法不能包含实现<br>抽象类：不能实例化；可以包含方法和属性；方法可以包含代码实现，也可以不包含代码实现<br>接口侧重于解耦，体现的是灵活性和可扩展性的设计思想。<br>抽象类侧重于代码复用，体现的是继承的特性，常用于模板设计模式。","like_count":0},{"had_liked":false,"id":165947,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1577348665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577348665","product_id":100039001,"comment_content":"打卡Day4：今天学习了【08 | 理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口？】<br><br>一、抽象类和接口的语法特性<br>抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也不可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。<br><br>二、抽象类和接口能解决什么编程问题？<br>1.抽象类不能被实例化，只能被继承，所以，抽象类也是为代码复用而生的。如果一个方法在父类中没有任何意义，只有在两个子类中才有具体的实现，还要达到多态的效果，使用抽象类作为父类比普通类作为父类要优雅很多。用普通类作为父类可能会忘记重写那个方法，抽象类编译器会强制要求重写抽象方法，普通类可以被实例化，没有任何意义的方法会被调用。<br>2.接口偏重于解耦，相当于一组协议或者契约，调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。<br><br>三、如何模拟抽象类和接口<br>1.某个类只要没有成员变量，只有方法声明，没有方法实现，继承某个类必须实现某个类中的所有方法。只要满足这几点就可以叫作接口。<br>让类中的方法抛出MethodUnSupportedException 异常，来模拟不包含实现的接口，子类继承这个父类的时候，都去主动实现父类的方法，否则就会抛出异常。<br>但是并不能保证被实例化，因为Java中私有化构造方法就不能被继承了，要的只是模拟，并不是和接口一模一样。<br>2.模拟抽象类的思想同上。<br><br>四、如何决定该用抽象类还是接口<br>1.如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示\b一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。<br>2.抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。","like_count":0},{"had_liked":false,"id":164814,"user_name":"黄政","can_delete":false,"product_type":"c1","uid":1345630,"ip_address":"","ucode":"9076A1BF7BB051","user_header":"https://static001.geekbang.org/account/avatar/00/14/88/5e/cc916a2b.jpg","comment_is_top":false,"comment_ctime":1577094650,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1577094650","product_id":100039001,"comment_content":"1.我熟悉的是C++，当前默认是支持抽象类，接口的话使用虚函数也可以实现<br>2.接口：存在方式，特性，应用<br>抽象类：特点，优点","like_count":0},{"had_liked":false,"id":164769,"user_name":"程序猿大叔文海","can_delete":false,"product_type":"c1","uid":1241846,"ip_address":"","ucode":"BB6D82C93EFCC5","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/f6/27cc6133.jpg","comment_is_top":false,"comment_ctime":1577088737,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577088737","product_id":100039001,"comment_content":"Java 中JDK8 接口里面有默认实现，还有static方法都是有方法体的。 <br>还有Java 接口里面是可以有属性的，不过很少有人这么玩，默认是public static final 修饰的。","like_count":0},{"had_liked":false,"id":164256,"user_name":"Next","can_delete":false,"product_type":"c1","uid":1748213,"ip_address":"","ucode":"D5ADDF248A9504","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ac/f5/2f97e279.jpg","comment_is_top":false,"comment_ctime":1576917271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576917271","product_id":100039001,"comment_content":"接口，只是一种通用行为描述。实现接口的类，表示该类具有接口描述的行为(has-a)。可以很好的支持多态，提升扩展性！<br>抽象类，是一种抽象概念描述，有特征，有行为，但没有具体的存在（实例）。继承抽象类（is-a），可以提高代码复用，优雅的实现子类，提升可维护性！","like_count":0},{"had_liked":false,"id":164240,"user_name":"Attract","can_delete":false,"product_type":"c1","uid":1112638,"ip_address":"","ucode":"DEB10AF9AB5A41","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/3e/92d74b38.jpg","comment_is_top":false,"comment_ctime":1576913587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576913587","product_id":100039001,"comment_content":"抽象类如果只有抽象方法，其实就约等于接口了","like_count":0},{"had_liked":false,"id":164058,"user_name":"东流","can_delete":false,"product_type":"c1","uid":1738147,"ip_address":"","ucode":"2715BC6E87BD83","user_header":"https://static001.geekbang.org/account/avatar/00/1a/85/a3/7e078442.jpg","comment_is_top":false,"comment_ctime":1576852195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576852195","product_id":100039001,"comment_content":"我觉得如果类与类之间有属性共有的话，就用抽象类，如果没有只有行为的话用接口","like_count":0},{"had_liked":false,"id":163906,"user_name":"睁眼看世界","can_delete":false,"product_type":"c1","uid":1206388,"ip_address":"","ucode":"F94CF34BC5B2AC","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/74/461b202d.jpg","comment_is_top":false,"comment_ctime":1576823698,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576823698","product_id":100039001,"comment_content":"老师，java的接口中也可以定义属性，不过默认是常量而已。","like_count":0},{"had_liked":false,"id":163048,"user_name":"tong467","can_delete":false,"product_type":"c1","uid":1560667,"ip_address":"","ucode":"544F6FB2C5A936","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJjw7KXibCGnibOm3O73xCGyCzdmgKuc017X8IQZCdNvAWxoWxHSgMTLgd7rGs1LCBPaU5oHbO16F0A/132","comment_is_top":false,"comment_ctime":1576647536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576647536","product_id":100039001,"comment_content":"java抽象类的子类也不要求必须实现所有抽象方法，如果他的子类也是一个抽象类就可不实现所有抽象方法，只有子类是个普通类才要求实现所有抽象方法；<br>1.8中 java 的接口有默认方法。即接口也可以有带实现的方法。","like_count":0},{"had_liked":false,"id":162559,"user_name":"海罗沃德","can_delete":false,"product_type":"c1","uid":1165364,"ip_address":"","ucode":"8704F1D6980FA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c8/34/fb871b2c.jpg","comment_is_top":false,"comment_ctime":1576554798,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576554798","product_id":100039001,"comment_content":"JDK 8中接口中可以存在包含default關鍵字的有具體實現的方法，這樣是不是破壞了原本接口has-a的定義？","like_count":0},{"had_liked":false,"id":162255,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1518880,"ip_address":"","ucode":"69655C3AF0976B","user_header":"https://static001.geekbang.org/account/avatar/00/17/2d/20/feeb9ffc.jpg","comment_is_top":false,"comment_ctime":1576487587,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576487587","product_id":100039001,"comment_content":"想提个问题，我是写scala的，java也写过但是不是那么精通，在讲抽象类里logger的例子里我有点疑惑：为什么要把这个logger的类型设置成抽象类logger？为什么不能直接是 FileLogger filelogger = new FileLogger, 它明明是一个FileLogger类型并且它可以直接使用FileLogger自己的log方法，为什么还要把这个变量类型设置成Logger呢<br><br>Logger logger = new FileLogger(&quot;access-log&quot;, true, Level.WARN, &quot;&#47;users&#47;wangzheng&#47;access.log&quot;);<br>logger.log(Level.ERROR, &quot;This is a test log message.&quot;);","like_count":0,"discussions":[{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128250,"discussion_content":"我的理解是主要是为了演示抽象类可以使用多态这个特性。\n在平时的生产上，我们会把log方法封装成一个公共接口或者方法，接受参数为Log类型的对象，例如:\nvoid log(Log log){\n      log.log;\n}\n然后在使用时，根据具体的业务场景，传入不同的实现了Log的对象，从而完成不同的操作。以后应该会讲到这个策略模式。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578623347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161895,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1576395290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576395290","product_id":100039001,"comment_content":"文章关于抽象类和普通父类嗯区别，我觉得只有能不能被实例化这一点。因为普通父类也可以分别有log和doLog方法，然后log调用doLog，doLod方法不做任何事情。这样子类重写doLog方法就可以了，也支持多态。","like_count":0},{"had_liked":false,"id":161843,"user_name":"乘坐Tornado的线程魔法师","can_delete":false,"product_type":"c1","uid":1132661,"ip_address":"","ucode":"C4C9915866E769","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","comment_is_top":false,"comment_ctime":1576376709,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576376709","product_id":100039001,"comment_content":"接口不能包含属性（也就是成员变量）。这句话是否可以更细化。我查阅后发现static final的成员变量是可以定义在接口中的。只不过需要在声明时赋值。就相当于单例模式中的饿汉型。","like_count":0},{"had_liked":false,"id":160252,"user_name":"alls well","can_delete":false,"product_type":"c1","uid":1072439,"ip_address":"","ucode":"8E3EB5A3DF6E0D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5d/37/8261fc68.jpg","comment_is_top":false,"comment_ctime":1575899323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575899323","product_id":100039001,"comment_content":"C再怎么玩，也脱离不了结构体和指针","like_count":0},{"had_liked":false,"id":159363,"user_name":"马建华","can_delete":false,"product_type":"c1","uid":1185974,"ip_address":"","ucode":"928189590259AB","user_header":"https://static001.geekbang.org/account/avatar/00/12/18/b6/f3f68a39.jpg","comment_is_top":false,"comment_ctime":1575606650,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575606650","product_id":100039001,"comment_content":"再提个问题：<br>1. 老师用普通父类实现的打印日志代码中，说在Logger中定义了空的log()方法，影响了可读性，可是第一种抽象类打印日志代码中，dolog()不也是空的方法吗？这个是不是也影响了可读性？<br>2. 老师说抽象类打印日志代码中，编译器会强制要求子类重写log()方法，我怎么觉得强制重写的只有doLog()方法呢？<br>请老师指正","like_count":0},{"had_liked":false,"id":158908,"user_name":"马建华","can_delete":false,"product_type":"c1","uid":1185974,"ip_address":"","ucode":"928189590259AB","user_header":"https://static001.geekbang.org/account/avatar/00/12/18/b6/f3f68a39.jpg","comment_is_top":false,"comment_ctime":1575476521,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1575476521","product_id":100039001,"comment_content":"请教一下老师，为何第一段Logger代码中的34行，不是写为this.fileWriter.write(...)而是fileWriter.write(...)呢？<br><br>this.fileWriter = new FileWriter(filepath); } <br>@Override public void doLog(Level level, String mesage) { <br>&#47;&#47; 格式化level和message,输出到日志文件 <br>fileWriter.write(...); }","like_count":0},{"had_liked":false,"id":158410,"user_name":"言","can_delete":false,"product_type":"c1","uid":1714156,"ip_address":"","ucode":"483EE23D2EA2E6","user_header":"https://static001.geekbang.org/account/avatar/00/1a/27/ec/9f6e999d.jpg","comment_is_top":false,"comment_ctime":1575365171,"is_pvip":false,"replies":[{"id":"60691","content":"那个异常可以是自定义的","user_name":"作者回复","comment_id":158410,"uid":"1190123","ip_address":"","utype":1,"ctime":1575424785,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"1575365171","product_id":100039001,"comment_content":"MethodUnSupportedException  这个异常没有找到，protected MockInteface() {}  这个类为啥不能被实例化","like_count":0,"discussions":[{"author":{"id":2731028,"avatar":"https://static001.geekbang.org/account/avatar/00/29/ac/14/a8ff8fec.jpg","nickname":"慕言","note":"","ucode":"4918FA682F3895","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572637,"discussion_content":"直接put就替换掉了引用的地址了，其实就已经实现了深拷贝了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652879502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306276,"discussion_content":"熊猫说的对，我们remove的只是 浅拷贝中 每个entry的内存地址，原来的currentKeywords没任何变化， 然后再给newKeywords.put()，就是一个新的map了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600238500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251145,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/49/b658b7bd.jpg","nickname":"微熊猫","note":"","ucode":"3EDC09591E64CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303205,"discussion_content":"因为是浅拷贝，所以newKeywords和currentKeywords存的value都是同一个引用\n先remove掉 再put，newKeywords里保存的value就和currentKeywords没有关系了。\n也就达到了深拷贝的目的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599185262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158005,"user_name":"greg","can_delete":false,"product_type":"c1","uid":1189197,"ip_address":"","ucode":"BEE952C7ED2C84","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/0o2FEeJiav8lK9Y49JUOBretDypyHic2FL9dSZYnweBPZ5ibm3vgfm3q7kgXmQEOGOLJFgPEcMweVFj5QTrt4Vb4g/132","comment_is_top":false,"comment_ctime":1575296807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575296807","product_id":100039001,"comment_content":"接口和抽象类的区别，接口是has a的关系，比如，读书时一个接口，可以读书的有男同学和女同学。那么男同学和女同学都可以实现这个接口。抽象类是is a的关系，从下向上设计，相同的特性可以放到抽象类中","like_count":0},{"had_liked":false,"id":157969,"user_name":"程浩","can_delete":false,"product_type":"c1","uid":1660225,"ip_address":"","ucode":"B178C4BF5965D3","user_header":"https://static001.geekbang.org/account/avatar/00/19/55/41/f4c22a44.jpg","comment_is_top":false,"comment_ctime":1575290978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575290978","product_id":100039001,"comment_content":"我觉得抽象类是继承和抽象的合体。为了代码复用，将复用的代码定义在抽象类，子类可以直接使用。为了抽象，在抽象类中定义标准或者说是功能方法，子类中必须实现以达到想要的功能。而接口只有抽象这一功能，单纯的抽象可以代码解耦。而代码复用的功能可以放在Utils类中实现。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500564,"discussion_content":"你联系一下上下文看下，都有讲到的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593994347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157679,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1575246537,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575246537","product_id":100039001,"comment_content":"从抽象类为了复用，接口为了解藕，推论语法特性更加容易记忆与理解","like_count":0},{"had_liked":false,"id":157611,"user_name":"张德","can_delete":false,"product_type":"c1","uid":1101929,"ip_address":"","ucode":"31FE63E8725EFC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","comment_is_top":false,"comment_ctime":1575212499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575212499","product_id":100039001,"comment_content":"老师能不能讲一下用接口到底好在哪？？  感觉一直在用  但是确一直不知道 接口解耦有什么好处  不解耦又会怎么样 感觉一个类中注入另一个类也未尝不可  能不能讲几个用接口非常巧妙的例子 让学生们开开眼界  谢谢老师","like_count":0},{"had_liked":false,"id":157373,"user_name":"禅若静水","can_delete":false,"product_type":"c1","uid":1266038,"ip_address":"","ucode":"5028D28106963C","user_header":"https://static001.geekbang.org/account/avatar/00/13/51/76/ad8115b0.jpg","comment_is_top":false,"comment_ctime":1575124124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575124124","product_id":100039001,"comment_content":"接口和抽象类区别与联系：<br>1、定义：<br>抽象类：不允许实例化，只能被继承；可包含属性和方法，包含抽象方法；子类继承抽象类必须重写抽象方法。<br>接口：不允许实例化，只能被实现；不包含属性和普通方法，包含抽象方法、静态方法、类实现接口时，必须实现抽象方法。<br>2、意义：<br>抽象类：解决复用问题，适用于is-a的关系。<br>接口：解决抽象问题，适用于has-a的关系。<br><br>从定义和意义来说，都是为了合理提高代码质量方法论，具体使用还是以天时（规范开发）地利（团队成员一致认可这些方法论）人和（个人技能素养），来决定的","like_count":0},{"had_liked":false,"id":157256,"user_name":"随风","can_delete":false,"product_type":"c1","uid":1437618,"ip_address":"","ucode":"7D243B6946E08D","user_header":"https://static001.geekbang.org/account/avatar/00/15/ef/b2/5064e98a.jpg","comment_is_top":false,"comment_ctime":1575098895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575098895","product_id":100039001,"comment_content":"还望争哥解惑：<br>这个设计思路虽然达到了代码复用的目的，但是无法使用多态特性了<br>1.这句话中的“多态特性”说的是其父类丧失了多态的特性？<br>2.如果写成以下这样：<br>logger = new FileLogger(&quot;access-log&quot;, true, Level.WARN, &quot;&#47;users&#47;wangzheng&#47;access.log&quot;);<br>logger.log(Level.ERROR, &quot;This is a test log message.&quot;);<br>编译就不会有错误了，您的这个” Logger logger =“代码中书写的Logger，是为了什么？","like_count":0},{"had_liked":false,"id":157242,"user_name":"江中猴姑饼干","can_delete":false,"product_type":"c1","uid":1238992,"ip_address":"","ucode":"4F288845CC70FA","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/d0/d145c11f.jpg","comment_is_top":false,"comment_ctime":1575095611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575095611","product_id":100039001,"comment_content":"使用抽象类3个理由正好证明它的鸡肋😂","like_count":0},{"had_liked":false,"id":156784,"user_name":"零度","can_delete":false,"product_type":"c1","uid":1071119,"ip_address":"","ucode":"C121285CD9D999","user_header":"https://static001.geekbang.org/account/avatar/00/10/58/0f/8ed4be99.jpg","comment_is_top":false,"comment_ctime":1574955652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574955652","product_id":100039001,"comment_content":"都有对实际场景的抽象<br>抽象类自下而上设计，适用于is_a的场景，从各个类中抽象出一部分共性作为这一类的共性，实现代码复用。<br>抽象类作为一个类型所以不能实例只能继承，抽象类可以包含属性和方法，有具体实现的方法是普通方法，没有具体实现的是抽象方法，抽象方法必须要在子类中重写。<br>接口自上而下设计，适用于has_a的场景，内部不能有属性只能包含方法，且方法必须是抽象方法(没有具体实现)，由子类实现。使用于包含某些功能，并强制这些功能(方法)必须由各子类自主实现，完成了代码解藕。<br>比如一个通过继承抽象类继承某些基本特性，然后又调用接口(接口组合)，这样又获取了某些能力","like_count":0},{"had_liked":false,"id":156659,"user_name":"Cest La Vie🤩","can_delete":false,"product_type":"c1","uid":1177849,"ip_address":"","ucode":"EDABE70BB796AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/f9/5d983b88.jpg","comment_is_top":false,"comment_ctime":1574931988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574931988","product_id":100039001,"comment_content":"现在1.8之后，接口不是可以加default了么","like_count":0},{"had_liked":false,"id":156410,"user_name":"我能走多远","can_delete":false,"product_type":"c1","uid":1240465,"ip_address":"","ucode":"07DF5D5DADFA3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/91/1d332031.jpg","comment_is_top":false,"comment_ctime":1574867525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574867525","product_id":100039001,"comment_content":"我是学习C语言的。没有使用过抽象和接口的概念。这个理解起来有点吃力。就是不知道区别和用法","like_count":0},{"had_liked":false,"id":156095,"user_name":"岁月如歌","can_delete":false,"product_type":"c1","uid":1428828,"ip_address":"","ucode":"1AEBD6F79941B7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QFE00aXGzaS6ibbfJSJsDrpIkqs0OrIYjzZv6L9vZmMhOlut2j24iaeZb0MCQazToE6FRXN960nNiaTrsmw09YjGw/132","comment_is_top":false,"comment_ctime":1574819100,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574819100","product_id":100039001,"comment_content":"1、java中利用抽象类实现代码复用很常见。类似哈希表实现中 Map为最顶层规范，而AbstractMap抽象出哈希表公用的代码实现重用，基础的HashMap就是继承AbstractMap实现具体逻辑。同样可以继承AbstractMap定制化哈希表。<br><br>2、抽象类和接口要从多方面比较<br>定义、区别、适用场景 <br>借用 @辣么大 描述： <br>2.1、定义：<br>抽象类：不允许实例化，只能被继承；可包含属性和方法，包含抽象方法；子类继承抽象类必须重写抽象方法。<br>接口：不允许实例化，只能被实现；不包含属性和普通方法，包含抽象方法、静态方法、default 方法；类实现接口时，必须实现抽象方法。<br><br>2.2、意义 和 适用场景：<br>抽象类：解决复用问题，适用于is-a的关系。<br>接口：解决抽象问题，或者描述为一种协议和规范，适用于has-a的关系。<br>","like_count":0},{"had_liked":false,"id":155938,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1574780385,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574780385","product_id":100039001,"comment_content":"接口和抽象类算是两个不同维度的抽象，前者是行为的抽象，非常彻底，即只定义行为，然后交由具体的对象去实现，设计上来看是自上而下的（这里其实有点疑问，实际代码开发中，这个设计和类是一个维度的，也就可以理解为一种先有上层抽象，再有相关实现），后者说到底还是一个类，相比较于传统的父类多了一个安全方便的多态特性","like_count":0},{"had_liked":false,"id":155890,"user_name":"睡不醒","can_delete":false,"product_type":"c1","uid":1718863,"ip_address":"","ucode":"50B60045AA2627","user_header":"https://static001.geekbang.org/account/avatar/00/1a/3a/4f/737fed25.jpg","comment_is_top":false,"comment_ctime":1574774927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574774927","product_id":100039001,"comment_content":"日常用python，学完此课明白了抽象类相比普通父类的优势：可读性好，对开发者有约束。<br><br>但仍有两点不明：<br>1. 还是不太明白接口和抽象类应用场景的区别。为什么Filter是has a不是is a呢？不可以理解为is a Filter，is a XXFilter吗？<br><br>2. 文中提到抽象类是自下而上，先有重复代码再抽象出抽象类，而接口是预先设计的。可是我设计程序时常常会先想好会有哪些父类，开发中慢慢写子类，这种设计思路是不合适的吗？<br><br>","like_count":0},{"had_liked":false,"id":155685,"user_name":"黄振宇","can_delete":false,"product_type":"c1","uid":1686397,"ip_address":"","ucode":"976BC7B46DA419","user_header":"https://static001.geekbang.org/account/avatar/00/19/bb/7d/26340713.jpg","comment_is_top":false,"comment_ctime":1574736210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574736210","product_id":100039001,"comment_content":"老师，有没有情况是两用都用到的。再实现一个类的时候，他同时继承了他的父类，也需要实现一个接口。我现在遇到类似的情况。如果不能同时使用，是不是得舍弃一个，二者不可同时得兼","like_count":0},{"had_liked":false,"id":155656,"user_name":"Morse","can_delete":false,"product_type":"c1","uid":1624157,"ip_address":"","ucode":"B09A716D79AE3B","user_header":"https://static001.geekbang.org/account/avatar/00/18/c8/5d/1e3685e6.jpg","comment_is_top":false,"comment_ctime":1574733341,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574733341","product_id":100039001,"comment_content":"我们知道类中的方法必须包含实现，这个不符合接口的定义。但是，我们可以让类中的方法抛出 MethodUnSupportedException 异常，来模拟不包含实现的接口，并且能强迫子类在继承这个父类的时候，都去主动实现父类的方法，否则就会在运行时抛出异常。<br>这一段这么理解呢？","like_count":0},{"had_liked":false,"id":155532,"user_name":"Juntíng","can_delete":false,"product_type":"c1","uid":1039290,"ip_address":"","ucode":"F6A3B528D6F3FD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/ba/304a9a4a.jpg","comment_is_top":false,"comment_ctime":1574695944,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574695944","product_id":100039001,"comment_content":"我在思考，JavaScript 怎么来实现？😭","like_count":0},{"had_liked":false,"id":155178,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1574657054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574657054","product_id":100039001,"comment_content":"又要达到代码复用，又想使用多态就用抽象类","like_count":0},{"had_liked":false,"id":155148,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1574652081,"is_pvip":false,"replies":[{"id":"60022","content":"可以，但是必须用public final static修饰，或者默认这样<br>这样的属性就是常量了<br>不过正常很少这样做","user_name":"作者回复","comment_id":155148,"uid":"1190123","ip_address":"","utype":1,"ctime":1574852951,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1574652081","product_id":100039001,"comment_content":"Java中的接口不是可以有属性吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475673,"discussion_content":"可以，但是必须用public final static修饰，或者默认这样\n这样的属性就是常量了\n不过正常很少这样做","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574852951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155129,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1574649632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574649632","product_id":100039001,"comment_content":"public class MockAbstract {<br>    &#47;**<br>     * 抽象类不能被实例化，只能被继承，所以是构造函数<br>     *&#47;<br>    protected MockAbstract() {<br><br>    }<br><br>    public void funcA() {<br>        throw new UnsupportedOperationException();<br>    }<br><br>    public void funcB() {<br>        System.out.println(&quot;funcB operation&quot;);<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":155061,"user_name":"研木","can_delete":false,"product_type":"c1","uid":1063371,"ip_address":"","ucode":"850DEFD2FCB371","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/cb/73628dfd.jpg","comment_is_top":false,"comment_ctime":1574642627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574642627","product_id":100039001,"comment_content":"抽象类是is-a的关系，接口是has-a，抽象类很多时候是在后面实现的时候，慢慢抽象出来的，把一些可复用的实现下沉到抽象类中；接口更关注的是隔离，将定义和实现分开，还有在提供对外的服务时，一般是先定义好接口，约定好对应功能方法，再具体实现功能","like_count":0},{"had_liked":false,"id":154782,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1574563391,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574563391","product_id":100039001,"comment_content":"1.java支持接口和抽象类<br>2.接口:<br>#没有属性<br>#强制子类实现，并且没有实现<br>#has a 的能力<br>#多继承的能力提供<br>#抽象的提取<br>3.抽象类<br>#有属性<br>#可以有方法的实现和抽象方法<br>#is a的描述<br>#是重复功能的提取。<br>","like_count":0},{"had_liked":false,"id":154731,"user_name":"Fun","can_delete":false,"product_type":"c1","uid":1145502,"ip_address":"","ucode":"5D89BA4C678785","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJdUGdEj3R25CrYqibPibYibibRicqUfyL4aTTPbMagyywjKMhXGZE37RTe7lEdvC4DibvtYpzg8zXvt9HQ/132","comment_is_top":false,"comment_ctime":1574524664,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574524664","product_id":100039001,"comment_content":"# day 13<br>今晚重新学习理论五，抽象类和接口。几个点：<br>1，抽象类和接口语法知识，重新了解学习；<br>2，意义，抽象类表示is-a的关系，接口表示has-a的关系。linux设备驱动框架完全适用这一套。同一类设备驱动可以区分到个体差异，这个共性的就是通过抽象出来的，这里可以类比抽象类；所有的设备驱动中都提供I&#47;O接口，这个I&#47;O接口就可以类比接口，实现差异应用层不感知。<br>3，应用场景，个人理解，抽象类是对同类事物的抽象，接口是对同类事物同种能力的抽象。","like_count":0},{"had_liked":false,"id":154663,"user_name":"PENG","can_delete":false,"product_type":"c1","uid":1239106,"ip_address":"","ucode":"28615BA561202D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/42/6061aefa.jpg","comment_is_top":false,"comment_ctime":1574502909,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574502909","product_id":100039001,"comment_content":"日常使用java开发语言。通过abstract和interface关键字实现抽象类和接口的定义。<br>抽象类：解决代码复用问题。<br>接口：解决抽象问题。","like_count":0},{"had_liked":false,"id":154595,"user_name":"zhou","can_delete":false,"product_type":"c1","uid":1087243,"ip_address":"","ucode":"E1CE8575B3F106","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","comment_is_top":false,"comment_ctime":1574488389,"is_pvip":false,"discussion_count":2,"race_medal":3,"score":"1574488389","product_id":100039001,"comment_content":"我还是没明白is a和has a的根本区别","like_count":0,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289791,"discussion_content":"删除的是key->value的映射关系而不是valve","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594213288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278831,"discussion_content":"不会的。 \n比如：\nA->B (A对象引用B) clone(浅拷贝)为 C->B (C对象引用B)\nA与C 中引用的B都是同一个对象\n然后把 C 引用的B对象删除，只是C和B之间的引用删除。B的对象还是存在的。\n不影响A中引用B的对象。\n可能讲的不太通俗易懂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591239583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":331330,"discussion_content":"那你是初步的理解，我专门回头看了一下，hashmap 尤其变为红黑树后，你的理论站不住脚。\nhashmap的remove() 并不是单纯的把 C和B之间的引用删除，remove方法需要查询index-->getNode--> 链表就修改链表关系，红黑树就删除前驱或后继节点(多种不同情况)， 不是单纯的 C 包含了个成员变量B，当B=null，这么简单。\n我的看法：\nhashmap 首先用了 Object.clone() 生成了新的mapNew，其中的成员表变量node[ ] 是浅拷贝，但是，\n它把 node[] 给清空了， 把mapOld，进行遍历，封装新的Node节点 装入mapNew，\nnode信息如下：如果是链表，new Node(oldKey,oldValue, null)，其中null为 next(链表的下一个节点)，这样，hashmap保证了 增删 不影响老的map","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606831172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":278831,"ip_address":""},"score":331330,"extra":""},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":331333,"discussion_content":"实际上 C如果是table[]， 那么B根本不是一个对象，而是一个单向链表，或者红黑树，如果hashmap不去重写clone(),那么当执行remove()方法的时候，必然会引起老map的紊乱。\n毕竟 红黑树在删减的时候，会删除前驱节点，或者进行 左旋 右旋，又或者进行递归下溢，B 只是一个 node[]中的头节点而已，这块是有点说法的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606831521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":278831,"ip_address":""},"score":331333,"extra":""},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":331336,"discussion_content":"（个人结论，还望指正） 期待大神们回复我","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606831695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":278831,"ip_address":""},"score":331336,"extra":""}]},{"author":{"id":1238654,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e6/7e/9ab3bd9b.jpg","nickname":"Tom","note":"","ucode":"ACF21163904EF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272227,"discussion_content":"同问 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590253852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1177602,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f8/02/a02d127d.jpg","nickname":"Treasure","note":"","ucode":"4211ECEB347C3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":193261,"discussion_content":"我也没明白这个点，按照老师在文稿中写的，这样remove也会把 currentkeywords中的删掉啊，因为引用的是同一个对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583142122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1177602,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f8/02/a02d127d.jpg","nickname":"Treasure","note":"","ucode":"4211ECEB347C3D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331331,"discussion_content":"是的，我看老师的图，死活不理解， 然后我自己研究半天， 实际上hashmap是重写了clone()，Node 是新的，只是node中的key-value 是老的，也就是所谓的 享元模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606831283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":193261,"ip_address":""},"score":331331,"extra":""}]}]},{"had_liked":false,"id":154558,"user_name":"条","can_delete":false,"product_type":"c1","uid":1203836,"ip_address":"","ucode":"6F8679175256E3","user_header":"https://static001.geekbang.org/account/avatar/00/12/5e/7c/94af3f5e.jpg","comment_is_top":false,"comment_ctime":1574479831,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574479831","product_id":100039001,"comment_content":"1.熟悉语言：java<br>  接口支持：    interface关键字，不能被实例化，定义了的接口应该被实现，接口中的方法只能声 <br>                       明、不能有实现，不能有属性。<br>  抽象类支持：abstract关键字，不能被实例化，应该被继承，可以有属性，可以包含有实现的方法，需 <br>                      要被重写的方法应该定义成抽象的，需要被实现才能用。<br>2.接口中定义的一些方法(一些行为)，主要是为了解耦，隔离了消费者和生产者，提高了代码的复性。 <br>   抽象类主要是为了解决代码复用的问题，也可以作为一个模板，定义一些必须要有的行为，这些行为 <br>   应该声明成抽象的，需要使用模板的人去实现。","like_count":0},{"had_liked":false,"id":154482,"user_name":"Tom.G","can_delete":false,"product_type":"c1","uid":1206034,"ip_address":"","ucode":"7929B45C1A51F8","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/12/5c6eb568.jpg","comment_is_top":false,"comment_ctime":1574440292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574440292","product_id":100039001,"comment_content":"接口不能定义属性，实现方法，只能定义契约，用于面向接口编程，起解耦作用，has-a关系使用接口，解决抽象而非代码复用问题<br>抽象类可以定义属性方法，不能实例化，继承后必须实现所有抽象方法或者子类也是抽象类，如果对象是is-a关系，使用抽象类，解决代码复用问题","like_count":0},{"had_liked":false,"id":154419,"user_name":"汤小高","can_delete":false,"product_type":"c1","uid":1555565,"ip_address":"","ucode":"D4AB7766273D52","user_header":"https://static001.geekbang.org/account/avatar/00/17/bc/6d/f6f0a442.jpg","comment_is_top":false,"comment_ctime":1574425796,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574425796","product_id":100039001,"comment_content":"抽象类解决代码复用，是is a关系<br>接口解决代码解耦，是 has a 关系， 是定义功能，或者规范（协议） ，而对外隐藏具体实现","like_count":0},{"had_liked":false,"id":154298,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1574405807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574405807","product_id":100039001,"comment_content":"想要表示一种is-a的关系，并且是为了解决代码复用的问题<br>\t自下而上的设计思路<br>想要表示一种has-a的关系，并且是为了解决抽象、解耦的问题<br>\t自上而下的设计思路","like_count":0},{"had_liked":false,"id":154169,"user_name":"teddytyy","can_delete":false,"product_type":"c1","uid":1268738,"ip_address":"","ucode":"E1569D81A4154E","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/02/e7af1750.jpg","comment_is_top":false,"comment_ctime":1574386926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574386926","product_id":100039001,"comment_content":"普通类模拟抽象类：<br>第一，构造函数私有<br>第二，抽象类抽象方法抛出异常","like_count":0},{"had_liked":false,"id":154164,"user_name":"看山","can_delete":false,"product_type":"c1","uid":1014260,"ip_address":"","ucode":"F030DD58D0BDC3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/79/f4/d85e7e58.jpg","comment_is_top":false,"comment_ctime":1574386112,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574386112","product_id":100039001,"comment_content":"重新学习接口和抽象类的定义，感觉醍醐灌顶。<br>1. 想请教一个问题，jdk8之后，接口可以提供default方法实现，是不是接口和抽象类之间的界限模糊了？<br>2. 附上几年前关于接口中定义常量的反模式行为的一篇短文 https:&#47;&#47;www.howardliu.cn&#47;constant-interface-anti-pattern&#47; 请大神斧正","like_count":0},{"had_liked":false,"id":154141,"user_name":"hong","can_delete":false,"product_type":"c1","uid":1110639,"ip_address":"","ucode":"1A826195907C71","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/6f/5680dc30.jpg","comment_is_top":false,"comment_ctime":1574384547,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574384547","product_id":100039001,"comment_content":"实际上从Java8开始，接口已经有了默认方法，那么为什么要这么设计呢","like_count":0,"discussions":[{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278835,"discussion_content":"在取出全部数据吗？那干嘛clone呢。直接取数据就完事了。\n文章中的取出的是 大于 传入的lastUpdateTime 的数据.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591239784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1595002,"avatar":"https://static001.geekbang.org/account/avatar/00/18/56/7a/60c3d6a5.jpg","nickname":"STAND ALONE COMPLEX","note":"","ucode":"2AC2F9B0A6D823","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198346,"discussion_content":"取交集，需要把db里面的数据全部读出来吧，就算不考虑时间，也要考虑机器的内存能不能撑得住吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583501452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154138,"user_name":"IOT..Yang","can_delete":false,"product_type":"c1","uid":1240343,"ip_address":"","ucode":"11589D83B67FE9","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/17/c3eb014f.jpg","comment_is_top":false,"comment_ctime":1574384233,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574384233","product_id":100039001,"comment_content":"我是一名Android开发者，所以使用比较多的是java，抽象类关键字为abstract，接口的关键字为interface，在平时的开发中一般都会创建一个Base抽象类，然后把一些公共UI，打点等，都写到该类，把需要传入的布局id，需要创建的对象都写成一个抽象方法让子类实现，给我的感觉，主要是为了实现复用，而接口是一种协议，暴露给其他类使用的，可以不用关心接口的实现，反正可以通过这些方法拿到所需要的。","like_count":0},{"had_liked":false,"id":154087,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1574380505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574380505","product_id":100039001,"comment_content":"继承是加法，接口是乘法。加法简单直观，但潜力有限，乘法是正交","like_count":0},{"had_liked":false,"id":154044,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1574353357,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1574353357","product_id":100039001,"comment_content":"我感觉普通类是相对纯粹的 is-a 关系，描述行为过程，解决代码复用。接口是相对纯粹的 has-a 关系，定义规范协议。抽象类是两头都占一点，既有行为过程，又有规范。普通类和抽象类都可以实现接口，“实现&#47;继承”接口的规范协议。<br>PS: 想问下老师 jdk8 接口的 default 方法的意义和场景有哪些呢？","like_count":0,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289804,"discussion_content":"问题一toBeUpdatedSearchWords又不是全量数据，你这样把没有更新的SearchWords也给删除了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594214719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154026,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1574349935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574349935","product_id":100039001,"comment_content":"普通类来模拟抽象类<br>public class Test2 {<br>    protected Test2() {}<br>    &#47;&#47;抽象类具体实现方法<br>    public void fun() {}<br>    &#47;&#47;抽象方法<br>    public void fun2() {throw new MethodUnSupportedException();}<br>}","like_count":0},{"had_liked":false,"id":153988,"user_name":"鱿鱼先森","can_delete":false,"product_type":"c1","uid":1694627,"ip_address":"","ucode":"543FB3F2AA852B","user_header":"https://wx.qlogo.cn/mmopen/vi_32/ox4nIqvFdt77xSW2rm5QJcYPj0r10up6etUXohw47B50Giby7wexBksrpcSu3n9n7iaqGFCGt2STMkJlJgKaTzvg/132","comment_is_top":false,"comment_ctime":1574342991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574342991","product_id":100039001,"comment_content":"普通类模拟抽象类：构造方法设为protect，每一个方法里最后都throw methodunsurpportedexcept即可","like_count":0},{"had_liked":false,"id":153949,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1574335579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574335579","product_id":100039001,"comment_content":"打卡：<br>抽象类是自下而上的设计思路，现有代码复用然后抽象出父类，之后进行代码复用，当然这其中也有抽象的部分或是约定（抽象方法）；而接口是自上而下的设计思路，先是对功能进行抽象和约束，之后再确定具体的实现。","like_count":0},{"had_liked":false,"id":153929,"user_name":"JavaGuide","can_delete":false,"product_type":"c1","uid":1184210,"ip_address":"","ucode":"246D2EAEA0ACEC","user_header":"https://static001.geekbang.org/account/avatar/00/12/11/d2/fb38b86f.jpg","comment_is_top":false,"comment_ctime":1574333480,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574333480","product_id":100039001,"comment_content":"不论是作者精彩的文章，还是文章下面精彩的评论，都很棒！！！赞！","like_count":0,"discussions":[{"author":{"id":1450486,"avatar":"https://static001.geekbang.org/account/avatar/00/16/21/f6/16bc9c24.jpg","nickname":"李达龙","note":"","ucode":"F5702E69D90B7F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270385,"discussion_content":"印象比较深刻的是，抽象类是因为复用抽取子类共性，自下而上产生的。接口强调具有一种能力的契约，自上而下产生。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589990620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153908,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1574328562,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574328562","product_id":100039001,"comment_content":"C++有现成的语法支持抽象类（有成员函数为纯虚函数）， 至于接口，完全可以用没有成员变量，成员函数全部是纯虚函数的抽象类代替<br>实际开发中我们也是这么用的， 抽象出来父类为了解决代码复用， 先定义接口，为了提供功能<br><br>普通类实现接口，可以把构造函数设为protect或private 权限， 接口类的接口实现上抛出异常，强制子类实现相应方法<br>","like_count":0},{"had_liked":false,"id":153903,"user_name":"AllenGFLiu","can_delete":false,"product_type":"c1","uid":1221991,"ip_address":"","ucode":"90FA8A619A2629","user_header":"https://static001.geekbang.org/account/avatar/00/12/a5/67/bf286335.jpg","comment_is_top":false,"comment_ctime":1574328316,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574328316","product_id":100039001,"comment_content":"用普通类实现抽象类的时候，为了防止生成实例，老师说只要把构造函数设置为protected 就可以了，这是为什么？哪位大牛帮忙解释下，我不会Java啊！","like_count":0,"discussions":[{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331335,"discussion_content":"这个hashmap就是 copy on write，我观察源码得出的结论：绝对有一个全额拷贝的过程。如果10w数据，会new 10万新的Node，只是key-value重用了。 \n链表的next， 红黑树的 left right parent，还是会重新构建。（个人结论，还望指正）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606831677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179798,"discussion_content":"我觉得可以, 本身cow的思想就是写时才复制, 只读的话其实不需要复制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582253820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153883,"user_name":"学好习，做好人","can_delete":false,"product_type":"c1","uid":1205294,"ip_address":"","ucode":"C991643DB458E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/2e/e70a317a.jpg","comment_is_top":false,"comment_ctime":1574325061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574325061","product_id":100039001,"comment_content":"接口是对行为的抽象，封装了或者定义，约束了实现类的行为，接口最大的作用就是封装隔离，即解决调用与具体实现的隔离，调用者不需要知道内部具体的实现细节，但是接口的定义也应该遵循一定的规范，那就是定义内部聚合高的行为--单一职责原则，这样的接口才是有意义的  抽象类是对子类公共行为的一种封装，比如某件事情有相同的行为或者相同的作用但是内部实现细节不一样，应该用抽象类，模板模式是对抽象类最好的应用，定义子类的公共行为，将不通的具体实现延迟到子类中进行","like_count":0},{"had_liked":false,"id":153867,"user_name":"🐾","can_delete":false,"product_type":"c1","uid":1087256,"ip_address":"","ucode":"D0AD0260351C31","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/18/a5218104.jpg","comment_is_top":false,"comment_ctime":1574322980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574322980","product_id":100039001,"comment_content":"接口可以包含成员变量吧，不过接口中的成员变量只能是 public static final 类型的。","like_count":0},{"had_liked":false,"id":153831,"user_name":"大胃王","can_delete":false,"product_type":"c1","uid":1120238,"ip_address":"","ucode":"17072DCDB4C7FC","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/ee/b123e7bc.jpg","comment_is_top":false,"comment_ctime":1574314482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574314482","product_id":100039001,"comment_content":"个人理解<br>抽象类：说来说去本质上还是一个类，接口则只是操作规范<br>","like_count":0},{"had_liked":false,"id":153790,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1574307815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574307815","product_id":100039001,"comment_content":"普通父类和抽象类对比的案例，可以在普通父类中实现一个log方法；","like_count":0},{"had_liked":false,"id":153751,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1574302302,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574302302","product_id":100039001,"comment_content":"抽象类案例在开发中会使用贫血模式,然后定义一个借口两个实现类.","like_count":0},{"had_liked":false,"id":153732,"user_name":"lmdcx","can_delete":false,"product_type":"c1","uid":1334409,"ip_address":"","ucode":"F2CDD0091ADFD7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjRETqRjvLESLDZkNTjIiaSibtNYBaS1o8WMUicOFn3ycF3Mgh6LRJibqSBjVBjiaO2ibW0gHkafATb21A/132","comment_is_top":false,"comment_ctime":1574300846,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574300846","product_id":100039001,"comment_content":"个人理解：<br>我喜欢这样描述接口的意义：接口用来描述需求，定义规格（隔壁的许式伟老师总是喜欢用规格这个词），“不关心”多态（即子类具体实现的差异，比如IO接口的抽象不关心是网络IO还是各种本地IO）。  <br>（当然怎么组织语言其实和老师表达的意思都是一致的）<br>我理解的抽象类其实还便于快速构建思路，快速实现简单方法，对于复杂方法可以先定义出接口，从而快速的完成整体逻辑。我见过在很多抽象类都会在本垒实现的方法中调用定义的抽象方法（尽管他们不是出于我说的目的而是为了留给子类实现）。  <br>我理解的里氏替换原则里的父类是指接口类，而不是抽象类，或者实体类。因为抽象类和实体类都会对子类有束缚（不能多重继承），而接口不会有这种副作用。  <br><br>疑问：<br>1. “基于接口而非实现编程” 的程度（或者说边界）怎么把控？  <br>  在贫血模型的MVC（上一章我已经中弹好几次）中，我们一般对于&quot;数据对象&quot;（我自己起的名字）不做接口定义，一般对于&quot;行为对象&quot;（比如 Service Repository&#47;DAO）会做接口定义。<br>  在实际的开源项目中，一般都会建议依赖接口，而我在看 SpringSecurity 的时候，发现他的“数据对象”也会定义为接口，比如 principal 。  <br>2. 那么什么情况下定义接口，什么情况下不用定义接口？  <br>  （我认为应该在模块边缘定义接口，但是如何确定模块边缘？是需要学学隔壁的DDD课程才能解决吗？）  <br>3. 如果“于接口而非实现编程”会不会导致接口数量的爆炸？（我其实也担心学了隔壁DDD，会导致定义类的数量爆炸）如果会造成接口数量膨胀，这是难以避免的繁琐，还是有可权衡的规则？  <br>","like_count":0,"discussions":[{"author":{"id":1334409,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjRETqRjvLESLDZkNTjIiaSibtNYBaS1o8WMUicOFn3ycF3Mgh6LRJibqSBjVBjiaO2ibW0gHkafATb21A/132","nickname":"lmdcx","note":"","ucode":"F2CDD0091ADFD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55465,"discussion_content":"老师的答案在下一篇啊 (＾▽＾) 。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574380943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153682,"user_name":"疯狂的石头","can_delete":false,"product_type":"c1","uid":1179676,"ip_address":"","ucode":"E14331FAA436EE","user_header":"https://static001.geekbang.org/account/avatar/00/12/00/1c/d39cdabd.jpg","comment_is_top":false,"comment_ctime":1574297119,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574297119","product_id":100039001,"comment_content":"在logger定义为抽象类的时候，子类继承它，不会强制重写log方法吧，因为他不是抽象方法。","like_count":0},{"had_liked":false,"id":153680,"user_name":"云","can_delete":false,"product_type":"c1","uid":1066629,"ip_address":"","ucode":"138F855329C281","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/85/6090b202.jpg","comment_is_top":false,"comment_ctime":1574296855,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574296855","product_id":100039001,"comment_content":"老师总结的很好","like_count":0},{"had_liked":false,"id":153673,"user_name":"李皮皮皮皮皮","can_delete":false,"product_type":"c1","uid":1200281,"ip_address":"","ucode":"3BF1DEE4A12359","user_header":"https://static001.geekbang.org/account/avatar/00/12/50/99/44378317.jpg","comment_is_top":false,"comment_ctime":1574296036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574296036","product_id":100039001,"comment_content":"关于c++部分的描述有个小问题，virtual只是为了实现多态和抽象没关系，=0声明纯虚函数才是子类必须实现的风。另外c++中，析构函数加上virtual是最佳实践，为了防止delete父类对象调用不到字累的析构导致子类有内存或资源泄漏","like_count":0},{"had_liked":false,"id":153663,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1574295076,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574295076","product_id":100039001,"comment_content":"java8已经支持default关键对接口方法添加默认实现了","like_count":0},{"had_liked":false,"id":153622,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1574282941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574282941","product_id":100039001,"comment_content":"个人以为动态语言没有必要定义接口和抽象类，只要用duck-typing即可，毕竟这种实现更贴近于动态语言的设计。如果模拟了抽象类和接口，要定义辅助类和继承，但是得不到静态语言编译期检查的好处，投入产出不成比例。","like_count":0},{"had_liked":false,"id":153621,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1574282595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574282595","product_id":100039001,"comment_content":"我一般不用抽象类，所以也就没有选择的烦恼。上面那个用抽象类的例子Logger，我会定义一个类，例如LogConfig来共享代码，另外定义一个接口明确调用的协议和实现多态。我个人以为用到抽象类地方一般都可以用接口拆分，达到协议和实现的分离。请王老师点评一下对这种编程风格（尽量用接口+包含替代抽象类），多谢。","like_count":0},{"had_liked":false,"id":153611,"user_name":"Last丶","can_delete":false,"product_type":"c1","uid":1234142,"ip_address":"","ucode":"43443006ECF176","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/de/086d79e4.jpg","comment_is_top":false,"comment_ctime":1574268852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574268852","product_id":100039001,"comment_content":"接口类子类要实现方法  抽象类子类也可以自己再实现这样用继承的方法来重写父类的方法 不同的场景就可以做不同的事  这个也是多态","like_count":0},{"had_liked":false,"id":153595,"user_name":"啦啦","can_delete":false,"product_type":"c1","uid":1084028,"ip_address":"","ucode":"B9D8DE2A5AB873","user_header":"","comment_is_top":false,"comment_ctime":1574264314,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574264314","product_id":100039001,"comment_content":"Scala支持抽象类，也支持接口Trait，换了名字而已<br>","like_count":0},{"had_liked":false,"id":153579,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1574262254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574262254","product_id":100039001,"comment_content":"1. 不知道文章中关于接口有一个描述：“接口不能包含属性”，是该如何理解？在java中，接口是可以定义public、static、final类型的属性的，属性必须被显示初始化。<br>2. 感觉普通类模拟抽象类，也只能将构造器声明为protected, 将需要子类重写的的方法抛出异常。不知道还有没有其他好的思路。","like_count":0},{"had_liked":false,"id":153575,"user_name":"追风筝的人","can_delete":false,"product_type":"c1","uid":1488020,"ip_address":"","ucode":"2993D60F94C396","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg","comment_is_top":false,"comment_ctime":1574261860,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574261860","product_id":100039001,"comment_content":"抽象类是向上抽象的，接口是自上而下抽象的","like_count":0},{"had_liked":false,"id":153571,"user_name":"Lifelong Learning","can_delete":false,"product_type":"c1","uid":1173517,"ip_address":"","ucode":"3E39BED3E13FB4","user_header":"https://static001.geekbang.org/account/avatar/00/11/e8/0d/fcd95db8.jpg","comment_is_top":false,"comment_ctime":1574260972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574260972","product_id":100039001,"comment_content":"1.抽象类中可以有成员变量和方法,方法也可以有具体的实现,但是抽象类不能被实例化,继承抽象类的子类必须要实现抽象类中所有抽象方法,抽象类主要体现的是“is-a”,主要用于代码复用<br>2.接口其实也是一种类而已,暂且定义为“接口类”,接口中不能有称有变量但是可以有以final static修饰的静态字面量,而方法不能有具体的实现,其他类在实现接口时,实现接口的类必须将接口中所有的方法实现一遍,接口主要体现的是“has-a”,主要用于问题的抽象.","like_count":0},{"had_liked":false,"id":153565,"user_name":"醉比","can_delete":false,"product_type":"c1","uid":1248399,"ip_address":"","ucode":"79E65F62BE7809","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/8f/4ebd303a.jpg","comment_is_top":false,"comment_ctime":1574259376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574259376","product_id":100039001,"comment_content":"如果有面试官再问我这种题的话，我想我会这么回答：抽象类是一种is-a的关系，一般是自下而上进行设计，可以帮我们解决代码复用的问题与增加代码的规范。接口则是一中has-a的关系，是为了解决解耦问题，制定接口是自上而下的。先答这么多，小争哥今天对接口的规范讲的相对少一些，等之后重点讲接口的时候我再重新补充。今天起码对抽象类有了更深的认识了~","like_count":0},{"had_liked":false,"id":153549,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1574257222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574257222","product_id":100039001,"comment_content":"我用的编程语言 java 支持接口和抽象类的语法, 接口重点在实现 解耦 抽象类代码复用, ","like_count":0},{"had_liked":false,"id":153541,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1574256401,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574256401","product_id":100039001,"comment_content":"接口与抽象类有什么不同?<br>先说语法上<br>1.接口不允许有方法体,抽象类可以有方法体;<br>2.接口可以被实现,抽象类可以被继承;<br>3.子类方法必须实现接口的所有方法,抽象类的非抽象方法则不需要实现;<br>再说功能上<br>1.抽象类可以复用代码,提高可读性,同时解决在开发中误用父类实例,忘记重写子类方法的问题;<br>2.面向接口编程则可以使我们关注功能而不需要关注具体实现,同时提高代码可扩展性;<br>举例说明:<br>抽象类:\t在tomcat源码中,server,service,connector,等组件底的父类LifecycleBase实现了init,start,stop等生命周期相关的方法,实现了代码复用,同时体现了设计模式中的模板方法模式<br>在spring源码中,抽象类运用的同样频繁<br>抽象类和接口在源码框架中更多是同时出现,一个类通常会继承一个抽象类,这个抽象类实现一个接口,接口定义动作,抽象类实现具体的行为,子类根据需求来确定是否重写父类方法<br>比如,我们常常以注解配置的方式启动springboot,我们用到的AnnotationConfigApplicationContext的依赖关系中有  <br>ConfigurableApplicationContext(接口)<br>↑实现<br>AbstractApplicationContext (抽象类)<br>↑继承<br>GenericApplicationContext (普通类)<br>↑继承<br>AnnotationConfigApplicationContext(普通类)<br>接口:不论我们使用什么数据库,mySQL,orcale,postgreSQL还是SQLServer,都可以用一套JDBC搞定,这就是面向接口编程的好处","like_count":0},{"had_liked":false,"id":153508,"user_name":"moqifei","can_delete":false,"product_type":"c1","uid":1358410,"ip_address":"","ucode":"E0A6C858B78A3A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLGovXf8jNP5ZqHsDKLwajjicbFwpX9on1xiaJDR4CgWaWP2KcfOdneasBfKFo3dO3dwQyGG6WjK40w/132","comment_is_top":false,"comment_ctime":1574249393,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574249393","product_id":100039001,"comment_content":"java 8 接口支持defualt method；java 9 接口支持private method","like_count":0},{"had_liked":false,"id":153479,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1574242914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574242914","product_id":100039001,"comment_content":"question1: 你熟悉的编程语言，是否有现成的语法支持接口和抽象类呢？具体是如何定义的呢？<br><br>answer1: Java中<br>&#47;&#47;抽象类的定义方式<br>public abstract class AbsObj{<br>protected abstract void onHandle();<br>}<br><br>&#47;&#47;接口的定义方式<br>public interface Listener{<br>    void onHandle();<br>}<br><br><br>question2: 前面我们提到，接口和抽象类是两个经常在面试中被问到的概念。学习完今天的内容之后，你是否对抽象类和接口有一个新的认识呢？如果面试官再让你聊聊接口和抽象类，你会如何回答呢？<br><br>抽象类与衍生类是is-a关系,抽象类解决代码复用问题,在程序设计中通常是多个子类中有代码重复,提取到抽象类,抽象类的产生是一个自下而上的过程;<br>接口与实现类是has-a的关系,接口解决解耦问题,在程序设计中通常是首先抽象业务,定义接口,再编写实现类.接口的产生是一个自上而下的过程.<br><br>抽象类与接口都是为了赋予实现类的功能而存在,这是抽象类与接口的同一性.<br>在程序设计中,要尽可能使用接口,少使用抽象类.<br><br>question3:如何用普通类模拟抽象类?<br><br>answer3:  普通类的所有方法均采用空实现,并抛出MethodUnsupportedException.","like_count":0},{"had_liked":false,"id":153458,"user_name":"大悲","can_delete":false,"product_type":"c1","uid":1341085,"ip_address":"","ucode":"3A7865964B0159","user_header":"https://static001.geekbang.org/account/avatar/00/14/76/9d/bfcdbdda.jpg","comment_is_top":false,"comment_ctime":1574238656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574238656","product_id":100039001,"comment_content":"我个人觉得类是is a的表示， 类中的属性是has a的表示， 接口理解为can do的表示更贴切。简单的说，类是现实生活中的名词，接口是一个动词或者形容词。请老师指正。","like_count":0},{"had_liked":false,"id":153449,"user_name":"gogo","can_delete":false,"product_type":"c1","uid":1003104,"ip_address":"","ucode":"E8F0F3B000020A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/60/0d5aa340.jpg","comment_is_top":false,"comment_ctime":1574237400,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574237400","product_id":100039001,"comment_content":"java接口是可以定义属性的，只不过默认是常量","like_count":0},{"had_liked":false,"id":153435,"user_name":"Zzz","can_delete":false,"product_type":"c1","uid":1536612,"ip_address":"","ucode":"5BDFF04D19442F","user_header":"https://static001.geekbang.org/account/avatar/00/17/72/64/a4890092.jpg","comment_is_top":false,"comment_ctime":1574235670,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574235670","product_id":100039001,"comment_content":"有一个疑问：java8后接口支持default方法，作用就更抽象类的代码复用差不多，但是接口是可以多实现的，同一个类实现多个接口，且接口中有default方法冲突的时候，会编译报错。java为了避免这种情况，类不能多继承，然后使用接口，现在接口出现了default方法，是不是设计的也不太合理","like_count":0},{"had_liked":false,"id":153417,"user_name":"曾经瘦过","can_delete":false,"product_type":"c1","uid":1240106,"ip_address":"","ucode":"57C32575A1C1FD","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/2a/b11d5ad8.jpg","comment_is_top":false,"comment_ctime":1574232802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574232802","product_id":100039001,"comment_content":"主要使用的是java 语言  <br>对于抽象类和接口主要牢记住两者的侧重点就可以了     抽象类侧重于方法复用   接口侧重于解耦   ","like_count":0},{"had_liked":false,"id":153413,"user_name":"流鶴粱","can_delete":false,"product_type":"c1","uid":1007252,"ip_address":"","ucode":"534EE37E96378C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/94/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1574232240,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574232240","product_id":100039001,"comment_content":"Swift中的协议，除了有接口的特性以外，还能定义属性，实现方法，所以Swift中的协议也是抽象类吗？","like_count":0},{"had_liked":false,"id":153410,"user_name":"流鶴粱","can_delete":false,"product_type":"c1","uid":1007252,"ip_address":"","ucode":"534EE37E96378C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/94/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1574231948,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574231948","product_id":100039001,"comment_content":"抽象类 vs swift中的接口<br><br>实例化\t否\t否<br>属性\t        是     是<br>方法          是     是<br>实现          是      是<br>目的         复用  扩展和复用?<br>意义          is-a   has-a?<br>抽象类能做的  swift中的接口也都能做,  所以swift中的接口也可以说是抽象类?","like_count":0},{"had_liked":false,"id":153404,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1257099,"ip_address":"","ucode":"9662D56F5EA546","user_header":"https://static001.geekbang.org/account/avatar/00/13/2e/8b/ea0a1585.jpg","comment_is_top":false,"comment_ctime":1574230804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574230804","product_id":100039001,"comment_content":"对为什么要有抽象类，理解的更深了","like_count":0},{"had_liked":false,"id":153402,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1574230734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574230734","product_id":100039001,"comment_content":"抽象类是为了解决代码复用的问题，是 is-a的关系。<br><br>接口是为了解耦，将定义和具体实现分开，提高代码的扩展性，是 has-a的关系。<br><br>接口是比抽象类更加抽象的一种设计方法。在实际中，我们设计具体的业务问题时，先考虑更加上层的（也就是更加抽象的），来定义一些规范或协议（其实就是我们的接口），然后再去考虑具体的各种实现。<br><br>比如，在Java中的List接口就会先定义一些方法size()、isEmpty()、add()、remove()等等。然后在AbstractList抽象类中对这些公有方法进行实现。最后在ArrayList、LinkedList等实际应用的类中添加自己的一些方法。","like_count":0},{"had_liked":false,"id":153370,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1574225375,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574225375","product_id":100039001,"comment_content":"看到都知道，自己说可能就没有组织的这么好，梳理成体系的感觉很赞","like_count":0},{"had_liked":false,"id":153369,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1574225046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574225046","product_id":100039001,"comment_content":"1.抽象类是某一类东西的公共模板。接口是某一类东西的行为抽象。<br>2.用组合加接口的方式也能很好的实现抽象类。但显然没有直接继承抽象类优雅。不过java只能单继承，所以抽象类相对于组合加接口的模式显得不够灵活（毕竟接口可以多实现，组合可以多组合）。","like_count":0},{"had_liked":false,"id":153349,"user_name":"pines","can_delete":false,"product_type":"c1","uid":1200708,"ip_address":"","ucode":"7B925605B36B4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/44/de7f2b98.jpg","comment_is_top":false,"comment_ctime":1574220804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574220804","product_id":100039001,"comment_content":"1.Go只有接口方式，type Reader interface{<br>        func read()([]byte,error)<br>}<br><br>2.从语法上抽象类必须由子类继承并实现方法，所有从语义上最好也是从属的关系（比如抽象类动物，子类鸭子，就是老师说的isa的问题）。接口的实现有的语言要求实例类中需要加implement，有的不需要。并且不需要有此类从属关系（例如有一个接口方法只有一个work(),那么实例类只要实现work方法，就实现了接口。就是老师说的hasa的问题）","like_count":0},{"had_liked":false,"id":153343,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1574220327,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574220327","product_id":100039001,"comment_content":"打卡，个人主要编程语言是PHP，有些地方很相近，有些地方又不甚清楚，总体上读两遍有收获 \\smile","like_count":0},{"had_liked":false,"id":153337,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1574219886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574219886","product_id":100039001,"comment_content":"最近也在学习go语言 恰好有一个就是接口的概念  通过今天的学习 对接口的理解更深刻了","like_count":0},{"had_liked":false,"id":153336,"user_name":"努力努力再努力m","can_delete":false,"product_type":"c1","uid":1644369,"ip_address":"","ucode":"9DD9E9C2988FFC","user_header":"https://static001.geekbang.org/account/avatar/00/19/17/51/3e13dc0c.jpg","comment_is_top":false,"comment_ctime":1574219842,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574219842","product_id":100039001,"comment_content":"在平常的mvc web项目开发中，更多的是使用接口，抽象类反而用的很少。看了这篇文章后，对抽象类和接口的适用场景和特性更加了解了。","like_count":0},{"had_liked":false,"id":153335,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1574219811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574219811","product_id":100039001,"comment_content":"通过今天的学习我才了解到抽象类和接口的真正含义 以前连函数和接口都是模糊的。。。。","like_count":0},{"had_liked":false,"id":153324,"user_name":"塔兹米","can_delete":false,"product_type":"c1","uid":1425252,"ip_address":"","ucode":"1A58C81EF9B0A4","user_header":"https://static001.geekbang.org/account/avatar/00/15/bf/64/c9a0e913.jpg","comment_is_top":false,"comment_ctime":1574217394,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574217394","product_id":100039001,"comment_content":"打卡，<br>Java 是单继承，通过接口可以实现 单继承多实现。如 ：Runnable 接口","like_count":0},{"had_liked":false,"id":153315,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1574214314,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574214314","product_id":100039001,"comment_content":"我感觉，<br>1. 在抽象类的目的，更多的是将子类的公共代码给抽象出来，然后在抽象类中执行。不同的逻辑在子类中执行。<br>2. 接口是先定义我们需要的接口，在不同子类中进行对应的功能实现。<br>总结：所以在抽象类和接口中，抽象是将公共部分抽象到父类，这样就有了抽象的概念。抽象类注重抽象的过程，接口类注重接口。所以在不同语言实现的时候，把握住不同的侧重点，就可以模拟出对应的抽象类和接口的样子。细想起来 其实接口和抽象类没有很明显的区别。","like_count":0},{"had_liked":false,"id":153307,"user_name":"Kang","can_delete":false,"product_type":"c1","uid":1237655,"ip_address":"","ucode":"088A8DA0A16BDE","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/97/dfadcc92.jpg","comment_is_top":false,"comment_ctime":1574213559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574213559","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":153306,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1574213459,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574213459","product_id":100039001,"comment_content":"抽象类为了代码复用，像文章中提到的模板模式就是非常典型的例子，接口类是为了抽象，同时屏蔽具体实现，达到封装的效果。","like_count":0},{"had_liked":false,"id":153303,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1574213090,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574213090","product_id":100039001,"comment_content":"接口中可以定义static final","like_count":0},{"had_liked":false,"id":153302,"user_name":"不与三季人说","can_delete":false,"product_type":"c1","uid":1693164,"ip_address":"","ucode":"A3F03832309FDD","user_header":"https://static001.geekbang.org/account/avatar/00/19/d5/ec/3d6e7ea7.jpg","comment_is_top":false,"comment_ctime":1574213088,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574213088","product_id":100039001,"comment_content":"终于出了抽象类的接口的文章，看到题目很兴奋。因为我面试曾被问过，但是我知道特性却不知道什么时候用抽象类，我的印象中好像很少用到抽象类，接口用的比较多，看了文章后发现也还是没有搞清楚什么时候要用抽象类，可能在高标准的开发环境下 ，会强制把一些类用成抽象类，然后通过继承，但我们平时开发不注意那么多 ，几乎直接用继承的比较多，不会考虑用抽象类的情况。","like_count":0},{"had_liked":false,"id":153288,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1574211169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574211169","product_id":100039001,"comment_content":"重新温习，并更加深入理解了抽象与接口的含义，讲的不错，分析透彻。","like_count":0},{"had_liked":false,"id":153239,"user_name":"grey927","can_delete":false,"product_type":"c1","uid":1202782,"ip_address":"","ucode":"833E02ED835B4A","user_header":"https://static001.geekbang.org/account/avatar/00/12/5a/5e/a897cb0d.jpg","comment_is_top":false,"comment_ctime":1574207267,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"1574207267","product_id":100039001,"comment_content":"jdk8中接口方法已经支持存在默认实现了，是不是意味着可以完全替代抽象类","like_count":0,"discussions":[{"author":{"id":1181647,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/cf/b0d6fe74.jpg","nickname":"L.","note":"","ucode":"46A2F679C094E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53953,"discussion_content":"只能说可以替代Adapter适配器模式~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574240876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1027798,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ae/d6/fbb8236d.jpg","nickname":"DebugDog","note":"","ucode":"1664D37CE03B9D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53779,"discussion_content":"完全替代不会吧，接口中还是没有成员变量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574215667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1100703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","nickname":"阿玛铭","note":"","ucode":"DBF948D82ACBE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1027798,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ae/d6/fbb8236d.jpg","nickname":"DebugDog","note":"","ucode":"1664D37CE03B9D","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":53859,"discussion_content":"java8中的接口可以定义常量","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574225634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53779,"ip_address":""},"score":53859,"extra":""},{"author":{"id":1202782,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5a/5e/a897cb0d.jpg","nickname":"grey927","note":"","ucode":"833E02ED835B4A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1027798,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ae/d6/fbb8236d.jpg","nickname":"DebugDog","note":"","ucode":"1664D37CE03B9D","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":53919,"discussion_content":"java接口中一直都可以定义常量呀","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574234912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53779,"ip_address":""},"score":53919,"extra":""},{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1100703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","nickname":"阿玛铭","note":"","ucode":"DBF948D82ACBE3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128282,"discussion_content":"常量跟变量不一样啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578625969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53859,"ip_address":""},"score":128282,"extra":""}]}]},{"had_liked":false,"id":153233,"user_name":"ismind","can_delete":false,"product_type":"c1","uid":1138710,"ip_address":"","ucode":"7AADD673ED3BC4","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/16/d1dd4972.jpg","comment_is_top":false,"comment_ctime":1574206410,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"1574206410","product_id":100039001,"comment_content":"为什么自己测试，将这个类的构造函数声明为 protected，然后再另一个类中new这个类，依然可以呢？","like_count":0,"discussions":[{"author":{"id":1435246,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e6/6e/062da5e4.jpg","nickname":"肥而不腻","note":"","ucode":"3E6786A82A6DD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53714,"discussion_content":"Protected范围是同一个package","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574211328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258209,"avatar":"https://static001.geekbang.org/account/avatar/00/13/32/e1/c9aacb37.jpg","nickname":"段启超","note":"","ucode":"164CF3018071B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54114,"discussion_content":"我觉得如果要在其他的任何一个类中都不能new这个类，这个类的构造方法应该写成private 的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574260334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1587803,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3a/5b/ce1724ca.jpg","nickname":"undefined","note":"","ucode":"867405CA5A9FB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1258209,"avatar":"https://static001.geekbang.org/account/avatar/00/13/32/e1/c9aacb37.jpg","nickname":"段启超","note":"","ucode":"164CF3018071B2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55734,"discussion_content":"emm，private 也能运行额。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574392908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54114,"ip_address":""},"score":55734,"extra":""}]},{"author":{"id":1237399,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/97/fec494f2.jpg","nickname":"大大。","note":"","ucode":"A6716E46264AC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53738,"discussion_content":"楼上说的对\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574212316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}