{"id":740822,"title":"第 18 章 输入与输出","content":"\n<blockquote>\n<p>Doolittle：你有什么具体证据能证明你的存在？</p>\n<p>炸弹-20：嗯……好吧……我思故我在。</p>\n<p>Doolittle：很好。非常好。但你又如何知道其他事物的存在呢？</p>\n<p>炸弹-20：我的感官感受到了。</p>\n<p style=\"text-align: right\">——科幻喜剧《暗星》（<em>Dark Star</em>）</p>\n</blockquote>\n<p>&nbsp;</p>\n<p>Rust 标准库中的输入和输出的特性是围绕 3 个特型组织的，即 <code>Read</code>、<code>BufRead</code> 和 <code>Write</code>。</p>\n<ul>\n<li>实现了 <code>Read</code> 的值具有面向字节的输入方法。它们叫作<strong>读取器</strong>。</li>\n<li>实现了 <code>BufRead</code> 的值是<strong>缓冲</strong>读取器。它们支持 <code>Read</code> 的所有方法，外加读取文本行等方法。</li>\n<li>实现了 <code>Write</code> 的值能支持面向字节和 UTF-8 文本的输出。它们叫作<strong>写入器</strong>。</li>\n</ul>\n<p>图 18-1 展示了这 3 个特型以及几个读取器类型和写入器类型的示例。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00873.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 18-1：Rust 的 3 个主要 I/O 特型和一些实现了它们的类型</strong></p>\n<p>在本章中，我们会讲解如何使用这些特型及其方法，涵盖了图 18-1 中所示的这些读取器类型和写入器类型，并展示了与文件、终端和网络进行交互的其他方式。</p>\n<h2 id=\"nav_point_350\">18.1　读取器与写入器</h2>\n<p>你的程序可以从<strong>读取器</strong>中读取一些字节。例如：</p>\n<ul>\n<li>使用 <code>std::fs::File::open(filename)</code> 打开的文件；</li>\n<li><code>std::net::TcpStream</code>，用于通过网络接收数据；</li>\n<li><code>std::io::stdin()</code>，用于从进程的标准输入流中进行读取；</li>\n<li><code>std::io::Cursor&lt;&amp;[u8]&gt;</code> 值和 <code>std::io::Cursor&lt;Vec&lt;u8&gt;&gt;</code> 值，它们是从已存在于内存中的字节数组或向量中进行“读取”的读取器。</li>\n</ul>\n<p><strong>写入器</strong>则可以向其中写入一些字节。例如：</p>\n<ul>\n<li>使用 <code>std::fs::File::create(filename)</code> 打开的文件；</li>\n<li><code>std::net::TcpStream</code>，用于通过网络发送数据；</li>\n<li><code>std::io::stdout()</code> 和 <code>std::io:stderr()</code>，用于写入到终端；</li>\n<li><code>Vec&lt;u8&gt;</code> 也是一个写入器，它的 <code>write</code> 方法会把内容追加到向量；</li>\n<li><code>std::io::Cursor&lt;Vec&lt;u8&gt;&gt;</code>，它与 <code>Vec&lt;u8&gt;</code> 很像，但允许读取数据和写入数据，并能在向量中寻找不同的位置；</li>\n<li><code>std::io::Cursor&lt;&amp;mut [u8]&gt;</code>，它与 <code>std::io::Cursor&lt;Vec&lt;u8&gt;&gt;</code> 很像，不过不能增长缓冲区，因为它只是一些现有字节数组的切片。</li>\n</ul>\n<p>由于读取器和写入器都有标准特型（<code>std::io::Read</code> 和 <code>std::io::Write</code>），因此编写适用于各种输入通道或输出通道的泛型代码是很常见的。例如，下面是一个将所有字节从任意读取器复制到任意写入器的函数：</p>\n<pre class=\"code-rows\"><code>use std::io::;\n\nconst DEFAULT_BUF_SIZE: usize = 8 * 1024;\n\npub fn copy&lt;R: ?Sized, W: ?Sized&gt;(reader: &amp;mut R, writer: &amp;mut W)\n    -&gt; io::Result&lt;u64&gt;\n    where R: Read, W: Write\n{\n    let mut buf = [0; DEFAULT_BUF_SIZE];\n    let mut written = 0;\n    loop {\n        let len = match reader.read(&amp;mut buf) {\n            Ok(0) =&gt; return Ok(written),\n            Ok(len) =&gt; len,\n            Err(ref e) if e.kind() == ErrorKind::Interrupted =&gt; continue,\n            Err(e) =&gt; return Err(e),\n        };\n        writer.write_all(&amp;buf[..len])?;\n        written += len as u64;\n    }\n}</code></pre>\n<p>这是 Rust 标准库中 <code>std::io::copy()</code> 的实现。由于是泛型的，因此可以使用它将数据从 <code>File</code> 复制到 TcpStream，从标准输入复制到内存中的 <code>Vec&lt;u8&gt;</code>，等等。</p>\n<p>如果对此处的错误处理代码不清楚，可以重温一下第 7 章。我们接下来还要不断使用 <code>Result</code> 类型，了解它的工作原理很重要。</p>\n<p><code>std::io</code> 的 <code>Read</code>、<code>BufRead</code> 和 <code>Write</code> 这 3 个特型以及 <code>Seek</code> 非常常用，下面是一个只包含这些特型的 <code>prelude</code> 模块：</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code>use std::io::prelude::*;</code></pre>\n<p>你会在本章中看到一两次这种写法。我们还习惯于导入 <code>std::io</code> 模块本身：</p>\n<pre class=\"code-rows\"><code>use std::io::;</code></pre>\n<p>此处的 <code>self</code> 关键字将 <code>io</code> 声明成了 <code>std::io</code> 模块的别名。这样，<code>std::io::Result</code> 和 <code>std::io::Error</code> 就可以更简洁地写为 <code>io::Result</code> 和 <code>io::Error</code> 了。</p>\n<h3 id=\"nav_point_351\">18.1.1　读取器</h3>\n<p><code>std::io::Read</code> 有以下几个读取数据的方法。所有这些方法都需要对读取器本身进行可变引用。</p>\n<blockquote>\n<p><code>reader.read(&amp;mut buffer)</code>（读取）</p>\n</blockquote>\n<p>从数据源中读取一些字节并将它们存储在给定的 <code>buffer</code> 中。<code>buffer</code> 参数的类型是 <code>&amp;mut[u8]</code>。此方法最多会读取 <code>buffer.len()</code> 字节。</p>\n<p>返回类型是 <code>io::Result&lt;u64&gt;</code>，它是 <code>Result&lt;u64, io::Error&gt;</code> 的类型别名。成功时，这个 <code>u64</code> 的值是已读取的字节数——可能等于或小于 <code>buffer.len()</code>，<strong>就算数据源突然涌入更多数据也不会超出</strong>。<code>Ok(0)</code> 则意味着没有更多输入可以读取了。</p>\n<p>出错时，<code>.read()</code> 会返回 <code>Err(err)</code>，其中 <code>err</code> 是一个 <code>io::Error</code> 值。为了对人类友好，<code>io::Error</code> 是可打印的；为了便于程序处理，它有一个 <code>.kind()</code> 方法，该方法会返回 <code>io::ErrorKind</code> 类型的错误代码。此枚举的成员都有 <code>PermissionDenied</code> 和 <code>ConnectionReset</code> 之类的名称。大多数表示严重的错误，不容忽视，但有一种错误需要特殊处理。<code>io::ErrorKind::Interrupted</code> 对应于 Unix 错误码 <code>EINTR</code>，表示读取恰好被某种信号中断了。除非程序的设计目标之一就是对信号中断做一些巧妙的处理，否则就应该再次尝试读取。18.1 节中的 <code>copy()</code> 代码就展示了这种示例。</p>\n<p>如你所见，<code>.read()</code> 方法是非常底层的，甚至还继承了底层操作系统的某些怪癖。如果你正在为一种新型数据源实现 <code>Read</code> 特型，那么这会给你很大的发挥空间。但如果你想读取一些数据，则会很痛苦。因此，Rust 提供了几个更高级的便捷方法。这些方法是 <code>Read</code> 中的默认实现，而且都处理了 <code>ErrorKind::Interrupted</code>，这样你就不必自己处理了。</p>\n<blockquote>\n<p><code>reader.read_to_end(&amp;mut byte_vec)</code>（读至末尾）</p>\n</blockquote>\n<p>从这个读取器读取所有剩余的输入，将其追加到 <code>Vec&lt;u8&gt;</code> 型的 <code>byte_vec</code> 中。返回 <code>io::Result&lt;usize&gt;</code>，即已读取的字节数。</p>\n<p>此方法对要装入向量中的数据量没有任何限制，因此不要在不受信任的来源上使用它。（可以用接下来要讲的 <code>.take()</code> 方法加以限制。）</p>\n<blockquote>\n<p><code>reader.read_to_string(&amp;mut string)</code>（读取字符串）</p>\n</blockquote>\n<p>和上一个方法类似，但此方法会将数据附加到给定的 <code>String</code>。如果流不是有效的 UTF-8，则返回 <code>ErrorKind::InvalidData</code> 错误。</p>\n<p>在某些编程语言中，字节输入和字符输入是由不同的类型处理的。如今，UTF-8 占据了绝对主导地位，所以 Rust 承认这一事实标准并且处处支持 UTF-8。开源的 <code>encoding</code> crate 可以支持其他字符集。</p>\n<blockquote>\n<p><code>reader.read_exact(&amp;mut buf)</code>（精确读满）</p>\n</blockquote>\n<p>读取足够的数据来填充给定的缓冲区。参数类型是 <code>&amp;[u8]</code>。如果读取器在读够 <code>buf.len()</code> 字节之前就耗尽了数据，那么此方法就会返回 <code>ErrorKind::UnexpectedEof</code> 错误。</p>\n<p>以上这些是 <code>Read</code> 特型的主要方法。此外，还有 3 个适配器方法可以按值获取 <code>reader</code>，将其转换为迭代器或另一种读取器。</p>\n<blockquote>\n<p><code>reader.bytes()</code>（字节迭代器）</p>\n</blockquote>\n<p>返回输入流中各字节的迭代器。条目类型是 <code>io::Result&lt;u8&gt;</code>，因此每字节都需要进行错误检查。此外，此方法会为每字节调用一次 <code>reader.read()</code>，如果没有缓冲，则会非常低效。</p>\n<blockquote>\n<p><code>reader.chain(reader2)</code>（串联）</p>\n</blockquote>\n<p>返回新的读取器，先生成来自 <code>reader</code> 的所有输入，然后再生成来自 <code>reader2</code> 的所有输入。</p>\n<blockquote>\n<p><code>reader.take(n)</code>（取出 <em>n</em> 个）</p>\n</blockquote>\n<p>返回新的读取器，从与 <code>reader</code> 相同的数据源读取，但仅限于前 <code>n</code> 字节的输入。</p>\n<p>没有关闭读取器的方法。读取器和写入器通常会实现 <code>Drop</code> 以便自行关闭。</p>\n<h3 id=\"nav_point_352\">18.1.2　缓冲读取器</h3>\n<p>为了提高效率，可以对读取器和写入器进行<strong>缓冲</strong>，这基本上意味着它们有一块内存（缓冲区），用于保存一些输入数据或输出数据。这可以减少一些系统调用，如图 18-2 所示。应用程序会从 <code>BufReader</code> 中读取数据，在本例中是通过调用其 <code>.read_line()</code> 方法实现的。<code>BufReader</code> 会依次从操作系统获取更大块的输入。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00874.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 18-2：缓冲文件读取器</strong></p>\n<p>图 18-2 未按比例绘制。<code>BufReader</code> 缓冲区的实际大小默认为几千字节，因此一次 <code>read</code> 系统调用就可以服务数百次 <code>.read_line()</code> 调用。这很重要，因为系统调用很慢。</p>\n<p>（如图 18-2 所示，操作系统也有自己的缓冲区。同理：系统调用固然慢，但从磁盘读取数据更慢。）</p>\n<p>缓冲读取器同时实现了 <code>Read</code> 特型和 <code>BufRead</code> 特型，后者添加了以下方法。</p>\n<blockquote>\n<p><code>reader.read_line(&amp;mut line)</code>（读一行）</p>\n</blockquote>\n<p>读取一行文本并将其追加到 <code>line</code>，<code>line</code> 是一个 <code>String</code>。行尾的换行符 <code>'\\n'</code> 包含在 <code>line</code> 中。</p>\n<p>如果输入带有 Windows 风格的行尾结束符号 <code>\"\\r\\n\"</code>，则这两个字符都会包含在 <code>line</code> 中。</p>\n<p>返回值是 <code>io::Result&lt;usize&gt;</code>，表示已读取的字节数，包括行尾结束符号（如果有的话）。</p>\n<p>如果读取器在输入的末尾，则会保持 <code>line</code> 不变并返回 <code>Ok(0)</code>。</p>\n<blockquote>\n<p><code>reader.lines()</code>（文本行迭代器）</p>\n</blockquote>\n<p>返回生成各个输入行的迭代器。条目类型是 <code>io::Result&lt;String&gt;</code>。字符串中不包含换行符。如果输入带有 Windows 风格的行尾结束符号 <code>\"\\r\\n\"</code>，则这两个字符都会被去掉。</p>\n<p>在绝大多数场景中，这个方法足够你进行文本输入了。接下来的 18.1.3 节和 18.1.4 节展示了它的一些使用示例。</p>\n<blockquote>\n<p><code>reader.read_until(stop_byte, &amp;mut byte_vec)</code>（读到 <code>stop_byte</code> 为止）和 <code>reader.split(stop_byte)</code>（根据 <code>stop_byte</code> 拆分）</p>\n</blockquote>\n<p>与 <code>.read_line()</code> 和 <code>.lines()</code> 类似，但这两个方法是面向字节的，会生成 <code>Vec&lt;u8&gt;</code> 而不是 <code>String</code>。你要自选分隔符 <code>stop_byte</code>。</p>\n<p><code>BufRead</code> 还提供了 <code>.fill_buf()</code> 和 <code>.consume(n)</code>，这是一对底层方法，用于直接访问读取器的内部缓冲区。有关这两个方法的更多信息，请参阅在线文档。</p>\n<p>接下来的 18.1.3 节和 18.1.4 节将更详细地介绍缓冲读取器。</p>\n<h3 id=\"nav_point_353\">18.1.3　读取行</h3>\n<p>下面是一个用于实现 Unix <code>grep</code> 实用程序的函数，该函数会在多行文本（通常是通过管道从另一条命令输入的文本）中搜索给定字符串：</p>\n<pre class=\"code-rows\"><code>use std::io;\nuse std::io::prelude::*;\n\nfn grep(target: &amp;str) -&gt; io::Result&lt;()&gt; {\n    let stdin = io::stdin();\n    for line_result in stdin.lock().lines() {\n        let line = line_result?;\n        if line.contains(target) {\n            println!(\"{}\", line);\n        }\n    }\n    Ok(())\n}</code></pre>\n<p>因为要调用 <code>.lines()</code>，所以需要一个实现了 <code>BufRead</code> 的输入源。在这种情况下，可以调用 <code>io::stdin()</code> 来获取通过管道传输给我们的数据。但是，Rust 标准库使用互斥锁保护着 <code>stdin</code>。因此要调用 <code>.lock()</code> 来锁定 <code>stdin</code> 以供当前线程独占使用，这会返回一个实现了 <code>BufRead</code> 的 <code>StdinLock</code> 值。在循环结束时，<code>StdinLock</code> 会被丢弃，释放互斥锁。（如果没有互斥锁，那么当两个线程试图同时从 <code>stdin</code> 读取时就会导致未定义行为。C 语言也有相同的问题，且以相同的方式来解决：所有 C 标准输入函数和输出函数都会在幕后获得锁。唯一的不同在于，在 Rust 中，锁是 API 的一部分。）</p>\n<p>该函数的其余部分都很简单：它会调用 <code>.lines()</code> 并对生成的迭代器进行循环。因为这个迭代器会生成 <code>Result</code> 值，所以要用 <code>?</code> 运算符检查错误。</p>\n<p>假如我们想完善这个 <code>grep</code> 程序，让它支持在磁盘上搜索文件。可以把这个函数变成泛型函数：</p>\n<pre class=\"code-rows\"><code>fn grep&lt;R&gt;(target: &amp;str, reader: R) -&gt; io::Result&lt;()&gt;\n    where R: BufRead\n{\n    for line_result in reader.lines() {\n        let line = line_result?;\n        if line.contains(target) {\n            println!(\"{}\", line);\n        }\n    }\n    Ok(())\n}</code></pre>\n<p>现在可以将 <code>StdinLock</code> 或带缓冲的 <code>File</code> 传给它：</p>\n<pre class=\"code-rows\"><code>let stdin = io::stdin();\ngrep(&amp;target, stdin.lock())?;  // 正确\n\nlet f = File::open(file)?;\ngrep(&amp;target, BufReader::new(f))?;  // 同样正确</code></pre>\n<p>请注意，<code>File</code> 不会自动缓冲。<code>File</code> 实现了 <code>Read</code> 但没实现 <code>BufRead</code>。但是，为 <code>File</code> 或任意无缓冲读取器创建缓冲读取器很容易。<code>BufReader::new(reader)</code> 就是做这个的。（要设置缓冲区的大小，请使用 <code>BufReader::with_capacity(size, reader)</code>。）</p>\n<p>在大多数语言中，文件默认是带缓冲的。如果想要无缓冲的输入或输出，就必须弄清楚如何关闭缓冲。在 Rust 中，<code>File</code> 和 <code>BufReader</code> 是两个独立的库特性，因为有时你想要不带缓冲的文件，有时你想要不带文件的缓冲（例如，你可能想要缓冲来自网络的输入）。</p>\n<p>下面是一个包括错误处理和一些粗略的参数解析的完整程序。</p>\n<pre class=\"code-rows\"><code>// grep——搜索stdin或其他文件，以便用给定的字符串进行逐行匹配\n\nuse std::error::Error;\nuse std::io::;\nuse std::io::prelude::*;\nuse std::fs::File;\nuse std::path::PathBuf;\n\nfn grep&lt;R&gt;(target: &amp;str, reader: R) -&gt; io::Result&lt;()&gt;\n    where R: BufRead\n{\n    for line_result in reader.lines() {\n        let line = line_result?;\n        if line.contains(target) {\n            println!(\"{}\", line);\n        }\n    }\n    Ok(())\n}\n\nfn grep_main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    // 获取命令行参数。第一个参数是要搜索的字符串，其他参数是一些文件名\n    let mut args = std::env::args().skip(1);\n    let target = match args.next() {\n        Some(s) =&gt; s,\n        None =&gt; Err(\"usage: grep PATTERN FILE...\")?\n    };\n    let files: Vec&lt;PathBuf&gt; = args.map(PathBuf::from).collect();\n\n    if files.is_empty() {\n        let stdin = io::stdin();\n        grep(&amp;target, stdin.lock())?;\n    } else {\n        for file in files {\n            let f = File::open(file)?;\n            grep(&amp;target, BufReader::new(f))?;\n        }\n    }\n\n    Ok(())\n}\n\nfn main() {\n    let result = grep_main();\n    if let Err(err) = result {\n        eprintln!(\"{}\", err);\n        std::process::exit(1);\n    }\n}</code></pre>\n<h3 id=\"nav_point_354\">18.1.4　收集行</h3>\n<p>有些读取器方法（包括 <code>.lines()</code>）会返回生成 <code>Result</code> 值的迭代器。当你第一次想要将文件的所有行都收集到一个大型向量中时，就会遇到如何摆脱 <code>Result</code> 的问题：</p>\n<pre class=\"code-rows\"><code>// 正确，但不是你想要的\nlet results: Vec&lt;io::Result&lt;String&gt;&gt; = reader.lines().collect();\n\n// 错误：不能把Result的集合转换成Vec&lt;String&gt;\nlet lines: Vec&lt;String&gt; = reader.lines().collect();</code></pre>\n<p>第二次尝试无法编译：遇到这些错误怎么办？最直观的解决方法是编写一个 <code>for</code> 循环并检查每个条目是否有错：</p>\n<pre class=\"code-rows\"><code>let mut lines = vec![];\nfor line_result in reader.lines() {\n    lines.push(line_result?);\n}</code></pre>\n<p>这固然没错，但这里最好还是用 <code>.collect()</code>，事实上确实可以做到。只要知道该请求哪种类型就可以了：</p>\n<pre class=\"code-rows\"><code>let lines = reader.lines().collect::&lt;io::Result&lt;Vec&lt;String&gt;&gt;&gt;()?;</code></pre>\n<p>这是怎么做到的呢？标准库中包含了 <code>Result</code> 对 <code>FromIterator</code> 的实现（在线文档中这很容易被忽略），这个实现让一切成为可能：</p>\n<pre class=\"code-rows\"><code>impl&lt;T, E, C&gt; FromIterator&lt;Result&lt;T, E&gt;&gt; for Result&lt;C, E&gt;\n    where C: FromIterator&lt;T&gt;\n{\n    ...\n}</code></pre>\n<p>这需要仔细阅读，但确实是一个很好的技巧。假设 <code>C</code> 是任意集合类型，比如 <code>Vec</code> 或 <code>HashSet</code>。只要已经知道如何从 <code>T</code> 值的迭代器构建出 <code>C</code>，就可以从生成 <code>Result&lt;T, E&gt;</code> 值的迭代器构建出 <code>Result&lt;C, E&gt;</code>。只需从迭代器中提取各个值并从 <code>Ok</code> 结果构建出集合即可，但一旦看到 <code>Err</code>，就停止并将其传出。</p>\n<p>换句话说，<code>io::Result&lt;Vec&lt;String&gt;&gt;</code> 是一种集合类型，因此 <code>.collect()</code> 方法可以创建并填充该类型的值。</p>\n<h3 id=\"nav_point_355\">18.1.5　写入器</h3>\n<p>如前所述，输入主要是用方法完成的，而输出略有不同。</p>\n<p>本书一直在使用 <code>println!()</code> 生成纯文本输出：</p>\n<pre class=\"code-rows\"><code>println!(\"Hello, world!\");\n\nprintln!(\"The greatest common divisor of {:?} is {}\",\n         numbers, d);\n\nprintln!();  // 打印空行</code></pre>\n<p>还有不会在行尾添加换行符的 <code>print!()</code> 宏，以及会写入标准错误流的 <code>eprintln!</code> 宏和 <code>eprint!</code> 宏。所有这些宏的格式化代码都和 <code>format!</code> 宏一样，17.4 节曾讲解过。</p>\n<p>要将输出发送到写入器，请使用 <code>write!()</code> 宏和 <code>writeln!()</code> 宏。它们和 <code>print!()</code> 和 <code>println!()</code> 类似，但有两点区别：</p>\n<pre class=\"code-rows\"><code>writeln!(io::stderr(), \"error: world not helloable\")?;\n\nwriteln!(&amp;mut byte_vec, \"The greatest common divisor of {:?} is {}\",\n         numbers, d)?;</code></pre>\n<p>一是每个 <code>write</code> 宏都接受一个额外的写入器作为第一参数。二是它们会返回 <code>Result</code>，因此必须处理错误。这就是为什么要在每行末尾使用 <code>?</code> 运算符。</p>\n<p><code>print</code> 宏不会返回 <code>Result</code>，如果写入失败，它们只会 panic。由于写入的是终端，所以极少失败。</p>\n<p><code>Write</code> 特型有以下几个方法。</p>\n<blockquote>\n<p><code>writer.write(&amp;buf)</code>（写入）</p>\n</blockquote>\n<p>将切片 <code>buf</code> 中的一些字节写入底层流。此方法会返回 <code>io::Result&lt;usize&gt;</code>。成功时，这给出了已写入的字节数，如果流突然提前关闭，那么这个值可能会小于 <code>buf.len()</code>。</p>\n<p>和 <code>Reader::read()</code> 一样，这是一个要避免直接使用的底层方法。</p>\n<blockquote>\n<p><code>writer.write_all(&amp;buf)</code>（写入全部）</p>\n</blockquote>\n<p>将切片 <code>buf</code> 中的所有字节都写入。返回 <code>Result&lt;()&gt;</code>。</p>\n<blockquote>\n<p><code>writer.flush()</code>（刷新缓冲区）</p>\n</blockquote>\n<p>将可能被缓冲在内存中的数据刷新到底层流中。返回 <code>Result&lt;()&gt;</code>。</p>\n<p>请注意，虽然 <code>println!</code> 宏和 <code>eprintln!</code> 宏会自动刷新 <code>stdout</code> 流和 <code>stderr</code> 流的缓冲区，但 <code>print!</code> 宏和 <code>eprint!</code> 宏不会。使用它们时，可能要手动调用 <code>flush()</code>。</p>\n<p>与读取器一样，写入器也会在被丢弃时自动关闭。</p>\n<p>正如 <code>BufReader::new(reader)</code> 会为任意读取器添加缓冲区一样，<code>BufWriter::new(writer)</code> 也会为任意写入器添加缓冲区：</p>\n<pre class=\"code-rows\"><code>let file = File::create(\"tmp.txt\")?;\nlet writer = BufWriter::new(file);</code></pre>\n<p>要设置缓冲区的大小，请使用 <code>BufWriter::with_capacity(size, writer)</code>。</p>\n<p>当丢弃 <code>BufWriter</code> 时，所有剩余的缓冲数据都将写入底层写入器。但是，如果在此写入过程中发生错误，则错误会被<strong>忽略</strong>。（由于错误发生在 <code>BufWriter</code> 的 <code>.drop()</code> 方法内部，因此没有合适的地方来报告。）为了确保应用程序会注意到所有输出错误，请在丢弃带缓冲的写入器之前将它手动 <code>.flush()</code> 一下。</p>\n<h3 id=\"nav_point_356\">18.1.6　文件</h3>\n<p>下面是本书已经介绍过的打开文件的两个方法。</p>\n<blockquote>\n<p><code>File::open(filename)</code>（打开）</p>\n</blockquote>\n<p>打开现有文件进行读取。此方法会返回一个 <code>io::Result&lt;File&gt;</code>，如果该文件不存在则报错。</p>\n<blockquote>\n<p><code>File::create(filename)</code>（创建）</p>\n</blockquote>\n<p>创建一个用于写入的新文件。如果存在具有给定文件名的文件，则会将其截断。</p>\n<p>请注意，<code>File</code> 类型位于文件系统模块 <code>std::fs</code> 中，而不是 <code>std::io</code> 中。</p>\n<p>当这两个方法都不符合需求时，可以使用 <code>OpenOptions</code> 来指定所期望的确切行为：</p>\n<pre class=\"code-rows\"><code>use std::fs::OpenOptions;\n\nlet log = OpenOptions::new()\n    .append(true)  // 如果文件已存在，则追加到末尾\n    .open(\"server.log\")?;\n\nlet file = OpenOptions::new()\n    .write(true)\n    .create_new(true)  // 如果文件已存在，则失败\n    .open(\"new_file.txt\")?;</code></pre>\n<p>方法 <code>.append()</code>、<code>.write()</code>、<code>.create_new()</code> 等是可以链式调用的：每个方法都会返回 <code>self</code>。这种链式调用的设计模式很常见，所以在 Rust 中它有一个专门的名字——<strong>构建器</strong>（builder）。另一个例子是 <code>std::process::Command</code>。有关 <code>OpenOptions</code> 的详细信息，请参阅在线文档。</p>\n<p><code>File</code> 打开后的行为就和任何读取器或写入器一样。如果需要，可以为它添加缓冲区。<code>File</code> 在被丢弃时会自动关闭。</p>\n<h3 id=\"nav_point_357\">18.1.7　寻址</h3>\n<p><code>File</code> 还实现了 <code>Seek</code> 特型，这意味着你可以在 <code>File</code> 中“跳来跳去”，而不是从头到尾一次性读取或写入。<code>Seek</code> 的定义如下：</p>\n<pre class=\"code-rows\"><code>pub trait Seek {\n    fn seek(&amp;mut self, pos: SeekFrom) -&gt; io::Result&lt;u64&gt;;\n}\n\npub enum SeekFrom {\n    Start(u64),\n    End(i64),\n    Current(i64)\n}</code></pre>\n<p>此枚举让 <code>seek</code> 方法表现得很好：可以用 <code>file.seek(SeekFrom::Start(0))</code> 倒回到开头，还能用 <code>file.seek(SeekFrom::Current(-8))</code> 回退几字节，等等。</p>\n<p>在文件中寻址很慢。无论使用的是硬盘还是固态驱动器（SSD），每一次寻址的开销都接近于读取数兆字节的数据。</p>\n<h3 id=\"nav_point_358\">18.1.8　其他读取器与写入器类型</h3>\n<p>迄今为止，本章一直在使用 <code>File</code> 作为示范的主力，但还有许多其他有用的读取器类型和写入器类型。</p>\n<blockquote>\n<p><code>io::stdin()</code>（标准输入）</p>\n</blockquote>\n<p>返回标准输入流的读取器。类型是 <code>io::Stdin</code>。由于它被所有线程共享，因此每次读取都会获取和释放互斥锁。</p>\n<p><code>Stdin</code> 有一个 <code>.lock()</code> 方法，该方法会获取互斥锁并返回 <code>io::StdinLock</code>，这是一个带缓冲的读取器，在被丢弃之前会持有互斥锁。因此，对 <code>StdinLock</code> 的单个操作就避免了互斥开销。18.1.3 节展示过使用此方法的示例代码。</p>\n<p>由于技术原因，不能直接调用 <code>io::stdin().lock()</code><span class=\"comment-number\">1</span>。这个锁持有对 <code>Stdin</code> 值的引用，这意味着此 <code>Stdin</code> 值必须存储在某个能让它“活得”足够长的地方：</p>\n\n<pre class=\"code-rows\"><code>let stdin = io::stdin();\nlet lines = stdin.lock().lines();  // 正确</code></pre>\n<blockquote>\n<p><code>io::stdout()</code>（标准输出）和 <code>io::stderr()</code>（标准错误）</p>\n</blockquote>\n<p>返回标准输出流（<code>Stdout</code>）类型和标准错误流（<code>Stderr</code>）类型的写入器。它们也有互斥锁和 <code>.lock()</code> 方法。</p>\n<blockquote>\n<p><code>Vec&lt;u8&gt;</code>（<code>u8</code> 向量）</p>\n</blockquote>\n<p>实现了 <code>Write</code>。写入 <code>Vec&lt;u8&gt;</code> 会使用新数据扩展向量。</p>\n<p>（但是，<code>String</code> <strong>没有</strong>实现 <code>Write</code>。要使用 <code>Write</code> 构建字符串，需要首先写入 <code>Vec&lt;u8&gt;</code>，然后使用 <code>String::from_utf8(vec)</code> 将向量转换为字符串。）</p>\n<blockquote>\n<p><code>Cursor::new(buf)</code>（新建）</p>\n</blockquote>\n<p>创建一个 <code>Cursor</code>（游标，一个从 <code>buf</code> 读取数据的缓冲读取器）。这样你就创建了一个能读取 <code>String</code> 的读取器。参数 <code>buf</code> 可以是实现了 <code>AsRef&lt;[u8]&gt;</code> 的任意类型，因此也可以传递 <code>&amp;[u8]</code>、<code>&amp;str</code> 或 <code>Vec&lt;u8&gt;</code>。</p>\n<p><code>Cursor</code> 的内部平平无奇，只有两个字段：<code>buf</code> 本身和一个整数，该整数是 <code>buf</code> 中下一次读取开始的偏移量。此位置的初始值为 0。</p>\n<p><code>Cursor</code> 实现了 <code>Read</code>、<code>BufRead</code> 和 <code>Seek</code>。如果 <code>buf</code> 的类型是 <code>&amp;mut [u8]</code> 或 <code>Vec&lt;u8&gt;</code>，那么 <code>Cursor</code> 也实现了 <code>Write</code>。写入游标会覆盖 <code>buf</code> 中从当前位置开始的字节。如果试图直接写到超出 <code>&amp;mut [u8]</code> 末尾的位置，就会导致一次“部分写入”或一个 <code>io::Error</code>。不过，使用游标写入 <code>Vec&lt;u8&gt;</code> 的结尾就没有这个问题：它会增长此向量。因此，<code>Cursor&lt;&amp;mut [u8]&gt;</code> 和 <code>Cursor&lt;Vec&lt;u8&gt;&gt;</code> 实现了所有这 4 个 <code>std::io::prelude</code> 特型。</p>\n<blockquote>\n<p><code>std::net::TcpStream</code>（<code>Tcp</code> 流）</p>\n</blockquote>\n<p>表示 TCP 网络连接。由于 TCP 支持双向通信，因此它既是读取器又是写入器。</p>\n<p>类型关联函数 <code>TcpStream::connect((\"hostname\", PORT))</code> 会尝试连接到服务器并返回 <code>io::Result&lt;TcpStream&gt;</code>。</p>\n<blockquote>\n<p><code>std::process::Command</code>（命令）</p>\n</blockquote>\n<p>支持启动子进程并通过管道将数据传输到其标准输入，如下所示：</p>\n<pre class=\"code-rows\"><code>use std::process::;\n\nlet mut child =\n    Command::new(\"grep\")\n    .arg(\"-e\")\n    .arg(\"a.*e.*i.*o.*u\")\n    .stdin(Stdio::piped())\n    .spawn()?;\n\nlet mut to_child = child.stdin.take().unwrap();\nfor word in my_words {\n    writeln!(to_child, \"{}\", word)?;\n}\ndrop(to_child);  // 关闭grep的stdin，以便让它退出\nchild.wait()?;</code></pre>\n<p><code>child.stdin</code> 的类型是 <code>Option&lt;std::process::ChildStdin&gt;</code>，这里在建立子进程时使用了 <code>.stdin(Stdio::piped())</code>，因此当 <code>.spawn()</code> 成功时，<code>child.stdin</code> 必然已经就位。如果没提供，那么 <code>child.stdin</code> 就是 <code>None</code>。</p>\n<p><code>Command</code> 还有两个类似的方法 <code>.stdout()</code> 和 <code>.stderr()</code>，可用于请求 <code>child.stdout</code> 和 <code>child.stderr</code> 中的读取器。</p>\n<p><code>std::io</code> 模块还提供了一些返回普通读取器和写入器的函数。</p>\n<blockquote>\n<p><code>io::sink()</code>（地漏）</p>\n</blockquote>\n<p>这是无操作写入器。所有的写入方法都会返回 <code>Ok</code>，但只是把数据扔掉了。</p>\n<blockquote>\n<p><code>io::empty()</code>（空白）</p>\n</blockquote>\n<p>这是无操作读取器。读取总会成功，但只会返回“输入结束”（EOF）。</p>\n<blockquote>\n<p><code>io::repeat(byte)</code>（重复）</p>\n</blockquote>\n<p>返回一个会无限重复给定字节的读取器。</p>\n<h3 id=\"nav_point_359\">18.1.9　二进制数据、压缩和序列化</h3>\n<p>许多开源 crate 建立在 <code>std::io</code> 框架之上，以提供额外的特性。</p>\n<p><code>byteorder</code> crate 提供了 <code>ReadBytesExt</code> 特型和 <code>WriteBytesExt</code> 特型，为所有读取器和写入器添加了二进制输入和输出的方法：</p>\n<pre class=\"code-rows\"><code>use byteorder::;\n\nlet n = reader.read_u32::&lt;LittleEndian&gt;()?;\nwriter.write_i64::&lt;LittleEndian&gt;(n as i64)?;</code></pre>\n<p><code>flate2</code> crate 提供了用于读取和写入 <code>gzip</code> 数据的适配器方法：</p>\n<pre class=\"code-rows\"><code>use flate2::read::GzDecoder;\nlet file = File::open(\"access.log.gz\")?;\nlet mut gzip_reader = GzDecoder::new(file);</code></pre>\n<p><code>serde</code> crate 及其关联的格式类 crate（如 <code>serde_json</code>）实现了序列化和反序列化：它们在 Rust 结构体和字节之间来回转换。11.2.2 节曾简单提到过这个 crate。现在可以仔细看看了。</p>\n<p>假设我们有一些数据（文字冒险游戏中的映射表）存储在 <code>HashMap</code> 中：</p>\n<pre class=\"code-rows\"><code>type RoomId = String;                       // 每个房间都有唯一的名字\ntype RoomExits = Vec&lt;(char, RoomId)&gt;;       // ……并且存在一个出口列表\ntype RoomMap = HashMap&lt;RoomId, RoomExits&gt;;  // 房间名和出口的简单映射表\n\n// 创建一个简单映射表\nlet mut map = RoomMap::new();\nmap.insert(\"Cobble Crawl\".to_string(),\n           vec![('W', \"Debris Room\".to_string())]);\nmap.insert(\"Debris Room\".to_string(),\n           vec![('E', \"Cobble Crawl\".to_string()),\n                ('W', \"Sloping Canyon\".to_string())]);\n...</code></pre>\n<p>将此数据转换为 JSON 输出只需一行代码：</p>\n<pre class=\"code-rows\"><code>serde_json::to_writer(&amp;mut std::io::stdout(), &amp;map)?;</code></pre>\n<p>在内部，<code>serde_json::to_writer</code> 使用了 <code>serde::Serialize</code> 特型的 <code>serialize</code> 方法。该库会将 <code>serde::Serialize</code> 特型附加到所有它知道如何序列化的类型中，包括我们的数据中出现过的类型：字符串、字符、元组、向量和 <code>HashMap</code>。</p>\n<p><code>serde</code> 很灵活。在这个程序中，输出是 JSON 数据，因为我们选择了 <code>serde_json</code> 序列化器。其他格式（如 <code>MessagePack</code>）也有对应的序列化器支持。同样，可以将此输出发送到文件、<code>Vec&lt;u8&gt;</code> 或任意写入器。前面的代码会将数据打印到 <code>stdout</code>。具体内容如下所示：</p>\n<pre class=\"code-rows\"><code>{\"Debris Room\":[[\"E\",\"Cobble Crawl\"],[\"W\",\"Sloping Canyon\"]],\"Cobble Crawl\":\n[[\"W\",\"Debris Room\"]]}</code></pre>\n<p><code>serde</code> 还包括对供派生的两个关键 <code>serde</code> 特型的支持：</p>\n<pre class=\"code-rows\"><code>#[derive(Serialize, Deserialize)]\nstruct Player {\n    location: String,\n    items: Vec&lt;String&gt;,\n    health: u32\n}</code></pre>\n<p>这里的 <code>#[derive]</code> 属性会让编译多花费一点儿时间，所以当你在 Cargo.toml 文件中将它列为依赖项时，要明确要求 <code>serde</code> 支持它。下面是要用在上述代码中的内容：</p>\n<pre class=\"code-rows\"><code>[dependencies]\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"</code></pre>\n<p>有关详细信息，请参阅 <code>serde</code> 文档。简而言之，构建系统会为 <code>Player</code> 自动生成 <code>serde::Serialize</code> 和 <code>serde::Deserialize</code> 的实现，因此序列化 <code>Player</code> 的值很简单：</p>\n<pre class=\"code-rows\"><code>serde_json::to_writer(&amp;mut std::io::stdout(), &amp;player)?;</code></pre>\n<p>输出如下所示。</p>\n<pre class=\"code-rows\"><code>{\"location\":\"Cobble Crawl\",\"items\":[\"a wand\"],\"health\":3}</code></pre>\n<h2 id=\"nav_point_360\">18.2　文件与目录</h2>\n<p>前面已经展示了如何使用读取器和写入器，接下来的几节将介绍 Rust 用于处理文件和目录的特性，这些特性位于 <code>std::path</code> 模块和 <code>std::fs</code> 模块中。所有这些特性都涉及使用文件名，因此我们将从文件名类型开始。</p>\n<h3 id=\"nav_point_361\">18.2.1　<code>OsStr</code> 与 <code>Path</code></h3>\n<p>麻烦的是，操作系统并不会强制要求其文件名是有效的 Unicode。下面是创建文本文件的两个 Linux shell 命令。第一个使用了有效的 UTF-8 文件名，第二个则没有：</p>\n<pre class=\"code-rows\"><code>$ echo \"hello world\" &gt; ô.txt\n$ echo \"O brave new world, that has such filenames in't\" &gt; $'\\xf4'.txt</code></pre>\n<p>这两个命令都没有任何报错就通过了，因为 Linux 内核并不检查 UTF-8 的格式有效性。对内核来说，任意字节串（除了 <code>null</code> 字节和斜杠）都是可接受的文件名。在 Windows 上的情况类似：几乎任意 16 位“宽字符”字符串都是可接受的文件名，即使字符串不是有效的 UTF-16 也可以。操作系统处理的其他字符串也是如此，比如命令行参数和环境变量。</p>\n<p>Rust 字符串始终是有效的 Unicode。文件名在实践中<strong>几乎</strong>总是 Unicode，但 Rust 必须以某种方式处理罕见的例外情况。这就是 Rust 会有 <code>std::ffi::OsStr</code> 和 <code>OsString</code> 的原因。</p>\n<p><code>OsStr</code> 是一种字符串类型，它是 UTF-8 的超集。<code>OsStr</code> 的任务是表示当前系统上的所有文件名、命令行参数和环境变量，<strong>无论它们是不是有效的 Unicode</strong>。在 Unix 上，<code>OsStr</code> 可以保存任意字节序列。在 Windows 上，<code>OsStr</code> 使用 UTF-8 的扩展格式存储，可以对任意 16 位值序列（包括不符合标准的半代用区码点）进行编码。</p>\n<p>所以我们有两种字符串类型：<code>str</code> 用于实际的 Unicode 字符串，而 <code>OsStr</code> 用于操作系统可能抛出的任意文字。还有用于文件名的 <code>std::path::Path</code>，这纯粹是一个便捷名称。<code>Path</code> 与 <code>OsStr</code> 完全一样，只是添加了许多关于文件名的便捷方法，18.2.2 节会介绍这些方法。绝对路径和相对路径都使用 <code>Path</code> 表示。对于路径中的单个组件，请使用 <code>OsStr</code>。</p>\n<p>最后，每种字符串类型都有对应的<strong>拥有型</strong>版本：<code>String</code> 拥有分配在堆上的 <code>str</code>，<code>std::ffi:: OsString</code> 拥有分配在堆上的 <code>OsStr</code>，而 <code>std::path::PathBuf</code> 拥有分配在堆上的 <code>Path</code>。表 18-1 概述了每种类型的一些特性。</p>\n<p><strong>表 18-1：文件名类型</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>&nbsp;</p></th>\n<th><p><code>str</code></p></th>\n<th><p><code>OsStr</code></p></th>\n<th><p><code>Path</code></p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>无固定大小类型，总是通过引用传递</p></td>\n<td><p>是</p></td>\n<td><p>是</p></td>\n<td><p>是</p></td>\n</tr>\n<tr>\n<td><p>可以包含任意 Unicode 文本</p></td>\n<td><p>是</p></td>\n<td><p>是</p></td>\n<td><p>是</p></td>\n</tr>\n<tr>\n<td><p>通常看起来和 UTF-8 一样</p></td>\n<td><p>是</p></td>\n<td><p>是</p></td>\n<td><p>是</p></td>\n</tr>\n<tr>\n<td><p>可以包含非 Unicode 数据</p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n<td><p>是</p></td>\n</tr>\n<tr>\n<td><p>文本处理类方法</p></td>\n<td><p>是</p></td>\n<td><p>否</p></td>\n<td><p>否</p></td>\n</tr>\n<tr>\n<td><p>文件名相关方法</p></td>\n<td><p>否</p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n</tr>\n<tr>\n<td><p>拥有型、可增长且分配在堆上的等价类型</p></td>\n<td><p><code>String</code></p></td>\n<td><p><code>OsString</code></p></td>\n<td><p><code>PathBuf</code></p></td>\n</tr>\n<tr>\n<td><p>转换为拥有型类型</p></td>\n<td><p><code>.to_string()</code></p></td>\n<td><p><code>.to_os_string()</code></p></td>\n<td><p><code>.to_path_buf()</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>所有这 3 种类型都实现了一个公共特型 <code>AsRef&lt;Path&gt;</code>，因此我们可以轻松地声明一个接受“任意文件名类型”作为参数的泛型函数。这使用了 13.7 节中展示过的技巧：</p>\n<pre class=\"code-rows\"><code>use std::path::Path;\nuse std::io;\n\nfn swizzle_file&lt;P&gt;(path_arg: P) -&gt; io::Result&lt;()&gt;\n   where P: AsRef&lt;Path&gt;\n{\n   let path = path_arg.as_ref();\n   ...\n}</code></pre>\n<p>所有接受 <code>path</code> 参数的标准函数和方法都使用了这种技巧，因此可以直接将字符串字面量传给它们中的任意一个。</p>\n<h3 id=\"nav_point_362\">18.2.2　<code>Path</code> 与 <code>PathBuf</code> 的方法</h3>\n<p><code>Path</code> 提供了以下方法。</p>\n<blockquote>\n<p><code>Path::new(str)</code>（新建）</p>\n</blockquote>\n<p>将 <code>&amp;str</code> 或 <code>&amp;OsStr</code> 转换为 <code>&amp;Path</code>。这不会复制字符串。新的 <code>&amp;Path</code> 会指向与原始 <code>&amp;str</code> 或 <code>&amp;OsStr</code> 相同的字节。</p>\n<pre class=\"code-rows\"><code>use std::path::Path;\nlet home_dir = Path::new(\"/home/fwolfe\");</code></pre>\n<p>（类似的方法 <code>OsStr::new(str)</code> 会将 <code>&amp;str</code> 转换为 <code>&amp;OsStr</code>。）</p>\n<p><code>path.parent()</code>（父目录）</p>\n<p>返回路径的父目录（如果有的话）。返回类型是 <code>Option&lt;&amp;Path&gt;</code>。</p>\n<p>这不会复制路径。<code>path</code> 的父路径一定是 <code>path</code> 的子串。</p>\n<pre class=\"code-rows\"><code>assert_eq!(Path::new(\"/home/fwolfe/program.txt\").parent(),\n           Some(Path::new(\"/home/fwolfe\")));</code></pre>\n<blockquote>\n<p><code>path.file_name()</code>（文件名）</p>\n</blockquote>\n<p>返回 <code>path</code> 的最后一个组件（如果有的话）。返回类型是 <code>Option&lt;&amp;OsStr&gt;</code>。</p>\n<p>典型情况下，<code>path</code> 由目录、斜杠和文件名组成，此方法会返回文件名。</p>\n<pre class=\"code-rows\"><code>use std::ffi::OsStr;\nassert_eq!(Path::new(\"/home/fwolfe/program.txt\").file_name(),\n           Some(OsStr::new(\"program.txt\")));</code></pre>\n<blockquote>\n<p><code>path.is_absolute()</code>（是绝对路径？）和 <code>path.is_relative()</code>（是相对路径？）</p>\n</blockquote>\n<p>这两个方法会指出文件是绝对路径（如 Unix 路径 /usr/bin/advent 或 Windows 路径 C:\\Program Files）还是相对路径（如 src/main.rs）。</p>\n<blockquote>\n<p><code>path1.join(path2)</code>（联结）</p>\n</blockquote>\n<p>联结两个路径，返回一个新的 <code>PathBuf</code>：</p>\n<pre class=\"code-rows\"><code>let path1 = Path::new(\"/usr/share/dict\");\nassert_eq!(path1.join(\"words\"),\n           Path::new(\"/usr/share/dict/words\"));</code></pre>\n<p>如果 <code>path2</code> 本身是绝对路径，则只会返回 <code>path2</code> 的副本，因此该方法可用于将任意路径转换为绝对路径。</p>\n<pre class=\"code-rows\"><code>let abs_path = std::env::current_dir()?.join(any_path);</code></pre>\n<blockquote>\n<p><code>path.components()</code>（组件迭代器）</p>\n</blockquote>\n<p>返回从左到右访问给定路径各个组件的迭代器。这个迭代器的条目类型是 <code>std::path::Component</code>，这是一个枚举，可以代表所有可能出现在文件名中的不同部分：</p>\n<pre class=\"code-rows\"><code>pub enum Component&lt;'a&gt; {\n    Prefix(PrefixComponent&lt;'a&gt;),  // 驱动器路径或共享路径（在Windows 上）\n    RootDir,                      // 根目录，`/`或`\\`\n    CurDir,                       // 特殊目录`.`\n    ParentDir,                    // 特殊目录`..`\n    Normal(&amp;'a OsStr)             // 普通文件或目录名\n}</code></pre>\n<p>例如，Windows 路径 \\\\venice\\Music\\A Love Supreme\\04-Psalm.mp3 包含一个表示 \\\\venice\\Music 的 <code>Prefix</code>，后跟一个 <code>RootDir</code>，然后是表示 A Love Supreme 和 04-Psalm.mp3 的两个 <code>Normal</code> 组件。</p>\n<p>有关详细信息，请参阅在线文档。</p>\n<blockquote>\n<p><code>path.ancestors()</code>（祖先迭代器）</p>\n</blockquote>\n<p>返回一个从 <code>path</code> 开始一直遍历到根路径的迭代器。生成的每个条目也都是 <code>Path</code>：首先是 <code>path</code> 本身，然后是它的父级，接下来是它的祖父级，以此类推：</p>\n<pre class=\"code-rows\"><code>let file = Path::new(\"/home/jimb/calendars/calendar-18x18.pdf\");\nassert_eq!(file.ancestors().collect::&lt;Vec&lt;_&gt;&gt;(),\n           vec![Path::new(\"/home/jimb/calendars/calendar-18x18.pdf\"),\n                Path::new(\"/home/jimb/calendars\"),\n                Path::new(\"/home/jimb\"),\n                Path::new(\"/home\"),\n                Path::new(\"/\")]);</code></pre>\n<p>这就像在重复调用 <code>parent</code> 直到它返回 <code>None</code>。最后一个条目始终是根路径或前缀路径（<code>Prefix</code>）。</p>\n<p>这些方法只针对内存中的字符串进行操作。<code>Path</code> 也有一些能查询文件系统的方法：<code>.exists()</code>、<code>.is_file()</code>、<code>.is_dir()</code>、<code>.read_dir()</code>、<code>.canonicalize()</code> 等。请参阅在线文档以了解更多信息。</p>\n<p>将 <code>Path</code> 转换为字符串有以下 3 个方法，每个方法都容许 <code>Path</code> 中存在无效 UTF-8。</p>\n<blockquote>\n<p><code>path.to_str()</code>（转字符串）</p>\n</blockquote>\n<p>将 <code>Path</code> 转换为字符串，返回 <code>Option&lt;&amp;str&gt;</code>。如果 <code>path</code> 不是有效的 UTF-8，则返回 <code>None</code>。</p>\n<pre class=\"code-rows\"><code>if let Some(file_str) = path.to_str() {\n    println!(\"{}\", file_str);\n}  // ……否则就跳过这种名称古怪的文件</code></pre>\n<blockquote>\n<p><code>path.to_string_lossy()</code>（转字符串，宽松版）</p>\n</blockquote>\n<p>基本上和上一个方法一样，但该方法在任何情况下都会设法返回某种字符串。如果 <code>path</code> 不是有效的 UTF-8，则该方法会制作一个副本，用 Unicode 代用字符 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00875.jpeg\" alt=\"\" width=\"16%\" style=\"width: 16%\" inline-img=\"true\" /> 替代每个无效的字节序列。</p>\n<p>返回类型为 <code>std::borrow::Cow&lt;str&gt;</code>：借用或拥有的字符串。要从此值获取 <code>String</code>，请使用其 <code>.to_owned()</code> 方法。（有关 <code>Cow</code> 的更多信息，请参阅 13.12 节。）</p>\n<blockquote>\n<p><code>path.display()</code>（转显示）</p>\n</blockquote>\n<p>用于打印路径：</p>\n<pre class=\"code-rows\"><code>println!(\"Download found. You put it in: {}\", dir_path.display());</code></pre>\n<p>此方法返回的值不是字符串，但它实现了 <code>std::fmt::Display</code>，因此可以与 <code>format!()</code>、<code>println!()</code> 和类似的宏一起使用。如果路径不是有效的 UTF-8，则输出可能包含 &#65533; 字符。</p>\n<h3 id=\"nav_point_363\">18.2.3　访问文件系统的函数</h3>\n<p>表 18-2 展示了 <code>std::fs</code> 中的一些函数及其在 Unix 和 Windows 上的近乎等价方式。所有这些函数都会返回 <code>io::Result</code> 值。除非另行说明，否则它们的返回值都是 <code>Result&lt;()&gt;</code>。</p>\n<p><strong>表 18-2：文件系统访问函数汇总表</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>&nbsp;</p></th>\n<th><p>Rust 函数</p></th>\n<th><p>Unix</p></th>\n<th><p>Windows</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>创建和删除</p></td>\n<td><p><code>create_dir(path)</code><br /><code>create_dir_all(path)</code><br /><code>remove_dir(path)</code><br /><code>remove_dir_all(path)</code><br /><code>remove_file(path)</code></p></td>\n<td><p><code>mkdir()</code><br />类似 <code>mkdir -p</code><br /><code>rmdir()</code><br />类似 <code>rm -r</code><br /><code>unlink()</code></p></td>\n<td><p><code>CreateDirectory()</code><br />类似 <code>mkdir</code><br /><code>RemoveDirectory()</code><br />类似 <code>rmdir /s</code><br /><code>DeleteFile()</code></p></td>\n</tr>\n<tr>\n<td><p>复制、移动和链接</p></td>\n<td><p><code>copy(src_path, dest_path) -&gt; Result&lt;u64&gt;</code><br /><code>rename(src_path, dest_path)</code><br /><code>hard_link(src_path, dest_path)</code></p></td>\n<td><p>类似 <code>cp -p</code><br /><code>rename()</code><br /><code>link()</code></p></td>\n<td><p><code>CopyFileEx()</code><br /><code>MoveFileEx()</code><br /><code>CreateHardLink()</code></p></td>\n</tr>\n<tr>\n<td><p>检查</p></td>\n<td><p><code>canonicalize(path) -&gt; Result&lt;PathBuf&gt;</code><br /><code>metadata(path) -&gt; Result&lt;Metadata&gt;</code><br /><code>symlink_metadata(path) -&gt; Result&lt;Metadata&gt;</code><br /><code>read_dir(path) -&gt; Result&lt;ReadDir&gt;</code><br /><code>read_link(path) -&gt; Result&lt;PathBuf&gt;</code></p></td>\n<td><p><code>realpath()</code><br /><code>stat()</code><br /><code>lstat()</code><br /><code>opendir()</code><br /><code>readlink()</code></p></td>\n<td><p><code>GetFinalPathNameByHandle()</code><br /><code>GetFileInformationByHandle()</code><br /><code>GetFileInformationByHandle()</code><br /><code>FindFirstFile()</code><br /><code>FSCTL_GET_REPARSE_POINT</code></p></td>\n</tr>\n<tr>\n<td><p>权限</p></td>\n<td><p><code>set_permissions(path, perm)</code></p></td>\n<td><p><code>chmod()</code></p></td>\n<td><p><code>SetFileAttributes()</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>（<code>copy()</code> 返回的数值是已复制文件的大小，以字节为单位。要创建符号链接，请参阅 18.2.5 节。）</p>\n<p>如你所见，Rust 会努力提供可移植的函数，这些函数可以在 Windows 以及 macOS、Linux 和其他 Unix 系统上如预期般工作。</p>\n<p>关于文件系统的完整教程超出了本书的范畴，如果你对这些函数中的任何一个感到好奇，可以轻松地在网上找到更多相关信息。18.2.4 节中会展示一些示例。</p>\n<p>所有这些函数都是通过调用操作系统实现的。例如，<code>std::fs::canonicalize(path)</code> 不仅会使用字符串处理来从给定的 <code>path</code> 中消除 <code>.</code> 和 <code>..</code>，还会使用当前工作目录解析相对路径，并追踪符号链接。如果路径不存在，则会报错。</p>\n<p><code>std::fs::metadata(path)</code> 和 <code>std::fs::symlink_metadata(path)</code> 生成的 <code>Metadata</code> 类型包含文件类型和大小、权限、时间戳等信息。同样，可以参阅在线文档了解详细信息。</p>\n<p>为便于使用，<code>Path</code> 类型将其中一些内置成了方法，比如，<code>path.metadata()</code> 和 <code>std::fs::metadata(path)</code> 是一样的。</p>\n<h3 id=\"nav_point_364\">18.2.4　读取目录</h3>\n<p>要列出目录的内容，请使用 <code>std::fs::read_dir</code> 或 <code>Path</code> 中的等效方法 <code>.read_dir()</code>：</p>\n<pre class=\"code-rows\"><code>for entry_result in path.read_dir()? {\n    let entry = entry_result?;\n    println!(\"{}\", entry.file_name().to_string_lossy());\n}</code></pre>\n<p>注意，在这段代码中有两行用到了 <code>?</code> 运算符。第 1 行检查了打开目录时的错误。第 2 行检查了读取下一个条目时的错误。</p>\n<p><code>entry</code> 的类型是 <code>std::fs::DirEntry</code>，这个结构体提供了数个方法。</p>\n<blockquote>\n<p><code>entry.file_name()</code>（文件名）</p>\n</blockquote>\n<p>文件或目录的名称，是 <code>OsString</code> 类型的。</p>\n<blockquote>\n<p><code>entry.path()</code>（路径）</p>\n</blockquote>\n<p>与 <code>entry.file_name()</code> 基本相同，但 <code>entry.path()</code> 联结了原始路径，生成了一个新的 <code>PathBuf</code>。如果正在列出的目录是 <code>\"/home/jimb\"</code>，并且 <code>entry.file_name()</code> 是 <code>\".emacs\"</code>，那么 <code>entry.path()</code> 将返回 <code>PathBuf::from(\"/home/jimb/.emacs\")</code>.</p>\n<blockquote>\n<p><code>entry.file_type()</code>（文件类型）</p>\n</blockquote>\n<p>返回 <code>io::Result&lt;FileType&gt;</code>。<code>FileType</code> 有 <code>.is_file()</code> 方法、<code>.is_dir()</code> 方法和 <code>.is_symlink()</code> 方法。</p>\n<blockquote>\n<p><code>entry.metadata()</code>（元数据）</p>\n</blockquote>\n<p>获取有关此条目的其他元数据。</p>\n<p>特殊目录 <code>.</code> 和 <code>..</code> 在读取目录时<strong>不会</strong>列出。</p>\n<p>下面是一个更接近现实的例子。以下代码会递归地将目录树从磁盘上的一个位置复制到另一个位置。</p>\n<pre class=\"code-rows\"><code>use std::fs;\nuse std::io;\nuse std::path::Path;\n\n/// 把现有目录`src`复制到目标路径`dst`\nfn copy_dir_to(src: &amp;Path, dst: &amp;Path) -&gt; io::Result&lt;()&gt; {\n    if !dst.is_dir() {\n        fs::create_dir(dst)?;\n    }\n\n    for entry_result in src.read_dir()? {\n        let entry = entry_result?;\n        let file_type = entry.file_type()?;\n        copy_to(&amp;entry.path(), &amp;file_type, &amp;dst.join(entry.file_name()))?;\n    }\n\n    Ok(())\n}</code></pre>\n<p>独立的 <code>copy_to</code> 函数用于复制单个目录条目。</p>\n<pre class=\"code-rows\"><code>/// 把`src`中的任何内容复制到目标路径`dst`\nfn copy_to(src: &amp;Path, src_type: &amp;fs::FileType, dst: &amp;Path)\n    -&gt; io::Result&lt;()&gt;\n{\n    if src_type.is_file() {\n        fs::copy(src, dst)?;\n    } else if src_type.is_dir() {\n        copy_dir_to(src, dst)?;\n    } else {\n        return Err(io::Error::new(io::ErrorKind::Other,\n                                  format!(\"don't know how to copy: {}\",\n                                          src.display())));\n    }\n    Ok(())\n}</code></pre>\n<h3 id=\"nav_point_365\">18.2.5　特定于平台的特性</h3>\n<p>到目前为止，<code>copy_to</code> 函数既可以复制文件也可以复制目录。接下来我们还打算在 Unix 上支持符号链接。</p>\n<p>没有可移植的方法来创建同时适用于 Unix 和 Windows 的符号链接，但标准库提供了一个特定于 Unix 的 <code>symlink</code> 函数：</p>\n<pre class=\"code-rows\"><code>use std::os::unix::fs::symlink;</code></pre>\n<p>有了这个函数，我们的工作就很容易了。只需向 <code>copy_to</code> 中的 <code>if</code> 表达式添加一个分支即可：</p>\n<pre class=\"code-rows\"><code>...\n} else if src_type.is_symlink() {\n    let target = src.read_link()?;\n    symlink(target, dst)?;\n...</code></pre>\n<p>如果只是为 Unix 系统（如 Linux 和 macOS）编译我们的程序，那么就能这么用。</p>\n<p><code>std::os</code> 模块包含各种特定于平台的特性，比如 <code>symlink</code>。<code>std::os</code> 在标准库中的实际主体如下所示（这里为了看起来整齐，调整了代码格式）：</p>\n<pre class=\"code-rows\"><code>//! 特定于操作系统的功能\n\n#[cfg(unix)]                    pub mod unix;\n#[cfg(windows)]                 pub mod windows;\n#[cfg(target_os = \"ios\")]       pub mod ios;\n#[cfg(target_os = \"linux\")]     pub mod linux;\n#[cfg(target_os = \"macos\")]     pub mod macos;\n...</code></pre>\n<p><code>#[cfg]</code> 属性表示条件编译：这些模块中的每一个仅在某些平台上存在。这就是为什么使用 <code>std::os::unix</code> 修改后的程序只能针对 Unix 成功编译，因为在其他平台上 <code>std::os::unix</code> 不存在。</p>\n<p>如果希望代码在所有平台上编译，并支持 Unix 上的符号链接，则必须也在程序中使用 <code>#[cfg]</code>。在这种情况下，最简单的方法是在 Unix 上导入 <code>symlink</code>，同时在其他系统上定义自己的 <code>symlink</code> 模拟实现：</p>\n<pre class=\"code-rows\"><code>#[cfg(unix)]\nuse std::os::unix::fs::symlink;\n\n/// 在未提供`symlink`的平台上提供的模拟实现\n#[cfg(not(unix))]\nfn symlink&lt;P: AsRef&lt;Path&gt;, Q: AsRef&lt;Path&gt;&gt;(src: P, _dst: Q)\n    -&gt; std::io::Result&lt;()&gt;\n{\n    Err(io::Error::new(io::ErrorKind::Other,\n                       format!(\"can't copy symbolic link: {}\",\n                               src.as_ref().display())))\n}</code></pre>\n<p>事实上，<code>symlink</code> 只是特殊情况。大多数特定于 Unix 的特性不是独立函数，而是将新方法添加到标准库类型的扩展特型（11.2.2 节介绍过扩展特型）。<code>prelude</code> 模块可用于同时启用所有这些扩展：</p>\n<pre class=\"code-rows\"><code>use std::os::unix::prelude::*;</code></pre>\n<p>例如，在 Unix 上，这会向 <code>std::fs::Permissions</code> 添加 <code>.mode()</code> 方法，从而支持表达 Unix 权限所需的底层 <code>u32</code> 值。同样，这还会给 <code>std::fs::Metadata</code> 添加一些访问器方法，从而得以访问底层 <code>struct stat</code> 的字段（比如 <code>.uid()</code> 可获得文件所有者的用户 <code>ID</code>）为 <code>std::fs::Metadata</code> 添加了访问器。</p>\n<p>总而言之，<code>std::os</code> 中的内容非常基础。更多特定于平台的功能可通过第三方 crate 获得，比如用于访问 Windows 注册表的 <code>winreg</code>。</p>\n<h2 id=\"nav_point_366\">18.3　网络</h2>\n<p>关于网络的教程远远超出了本书的范畴。但是，如果你已经对网络编程有所了解，那么本节能帮你开始使用 Rust 中的网络支持。</p>\n<p>要编写较底层的网络代码，可以使用 <code>std::net</code> 模块，该模块为 TCP 网络和 UDP 网络提供了跨平台支持。可以使用 <code>native_tls</code> crate 来支持 SSL/TLS。</p>\n<p>这些模块为网络上直接的、阻塞型的输入和输出提供了一些基础构件。用几行代码就可以编写一个简单的服务器，只要使用 <code>std::net</code> 并为每个连接启动一个线程即可。例如，下面是一个“回显”（echo）服务器：</p>\n<pre class=\"code-rows\"><code>use std::net::TcpListener;\nuse std::io;\nuse std::thread::spawn;\n\n/// 不断接受连接，为每个连接启动一个线程\nfn echo_main(addr: &amp;str) -&gt; io::Result&lt;()&gt; {\n    let listener = TcpListener::bind(addr)?;\n    println!(\"listening on {}\", addr);\n    loop {\n        // 等待客户端连入\n        let (mut stream, addr) = listener.accept()?;\n        println!(\"connection received from {}\", addr);\n\n        // 启动一个线程来处理此客户端\n        let mut write_stream = stream.try_clone()?;\n        spawn(move || {\n            // 回显从`stream`中收到的一切\n            io::copy(&amp;mut stream, &amp;mut write_stream)\n                .expect(\"error in client thread: \");\n            println!(\"connection closed\");\n        });\n    }\n}\n\nfn main() {\n    echo_main(\"127.0.0.1:17007\").expect(\"error: \");\n}</code></pre>\n<p>回显服务器会简单地重复发给它的所有内容。这种代码与用 Java 或 Python 编写的代码没有太大区别。（第 19 章会介绍 <code>std::thread::spawn()</code>。）</p>\n<p>但是，对于高性能服务器，需要使用异步输入和输出。第 20 章会介绍 Rust 对异步编程的支持，并展示网络客户端和服务器的完整代码。</p>\n<p>更高层级的协议由第三方 crate 提供支持。例如，<code>reqwest</code> crate 为 HTTP 客户端提供了一个漂亮的 API。下面是一个完整的命令行程序，该程序可以通过 <code>http:</code> 或 <code>https:</code> URL 获取对应文档，并将其内容打印到你的终端。此代码是使用 <code>reqwest = \"0.11\"</code> 编写的，并启用了其 <code>\"blocking\"</code> 特性。<code>reqwest</code> 还提供了一个异步接口。</p>\n<pre class=\"code-rows\"><code>use std::error::Error;\nuse std::io;\n\nfn http_get_main(url: &amp;str) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    // 发送HTTP请求并获取响应\n    let mut response = reqwest::blocking::get(url)?;\n    if !response.status().is_success() {\n        Err(format!(\"{}\", response.status()))?;\n    }\n\n    // 读取响应体并写到标准输出\n    let stdout = io::stdout();\n    io::copy(&amp;mut response, &amp;mut stdout.lock())?;\n    Ok(())\n}\n\nfn main() {\n    let args: Vec&lt;String&gt; = std::env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"usage: http-get URL\");\n        return;\n    }\n\n    if let Err(err) = http_get_main(&amp;args[1]) {\n        eprintln!(\"error: {}\", err);\n    }\n}</code></pre>\n<p><code>actix-web</code> 框架为 HTTP 服务器提供了一些高层次抽象，比如 <code>Service</code> 特型和 <code>Transform</code> 特型，这两个特型可以帮助你从一些可插接部件组合出应用程序。<code>websocket</code> crate 实现了 WebSocket 协议。Rust 是一门年轻的语言，拥有繁荣的开源生态系统，对网络的支持正在迅速扩展。</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 17 章 字符串与文本(2)","id":740821},"right":{"article_title":"第 19 章 并发(1)","id":740823}},"comments":[]}