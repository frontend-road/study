{"id":202786,"title":"49 | 桥接模式：如何实现支持不同类型和渠道的消息推送系统？","content":"<p>上一节课我们学习了第一种结构型模式：代理模式。它在不改变原始类（或者叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。代理模式在平时的开发经常被用到，常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。</p><p>今天，我们再学习另外一种结构型模式：桥接模式。桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相对于代理模式来说，桥接模式在实际的项目中并没有那么常用，你只需要简单了解，见到能认识就可以，并不是我们学习的重点。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>桥接模式的原理解析</h2><p><strong>桥接模式</strong>，也叫作<strong>桥梁模式</strong>，英文是<strong>Bridge Design Pattern</strong>。这个模式可以说是23种设计模式中最难理解的模式之一了。我查阅了比较多的书籍和资料之后发现，对于这个模式有两种不同的理解方式。</p><p>当然，这其中“最纯正”的理解方式，当属GoF的《设计模式》一书中对桥接模式的定义。毕竟，这23种经典的设计模式，最初就是由这本书总结出来的。在GoF的《设计模式》一书中，桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。”</p><!-- [[[read_end]]] --><p>关于桥接模式，很多书籍、资料中，还有另外一种理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。这种理解方式非常类似于，我们之前讲过的“组合优于继承”设计原则，所以，这里我就不多解释了。我们重点看下GoF的理解方式。</p><p>GoF给出的定义非常的简短，单凭这一句话，估计没几个人能看懂是什么意思。所以，我们通过JDBC驱动的例子来解释一下。JDBC驱动是桥接模式的经典应用。我们先来看一下，如何利用JDBC驱动来查询数据库。具体的代码如下所示：</p><pre><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载及注册JDBC驱动程序\nString url = &quot;jdbc:mysql://localhost:3306/sample_db?user=root&amp;password=your_password&quot;;\nConnection con = DriverManager.getConnection(url);\nStatement stmt = con.createStatement()；\nString query = &quot;select * from test&quot;;\nResultSet rs=stmt.executeQuery(query);\nwhile(rs.next()) {\n  rs.getString(1);\n  rs.getInt(2);\n}\n</code></pre><p>如果我们想要把MySQL数据库换成Oracle数据库，只需要把第一行代码中的com.mysql.jdbc.Driver换成oracle.jdbc.driver.OracleDriver就可以了。当然，也有更灵活的实现方式，我们可以把需要加载的Driver类写到配置文件中，当程序启动的时候，自动从配置文件中加载，这样在切换数据库的时候，我们都不需要修改代码，只需要修改配置文件就可以了。</p><p>不管是改代码还是改配置，在项目中，从一个数据库切换到另一种数据库，都只需要改动很少的代码，或者完全不需要改动代码，那如此优雅的数据库切换是如何实现的呢？</p><p>源码之下无秘密。要弄清楚这个问题，我们先从com.mysql.jdbc.Driver这个类的代码看起。我摘抄了部分相关代码，放到了这里，你可以看一下。</p><pre><code>package com.mysql.jdbc;\nimport java.sql.SQLException;\n\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver {\n\tstatic {\n\t\ttry {\n\t\t\tjava.sql.DriverManager.registerDriver(new Driver());\n\t\t} catch (SQLException E) {\n\t\t\tthrow new RuntimeException(&quot;Can't register driver!&quot;);\n\t\t}\n\t}\n\n\t/**\n\t * Construct a new driver and register it with DriverManager\n\t * @throws SQLException if a database error occurs.\n\t */\n\tpublic Driver() throws SQLException {\n\t\t// Required for Class.forName().newInstance()\n\t}\n}\n</code></pre><p>结合com.mysql.jdbc.Driver的代码实现，我们可以发现，当执行Class.forName(“com.mysql.jdbc.Driver”)这条语句的时候，实际上是做了两件事情。第一件事情是要求JVM查找并加载指定的Driver类，第二件事情是执行该类的静态代码，也就是将MySQL Driver注册到DriverManager类中。</p><p>现在，我们再来看一下，DriverManager类是干什么用的。具体的代码如下所示。当我们把具体的Driver实现类（比如，com.mysql.jdbc.Driver）注册到DriverManager之后，后续所有对JDBC接口的调用，都会委派到对具体的Driver实现类来执行。而Driver实现类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换Driver的原因。</p><pre><code>public class DriverManager {\n  private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;DriverInfo&gt;();\n\n  //...\n  static {\n    loadInitialDrivers();\n    println(&quot;JDBC DriverManager initialized&quot;);\n  }\n  //...\n\n  public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException {\n    if (driver != null) {\n      registeredDrivers.addIfAbsent(new DriverInfo(driver));\n    } else {\n      throw new NullPointerException();\n    }\n  }\n\n  public static Connection getConnection(String url, String user, String password) throws SQLException {\n    java.util.Properties info = new java.util.Properties();\n    if (user != null) {\n      info.put(&quot;user&quot;, user);\n    }\n    if (password != null) {\n      info.put(&quot;password&quot;, password);\n    }\n    return (getConnection(url, info, Reflection.getCallerClass()));\n  }\n  //...\n}\n</code></pre><p>桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。那弄懂定义中“抽象”和“实现”两个概念，就是理解桥接模式的关键。那在JDBC这个例子中，什么是“抽象”？什么是“实现”呢？</p><p>实际上，JDBC本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。JDBC和Driver独立开发，通过对象之间的组合关系，组装在一起。JDBC的所有逻辑操作，最终都委托给Driver来执行。</p><p>我画了一张图帮助你理解，你可以结合着我刚才的讲解一块看。</p><p><img src=\"https://static001.geekbang.org/resource/image/81/40/812234b0717043a67c2d62ea8e783b40.jpg?wh=2136*1221\" alt=\"\"></p><h2>桥接模式的应用举例</h2><p>在<a href=\"https://time.geekbang.org/column/article/176075\">第16节</a>中，我们讲过一个API接口监控告警的例子：根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如，SERVE（严重）级别的消息会通过“自动语音电话”告知相关人员。</p><p>在当时的代码实现中，关于发送告警信息那部分代码，我们只给出了粗略的设计，现在我们来一块实现一下。我们先来看最简单、最直接的一种实现方式。代码如下所示：</p><pre><code>public enum NotificationEmergencyLevel {\n  SEVERE, URGENCY, NORMAL, TRIVIAL\n}\n\npublic class Notification {\n  private List&lt;String&gt; emailAddresses;\n  private List&lt;String&gt; telephones;\n  private List&lt;String&gt; wechatIds;\n\n  public Notification() {}\n\n  public void setEmailAddress(List&lt;String&gt; emailAddress) {\n    this.emailAddresses = emailAddress;\n  }\n\n  public void setTelephones(List&lt;String&gt; telephones) {\n    this.telephones = telephones;\n  }\n\n  public void setWechatIds(List&lt;String&gt; wechatIds) {\n    this.wechatIds = wechatIds;\n  }\n\n  public void notify(NotificationEmergencyLevel level, String message) {\n    if (level.equals(NotificationEmergencyLevel.SEVERE)) {\n      //...自动语音电话\n    } else if (level.equals(NotificationEmergencyLevel.URGENCY)) {\n      //...发微信\n    } else if (level.equals(NotificationEmergencyLevel.NORMAL)) {\n      //...发邮件\n    } else if (level.equals(NotificationEmergencyLevel.TRIVIAL)) {\n      //...发邮件\n    }\n  }\n}\n\n//在API监控告警的例子中，我们如下方式来使用Notification类：\npublic class ErrorAlertHandler extends AlertHandler {\n  public ErrorAlertHandler(AlertRule rule, Notification notification){\n    super(rule, notification);\n  }\n\n\n  @Override\n  public void check(ApiStatInfo apiStatInfo) {\n    if (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) {\n      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);\n    }\n  }\n}\n</code></pre><p>Notification类的代码实现有一个最明显的问题，那就是有很多if-else分支逻辑。实际上，如果每个分支中的代码都不复杂，后期也没有无限膨胀的可能（增加更多if-else分支判断），那这样的设计问题并不大，没必要非得一定要摒弃if-else分支逻辑。</p><p>不过，Notification的代码显然不符合这个条件。因为每个if-else分支中的代码逻辑都比较复杂，发送通知的所有逻辑都扎堆在Notification类中。我们知道，类的代码越多，就越难读懂，越难修改，维护的成本也就越高。很多设计模式都是试图将庞大的类拆分成更细小的类，然后再通过某种更合理的结构组装在一起。</p><p>针对Notification的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender相关类）。其中，Notification类相当于抽象，MsgSender类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们可以动态地去指定（比如，通过读取配置来获取对应关系）。</p><p>按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：</p><pre><code>public interface MsgSender {\n  void send(String message);\n}\n\npublic class TelephoneMsgSender implements MsgSender {\n  private List&lt;String&gt; telephones;\n\n  public TelephoneMsgSender(List&lt;String&gt; telephones) {\n    this.telephones = telephones;\n  }\n\n  @Override\n  public void send(String message) {\n    //...\n  }\n\n}\n\npublic class EmailMsgSender implements MsgSender {\n  // 与TelephoneMsgSender代码结构类似，所以省略...\n}\n\npublic class WechatMsgSender implements MsgSender {\n  // 与TelephoneMsgSender代码结构类似，所以省略...\n}\n\npublic abstract class Notification {\n  protected MsgSender msgSender;\n\n  public Notification(MsgSender msgSender) {\n    this.msgSender = msgSender;\n  }\n\n  public abstract void notify(String message);\n}\n\npublic class SevereNotification extends Notification {\n  public SevereNotification(MsgSender msgSender) {\n    super(msgSender);\n  }\n\n  @Override\n  public void notify(String message) {\n    msgSender.send(message);\n  }\n}\n\npublic class UrgencyNotification extends Notification {\n  // 与SevereNotification代码结构类似，所以省略...\n}\npublic class NormalNotification extends Notification {\n  // 与SevereNotification代码结构类似，所以省略...\n}\npublic class TrivialNotification extends Notification {\n  // 与SevereNotification代码结构类似，所以省略...\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>总体上来讲，桥接模式的原理比较难理解，但代码实现相对简单。</p><p>对于这个模式有两种不同的理解方式。在GoF的《设计模式》一书中，桥接模式被定义为：“将抽象和实现解耦，让它们可以独立变化。”在其他资料和书籍中，还有另外一种更加简单的理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”</p><p>对于第一种GoF的理解方式，弄懂定义中“抽象”和“实现”两个概念，是理解它的关键。定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中的“实现”，也并非“接口的实现类”，而是一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的组合关系，组装在一起。</p><p>对于第二种理解方式，它非常类似我们之前讲过的“组合优于继承”设计原则，通过组合关系来替代继承关系，避免继承层次的指数级爆炸。</p><h2>课堂讨论</h2><p>在桥接模式的第二种理解方式的第一段代码实现中，Notification类中的三个成员变量通过set方法来设置，但是这样的代码实现存在一个明显的问题，那就是emailAddresses、telephones、wechatIds中的数据有可能在Notification类外部被修改，那如何重构代码才能避免这种情况的发生呢？</p><pre><code>public class Notification {\n  private List&lt;String&gt; emailAddresses;\n  private List&lt;String&gt; telephones;\n  private List&lt;String&gt; wechatIds;\n\n  public Notification() {}\n\n  public void setEmailAddress(List&lt;String&gt; emailAddress) {\n    this.emailAddresses = emailAddress;\n  }\n\n  public void setTelephones(List&lt;String&gt; telephones) {\n    this.telephones = telephones;\n  }\n\n  public void setWechatIds(List&lt;String&gt; wechatIds) {\n    this.wechatIds = wechatIds;\n  }\n  //...\n}\n</code></pre><p>欢迎留言和我分享你的思考和疑惑。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"48 | 代理模式：代理在RPC、缓存、监控等场景中的应用","id":201823},"right":{"article_title":"50 | 装饰器模式：通过剖析Java IO类库源码学习装饰器模式","id":204845}},"comments":[{"had_liked":false,"id":184483,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1583325624,"is_pvip":false,"discussion_count":12,"race_medal":0,"score":"834806981048","product_id":100039001,"comment_content":"桥接看着就像是面向接口编程这一原则的原旨---将实现与抽象分离。让我迷惑的是，让两者独立变化的说法，接口不是应该稳定吗，为什么要变化?<br><br>多个纬度独立变化那个解释倒是比较容易理解。文中举的警报的例子很贴切。紧急程度和警报的方式可以是两个不同的纬度。可以有不同的组合方式。这与slf4j这一日志门面的设计有异曲同工之妙。slf4j其中有三个核心概念，logger,appender和encoder。分别指这个日志记录器负责哪个类的日志，日志打印到哪里以及日志打印的格式。三个纬度上可以有不同的实现，使用者可以在每一纬度上定义多个实现，配置文件中将各个纬度的某一个实现组合在一起就ok了。<br><br>行文至此，开头的那个问题也有了答案。一句话就是，桥接就是面向接口编程的集大成者。面向接口编程只是说在系统的某一个功能上将接口和实现解藕，而桥接是详细的分析系统功能，将各个独立的纬度都抽象出来，使用时按需组合。","like_count":195},{"had_liked":false,"id":212471,"user_name":"zhengyu.nie","can_delete":false,"product_type":"c1","uid":1541669,"ip_address":"","ucode":"FFE0377D323E46","user_header":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","comment_is_top":false,"comment_ctime":1588129584,"is_pvip":true,"replies":[{"id":"78927","content":"是我说的第二种理解方式","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1588130058,"ip_address":"","comment_id":212471,"utype":1}],"discussion_count":23,"race_medal":0,"score":"809041981232","product_id":100039001,"comment_content":"举个很简单的例子，现在有两个纬度<br>Car 车 （奔驰、宝马、奥迪等）<br>Transmission 档位类型 （自动挡、手动挡、手自一体等）<br>按照继承的设计模式，Car是一个Abstract基类，假设有M个车品牌，N个档位一共要写M*N个类去描述所有车和档位的结合。<br>而当我们使用桥接模式的话，我首先new一个具体的Car（如奔驰），再new一个具体的Transmission（比如自动档）。然后奔驰.set(手动档)就可以了。<br>那么这种模式只有M+N个类就可以描述所有类型，这就是M*N的继承类爆炸简化成了M+N组合。<br><br>public abstract class AbstractCar {<br><br>  protected Transmission gear;<br>  <br>  public abstract void run();<br>  <br>  public void setTransmission(Transmission gear) {<br>    this.gear = gear;<br>  }<br>  <br>}<br><br>所以桥接模式解决的应该是继承爆炸问题。<br>可以看作是两个abstract组合在一起，独立去拓展，在运行之前将两个具体实现组合到一起。<br>遵循以下原则<br>·依赖倒置原则<br>·迪米特法则<br>·里氏替换原则<br>·接口隔离原则<br>·单一职责原则<br>·开闭原则<br><br>","like_count":189,"discussions":[{"author":{"id":1012815,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/74/4f/7975c7ee.jpg","nickname":"胡敏And","note":"","ucode":"8FA14B27F47F92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374026,"discussion_content":"ImageStore类中无法抽取出各个子类都会使用的公共细节呀，抽象类侧重解决代码复用，在这个例子中没有需要复用的代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620975281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181182,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1582513619,"is_pvip":false,"discussion_count":10,"race_medal":0,"score":"340884930003","product_id":100039001,"comment_content":"课后题：可以考虑使用建造者模式来重构！参见46讲中<br><br>建造者使用场景：<br>1.构造方法必填属性很多，需要检验<br>2.类属性之间有依赖关系或者约束条件<br>3.创建不可变对象(此题刚好符合这种场景)<br>","like_count":80,"discussions":[{"author":{"id":1596047,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIlZ9AObDSXrfSEibY94uyQvMQ4tOvbb7iaQH9H7QQ6ibNaqFKUGq1TboaFpBSLuP0MCcSXvmqHNg0IA/132","nickname":"Geek_8c5f9c","note":"","ucode":"70CD441EAF490F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":242902,"discussion_content":"数据类型是个LIST, 用Builder也无法保证数据不被更改。在Setter 中用Collections.unmodifiableList 对传入的数据进行一个封装就可以了。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1587494221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2838947,"avatar":"","nickname":"覃柯源","note":"","ucode":"02130B9D09B923","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1596047,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIlZ9AObDSXrfSEibY94uyQvMQ4tOvbb7iaQH9H7QQ6ibNaqFKUGq1TboaFpBSLuP0MCcSXvmqHNg0IA/132","nickname":"Geek_8c5f9c","note":"","ucode":"70CD441EAF490F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582835,"discussion_content":"这个也不能保证，add 就会影响","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659692625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":242902,"ip_address":"上海"},"score":582835,"extra":""}]},{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243431,"discussion_content":"这个list的引用对象是从外部传入的。也就是说在Notification类的外部是持有这个引用对象的。而Notification类的外部对这个引用对象的操作会影响到Notification类内部。问题应该是上述描述。所以跟建造者模式有什么关系？Geek_8c5f9c的答案有解决这个的思路了。但是也有问题，因为Collections.unmodifiableList是复合的方式返回一个新的不可变的list对象。至于这个被复合的入参list对象，在Notification类的外部依旧可被修改的。而其修改依旧会影响到Notification类内部的不可变集合。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587540384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316433,"discussion_content":"是的，外部的list修改会影响到Notification类内部。可以在执行set方法的时候deep copy一份外部list","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603413509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":243431,"ip_address":""},"score":316433,"extra":""}]},{"author":{"id":1738326,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","nickname":"守拙","note":"","ucode":"F594B2DA3F6D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185661,"discussion_content":"问题的本质是构造器初始化成员变量, 而不是setter.\n根据依赖倒转原则,尽量不要为客户提供new的方式初始化对象,即构造器私有.\n所以无论是Builder还是简单工厂都能很好的完成任务.\n当然Builder的扩展性要好于简单工厂, 特别是构造对象需要多个参数时.","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582637904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1052859,"avatar":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","nickname":"Demon.Lee","note":"","ucode":"7F0E5493A8E345","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300566,"discussion_content":"课后思考题：\n1. 如果可以从构造器传入，则最方便，将emailAddresses，telephones，wechatIds三个属性，用final修饰，并且在构造器里面进行深度copy\n2. 如果只能通过set方法处理，则在set方法中进行深度copy\n不管哪种方式，都增加注释进行说明；\n不管哪种方式，都要在类中增加三个方法addEmailAddress, addTelephone, addWechatId，保证可以通过指定的方式进行增加相关属性的值。\n\n欢迎大家指正。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598173715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250864,"discussion_content":"get属性时，用Collections.unmodifiableList返回","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588045681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1541669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","nickname":"zhengyu.nie","note":"","ucode":"FFE0377D323E46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251953,"discussion_content":"首先Collections.unmodifiableList是浅拷贝，另外是人家会直接操作set方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588128758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":250864,"ip_address":""},"score":251953,"extra":""}]},{"author":{"id":1415619,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","nickname":"陌兮","note":"","ucode":"00CE47CAECD5CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573879,"discussion_content":"我觉得没必要使用建造者，毕竟为了不暴露set方法，而引入建造者模式，增加代码的复杂度有点得不偿失。使用unModifyList会更好一点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653706941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194858,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3b/6a/80d9c545.jpg","nickname":"RD","note":"","ucode":"E3947B6E1681AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362713,"discussion_content":"我觉得建造者可以，无论深拷贝，还是扩展更多字段，还是不变性都挺适合的。我有个问题就是，说 list 外部可变的问题，这个例子都是 list，重新循环赋值一遍就行。但是，我们平时写的方法，对象引用传递很正常，总不能都深拷贝一份吧。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617017339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226338,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1592040287,"is_pvip":false,"replies":[{"id":"83997","content":"有点那个意思~👍","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1592526404,"ip_address":"","comment_id":226338,"utype":1}],"discussion_count":2,"race_medal":0,"score":"323714587487","product_id":100039001,"comment_content":"老师请问是否可以这样理解：代理模式是一个类与另一个类的组合，桥接模式是一组类和另外一组类的组合","like_count":76},{"had_liked":false,"id":181162,"user_name":"松花皮蛋me","can_delete":false,"product_type":"c1","uid":1000054,"ip_address":"","ucode":"B0846CEEF6B0D1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/76/256bbd43.jpg","comment_is_top":false,"comment_ctime":1582509296,"is_pvip":false,"discussion_count":13,"race_medal":0,"score":"130431528176","product_id":100039001,"comment_content":"这个模式和策略模式的区别是？","like_count":30,"discussions":[{"author":{"id":1178683,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fc/3b/c6b5b64f.jpg","nickname":"bboy孙晨杰","note":"","ucode":"D7389FB3368749","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":233941,"discussion_content":"桥接模式比策略模式更复杂，更具可塑性，可以说桥接模式中包含策略模式。桥接模式注重的是将两个类的职责隔离开来，并任意组合；策略模式的目的是将不同的算法封装起来便于运行时任意替换。因此可以想象成，桥接组合的实现几乎不会在运行时更改，而策略模式的算法很有可能在运行时替换。","likes_number":30,"is_delete":false,"is_hidden":false,"ctime":1586952474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1514606,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1c/6e/99292a4b.jpg","nickname":"WL","note":"","ucode":"5DBEE67371CFEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1178683,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fc/3b/c6b5b64f.jpg","nickname":"bboy孙晨杰","note":"","ucode":"D7389FB3368749","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272885,"discussion_content":"学又学的好，还跳bk，这么优秀的人可怎么办哟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590371884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":233941,"ip_address":""},"score":272885,"extra":""},{"author":{"id":2853072,"avatar":"","nickname":"小杰同学","note":"","ucode":"C6FC59D58F772C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1178683,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fc/3b/c6b5b64f.jpg","nickname":"bboy孙晨杰","note":"","ucode":"D7389FB3368749","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577614,"discussion_content":"有点牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656232605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":233941,"ip_address":""},"score":577614,"extra":""}]},{"author":{"id":1330894,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4e/ce/dde84de4.jpg","nickname":"昌俊","note":"","ucode":"8397286E362827","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308475,"discussion_content":"策略模式里面没有成员变量，每个策略都是无状态的算法，注重的是可随时替换。桥接模式结构是有成员变量，有状态的，这也决定了桥接模式并不支持随时替换特性。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1600959414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1330894,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4e/ce/dde84de4.jpg","nickname":"昌俊","note":"","ucode":"8397286E362827","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":537512,"discussion_content":"精辟！易懂！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639091092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":308475,"ip_address":""},"score":537512,"extra":""}]},{"author":{"id":1255918,"avatar":"https://static001.geekbang.org/account/avatar/00/13/29/ee/fba11edf.jpg","nickname":"        ","note":"","ucode":"21028A49D81B06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214436,"discussion_content":"尝试回答，欢迎指正。策略模式解决的是策略的定义、创建和使用的解耦。侧重的于单个变化维度的解耦，对于调用方（策略使用的客户端）是透明的。但是桥接模式组合多个独立变化（重点是独立）的维度，这些维度都可以有多种实现（类似多个不同策略），而桥接模式将他们的抽象组合起来，暂不接入具体实现，因而实现桥接整体的稳定性，隔离调用方与策略的具体实现。","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1585192953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1286741,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a2/55/1092ebb8.jpg","nickname":"边城路远","note":"","ucode":"214ECD8981E87F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245550,"discussion_content":"桥接模式在于抽象的桥，比如你要去某个地方选择三级桥，你在过每级桥的时候可以做出选择。而不是一次就根据策略做好了选择，提高了策略的灵活性和简单性","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1587685843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309094,"discussion_content":"由于 桥接模式是 结构型，解决类和类之间的结构问题\n策略模式是 行为型，解决对象和对象间的调用问题，本质上有点区别。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1601188033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309092,"discussion_content":"其实我感觉  原文中 同时采用了 桥接模式 和策略模式\n桥接模式 解决了 Notification 和MsgSender间的 抽象和实现，上层和下层灵活调用关系。\n策略模式，解决了多个if-else。\n只是策略模式存在变种， 普通的策略是 工厂类.get（Type） = Notification实现类，开干，此出 传入的是 apiStatInfo， 需要遍历每个策略，去试试符不符合自己的要求，所以不需要工厂类。\n灵活运用。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1601187940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287147,"discussion_content":"我也觉得和策略模式很像，傻傻分不清楚","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1593391450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1625233,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cc/91/d56a81af.jpg","nickname":"CoderArthur","note":"","ucode":"5B591914F0F67C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325678,"discussion_content":"你最起码能发现它们很像","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605406258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":287147,"ip_address":""},"score":325678,"extra":""}]},{"author":{"id":1737397,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/82/b5/a6049a26.jpg","nickname":"大强","note":"","ucode":"D5C64C5A01B25D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293249,"discussion_content":"没有类图，很难理解 哈哈 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595492274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1310251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/fe/2b/468ebdeb.jpg","nickname":"闷骚程序员","note":"","ucode":"B6AEA1B55F4D8F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289541,"discussion_content":"抽象的骨架吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594132764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181167,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1582510384,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"91776823600","product_id":100039001,"comment_content":"参数不多的情况可以在构造函数初始化，如果参数较多 就可以使用建造者模式初始化。","like_count":21},{"had_liked":false,"id":185010,"user_name":"李朝辉","can_delete":false,"product_type":"c1","uid":1152951,"ip_address":"","ucode":"8E4A4469A77A88","user_header":"https://static001.geekbang.org/account/avatar/00/11/97/b7/d5a83264.jpg","comment_is_top":false,"comment_ctime":1583465477,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"83187844101","product_id":100039001,"comment_content":"一点思考：如果notification类针对一次告警，需要同时在微信、电话、邮件上发送通知，当前的Notification类定义就没办法满足条件了，可以将组合的MsgSender变成一个list或者set，将不同渠道的sender注册进去，这样，就可以在调用notify的时候，将list或set内的sender，都调用一遍send","like_count":20,"discussions":[{"author":{"id":1196864,"avatar":"https://static001.geekbang.org/account/avatar/00/12/43/40/e7ef18de.jpg","nickname":"嘉一","note":"","ucode":"8D16BD0B75B019","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234960,"discussion_content":"我觉得理论上就应该用配置的方式设计成一个告警类型对应一个渠道list这种方式，这样设计的灵活性会更好","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587008470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cc/d9/20d4f7c2.jpg","nickname":"大雁小鱼","note":"","ucode":"44090581E59FDA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336140,"discussion_content":"我也在想，这个例子太不实际了，我们开发中都是多个通知一起上的，不太会只通过一种途径通知","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608512750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102194,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/72/4cc8475c.jpg","nickname":"Leaf","note":"","ucode":"9AB56B7971237D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308861,"discussion_content":"同意上面的评论，这个是调用者需要考虑的问题，notification 设计不仅便于自己扩展和维护，也要便于调用者方便使用。从单一职责来看，思考的问题就不是 notification 的职责所在了，要不就变成大而全的耦合一起了。业务规则多变，业务根据自己规则去组合 notification 就好，两者有个隔离。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601101693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182998,"user_name":"攻城拔寨","can_delete":false,"product_type":"c1","uid":1053934,"ip_address":"","ucode":"CBC37183DAB6B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/ee/d72a8222.jpg","comment_is_top":false,"comment_ctime":1582904635,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"74597348667","product_id":100039001,"comment_content":"我觉得桥接模式解释成： 一个类存在不同纬度的变化，可以通过组合的方式，让它们独自扩展。<br>栗子：白色圆形，白色正方形，黑色圆形，黑色正方形。 抽象成 颜色 跟 形状 两个纬度去搞，就是桥接模式啦。<br> 至于 jdbc 的，我水平有限啊，还是理解不了～","like_count":17},{"had_liked":false,"id":181153,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1582507927,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"53122115479","product_id":100039001,"comment_content":" “emailAddresses、telephones、wechatIds 中的数据有可能在 Notification 类外部被修改”的原因是对外暴露了修改接口set*，如果不想被修改那么就不要暴露set接口，这样的话初始化这些email，telephone和wechat的工作就放到构造函数里，用构造函数去初始化这些变量，这样初始化之后正常情况下外面没法修改。","like_count":12,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495934,"discussion_content":"代码复用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593912017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181605,"user_name":"冰激凌的眼泪","can_delete":false,"product_type":"c1","uid":1087945,"ip_address":"","ucode":"5DCB974667E93A","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg","comment_is_top":false,"comment_ctime":1582594018,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"48827234274","product_id":100039001,"comment_content":"在桥接模式中，所谓抽象就是要干什么，所谓实现就是怎么去干，但是这俩是没有抽象与实现的意义的。","like_count":11,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494434,"discussion_content":"这个就没法抽象成接口了，只能每个不同的云平台不同处理了。我们也没法追求在替换云平台时，一点代码都不改。尽量少改动代码就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594903956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182153,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1582721863,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"40237427527","product_id":100039001,"comment_content":"我觉得Notification没有必要再分成三个子类了，直接传入MsgSender子类就可以了吧","like_count":9,"discussions":[{"author":{"id":1102194,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/72/4cc8475c.jpg","nickname":"Leaf","note":"","ucode":"9AB56B7971237D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308866,"discussion_content":"从桥接模式的讲解上，三个子类传达的就是要表达不同维度独立的变化实现，MsgSender 是一个维度，Notification 是一个维度，两个维度可以独立扩展变化。如果仅仅从举例代码的简单上来看，似乎用一个 Notification 就够了，这是因为业务简单可以这样。试想，如果不同 Notification 有其他不同需要处理的业务逻辑，又需要做区分了。总之，怎么实现的问题，也要看具体业务的复杂度和演变性。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1601102354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1581878,"avatar":"https://static001.geekbang.org/account/avatar/00/18/23/36/8bc95dca.jpg","nickname":"Lee","note":"","ucode":"5A232B7388EB2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540108,"discussion_content":"没写三个类，怎么体现两个维度呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639963591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306637,"discussion_content":"同感，不过老师应该是想传达，抽象类是一个类库 不仅仅是一个类。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600337673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1332393,"avatar":"https://static001.geekbang.org/account/avatar/00/14/54/a9/76137b03.jpg","nickname":"doug","note":"","ucode":"DF941FB97DCC4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252152,"discussion_content":"我也是这样想的，没理解到为啥写三个子类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588143359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272474,"user_name":"Ryan24G","can_delete":false,"product_type":"c1","uid":1631292,"ip_address":"","ucode":"EA1E134C18DA80","user_header":"https://static001.geekbang.org/account/avatar/00/18/e4/3c/dfcb86df.jpg","comment_is_top":false,"comment_ctime":1610096519,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"31674867591","product_id":100039001,"comment_content":"每次举得例子都无比难理解，能不能先举个简单有共性的例子让大家知道是怎么回事，然后再加一些实用实战的源码之类的进行拓展？","like_count":7,"discussions":[{"author":{"id":3178447,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Pw2K9YovHNA4UddNibv42gwtJTiabiaVwEZ7fmrb2IyhF5k0nXMiaTpWUc1uib49XaKsKc7CVvnPcHvE7d0FE5F28dw/132","nickname":"Geek_17f801","note":"","ucode":"5EB01D36BB2C18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591103,"discussion_content":"理解不了其实没必要看了 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666278308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258644,"avatar":"https://static001.geekbang.org/account/avatar/00/13/34/94/b58be1b8.jpg","nickname":"贰零壹捌","note":"","ucode":"211A7EC98C4E4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589750,"discussion_content":"非常赞成","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665298516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186351,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1583829361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27353633137","product_id":100039001,"comment_content":"对于题目,由于这三个类之间不具有任何的依赖关系,所以没必要去使用我们的建造者模式,有些过度设计,直接使用构造函数就可以了<br>对于桥接模式,我个人认为,就是一个类中有多个属性,我们可以将这些属性分开来设计,彼此之间不具有关联,这些个属性就可以认为是多个维度,可以说,就是所谓的抽象,而这个类,就是讲这些属性连接起来的桥,这就是桥接模式,也就是真正实现这个类时候,属性需要注入真正的实现类.例如:一个商品可以对应的多种属性,不同属性就是多个维度,这些属性在这个商品中可以是个抽象的概念,但是在扩展的时候,扩展出了实现类,而这个商品负责连接他们,做到了真正意义上的解耦.突然想到了小岛秀夫的死亡搁浅,所谓的桥接型游戏","like_count":6},{"had_liked":false,"id":181135,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1582503140,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"27352306916","product_id":100039001,"comment_content":"set 方法里拷贝一份值，而不是直接赋值。","like_count":6},{"had_liked":false,"id":305855,"user_name":"王喜春","can_delete":false,"product_type":"c1","uid":1022349,"ip_address":"","ucode":"436E91FDED1B30","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/8d/4d5dbfc5.jpg","comment_is_top":false,"comment_ctime":1628211225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18808080409","product_id":100039001,"comment_content":"Notification和MsgSender的场景很形象，不过还是不过瘾。如能基于这个场景， 先IfElse地爆炸实现、实际工作中评估不全、造成线上事故等问题， 再引申出设计大神的桥接模式救场，再复盘地研究下， 桥接模式究竟是哪些天赋异禀造就了神奇的解耦效果， 就更好了。 <br><br>不过， 这些内容， 可以留在升级课程中提供一对一的工作坊式教学。 <br><br>感谢老师","like_count":4},{"had_liked":false,"id":282256,"user_name":"Geek_pillar6699","can_delete":false,"product_type":"c1","uid":1792693,"ip_address":"","ucode":"5DBC09E915FA05","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLksibnCgErxGkPrbA3eCdmamvGHD7HAL6LwBOT7U6oTlql8arcb64tVMKBy6rXkBOfe8n4vdSeiaPQ/132","comment_is_top":false,"comment_ctime":1615174384,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18795043568","product_id":100039001,"comment_content":"补充参考：<br>https:&#47;&#47;refactoringguru.cn&#47;design-patterns&#47;bridge","like_count":4},{"had_liked":false,"id":182660,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1582845361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18762714545","product_id":100039001,"comment_content":"类庞大，在单一职责原则的基础上，是因为<br>1、非功能需求，如缓存、日志、鉴权等需求引起的，这时使用代理模式，增强原始类或函数的非相关功能，调用代理类，实现类规模的降低。<br><br>2、功能类需求，但还要求可扩展性。使用桥接模式，将可扩展的部分委托给实现类。比如JDBC使用桥接模式使得JDBC可扩展、可配置；Notification类使用桥接模式实现不同的消息发送渠道的可扩展。<br><br>3、拓展原功能的某一侧面，如缓存。这里侧面就是某个方法，增强这个接口，首先它必须有实现，所以采用继承抽象类而不是实现某个接口的方式。使用装饰器模式，覆盖这个接口，强化某一个侧面。<br><br>上述后两点，都是和原功能需求相关，被委托或组合的类都实现或继承自同一个接口或抽象类，这一点将其和一般的组合区分开来，一般的组合不要求被组合的类和原类继承自同一个父类。","like_count":4},{"had_liked":false,"id":181219,"user_name":"陈尧东","can_delete":false,"product_type":"c1","uid":1073663,"ip_address":"","ucode":"66095DDCA1C114","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/ff/8872d3cd.jpg","comment_is_top":false,"comment_ctime":1582520260,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"18762389444","product_id":100039001,"comment_content":"老师，有个疑问，重构后SevereNotification类依赖的都是接口MessageSender，没有依赖具体的实现，哪其它几个XxxNotification实现与其有何区别？","like_count":4,"discussions":[{"author":{"id":1297630,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","nickname":"剑八","note":"","ucode":"0A09F41DB8A4E7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288369,"discussion_content":"notification重构后，没解决根据消息级别发给不同msgsender的问题","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1593738888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251721,"avatar":"https://static001.geekbang.org/account/avatar/00/13/19/89/20488013.jpg","nickname":"hanazawakana","note":"","ucode":"E0F6FACBFE7D15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185122,"discussion_content":"可能是不同的xxxNotification里有不同的设置方法，比如发邮件要设置发给谁，打电话要设置打给谁？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582596606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":184484,"discussion_content":"好像没啥区别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582555717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181217,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1582520081,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18762389265","product_id":100039001,"comment_content":"1.防止引用类型成员变量内的属性或元素被外部程序修改。可以在set时赋值 目标参数的深拷贝对象，以保证当前引用类型成员变量的作用范围尽在当前类（同时，对引用类型成员变量的所有修改操作，也应以对象方法的方式，限定在当前类的对象上）。<br><br>2.防止成员变量本身被修改。为成员变量加final标识（增强语意），如此一来，其赋值操作将被限制在构造器构造的时候完成，不会出现被二次修改的场景。","like_count":4},{"had_liked":false,"id":270650,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1609206822,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10199141414","product_id":100039001,"comment_content":"推荐大家看这篇文章：https:&#47;&#47;golangbyexample.com&#47;bridge-design-pattern-in-go&#47;","like_count":2},{"had_liked":false,"id":181762,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1582630464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10172565056","product_id":100039001,"comment_content":"返回不可变对象","like_count":2},{"had_liked":false,"id":181210,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1582518222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10172452814","product_id":100039001,"comment_content":"打卡","like_count":2},{"had_liked":false,"id":181179,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1582512760,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"10172447352","product_id":100039001,"comment_content":"建造者模式","like_count":2},{"had_liked":false,"id":332810,"user_name":"数学汤家凤","can_delete":false,"product_type":"c1","uid":2029485,"ip_address":"","ucode":"DE84E777C384AD","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f7/ad/4fd4d867.jpg","comment_is_top":false,"comment_ctime":1643662247,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5938629543","product_id":100039001,"comment_content":"在下才疏学浅，让我感觉桥接模式就是面向接口编程","like_count":1},{"had_liked":false,"id":298021,"user_name":"Amon Tin","can_delete":false,"product_type":"c1","uid":2618193,"ip_address":"","ucode":"25391BEEB6A719","user_header":"https://static001.geekbang.org/account/avatar/00/27/f3/51/c8eb2d0c.jpg","comment_is_top":false,"comment_ctime":1623892890,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5918860186","product_id":100039001,"comment_content":"js和native的交互，是通过一个js bridge去实现的：js将针对不同操作系统的原生功能调用方式封装成了统一的js bridge api，js唤起系统功能时，如果底层是Android系统，bridge就会委托Android系统的api唤起相关功能，如果iOS，bridge就会委托iOS系统的api唤起相关功能。看起来js bridge就是对桥接模式的应用。","like_count":1},{"had_liked":false,"id":243535,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1598173701,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5893140997","product_id":100039001,"comment_content":"课后思考题：<br>1. 如果可以从构造器传入，则最方便，将emailAddresses，telephones，wechatIds三个属性，用final修饰，并且在构造器里面进行深度copy<br>2. 如果只能通过set方法处理，则在set方法中进行深度copy<br>不管哪种方式，都增加注释进行说明；<br>不管哪种方式，都要在类中增加三个方法addEmailAddress, addTelephone, addWechatId，保证可以通过额外的方式增加相关属性的值。<br><br>欢迎大家指正。","like_count":1},{"had_liked":false,"id":198535,"user_name":"弹簧人","can_delete":false,"product_type":"c1","uid":1697679,"ip_address":"","ucode":"BCB4A6FC76EA17","user_header":"https://static001.geekbang.org/account/avatar/00/19/e7/8f/56387f77.jpg","comment_is_top":false,"comment_ctime":1585455682,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880422978","product_id":100039001,"comment_content":"Collections.unmodifiableList。list不能修改","like_count":1},{"had_liked":false,"id":195495,"user_name":"        ","can_delete":false,"product_type":"c1","uid":1255918,"ip_address":"","ucode":"21028A49D81B06","user_header":"https://static001.geekbang.org/account/avatar/00/13/29/ee/fba11edf.jpg","comment_is_top":false,"comment_ctime":1585191383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880158679","product_id":100039001,"comment_content":"课后思考题：<br>使用建造者模式，解决创建不可变对象的问题","like_count":1},{"had_liked":false,"id":186867,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1583941317,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878908613","product_id":100039001,"comment_content":"果然不好懂，需要多来几次","like_count":1},{"had_liked":false,"id":182804,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1582868889,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877836185","product_id":100039001,"comment_content":"这个桥接模式看上去有点像策略模式 争哥 这两个有什么区别么","like_count":1},{"had_liked":false,"id":182723,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1582856043,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877823339","product_id":100039001,"comment_content":" 可以使用 Builder来实现","like_count":1},{"had_liked":false,"id":181944,"user_name":"李稳","can_delete":false,"product_type":"c1","uid":1401912,"ip_address":"","ucode":"B8164B6B65E26C","user_header":"https://static001.geekbang.org/account/avatar/00/15/64/38/1bd1324e.jpg","comment_is_top":false,"comment_ctime":1582683805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877651101","product_id":100039001,"comment_content":"消息发送方式和消息紧急级别2个维度，根据消息紧急维度注入不同的消息发送方式。<br>jdbc和具体的数据库实现，通过Driver实现桥接","like_count":1},{"had_liked":false,"id":181804,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1582637108,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877604404","product_id":100039001,"comment_content":"课堂讨论: <br>方式一: 使用Builder模式构造Notification类.<br>方式二: 在set方法中做限制, 若成员变量已被赋值, 抛出UnsupportedOperationException<br>.<br>public void setEmailAddress(List emailAddress) { <br>if(this.emailAddresses != null){<br>    throw new UnsupportedOperationException(&quot;Email Address already initialized!&quot;);<br>    }<br>this.emailAddresses = emailAddress; <br>}<br>","like_count":1},{"had_liked":false,"id":181589,"user_name":"小兵","can_delete":false,"product_type":"c1","uid":1261674,"ip_address":"","ucode":"AA3BA727C25179","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/6a/ab1cf396.jpg","comment_is_top":false,"comment_ctime":1582585164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877552460","product_id":100039001,"comment_content":"最简单的是加一个非空判断，其次是在构造函数中赋值，这里并没有很复杂的逻辑，通过构造函数就可以了，如果逻辑复杂，可以考虑建造者模式。","like_count":1},{"had_liked":false,"id":181580,"user_name":"sunnywhy","can_delete":false,"product_type":"c1","uid":1513427,"ip_address":"","ucode":"061F4DED04738A","user_header":"https://static001.geekbang.org/account/avatar/00/17/17/d3/936f4599.jpg","comment_is_top":false,"comment_ctime":1582566041,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5877533337","product_id":100039001,"comment_content":"课后题：首先去掉public的setter方法是必须的，然后可以用构造方法来初始化（没有太多参数的情况下，没有必要用builder模式）。另外，还要考虑是不是需要暴露getter方法，如果需要的话，可以返回一个不可修改的list（本文中list中的元素为String，所以不用担心单个元素被修改的情况，没有必要返回一个copy）","like_count":1},{"had_liked":false,"id":181579,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1582563402,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5877530698","product_id":100039001,"comment_content":"Builder模式隐藏目标对象的set方法，或者在set方法里深拷贝构建一个新的只读容器。","like_count":1},{"had_liked":false,"id":181534,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1582555674,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877522970","product_id":100039001,"comment_content":"1. 桥接模式是将“抽象”和“实现”解耦，让它们可以独立变化。重点在于理解“抽象”和“实现”。这个模式理解难度挺大的。<br>2. 对于第二种理解“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展”不能理解清楚，一个类的不同维度怎么独立扩展？是像例子中的Notification类，抽离出发送渠道类，Notification演变成抽象，只定义需要子类实现的锲约。这样在物理上是变成两个类了。在逻辑上是不是可以理解成Notification的抽象和发送渠道实现在一定程度上是原先Notification类的不同维度的扩展？<br>对于课堂讨论我能想到将Notification 类的创建设计成建造者模式，使其不可变。","like_count":1},{"had_liked":false,"id":181486,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1582550133,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877517429","product_id":100039001,"comment_content":"设计模式_49:<br># 作业<br>使用Builder模式<br><br># 感想<br>老实讲，桥接这个模式，我现在还是似懂非懂(也就是不懂)，文章已经看了3遍了，还看了*Head First*中的解读，依然不是很明白，我想又要慢慢来了，期待一段时间后的一声 “哦。。。”","like_count":1},{"had_liked":false,"id":181134,"user_name":"君子幽幽","can_delete":false,"product_type":"c1","uid":1125551,"ip_address":"","ucode":"4C4841813945C4","user_header":"https://static001.geekbang.org/account/avatar/00/11/2c/af/1817e787.jpg","comment_is_top":false,"comment_ctime":1582502661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877469957","product_id":100039001,"comment_content":"Builder模式用上","like_count":1},{"had_liked":false,"id":181129,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1582500648,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5877467944","product_id":100039001,"comment_content":"课堂讨论题：用构造器模式对外暴露Notification的成员变量的设置，去掉公有的构造函数和setter方法","like_count":1,"discussions":[{"author":{"id":2347137,"avatar":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","nickname":"snake","note":"","ucode":"47BFFE4D048156","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331220,"discussion_content":"同意","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606810450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181127,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1582499017,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5877466313","product_id":100039001,"comment_content":"这个是前面依赖倒置原则的应用吧","like_count":1},{"had_liked":false,"id":357612,"user_name":"Andrew","can_delete":false,"product_type":"c1","uid":2041199,"ip_address":"中国香港","ucode":"837D7A71307A49","user_header":"https://static001.geekbang.org/account/avatar/00/1f/25/6f/bbf7bded.jpg","comment_is_top":false,"comment_ctime":1663480399,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1663480399","product_id":100039001,"comment_content":"感觉所有的管理器都可以用这个模式","like_count":0},{"had_liked":false,"id":356757,"user_name":"布朗战熊","can_delete":false,"product_type":"c1","uid":3171618,"ip_address":"安徽","ucode":"7B658B00B738C2","user_header":"https://static001.geekbang.org/account/avatar/00/30/65/22/3fe35abe.jpg","comment_is_top":false,"comment_ctime":1662559310,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662559310","product_id":100039001,"comment_content":"跟着敲了一遍重构前和重构后的「消息推送系统」，我有个强烈的感觉，这不就是「依赖反转」嘛。","like_count":0},{"had_liked":false,"id":355918,"user_name":"付磊","can_delete":false,"product_type":"c1","uid":1924882,"ip_address":"上海","ucode":"719BD0B72FF2AF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/aXnFBB3XD3lwB3jf1A0PQqT66aJy4yycbRupJI3ia2CUFMuLsvYthM41TDopIIjL8kz7k2xE5vrAtQggQ6Jt8Zw/132","comment_is_top":false,"comment_ctime":1661851071,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661851071","product_id":100039001,"comment_content":"个人对两种理解方式的解读：<br>（第一种理解方式）将抽象和现实解耦，其实说白了就是当一件事有两个变化维度,且是层阶梯性的关联，那么将其拆分，使其独立变化比如我要去旅游这件事情，其实其中有怎么去，和去哪的概念。那么如果这两个都需要灵活变化，比如怎么去有:坐飞机，高铁等。 去哪有：美国，英国等<br>组合太多了，不可能一次定义完这个具体的事物，因此只能拆分且抽象化<br>（第二种理解方式）现在有两个纬度<br>\tCar 车 （奔驰、宝马、奥迪等）<br>\tTransmission 档位类型 （自动挡、手动挡、手自一体等）<br>\t按照继承的设计模式，Car是一个Abstract基类，假设有M个车品牌，N个档位一共要写M*N个类去描述所有车和档位的结合。<br>\t而当我们使用桥接模式的话，我首先new一个具体的Car（如奔驰），再new一个具体的Transmission（比如自动档）。然后奔驰.set(手动档)就可以了。<br>\t那么这种模式只有M+N个类就可以描述所有类型，这就是M*N的继承类爆炸简化成了M+N组合。<br>\t其实就是把原本车这一种维度，抽成两种维度，一个是车本身 一个是车的档位类型，通过组合和抽象的方式，减少车这个具体类型的数量，由调用方去组合他们具体的关系，而不是一上来就直接定义好所有类<br><br>最后。我认为其实上诉两种理解不冲突，可以说先有1，再有2，第一种理解其实是一个较为抽象概念性的东西。而第二种理解其实就是这个概率的具体实现，以及实际解决了什么问题，因为它具体，所以容易被理解","like_count":0},{"had_liked":false,"id":355428,"user_name":"曾帅","can_delete":false,"product_type":"c1","uid":1234319,"ip_address":"广东","ucode":"322F049DA9284D","user_header":"https://static001.geekbang.org/account/avatar/00/12/d5/8f/d0874a01.jpg","comment_is_top":false,"comment_ctime":1661357005,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661357005","product_id":100039001,"comment_content":"改造 MsgSender 和 Notification 之后的代码，如果没有翻回去看 16 讲相关代码的同学，可能还会有点懵。这里补充说明一下相关的逻辑，就是实际的告警 Alert 里面其实是添加了多个 Handler，然后遍历 Handler 去进行 check ，之后是直接在 Notification 里面根据 Level 来判断需要通过那种渠道来发送告警。<br>改造后，Handler 里面传进来的是绑定好对应发送渠道的 Notification，直接调用 notify 方法即可。也就是把之前在 Notification 里面写死的 Level 和 发送渠道 关系拆除了，变成通过在外面进行组合之后再把实现委派给 MsgSender 的具体实现类。使 告警等级 和 发送渠道 的组合更加灵活、可配置。","like_count":0},{"had_liked":false,"id":350878,"user_name":"谁都会变","can_delete":false,"product_type":"c1","uid":1195017,"ip_address":"","ucode":"9965748F7EBB57","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","comment_is_top":false,"comment_ctime":1657271658,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657271658","product_id":100039001,"comment_content":"这个发消息的，弄成策略模式可以吗？ 根据不同的level级别，采用不同的消息通知","like_count":0},{"had_liked":false,"id":345105,"user_name":"lay","can_delete":false,"product_type":"c1","uid":1173616,"ip_address":"","ucode":"27EA76E346C308","user_header":"https://static001.geekbang.org/account/avatar/00/11/e8/70/612f3078.jpg","comment_is_top":false,"comment_ctime":1652025410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652025410","product_id":100039001,"comment_content":"JNI就是桥接模式","like_count":0},{"had_liked":false,"id":345013,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1651934061,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1651934061","product_id":100039001,"comment_content":"推荐大家去看看这个例子：https:&#47;&#47;refactoring.guru&#47;design-patterns&#47;bridge<br>这个讲得比较通熟易懂。","like_count":0},{"had_liked":false,"id":344176,"user_name":"zero","can_delete":false,"product_type":"c1","uid":1145759,"ip_address":"","ucode":"D8A22815D8987C","user_header":"https://static001.geekbang.org/account/avatar/00/11/7b/9f/da374651.jpg","comment_is_top":false,"comment_ctime":1651324824,"is_pvip":false,"discussion_count":0,"race_medal":5,"score":"1651324824","product_id":100039001,"comment_content":"针对桥接模式写了一篇文章，加深了一下理解，欢迎指正。https:&#47;&#47;juejin.cn&#47;post&#47;7092376468621590542?share_token=7cd7ea24-38d3-427a-b780-c0e4e0cc8bb6","like_count":0},{"had_liked":false,"id":343413,"user_name":"肥猫不开心","can_delete":false,"product_type":"c1","uid":2357566,"ip_address":"","ucode":"FA9204B84913C0","user_header":"https://static001.geekbang.org/account/avatar/00/23/f9/3e/0d5f27c4.jpg","comment_is_top":false,"comment_ctime":1650826550,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650826550","product_id":100039001,"comment_content":"有没有谁知道 桥接模式在spring注入下怎么玩 我是完全没办法了 ","like_count":0},{"had_liked":false,"id":342759,"user_name":"woJA1wCgAADPn-mAUDOmrWvgvB0cj-Pw","can_delete":false,"product_type":"c1","uid":2919021,"ip_address":"","ucode":"5F4376EB542CA9","user_header":"","comment_is_top":false,"comment_ctime":1650449246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650449246","product_id":100039001,"comment_content":"感觉设计模式没有面向对象说得透彻","like_count":0},{"had_liked":false,"id":340292,"user_name":"Jamie","can_delete":false,"product_type":"c1","uid":1364550,"ip_address":"","ucode":"DB850A58DB0893","user_header":"https://static001.geekbang.org/account/avatar/00/14/d2/46/a86b950d.jpg","comment_is_top":false,"comment_ctime":1648721739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648721739","product_id":100039001,"comment_content":"我觉得作者讲的复杂了，其实就是简单的组合模式，<br>但是组合的是一个接口，而且这个接口是解决了一个事情，具体是怎么解决的不清楚，就是解决了，<br>举个例子：比如说交罚款这件事<br>接口：罚款，方法：交罚款 实现：机动车罚款，非机动车罚款<br>交罚款这个接口，可以是自己交，也可以是代缴，就是缴了，不用担心罚款是怎么缴的，就是简单的组合。","like_count":0},{"had_liked":false,"id":334384,"user_name":"山鬼谣","can_delete":false,"product_type":"c1","uid":1543162,"ip_address":"","ucode":"E25F498B85A01B","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/fa/103e6900.jpg","comment_is_top":false,"comment_ctime":1644910853,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644910853","product_id":100039001,"comment_content":"难怪以前通说，23中设计模式，感觉大部分都一样。<br>桥接模式，应该就是SPI机制。自己定义标准，让别人去实现。<br>而这有时又和策略模式有点像。都是定义接口，然后有不同的实现类，只不过策略模式是自己写多个实现类，桥接模式（拿JDBC举例）是各个数据库厂家自己实现，也就是不同的人去实现。<br>所以等学完了23中设计模式，特别是行为模式，应该都会有一种感觉，他们似乎就是一个模式。换汤不换药","like_count":0},{"had_liked":false,"id":325851,"user_name":"HomeyLiu","can_delete":false,"product_type":"c1","uid":1330141,"ip_address":"","ucode":"EF4CCB92C369B4","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/dd/41614582.jpg","comment_is_top":false,"comment_ctime":1639196728,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639196728","product_id":100039001,"comment_content":"也可以理解成多维正交模式,2纬,3纬,4纬,N纬,","like_count":0},{"had_liked":false,"id":325850,"user_name":"HomeyLiu","can_delete":false,"product_type":"c1","uid":1330141,"ip_address":"","ucode":"EF4CCB92C369B4","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/dd/41614582.jpg","comment_is_top":false,"comment_ctime":1639196355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639196355","product_id":100039001,"comment_content":"我认同第2种解释,一个事物分成N种纬度,每个纬度独立演化,互不干涉,这种场景就是桥接模式使用的场景.<br>例如电商里面的订单, 分为支付方式(支付宝,微信,银联支付,美团支付),配送场景(蜂鸟配送,闪送,小时达,1日达),独立变化,那就是桥接模式的典型使用场景了.新接入新的支付方式例如华为支付,或者新接入另外一家配送公司顺丰快递,代码新增2个具体不同纬度的实现就ok了,其他代码不用修改一丁点代码就done了.<br>","like_count":0},{"had_liked":false,"id":325026,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1638782346,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638782346","product_id":100039001,"comment_content":"用jdbc举例讲桥接。。。没看懂，jdbc是抽象driver是实现，那组合去哪了。。","like_count":0},{"had_liked":false,"id":322431,"user_name":"陆一鸣猜不动","can_delete":false,"product_type":"c1","uid":2831163,"ip_address":"","ucode":"68E89A037F9A0C","user_header":"https://static001.geekbang.org/account/avatar/00/2b/33/3b/0b25b622.jpg","comment_is_top":false,"comment_ctime":1637383045,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637383045","product_id":100039001,"comment_content":"收到nie同学汽车和驾驶方式的比喻的启发，GoF的“将抽象和实现解耦”可以看作：不要将“自动挡的宝马汽车”当成一种抽象的一种实现，而是多种抽象组合后的多种实现的组合。这样一来，车这一终极抽象，就可以灵活的变化和增加功能。而对车的实现也是五花八门。","like_count":0},{"had_liked":false,"id":322330,"user_name":"stronger.","can_delete":false,"product_type":"c1","uid":1095136,"ip_address":"","ucode":"AD0F2BE338824C","user_header":"https://static001.geekbang.org/account/avatar/00/10/b5/e0/fc3ac264.jpg","comment_is_top":false,"comment_ctime":1637305344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637305344","product_id":100039001,"comment_content":"slf4j也使用了桥接模式，但是感觉和文章描述的场景和功能不太一样，举例：log4j-over-slf4j。使用的桥接模式是把log4j转成了slf4j接口协议，不是为了抽象和实现分离，是不是这种不应该叫桥接模式，更像适配器模式，还是说这也是属于桥接模式的一种","like_count":0},{"had_liked":false,"id":321092,"user_name":"笑天","can_delete":false,"product_type":"c1","uid":1561173,"ip_address":"","ucode":"B71B671B302D3B","user_header":"","comment_is_top":false,"comment_ctime":1636677345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636677345","product_id":100039001,"comment_content":"先理解第一种解读:抽象和实现解耦，让他们可以独立变化。<br>一般理解的实现，就是对一个抽象的具体化，大家常用的手段就是类的继承，或者接口的实现。这种依赖关系，在这个设计模式看来，即在一定场景下还是太过于紧密。在我看来<br>1.组合代替继承，是这种设计模式的一个解读。<br>2.组合代替接口实现，应该也是这个设计模式的一种解读。<br>用jdbc的这个例子套进去。<br>实现和抽象解耦:  driver本可以使用接口实现，或者类的继承来实现jdbc所有的功能，现在把driver抽离出来，这就是实现和抽象的解耦。<br>让他们可以独立变化:  jdbc可以扩展新方法，因为没有了继承和接口实现的束缚，driver也可以单独扩展，不一定非要去实现jdbc的新方法。","like_count":0},{"had_liked":false,"id":320899,"user_name":"静✨","can_delete":false,"product_type":"c1","uid":1658413,"ip_address":"","ucode":"1B33229C206339","user_header":"https://static001.geekbang.org/account/avatar/00/19/4e/2d/06d3f9f5.jpg","comment_is_top":false,"comment_ctime":1636547855,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636547855","product_id":100039001,"comment_content":"组合+委托，不过这个重点是描述这种实现方式下类之间的关系","like_count":0},{"had_liked":false,"id":314309,"user_name":"丌否","can_delete":false,"product_type":"c1","uid":1530082,"ip_address":"","ucode":"84CA8794B74C06","user_header":"https://static001.geekbang.org/account/avatar/00/17/58/e2/3c3b6b19.jpg","comment_is_top":false,"comment_ctime":1632967391,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632967391","product_id":100039001,"comment_content":"怎么感觉比较像工厂模式","like_count":0},{"had_liked":false,"id":311620,"user_name":"易飞","can_delete":false,"product_type":"c1","uid":2630424,"ip_address":"","ucode":"32AC28754237F7","user_header":"https://static001.geekbang.org/account/avatar/00/28/23/18/4284361f.jpg","comment_is_top":false,"comment_ctime":1631345332,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631345332","product_id":100039001,"comment_content":"思考题：建造者模式","like_count":0},{"had_liked":false,"id":309446,"user_name":"小周","can_delete":false,"product_type":"c1","uid":2453498,"ip_address":"","ucode":"7ED7BC27A46C4C","user_header":"https://static001.geekbang.org/account/avatar/00/25/6f/fa/615a0df3.jpg","comment_is_top":false,"comment_ctime":1630138973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630138973","product_id":100039001,"comment_content":"通过构造函数设置，或者用建造者模式，不提供set方法，并且在get的时候进行防御性拷贝。","like_count":0},{"had_liked":false,"id":307824,"user_name":"Geek_b7eb88","can_delete":false,"product_type":"c1","uid":1573715,"ip_address":"","ucode":"0EB46381D9B1CB","user_header":"","comment_is_top":false,"comment_ctime":1629272654,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629272654","product_id":100039001,"comment_content":"对传入的对象进行深拷贝","like_count":0},{"had_liked":false,"id":306069,"user_name":"乔帆 Kayla","can_delete":false,"product_type":"c1","uid":1883514,"ip_address":"","ucode":"81944832230BC4","user_header":"https://static001.geekbang.org/account/avatar/00/1c/bd/7a/37df606b.jpg","comment_is_top":false,"comment_ctime":1628326776,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628326776","product_id":100039001,"comment_content":"关于桥接模式中的“抽象”和“实现”的个人理解：<br>抽象：标准、规范、协议、约定...<br>实现：根据“协议、规范”，提供具体功能支持的一系列中间件、库、框架。<br><br>课堂讨论：<br>如果是不想在外部被修改，那就把提供这三个参数值的类组合到Notification 类中，在Notification 类被初始化的时候委托被组合进来的成员去给变量赋值，并关掉set()方法；接着再组合要使用到这三个变量的类，Notification 类暴露使用这几个类的方法，关掉 get()方法，彻底将这三个变量私有化。","like_count":0},{"had_liked":false,"id":303566,"user_name":"小帅","can_delete":false,"product_type":"c1","uid":1239663,"ip_address":"","ucode":"4129A7E9427FFC","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/6f/09de5f65.jpg","comment_is_top":false,"comment_ctime":1626858301,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626858301","product_id":100039001,"comment_content":"这个桥接模式 没看懂。。。","like_count":0},{"had_liked":false,"id":299661,"user_name":"Sun Fei","can_delete":false,"product_type":"c1","uid":1032631,"ip_address":"","ucode":"092EC0992050BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/b7/57f153f6.jpg","comment_is_top":false,"comment_ctime":1624786165,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624786165","product_id":100039001,"comment_content":"https:&#47;&#47;refactoringguru.cn&#47;design-patterns&#47;bridge","like_count":0},{"had_liked":false,"id":297780,"user_name":"zart","can_delete":false,"product_type":"c1","uid":1148637,"ip_address":"","ucode":"E32677C0FD4421","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eomCrCRrLAWib0gMI2L2NbicMummlxOY6nVmphsDO0J3xx7OygNd8wJicc88RbNoHrcuXBsKLtCMvgFQ/132","comment_is_top":false,"comment_ctime":1623772693,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1623772693","product_id":100039001,"comment_content":"桥接模式和模版模式的异同：他们都有一个抽象和实现的关系，或者说是调用和被调用的关系，或者说是框架和具体实现的关系，但是对于模版模式，框架只有一套，具体实现有多套，所以可以实现子类继承父类，每个子类负责自己的具体实现；而桥接模式中框架不止一套，可能有多套，如果还用模版模式子类继承父类，会形成笛卡尔积效应。","like_count":0},{"had_liked":false,"id":293291,"user_name":"Earth Dog","can_delete":false,"product_type":"c1","uid":1435329,"ip_address":"","ucode":"63B1674F1B27E7","user_header":"https://static001.geekbang.org/account/avatar/00/15/e6/c1/041a39c4.jpg","comment_is_top":false,"comment_ctime":1621324251,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1621324251","product_id":100039001,"comment_content":"JDBC如果用抽象工厂解释是不是稍微更好一点哈？因为实际JDBC的接口定义后就不再变化了，即提供一个生产一一系列对象的接口，（在码农翻身里面看到的哈）。 如果是接口和实现独立变化，个人感觉意味着，和一般继承不同的是，接口也要能变化，且与实现的变化相互独立。","like_count":0},{"had_liked":false,"id":293289,"user_name":"Earth Dog","can_delete":false,"product_type":"c1","uid":1435329,"ip_address":"","ucode":"63B1674F1B27E7","user_header":"https://static001.geekbang.org/account/avatar/00/15/e6/c1/041a39c4.jpg","comment_is_top":false,"comment_ctime":1621323622,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1621323622","product_id":100039001,"comment_content":"老师，“只需要把第一行代码中的 com.mysql.jdbc.Driver 换成 oracle.jdbc.driver.OracleDriver 就可以了”这句话似乎有点错误把，应该第二行的url中的mysql也要换成oracle把","like_count":0},{"had_liked":false,"id":293026,"user_name":"惊蛰","can_delete":false,"product_type":"c1","uid":2574819,"ip_address":"","ucode":"E5A29CF79A24CD","user_header":"https://static001.geekbang.org/account/avatar/00/27/49/e3/1e3320e9.jpg","comment_is_top":false,"comment_ctime":1621159859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621159859","product_id":100039001,"comment_content":"这个模式应该和模板模式一起理解才会更有透彻","like_count":0},{"had_liked":false,"id":293025,"user_name":"惊蛰","can_delete":false,"product_type":"c1","uid":2574819,"ip_address":"","ucode":"E5A29CF79A24CD","user_header":"https://static001.geekbang.org/account/avatar/00/27/49/e3/1e3320e9.jpg","comment_is_top":false,"comment_ctime":1621159813,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621159813","product_id":100039001,"comment_content":"这难道不就是mvc中的依赖注入么？ 想service中，依赖注入dao的时候，dao本身也是一个接口，不管dao是怎么实现的，只要调用就好了。这个好像是最常用的，只是抛开mvc的curd场景，很少会依照这种模式来优化自己的代码。最常用的，不一定就是最理解的","like_count":0},{"had_liked":false,"id":289270,"user_name":"李叶","can_delete":false,"product_type":"c1","uid":1470449,"ip_address":"","ucode":"41B33FA8526E48","user_header":"https://static001.geekbang.org/account/avatar/00/16/6f/f1/35f9f16f.jpg","comment_is_top":false,"comment_ctime":1618963764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618963764","product_id":100039001,"comment_content":"一个类变化的具有不同的变化维度时，通过桥接模式将维度分为不同的接口和实现类，通过组合达到目标","like_count":0},{"had_liked":false,"id":289125,"user_name":"猛男还是萌男","can_delete":false,"product_type":"c1","uid":1132630,"ip_address":"","ucode":"BD334667FCCBFF","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/56/99369df2.jpg","comment_is_top":false,"comment_ctime":1618883021,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618883021","product_id":100039001,"comment_content":"老师一个人想问一下，根据文章的例子和设计的代码，如果在实际业务中有一个业务需要同时发送一个严重通知和一个警告通知，严重通知需要发送短信和邮箱，警告通知需要发送邮箱。那么像这种业务情况，需要怎么样设计？ 难道需要在业务使用的地方针对于每一种组合都单独创建然后进行发送吗？","like_count":0},{"had_liked":false,"id":288928,"user_name":"Tomy","can_delete":false,"product_type":"c1","uid":1192601,"ip_address":"","ucode":"D7E49E90B0D60F","user_header":"https://static001.geekbang.org/account/avatar/00/12/32/99/91b58bf7.jpg","comment_is_top":false,"comment_ctime":1618791070,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618791070","product_id":100039001,"comment_content":"这里还可以用策略模式，按发送消息类型来定义策略","like_count":0},{"had_liked":false,"id":288661,"user_name":"懒猫","can_delete":false,"product_type":"c1","uid":1206544,"ip_address":"","ucode":"B4B567A11B491D","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg","comment_is_top":false,"comment_ctime":1618586169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618586169","product_id":100039001,"comment_content":"看到这个sql类库的实现立马想到了go语言：标准sql库定义接口方法，mysql实现库实现接口，初始化方法注册mysql driver，原来这就是桥接啊","like_count":0},{"had_liked":false,"id":283763,"user_name":"倡印","can_delete":false,"product_type":"c1","uid":1455958,"ip_address":"","ucode":"4F53AA5D017D89","user_header":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","comment_is_top":false,"comment_ctime":1615908320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615908320","product_id":100039001,"comment_content":"还是用建造者模式比较好","like_count":0},{"had_liked":false,"id":281656,"user_name":"马晨阳","can_delete":false,"product_type":"c1","uid":1230031,"ip_address":"","ucode":"344ACC3BF7F14A","user_header":"https://static001.geekbang.org/account/avatar/00/12/c4/cf/6e1205cc.jpg","comment_is_top":false,"comment_ctime":1614841492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614841492","product_id":100039001,"comment_content":"我觉得侨接更偏向于业务思维","like_count":0},{"had_liked":false,"id":270241,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1609001358,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1609001358","product_id":100039001,"comment_content":"桥接模式定义: 将实现与抽象分离 。我的理解两者可以分开变化，基于规范编程。例如jdbc(DriverManager和Driver接口)，Slf4j(logger,appender,encoder接口)，自定义通知框架(Notifier和Sender接口)","like_count":0},{"had_liked":false,"id":269515,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1608689847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608689847","product_id":100039001,"comment_content":"很明显这里的桥接模式，不是虚拟机的网络模式。<br>对我来说，客户端的分享和埋点是最典型的应用。在app开发初期，我们的数据上报是接入的talkingData，后来更换成了友盟，这个更换的过程太痛苦了，所以就引入了一个中间层，所有的上报都通过中间层调用。后来再次更换上报到我们自己的大数据，简直太舒服了，只需要改中间层就可以了。<br>咦？我觉得这只是一个适配器呀！看看目录《适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别》。期待一下～","like_count":0},{"had_liked":false,"id":266583,"user_name":"李明威","can_delete":false,"product_type":"c1","uid":1766127,"ip_address":"","ucode":"199C95F3A4C1A3","user_header":"https://static001.geekbang.org/account/avatar/00/1a/f2/ef/014389c5.jpg","comment_is_top":false,"comment_ctime":1607402668,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1607402668","product_id":100039001,"comment_content":"听一遍没什么感觉，又仔细看了一遍，大致意思明白了，但是没有想要提问的问题，有点云里雾里的感觉。","like_count":0},{"had_liked":false,"id":263504,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1606143906,"is_pvip":false,"replies":[{"id":"96095","content":"嗯嗯 桥接不好理解","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700755,"ip_address":"","comment_id":263504,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606143906","product_id":100039001,"comment_content":"回过头再看，总结一下<br><br>桥接在网络osi模型中的链路层上代表一种设备，这种设备通过学习连接到此设备上的计算机macid来识别并原封不动的转发数据包。在软件上抽象层类似于桥接设备，具体实现类似于连接到抽象层的设备一样，如果用户通过抽象的桥接层发送消息，那么就要通过macid寻找具体设备，而这个macid在桥接模式中类似于抽象层定义的需要由具体层实现的方法的集合。 同时也要注意一下物理链路寻找macid的过程是在第一次的时候就动态绑定指定计算机macid到桥接器中，换句话说，可以通过在创建类或者初始化类的时候直接就绑定了对象。这个过程可以通过static方法块和初始化函数中创建","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510217,"discussion_content":"嗯嗯 桥接不好理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262520,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1605756430,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605756430","product_id":100039001,"comment_content":"由于不需要建造复杂对象，通过改造构造函数应该就能解决。","like_count":0},{"had_liked":false,"id":252244,"user_name":"Gopher","can_delete":false,"product_type":"c1","uid":1206229,"ip_address":"","ucode":"3C1F9012BB486D","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","comment_is_top":false,"comment_ctime":1602211379,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602211379","product_id":100039001,"comment_content":"理解  &quot;实现与抽象&quot; 和 独立变化","like_count":0},{"had_liked":false,"id":250327,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1601026336,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1601026336","product_id":100039001,"comment_content":"桥接模式的关键是利用组合模式，在独立维护对象多个维护的变化的同时，保证了各个实现间清晰的耦合。刚刚遇到一个问题，一块业务，从扩展性的角度来看具有多个扩展的方向，彼此间还需要配合，一开始没想到桥接模式，用责任链模式设计好了某一个维度的扩展后，发现如何优雅地在保证另一个维度的扩展性的同时切入，很难。其实这个问题就可以很简单地使用组合模式来解决，其中的关键是如何划分好不同纬度的界限并作出抽象，想通了，其实问题就都迎刃而解了","like_count":0},{"had_liked":false,"id":249472,"user_name":"小乙哥","can_delete":false,"product_type":"c1","uid":1063308,"ip_address":"","ucode":"C77E79BEA0C325","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","comment_is_top":false,"comment_ctime":1600667780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600667780","product_id":100039001,"comment_content":"桥接模式有点类似接口设计当中的spi，接口的定义与接口的实现是可以独立变化的，接口的实现者不是接口的定义者","like_count":0},{"had_liked":false,"id":247780,"user_name":"天降祥瑞","can_delete":false,"product_type":"c1","uid":1131732,"ip_address":"","ucode":"005E475B4D1A54","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/d4/542ad2c6.jpg","comment_is_top":false,"comment_ctime":1599834806,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599834806","product_id":100039001,"comment_content":"对于桥接模式我是这样理解的。文中JDBC例子中的DriverManager就是充当桥的角色，它屏蔽了客户端代码对java.sql.Driver接口和com.mysql.jdbc.Driver实现类的依赖（com.mysql.jdbc.Driver可以通过配置的方式解除依赖），即“将抽象和实现解耦，让它们可以独立变化”。<br>试想一下如果客户端代码直接依赖java.sql.Driver，这个接口如果不满足日后的需求，修改了契约，那么所有的客户端都要改。如果客户端都依赖DriverManager这个桥梁，那么不管是抽象还是实现类，我们都可以放心改，对客户端没有影响。","like_count":0},{"had_liked":false,"id":245523,"user_name":"观弈道人","can_delete":false,"product_type":"c1","uid":1016905,"ip_address":"","ucode":"F3BB619A33C605","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","comment_is_top":false,"comment_ctime":1598967407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598967407","product_id":100039001,"comment_content":"这个Notification 和 Sender的组合也是个麻烦事，怎么绕得开一堆if else?","like_count":0},{"had_liked":false,"id":245382,"user_name":"冰河时代","can_delete":false,"product_type":"c1","uid":1098504,"ip_address":"","ucode":"F4375FB7CE4FD4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/08/28c327d0.jpg","comment_is_top":false,"comment_ctime":1598928923,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598928923","product_id":100039001,"comment_content":"本文课后题答案交流<br>1.源码部分：<br>public class Notification {<br>    private final List&lt;String&gt; emailAddress;<br>    private final List&lt;String&gt; telephones;<br>    private final List&lt;String&gt; wechatIds;<br><br>    public Notification(List&lt;String&gt; emailAddress, List&lt;String&gt; telephones, List&lt;String&gt; wechatIds) {<br>        this.emailAddress = emailAddress;<br>        this.telephones = telephones;<br>        this.wechatIds = wechatIds;<br><br>    }<br><br>}<br>2.源码解析：<br>如果对成员变量暴露setter方法，就可以多次进行赋值，示例如下：<br>Notification notification = new Notification();<br>notification.setEmailAddress(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;));<br>notification.setEmailAddress(Arrays.asList(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;));<br>如果对成员变量暴露getter方法，也可以多次进行赋值，示例如下：<br>notification.getEmailAddress().add(&quot;g&quot;);<br>所以为了避免拥有notification引用的地方对其进行修改，需要去掉setter，getter方法，改成采用构造器注入的方式<br>另外成员变量emailAddress增加了final关键字修饰，让其只有一次被赋值的机会<br>emailAddress中存放的是String类型，由于期本身设计就是不可变的，故不需要额外进行深度copy了，具体的见上述代码","like_count":0},{"had_liked":false,"id":243558,"user_name":"写代码的","can_delete":false,"product_type":"c1","uid":2085090,"ip_address":"","ucode":"F58186409A3D65","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","comment_is_top":false,"comment_ctime":1598185207,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598185207","product_id":100039001,"comment_content":"public void setEmailAddress(List emailAddress) {<br>    this.emailAddresses = new ArrayList(emailAddress);<br>}","like_count":0},{"had_liked":false,"id":243269,"user_name":"Ke","can_delete":false,"product_type":"c1","uid":1021588,"ip_address":"","ucode":"3C5D87EFC92202","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/94/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1598007893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598007893","product_id":100039001,"comment_content":"一个类如果有多个纬度的的变化，按照正常思路实现，会出现M*N*…种变化，导致类数量爆炸，那么按照桥接模式我们可以将这这多个纬度抽象出来各自演进，而最终通过一个类将他们的关系有机组合起来达，对外提供一套统一的业务接口，不知道这样理解是否正确","like_count":0},{"had_liked":false,"id":241733,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1597404296,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597404296","product_id":100039001,"comment_content":"关键时这句话：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”，举个我们天天使用的Log4j就知道了。如果让你来设计log4j，你会怎么设计？<br>既然是打日志那么有三个问题需解决：<br>1、日志怎么记录<br>2、记录到哪里<br>3、日志的格式<br>我们看到这三个问题是三个不同维度的问题，第一个问题使用Logger类记录日志本身，包括内容和时间等，第二个问题使用Appender记录，表示发到哪里，第三个问题用Formatter来指定日志的格式信息。这三个独立变化的维度在数学上称为正交，正交的好处是隔离变化，任意一个维度的变化都不会影响其他维度。对于桥接模式我理解是正交思想的体现，值得借鉴，同时也说明在设计的时候抽象的重要性。","like_count":0},{"had_liked":false,"id":239764,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1596635820,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596635820","product_id":100039001,"comment_content":"最后一个问题建造者模式呀。。。","like_count":0},{"had_liked":false,"id":239472,"user_name":"susanguan","can_delete":false,"product_type":"c1","uid":2106165,"ip_address":"","ucode":"B8A83D270FCAD5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/411lrtIQO2bQFSvmb7DGO2XKqjc7ZAnXcsC73FFiaLhjInTfsQntSJM7BFicpJNssH6xhVavQICv32HkOe18HwTQ/132","comment_is_top":false,"comment_ctime":1596542953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596542953","product_id":100039001,"comment_content":"去掉if else了，那调用的时候是怎么调的呢？ 什么时候去创建的UrgencyNotification等这些***Notification实现类呢？","like_count":0},{"had_liked":false,"id":239094,"user_name":"Jamie","can_delete":false,"product_type":"c1","uid":1364550,"ip_address":"","ucode":"DB850A58DB0893","user_header":"https://static001.geekbang.org/account/avatar/00/14/d2/46/a86b950d.jpg","comment_is_top":false,"comment_ctime":1596434368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596434368","product_id":100039001,"comment_content":"老是为什么还要抽出来一层 Notification 呢？直接传一个 MsgSender 参数，是不是也行呀","like_count":0},{"had_liked":false,"id":238701,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1596265259,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596265259","product_id":100039001,"comment_content":"课后题：通过建造者模式，在构造对象时set","like_count":0},{"had_liked":false,"id":238117,"user_name":"咸鱼与果汁","can_delete":false,"product_type":"c1","uid":1283861,"ip_address":"","ucode":"F79383599ACB02","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRyUPicEMqGsbsMicHPuvwM8nibfgK8Yt0AibAGUmnic7rLF4zUZ4dBj4ialYz54fOD6sURKwuJIWBNjhg/132","comment_is_top":false,"comment_ctime":1596073590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596073590","product_id":100039001,"comment_content":"感觉没讲明白啊，“类库”又指的是什么呢","like_count":0},{"had_liked":false,"id":237009,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1595650983,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1595650983","product_id":100039001,"comment_content":"桥接模式我理解分为两部分，抽象是具体业务（功能和非功能性需求）的骨架，可以是抽象类，可以是接口也可以是一个抽象的模块，实现就是这个骨架在不同场景下的具体实现，可以是接口也可以是类，但是骨架中必须有提供实现的抽象的位置，比如接口或者抽象类，那桥接的含义在哪里呢？抽象和实现的关系应该是组合而非简单的实现（当然我觉得实现也可以理解成很简单的桥接），也就是说桥接就是组合的集大成实现，这种设计模式在代码中经常被使用到，多用用就能理解这里的含义了吧","like_count":0},{"had_liked":false,"id":236057,"user_name":"一元(wx:abley1874)","can_delete":false,"product_type":"c1","uid":1809802,"ip_address":"","ucode":"5E7A33642FC767","user_header":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","comment_is_top":false,"comment_ctime":1595299639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595299639","product_id":100039001,"comment_content":"其实第二种定义和第一种定义是殊途同归的。第二种定义可以看作是第一种定义的具象化，反之，第一种定义可以看作是第二种的抽象化。<br>在我看来，这里的桥接的落地方式就是组合。核心思想就是将大的、耦合度高的类通过抽象为接口等手段合理拆分为小的类，再通过组合等方式将其更合理的拼装到一起，实现独立，达到解耦。","like_count":0},{"had_liked":false,"id":232630,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1594054211,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594054211","product_id":100039001,"comment_content":"桥接模式的桥可真抽象啊！","like_count":0},{"had_liked":false,"id":232056,"user_name":"CoderArthur","can_delete":false,"product_type":"c1","uid":1625233,"ip_address":"","ucode":"5B591914F0F67C","user_header":"https://static001.geekbang.org/account/avatar/00/18/cc/91/d56a81af.jpg","comment_is_top":false,"comment_ctime":1593845656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593845656","product_id":100039001,"comment_content":"AInterface 、AInterfaceImp<br>与<br>BInterface、BInterfaceImp<br><br>BInterfaceImp通过注入方式调用AInterfaceImp，依赖的是AInterface。<br><br>为什么要这样做？<br>如果去掉 AInterface 和 BInterface，那BInterfaceImp只是将AInterfaceImp包了一层，大概就是代理模式了吧！<br><br>只去掉AInterface呢？那BInterfaceImp中就无法动态调用AInterfaceImp了，例子中的严重Notification用的是telephone，如果改成msg，还要动BInterfaceImp，没做到对扩展开放。<br><br>只去掉BInterface呢？那就是无法动态调用BInterfaceImp。<br><br>桥接，将两个类连接起来。","like_count":0},{"had_liked":false,"id":231791,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1593769952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593769952","product_id":100039001,"comment_content":"想到桥接模式的一个典型应用：在解耦过程中，有时会引入一个中间层让各业务方依赖和调用，业务方通过调用中间层间接调用具体的实现。<br>这个中间层和具体的实现，构成了桥接模式","like_count":0},{"had_liked":false,"id":231576,"user_name":"田","can_delete":false,"product_type":"c1","uid":1282833,"ip_address":"","ucode":"86B1850CFE6572","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJl6JzQNBk6rFIiafk7SPAJJn1haeMgGiaVMSov0b90ywvcSvlFK5YERM4FhPibUicvlZdhsoucPcqZzA/132","comment_is_top":false,"comment_ctime":1593731123,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593731123","product_id":100039001,"comment_content":"感觉这个和委托的概念很像的","like_count":0},{"had_liked":false,"id":231442,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1593678212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593678212","product_id":100039001,"comment_content":"抽象：把数据库操作抽象出来，抽象成JDBC，JDBC包含了各种数据库的增删改查接口功能；<br>实现：创建不同的数据库实体驱动，各个数据库分别实现JDBC中对应自己数据量的增删改查接口。<br>通过JDBC暴露的注册驱动功能，能加不同的数据库实体注册进来。<br>当用Mysql时，就将Mysql的驱动注册到JDBC。这种在JDBC中操作数据库的实体其实是Mysql驱动，因为Mysql驱动实现了JDBC中对应自己数据库的增删改查接口，这样增删改查用的是Mysql具体的增删改查方法；<br>当用Oracle时，就通过JVM把Oracle的驱动加载进来，并替换JDBC中注册的数据库驱动为Oracle驱动，这样利用JDBC增删改成，其实是用的Oracle的增删改查；<br>桥接的好处：在jdbc中，只需要维护数据的基本操作，而不用关心具体操作是怎么实现的；具体实现的功能都有各自的驱动去维护去扩展。把数据的抽象操作和具体的实现操作隔离开，通过注册驱动的方式桥接起来，实现数据库自由的切换。<br>如果不用桥接模式，怎么实现不同的数据库自己切换？<br>第一：不通过JDBC，每次切换，都修改数据的具体操作逻辑和sql，相当于重写代码实现功能；<br>第二：用jdbc，可以把jdbc当做一种中间层，jdbc负责系统与数据数据建立连接，并把系统的操作，作用到具体的数据库上。如果不用桥接模式，那么jdbc，就需要，维护不同的数据库之间的操作差异。也可以理解为，在jdbc中，需要包含各种数据库的具体实现。如果某个数据库功能改造或者升级，就需要相应的修改jdbc的功能，这样，jdbc与数据库的耦合太强，不便于维护与扩展。","like_count":0},{"had_liked":false,"id":230444,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1593391856,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593391856","product_id":100039001,"comment_content":"思考题：可以在对外提供数据时，复制一份给外部调用，这样即使外部修改了，也不会影响原来的数据。忘了这个模式叫什么名字。","like_count":0},{"had_liked":false,"id":230378,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1593357369,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1593357369","product_id":100039001,"comment_content":"桥接模式定义：把抽象和实现分离解藕，让其独立变化。一个类有两种或多种独立变化的纬度，通过组合的方式，让这两个或多个维度独立扩展。典型案例jdbc。jdbc是抽象，驱动是实现，通过组合的方式，jdbc和驱动独立开发和扩展。","like_count":0},{"had_liked":false,"id":229693,"user_name":"楚小奕","can_delete":false,"product_type":"c1","uid":1011022,"ip_address":"","ucode":"AB808A42C2535E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6d/4e/347c3e8f.jpg","comment_is_top":false,"comment_ctime":1593100094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593100094","product_id":100039001,"comment_content":"桥接模式可以类比开关与电器之间的关系，开关与电器彼此关联，但是又可以独立变化，比如开关有手动开关&#47;感应开关，电器的分类也很多","like_count":0},{"had_liked":false,"id":227843,"user_name":"吃饭睡觉打酱油","can_delete":false,"product_type":"c1","uid":1071668,"ip_address":"","ucode":"95EC98C2B5045B","user_header":"https://static001.geekbang.org/account/avatar/00/10/5a/34/4cbadca6.jpg","comment_is_top":false,"comment_ctime":1592492860,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592492860","product_id":100039001,"comment_content":"可以用依赖倒置来理解么，这里的“抽象”就是高层，具体的driver实现是低层，而driver就是高层和低层共同依赖的抽象。","like_count":0},{"had_liked":false,"id":227597,"user_name":"zz","can_delete":false,"product_type":"c1","uid":1237202,"ip_address":"","ucode":"EA1CD86520FE14","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/d2/fb5306c4.jpg","comment_is_top":false,"comment_ctime":1592441068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592441068","product_id":100039001,"comment_content":"看了三遍，终于有些明白了。策略是1对1的，而桥接是多对多的（jdbc是1对多）。两个维度可以理解为告警级别跟发送方式，你的功能是一个告警对应一个发送方式，我可以实现的时候让你自由组合，这就是扩展点，关键是你增加类似功能的时候不用改代码，增加类就行了。","like_count":0},{"had_liked":false,"id":226023,"user_name":"Tobias","can_delete":false,"product_type":"c1","uid":1803858,"ip_address":"","ucode":"F3225639EDA193","user_header":"https://static001.geekbang.org/account/avatar/00/1b/86/52/b92dc111.jpg","comment_is_top":false,"comment_ctime":1591930782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591930782","product_id":100039001,"comment_content":"对桥接模式的定义理解：<br>当一个类的责任在多个独立(不同)的维度上存在多种变化的情况，我们将各个维度的变化单独拆分封装起来，实现每个维度的各自独立扩展。然后根据类的责任在这些维度上的体现，将这些维度的变化组合(桥接)起来，实现这个类的责任。","like_count":0},{"had_liked":false,"id":224474,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1591414418,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1591414418","product_id":100039001,"comment_content":"使用创建型里面Builder模式<br>public class TelephoneMsgSender implements MsgSender {<br>    private List&lt;String&gt; telephones;<br><br>    @Override<br>    public void send(String message) {<br>    }<br><br>    public TelephoneMsgSender(Builder builder) {<br>        this.telephones = builder.telephones;<br>    }<br><br><br>    public static TelephoneMsgSender.Builder builder() {<br>        return new TelephoneMsgSender.Builder();<br>    }<br><br><br>    public static class Builder {<br>        private List&lt;String&gt; telephones;<br><br>        public TelephoneMsgSender build() {<br>            if (CollectionUtils.isEmpty(telephones)) {<br>                throw new IllegalArgumentException(&quot;联系人不能为空&quot;);<br>            }<br>            return new TelephoneMsgSender(this);<br>        }<br><br>        public TelephoneMsgSender.Builder setTelephones(List&lt;String&gt; telephones) {<br>            this.telephones = telephones;<br>            return this;<br>        }<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289695,"discussion_content":"TelephoneMsgSender的构造方法应该是私有的另外builder() 也没有意义，builder有默认的构造方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594183823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221745,"user_name":"肖臧","can_delete":false,"product_type":"c1","uid":1047733,"ip_address":"","ucode":"4FAC9FF54DD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","comment_is_top":false,"comment_ctime":1590580505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590580505","product_id":100039001,"comment_content":"王老师提到的“emailAddresses、telephones、wechatIds中的数据有可能在Notificaition类外部被修改的意思是，这几个对象都是List，Java参数传递的是这几个参数的地址，那么就是说外部可以对这个list进行add, remove等操作，那么Notification里引用的这些list就变了，用建造者模式解决不了这个问题，还是要对传入的参数进行深拷贝才行。","like_count":0},{"had_liked":false,"id":221725,"user_name":"肖臧","can_delete":false,"product_type":"c1","uid":1047733,"ip_address":"","ucode":"4FAC9FF54DD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","comment_is_top":false,"comment_ctime":1590576184,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590576184","product_id":100039001,"comment_content":"既然发送逻辑都在MsgSender这个接口了，Notification这个类是不是可以不用设计成抽象类了，他就把发送者信息和MsgSender封装起来即可，把MsgSender加载到一个Map里，Key是报警级别，Value是MsgSender的实例，相当于策略模式。","like_count":0},{"had_liked":false,"id":221083,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1590400856,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590400856","product_id":100039001,"comment_content":"import java.util.ArrayList;<br>import java.util.List;<br><br>public class Notification {<br>    private List&lt;String&gt; emailAddress;    <br><br>    public void setEmailAddress(List&lt;String&gt; emailAddress) {<br>        this.emailAddress = new ArrayList&lt;&gt;(emailAddress);<br>    }<br><br>    public void printEmailAddress(){<br>        emailAddress.stream().forEach(System.out::println);<br>    }<br><br>    public static void main(String[] args) {<br>        List&lt;String&gt; emailsAddress = new ArrayList&lt;&gt;();<br>        emailsAddress.add(&quot;1111&quot;);<br><br>        Notification notification = new Notification();<br>        notification.setEmailAddress(emailsAddress);<br><br>        emailsAddress.add(&quot;22222&quot;);<br>        emailsAddress.set(0 , &quot;0000&quot;);<br>        <br>        notification.printEmailAddress();<br>    }<br>}","like_count":0},{"had_liked":false,"id":219076,"user_name":"某小浩","can_delete":false,"product_type":"c1","uid":1511556,"ip_address":"","ucode":"F0A65F516B17BB","user_header":"","comment_is_top":false,"comment_ctime":1589940109,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589940109","product_id":100039001,"comment_content":"对于提出的问题，个人认为可以考虑移除set方法，使用配置文件的方式（白名单）来维护发送对象，但是考虑到很多时候发送消息名单本身就是可能会动态维护的，所以这里提供的set方法，个人并不觉得有什么不妥，不过可能从另一个角度，将set方法替换为add、clear，不直接设置数组，而是只能对数组中的内容进行增减可能更符合要求<br>最后看完本节课以后觉得桥接模式的核心还是利用组合（以JDBC的例子来说），而且结合上节的代理模式，也是组合是核心内容，总觉得傻傻分不清了","like_count":0},{"had_liked":false,"id":218028,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1589698740,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589698740","product_id":100039001,"comment_content":"这个模式又复习了一遍，说下我的理解：<br>1. 关键点是理解清楚“抽象”和“实现”这俩概念，已JDBC的例子来说，处理数据库连接的逻辑，就是抽象。处理具体类型的数据库的适配的逻辑，就是实现。这两份逻辑分别属于不同的类库，也要由不同的团队维护。那么怎么办呢？就是两者之间确定一个协议，也就是数据库驱动里的注册接口，利用这个接口可以将这两份逻辑组合在一起起作用。<br>2. 抽象和实现，其实体现的是，围绕一个开发需求，在不同的维度有不同的发展变化，这种情况下就需要用组合来代替继承，否则就会将两个不同维度的需求缠绕在一起<br><br>","like_count":0},{"had_liked":false,"id":218026,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1589698478,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589698478","product_id":100039001,"comment_content":"课后题：使用构建者模式代替set方法，这样就可以确保Notification类的对象是不可变的","like_count":0},{"had_liked":false,"id":216859,"user_name":"汐阳可惜夏","can_delete":false,"product_type":"c1","uid":1756327,"ip_address":"","ucode":"A6172D03ED808D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/cc/a7/088033c7.jpg","comment_is_top":false,"comment_ctime":1589355921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589355921","product_id":100039001,"comment_content":"桥接模式 ：  和代理模式比较相亲。 但是也有区别。<br>1代理模式通过（静态代理） 通过实现共同接口，并且在代理类的构造方法中引用被代理类；来达到给功能逻辑添加附属功能的的一种方式（直白一点就是调用的功能前加入一些你想加入的功能） <br>并且不对呗代理类有操作性。（总结一句。在代理类中实现了被代理类或者相应的接口，从而有相同的返回值。方便调用）<br><br>2桥接模式， 他的被代理类不是一个（重点一个）实现业务逻辑的类。而是实现了同一个接口的不同类， 这么理解首先 桥接和代理的目的不一样。代理的作用是添加附属功能并不改变原有的业务逻辑，而桥接模式是为了抽象和实现的分离，这么理解它可能有多个实现抽象的类也能有多个实现接口的具体类。然后可以通过set方法组合在一起。然后达到了创建不同对象可以有很多种组合（实现接口的类），有人会说这个和建造模式的区别。 建造模式 是创建一个复杂的对象。 重点是一个。然后通过build来添加参数。桥接模式是很多个对象。所以这么久区别出来了。 下面是网上的一个例子很不错（上面有一点想法是错误的。 建造模式是为了创建对象，而桥接模式是 抽象和实现的分离是一种松耦合，你做你的我做我的。互不干扰。在你需要的时候 通过set方式把我引入进来。）<br><br>所以桥接模式更像是一种组合。在你的抽象类中有接口，然后通过set方式调用具体的实现类，然后在继承抽象类的时候可以各种组合","like_count":0},{"had_liked":false,"id":216858,"user_name":"汐阳可惜夏","can_delete":false,"product_type":"c1","uid":1756327,"ip_address":"","ucode":"A6172D03ED808D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/cc/a7/088033c7.jpg","comment_is_top":false,"comment_ctime":1589355849,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589355849","product_id":100039001,"comment_content":"桥接模式 ：  和代理模式比较相亲。 但是也有区别。<br>1代理模式通过（静态代理） 通过实现共同接口，并且在代理类的构造方法中引用被代理类；来达到给功能逻辑添加附属功能的的一种方式（直白一点就是调用的功能前加入一些你想加入的功能） <br>并且不对呗代理类有操作性。（总结一句。在代理类中实现了被代理类或者相应的接口，从而有相同的返回值。方便调用）<br><br>2桥接模式， 他的被代理类不是一个（重点一个）实现业务逻辑的类。而是实现了同一个接口的不同类， 这么理解首先 桥接和代理的目的不一样。代理的作用是添加附属功能并不改变原有的业务逻辑，而桥接模式是为了抽象和实现的分离，这么理解它可能有多个实现抽象的类也能有多个实现接口的具体类。然后可以通过set方法组合在一起。然后达到了创建不同对象可以有很多种组合（实现接口的类），有人会说这个和建造模式的区别。 建造模式 是创建一个复杂的对象。 重点是一个。然后通过build来添加参数。桥接模式是很多个对象。所以这么久区别出来了。 下面是网上的一个例子很不错（上面有一点想法是错误的。 建造模式是为了创建对象，而桥接模式是 抽象和实现的分离是一种松耦合，你做你的我做我的。互不干扰。在你需要的时候 通过set方式把我引入进来。）<br><br>所以桥接模式更像是一种组合。在你的抽象类中有接口，然后通过set方式调用具体的实现类，然后在继承抽象类的时候可以各种组合","like_count":0},{"had_liked":false,"id":215987,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1589163891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589163891","product_id":100039001,"comment_content":"总结：<br>桥接模式：<br>GOF:“将抽象和实现解耦，让它们可以独立变化。”<br>另外一种更加简单的理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。<br><br>第一种理解符合基于接口而非实现编程原则，比如框架提供方定义一个抽象，并基于抽象开发，这个框架不关心具体实现，框架的使用方自定义实现，这让框架的扩展性更好。这时候抽象就是连接框架和实现的桥梁一样。<br><br>第二种理解：多个维度，让使用者自由实现并自由组合。<br>抽象工厂模式也是适用于多个维度的设计模式，但是抽象工厂是定义好实现，并固定组合，使用者直接即可。也就是说框架提供者需要去实现抽象，这就不是独立开发了。<br>所以多维度的桥接模式侧重多维度自由实现+自由组合，灵活性更高，但易用性不好，抽象工厂模式固定实现，更易用但是灵活性不够。<br>","like_count":0},{"had_liked":false,"id":213473,"user_name":"fly","can_delete":false,"product_type":"c1","uid":1025992,"ip_address":"","ucode":"D1F6938C9CE15D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a7/c8/5608cbdb.jpg","comment_is_top":false,"comment_ctime":1588427015,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588427015","product_id":100039001,"comment_content":"确实比较难理解，本来套用面向接口而非实现的方式。用API+具体实现代码来解释。但看到文末，其实“抽象”和“实现”，又有点像“规范”+“实现”。制定统一的规范，不同的语言或方式可以不同，但要符合“约定”。","like_count":0},{"had_liked":false,"id":212706,"user_name":"风不会停息 。","can_delete":false,"product_type":"c1","uid":1700607,"ip_address":"","ucode":"A7806203EAC6A2","user_header":"https://static001.geekbang.org/account/avatar/00/19/f2/ff/efea501e.jpg","comment_is_top":false,"comment_ctime":1588179821,"is_pvip":false,"replies":[{"id":"86453","content":"组合模式跟他完全是两回事，你可以先看下组合模式再说。它有点类似“组合”关系。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594633393,"ip_address":"","comment_id":212706,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1588179821","product_id":100039001,"comment_content":"个人理解，这个模式，跟组合模式很像，两者的区别是什么呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493586,"discussion_content":"组合模式跟他完全是两回事，你可以先看下组合模式再说。它有点类似“组合”关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594633393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008671,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/64/1f/4ad47146.jpg","nickname":"St_gloden","note":"","ucode":"601E0A42B41C25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276721,"discussion_content":"组合模式说的是对象之间的依赖是树形结构时可以考虑用组合，和桥接完全没有相似点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590932824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211071,"user_name":"Ctrl","can_delete":false,"product_type":"c1","uid":1326059,"ip_address":"","ucode":"FDA70234F43703","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/eb/56bc8aa8.jpg","comment_is_top":false,"comment_ctime":1587891078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587891078","product_id":100039001,"comment_content":"发表下个人看法：<br>1 解决的问题是，某个抽象的扩展方向比较多，且每个扩展方向都会有不同的实现；如果用继承的方式去实现所有的扩展+实现，意味着子类爆炸。<br>2 解决方案： 将不同的扩展通过组合的方式来联系到一起。文中的Notification接口的实现依赖于MsgSender接口，是以构造函数参数注入依赖的方式进行组合。","like_count":0},{"had_liked":false,"id":209486,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1587558172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587558172","product_id":100039001,"comment_content":"直接用构造方法初始化不就好了么，说用建造者模式的，最终不还是要调用原本类的构造方法么，麻烦。<br>我有一点有费解将业务逻辑进行抽象后，我觉得并没有必要再用三个类去继承notification类。确实是将抽象与实现分离，但是我觉得是在不同维度去抽象，本身扩展功能的化，多重继承确实能够增强方法，但是维度太多，不利于维护和扩展，个人见解，觉得桥接模式使用在二个维度以上的变化中比较好。单单为了抽象而抽象有点牵强","like_count":0},{"had_liked":false,"id":209360,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1587540671,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587540671","product_id":100039001,"comment_content":"桥接模式放到应用架构上，和微内核或者说插件模式很像。","like_count":0},{"had_liked":false,"id":208477,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1587367508,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587367508","product_id":100039001,"comment_content":"重构之后,如何使用ApplicationContext 类,是这样子使用吧?<br>public class ApplicationContext {<br>  private AlertRule alertRule;<br>  private Alert alert;<br>  public void initializeBeans() {<br>    alertRule = new AlertRule(&#47;*.省略参数.*&#47;); &#47;&#47;省略一些初始化代码<br>    TelephoneMsgSender telephoneMsgSender = new TelephoneMsgSender();<br>    SevereNotification severeNotification = new SevereNotification (telephoneMsgSender); <br>    EmailMsgSender emailMsgSender = new EmailMsgSender();<br>    NormalNotification normalNotification = new NormalNotification (emailMsgSender); <br>    alert = new Alert();<br>    alert.addAlertHandler(new TpsAlertHandler(alertRule, severeNotification ));<br>    alert.addAlertHandler(new ErrorAlertHandler(alertRule, normalNotification ));<br>  }<br>  public Alert getAlert() { return alert; }<br><br>  &#47;&#47; 饿汉式单例<br>  private static final ApplicationContext instance = new ApplicationContext();<br>  private ApplicationContext() {<br>    instance.initializeBeans();<br>  }<br>  public static ApplicationContext getInstance() {<br>    return instance;<br>  }<br>}","like_count":0},{"had_liked":false,"id":206579,"user_name":"ttxser","can_delete":false,"product_type":"c1","uid":1022694,"ip_address":"","ucode":"47C3FCB59F8027","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9a/e6/e8439f9a.jpg","comment_is_top":false,"comment_ctime":1586889562,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586889562","product_id":100039001,"comment_content":"【抽象和实现分离】这个可以说是很体现本质的一句话，就桥接模式而言，他是对使用者说的，抽象层是使用者面对的那一层，实现层是内部的；这个角度可以一直往里走，凡是有变化的地方，都可以 抽象和实现分离，按照变化分好纬度，可以抽象一个类，用参数区分，对调用函数封装一个方法，即访问者；也可以抽象为类级别，就是组合模式，策略模式等","like_count":0},{"had_liked":false,"id":205642,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1586694494,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586694494","product_id":100039001,"comment_content":"我理解java的Spi就是桥接，把抽象和实现分离。","like_count":0,"discussions":[{"author":{"id":1541669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","nickname":"zhengyu.nie","note":"","ucode":"FFE0377D323E46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251965,"discussion_content":"不一定，可能是facade，桥接更多是解决继承引发的类爆炸","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588130195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202422,"user_name":"Johar","can_delete":false,"product_type":"c1","uid":1101969,"ip_address":"","ucode":"834136A6F64CDC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/91/89123507.jpg","comment_is_top":false,"comment_ctime":1585986779,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1585986779","product_id":100039001,"comment_content":"一直都分不清桥接模式，策略模式，请问一下有什么区别？另外很多设计模式中都通过依赖注入的方式来实现组合，解偶，例如:桥接，策略，代理等。那应该怎么看待依赖注入在设计模式的使用？","like_count":0},{"had_liked":false,"id":202315,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1585966501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585966501","product_id":100039001,"comment_content":"桥接模式实际使用非常灵活，之所以能“将抽象和实现解耦，让它们可以独立变化”，实际是借助面向接口编程，由接口来封装变化。由接口来搭建业务骨架，具体的功能行为由子类来实现。<br><br>用好这个模式的关键在于分层抽象意识，编码时关注“抽象行为”即可。比如发生异常需要通知，这里的通知就是一个“抽象行为”，而怎么通知那是子类实现关注的点。","like_count":0},{"had_liked":false,"id":202312,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1585966080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585966080","product_id":100039001,"comment_content":"成员变量能被修改有俩个前提条件 1.成员变量能被访问到 2.成员变量可变，我们只需要控制其中一个就可以。<br><br>由于对象本身是String非引用类型，不存在修改对象的可能。所以只需要控制list访问即可。a.设置list的时候对list进行深拷贝 b.add(List&lt;String&gt;) 改为add(String)。","like_count":0},{"had_liked":false,"id":202225,"user_name":"Yuuuuu","can_delete":false,"product_type":"c1","uid":1233780,"ip_address":"","ucode":"64FD04761D2111","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/74/578b169d.jpg","comment_is_top":false,"comment_ctime":1585926834,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585926834","product_id":100039001,"comment_content":"需要通过两个手段<br>1.使用建造者模式创建对象，防止多次调用set方法<br>2.创建对象时使用集合的浅拷贝对象，防止外部修改集合中的数据","like_count":0},{"had_liked":false,"id":194913,"user_name":"不能忍的地精","can_delete":false,"product_type":"c1","uid":1754913,"ip_address":"","ucode":"66A921C0BC8102","user_header":"","comment_is_top":false,"comment_ctime":1585119915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585119915","product_id":100039001,"comment_content":"思考题: 可以通过构造方法来传入,取消set方法","like_count":0},{"had_liked":false,"id":194642,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1585094801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585094801","product_id":100039001,"comment_content":"1.通过建造者模式构建参数<br>2.属性设置为final， unmodifiedList","like_count":0},{"had_liked":false,"id":194359,"user_name":"索旭东","can_delete":false,"product_type":"c1","uid":1139039,"ip_address":"","ucode":"BFD07BCD8C8CAE","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/5f/b279daaf.jpg","comment_is_top":false,"comment_ctime":1585054069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585054069","product_id":100039001,"comment_content":"前面讲的建造者模式","like_count":0},{"had_liked":false,"id":193404,"user_name":"Q罗","can_delete":false,"product_type":"c1","uid":1792098,"ip_address":"","ucode":"E797378F4DA1F4","user_header":"https://static001.geekbang.org/account/avatar/00/1b/58/62/346dd248.jpg","comment_is_top":false,"comment_ctime":1584891994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584891994","product_id":100039001,"comment_content":"快赶上进度了，小争哥加油","like_count":0},{"had_liked":false,"id":190782,"user_name":"空白昵称","can_delete":false,"product_type":"c1","uid":1433815,"ip_address":"","ucode":"91F50CA25102AB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","comment_is_top":false,"comment_ctime":1584691966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584691966","product_id":100039001,"comment_content":"说实话JDBC的例子没看懂... 后面的notification的例子好懂一些，明显能看到两个类通过组合MsgSender接口在一起。且两个大类都是独立变化，可以无限扩展下去。<br>这是不是代表只理解了一半？","like_count":0},{"had_liked":false,"id":190412,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1584640857,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584640857","product_id":100039001,"comment_content":"两个纬度的桥接比较好理解，但是想象不出来超过2个纬度的桥接的代码结构；比如我要做一个账单解析器；账单渠道有微信，支付宝；账单文件格式有xml,xlsx；账单明细类型有保险费，水费，电费；实现语义有从微信的xml账单中解析出保险费的明细记录，从支付宝的xlsx账单中解析成保险费的明细记录。请教老师，这种是用工厂还是桥接？","like_count":0,"discussions":[{"author":{"id":1541669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","nickname":"zhengyu.nie","note":"","ucode":"FFE0377D323E46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251971,"discussion_content":"账单渠道、账单文件格式、账单明细类型。\n就这三个纬度如果你用继承设计，是不是有三个维度拓展。\n假设你有2个渠道，3个格式，4个明细类型。是不是有2*3*4 = 24个类。\n如果你用桥接，那就是2+3+4个类。\n三个抽象类如下：\n抽象账单渠道\n抽象账单文件格式\n抽象账单明细类型\n\n每个实现类分别有2、3、4个子类。\n那么你最终的结构就是，打个比方你其中一种type是支付宝 水费.xlsx\n你最终就是\n抽象账单渠道 支付宝 = new 支付宝渠道();\n抽象账单文件格式 xlsx = new xlsx格式;\n抽象账单明细类型 水费  = new 水费()；\n\n支付宝.set文件格式(xlsx).set明细类型(水费).apply()；","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588131091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188809,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1584419529,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584419529","product_id":100039001,"comment_content":"加载类DriverManager的时候，static块中会自动通过ServiceLoader的方式去加载jdbc的，不需要class.forName<br>","like_count":0},{"had_liked":false,"id":187393,"user_name":"浩浩","can_delete":false,"product_type":"c1","uid":1580841,"ip_address":"","ucode":"47558B9C9B7368","user_header":"https://static001.geekbang.org/account/avatar/00/18/1f/29/c7a69190.jpg","comment_is_top":false,"comment_ctime":1584098971,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584098971","product_id":100039001,"comment_content":"报警级别和通知方式通过组合实现2维的灵活应用。在想有没有三维的应用需求，场景，例子呢？ <br>虚心求教","like_count":0},{"had_liked":false,"id":187139,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1584024443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584024443","product_id":100039001,"comment_content":"这篇文章，可能看了第5遍了，终于好像读懂了。。。<br>“将实现和抽象解耦，让他们可以独立变化”，<br>“一个类存在多个变化维度，通过组合的方式，让这两个维度独立进行扩展”<br>。。。<br>开心","like_count":0},{"had_liked":false,"id":187132,"user_name":"花儿少年","can_delete":false,"product_type":"c1","uid":1318540,"ip_address":"","ucode":"CFE4F64243673B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","comment_is_top":false,"comment_ctime":1584022739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584022739","product_id":100039001,"comment_content":"看到这个刚好回顾一下项目中的那个发消息的模块，确实很符合桥接模式。<br>业务上有多个状态，当某个状态满足时就需要发送不同渠道的消息给用户。<br>不同渠道是一种变化，不同的状态也是一种变化。<br>不一样的是每种状态下可以发送的消息渠道是不同的，并且可以是多个渠道，每次发送都需要动态去查询这种状态对应可以发送的消息渠道是什么，有点不太确定这个动态去查询渠道的步骤放在哪里合适？<br>看的太迟，不知道争哥能看见不","like_count":0},{"had_liked":false,"id":186875,"user_name":"观弈道人","can_delete":false,"product_type":"c1","uid":1016905,"ip_address":"","ucode":"F3BB619A33C605","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","comment_is_top":false,"comment_ctime":1583942232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583942232","product_id":100039001,"comment_content":"作者通过jdbc和具体是数据库驱动解释桥接模式，感觉没解释通透","like_count":0},{"had_liked":false,"id":186861,"user_name":"观弈道人","can_delete":false,"product_type":"c1","uid":1016905,"ip_address":"","ucode":"F3BB619A33C605","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","comment_is_top":false,"comment_ctime":1583940811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583940811","product_id":100039001,"comment_content":"不同等级的Notification注入不同的Sender","like_count":0},{"had_liked":false,"id":186315,"user_name":"LT","can_delete":false,"product_type":"c1","uid":1147795,"ip_address":"","ucode":"4E902E1EFBB9C1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBV8Deuz0Ys4omVlErUvTeRLt7xYRPd8nxhSZ1C2Q9Nice7icHnndsHmyT3KBenxLGw7xghlDzfIuA/132","comment_is_top":false,"comment_ctime":1583824666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583824666","product_id":100039001,"comment_content":"TelephoneMsgSender 包含 telephones<br>EmailMsgSender 包含emailAddresses<br>WechatMsgSender 包含 wechatIds<br>它们不应该放到Notification这个”抽象“中，它们是”实现“，应该放到实现类库中。","like_count":0},{"had_liked":false,"id":186278,"user_name":"Tom.G","can_delete":false,"product_type":"c1","uid":1206034,"ip_address":"","ucode":"7929B45C1A51F8","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/12/5c6eb568.jpg","comment_is_top":false,"comment_ctime":1583815307,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583815307","product_id":100039001,"comment_content":"课后题：使用构造函数传入","like_count":0},{"had_liked":false,"id":185646,"user_name":"我的黄金时代","can_delete":false,"product_type":"c1","uid":1062070,"ip_address":"","ucode":"D7825B45B372F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/34/b6/0feb574b.jpg","comment_is_top":false,"comment_ctime":1583654405,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583654405","product_id":100039001,"comment_content":"我可以理解为JMS和ActiveMQ的关系吗？","like_count":0},{"had_liked":false,"id":184492,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1583327355,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1583327355","product_id":100039001,"comment_content":"课后题：添加 final 如何？","like_count":0,"discussions":[{"author":{"id":1541669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","nickname":"zhengyu.nie","note":"","ucode":"FFE0377D323E46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251962,"discussion_content":"final是引用不可变，值可变(比如我get出来add remove元素)，理论上set改为builder，get套一个ImmutableList.CopyOf是比较保险的，看需求啦，如果不是非常严格，final也够了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588130129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184000,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1583201943,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1583201943","product_id":100039001,"comment_content":"思考题中对于对象被修改的问题，个人认为是对原型模式中的深copy的一个问题，不管是使用建造者构建复杂的对象，只要没有解决深copy的问题，还是会被修改的。 所以使用遍历方式copy基本数据类型的方式就可以了","like_count":0,"discussions":[{"author":{"id":1683130,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","nickname":"乾坤瞬间","note":"","ucode":"15BDCF29CBF8EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328469,"discussion_content":"现在回想直接使用collections中的深度copy方法来创建就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606144072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183934,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1583163979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583163979","product_id":100039001,"comment_content":"多个维度，单独设计","like_count":0},{"had_liked":false,"id":183878,"user_name":"yu","can_delete":false,"product_type":"c1","uid":1138645,"ip_address":"","ucode":"56856DCC0C8387","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/d5/2fec2911.jpg","comment_is_top":false,"comment_ctime":1583152554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583152554","product_id":100039001,"comment_content":"我理解桥接模式与&quot;组合而非继承&quot;是一个意思，但是桥接的组合更复杂，一般需要一个类充当桥梁","like_count":0},{"had_liked":false,"id":183751,"user_name":"雷刚","can_delete":false,"product_type":"c1","uid":1655725,"ip_address":"","ucode":"115FE2BE1AAB61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132","comment_is_top":false,"comment_ctime":1583126328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583126328","product_id":100039001,"comment_content":"以前理解桥接模式都是第二种，使用组合避免类无限膨胀。今天听了老师的讲解，对桥接模式的认识又深了一步，其思想还是面向抽象或接口编程，组合优于继承，设计模式是设计原则的具体实现。<br>课堂讨论：可以使用 Builder 模式创建不可变对象，或不暴露 setter 方法。","like_count":0},{"had_liked":false,"id":183680,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1583115627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583115627","product_id":100039001,"comment_content":"关于思考题我觉得可以使用代理模式 把Notification再进行一层封装 或者使用创建者模型 控制好他的创建过后就不让修改了","like_count":0},{"had_liked":false,"id":183349,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1583026127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583026127","product_id":100039001,"comment_content":"一、定义：<br>两种理解：<br>1）将抽象和实现解耦，让它们可以独立变化；<br>2）组合优先于继承的思想：一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展，进行功能方面的解耦”<br><br>二、使用场景：<br>当一个类中有多个维度在变化，同时各个维度的复杂度又很高，可以对每个维度进行抽象，之后对抽象进行实现，最终通过组合实现需求。已达到解耦各个维度，各个维度可以独立变化和扩展。<br><br>三、实现方式：<br>实际实现时，对每个维度抽象出接口或是抽象类或是类库，“抽象”和“实现”独立开发，通过对象之间的组合关系，组装在一起。（“组合优于继承”的设计原则）<br><br>","like_count":0},{"had_liked":false,"id":181473,"user_name":"岁月神偷","can_delete":false,"product_type":"c1","uid":1484111,"ip_address":"","ucode":"BA851259EA1F71","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/4f/592d00f2.jpg","comment_is_top":false,"comment_ctime":1582548345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582548345","product_id":100039001,"comment_content":"这个模式挺精妙的，不知道最终使用的时候是不是通过传入等级再反射来生成Notification的实现类，类似于JDBC的用法。这样确实可以完成抽象和实现的解耦，丢掉那些讨厌的if else语句","like_count":0},{"had_liked":false,"id":181378,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1582531909,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582531909","product_id":100039001,"comment_content":"简单的问题将复杂了， 建议看一看大话设计模式","like_count":0},{"had_liked":false,"id":181178,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1582512707,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582512707","product_id":100039001,"comment_content":"public enum NotificationTargetAddressType {<br>    EMAIL,<br>    TELEPHONE,<br>    WECHAT<br>}<br><br>public class Notification {<br>    private Map&lt;NotificationTargetAddressType,List&lt;String&gt;&gt; targetAddresses;<br><br>    public Notification(Map&lt;NotificationTargetAddressType,List&lt;String&gt;&gt; TargetAddresses) {<br>        targetAddresses = TargetAddresses;<br>    }<br><br>    &#47;&#47;...<br>}","like_count":0},{"had_liked":false,"id":181177,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1582512449,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1582512449","product_id":100039001,"comment_content":"课后题:我们项目有短信通知服务模块,我们使用的方式是每次调用短信服务时,请求体都需要携带发送的对象集合,短信模板,然后交给短信服务校验和发送<br>\t如果需要邮件通知,微信通知的话,我的想法是这样的:<br>将短信通知模块扩展成消息通知模块,将短信通知,邮件通知,微信通知等分别以不同的Sender分装起来,同时编写SMSService,EmailService来调用,同样,上层封装不同的接口开放出来(这样做的目的是隔绝变化,譬如短信通知可以扩展为短信通知和短信验证码验证,他们在处理上有很大的不同)<br>\tSender属于比较基础的内容,可与业务无关,以下沉为一个模块,但是Notification更偏向于高层的业务,因为不同的业务有不同的通知规则,Notification并不通用,所以应该将其放在调用者的服务里,专门封装消息模板,消息发送的对象,消息发送渠道等内容","like_count":0,"discussions":[{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263028,"discussion_content":"您的短信模块对发送方式进行了实现，感觉这就不算是桥接模式了，个人认为桥接模式需要抓住抽象和实现独立开发这个点，比如短信框架进行内容封装后调用抽象接口进行发送，而具体发送方式交给使用者自己实现后传入短信框架。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589164357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}