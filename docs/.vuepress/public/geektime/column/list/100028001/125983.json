{"id":125983,"title":"41 | 如何设计更优的分布式锁？","content":"<p>你好，我是刘超。</p><p>从这一讲开始，我们就正式进入最后一个模块的学习了，综合性实战的内容来自我亲身经历过的一些案例，其中用到的知识点会相对综合，现在是时候跟我一起调动下前面所学了！</p><p>去年双十一，我们的游戏商城也搞了一波活动，那时候我就发现在数据库操作日志中，出现最多的一个异常就是Interrupted Exception了，几乎所有的异常都是来自一个校验订单幂等性的SQL。</p><p>因为校验订单幂等性是提交订单业务中第一个操作数据库的，所以幂等性校验也就承受了比较大的请求量，再加上我们还是基于一个数据库表来实现幂等性校验的，所以出现了一些请求事务超时，事务被中断的情况。其实基于数据库实现的幂等性校验就是一种分布式锁的实现。</p><p><span class=\"orange\">那什么是分布式锁呢，它又是用来解决哪些问题的呢？</span></p><p>在JVM中，在多线程并发的情况下，我们可以使用同步锁或Lock锁，保证在同一时间内，只能有一个线程修改共享变量或执行代码块。但现在我们的服务基本都是基于分布式集群来实现部署的，对于一些共享资源，例如我们之前讨论过的库存，在分布式环境下使用Java锁的方式就失去作用了。</p><p>这时，我们就需要实现分布式锁来保证共享资源的原子性。除此之外，分布式锁也经常用来避免分布式中的不同节点执行重复性的工作，例如一个定时发短信的任务，在分布式集群中，我们只需要保证一个服务节点发送短信即可，一定要避免多个节点重复发送短信给同一个用户。</p><!-- [[[read_end]]] --><p>因为数据库实现一个分布式锁比较简单易懂，直接基于数据库实现就行了，不需要再引入第三方中间件，所以这是很多分布式业务实现分布式锁的首选。但是数据库实现的分布式锁在一定程度上，存在性能瓶颈。</p><p>接下来我们一起了解下如何使用数据库实现分布式锁，其性能瓶颈到底在哪，有没有其它实现方式可以优化分布式锁。</p><h2>数据库实现分布式锁</h2><p>首先，我们应该创建一个锁表，通过创建和查询数据来保证一个数据的原子性：</p><pre><code>CREATE TABLE `order`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `order_no` int(11) DEFAULT NULL,\n  `pay_money` decimal(10, 2) DEFAULT NULL,\n  `status` int(4) DEFAULT NULL,\n  `create_date` datetime(0) DEFAULT NULL,\n  `delete_flag` int(4) DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE,\n  INDEX `idx_status`(`status`) USING BTREE,\n  INDEX `idx_order`(`order_no`) USING BTREE\n) ENGINE = InnoDB\n</code></pre><p>其次，如果是校验订单的幂等性，就要先查询该记录是否存在数据库中，查询的时候要防止幻读，如果不存在，就插入到数据库，否则，放弃操作。</p><pre><code>select id from `order` where `order_no`= 'xxxx' for update\n</code></pre><p>最后注意下，除了查询时防止幻读，我们还需要保证查询和插入是在同一个事务中，因此我们需要申明事务，具体的实现代码如下：</p><pre><code>\t@Transactional\n\tpublic int addOrderRecord(Order order) {\n\t\tif(orderDao.selectOrderRecord(order)==null){\n               int result = orderDao.addOrderRecord(order);\n              if(result&gt;0){\n                      return 1;\n              }\n         }\n\t\treturn 0;\n\t}\n</code></pre><p>到这，我们订单幂等性校验的分布式锁就实现了。我想你应该能发现为什么这种方式会存在性能瓶颈了。我们在<a href=\"https://time.geekbang.org/column/article/116369\">第34讲</a>中讲过，在RR事务级别，select的for update操作是基于间隙锁gap lock实现的，这是一种悲观锁的实现方式，所以存在阻塞问题。</p><p>因此在高并发情况下，当有大量的请求进来时，大部分的请求都会进行排队等待。为了保证数据库的稳定性，事务的超时时间往往又设置得很小，所以就会出现大量事务被中断的情况。</p><p>除了阻塞等待之外，因为订单没有删除操作，所以这张锁表的数据将会逐渐累积，我们需要设置另外一个线程，隔一段时间就去删除该表中的过期订单，这就增加了业务的复杂度。</p><p>除了这种幂等性校验的分布式锁，有一些单纯基于数据库实现的分布式锁代码块或对象，是需要在锁释放时，删除或修改数据的。如果在获取锁之后，锁一直没有获得释放，即数据没有被删除或修改，这将会引发死锁问题。</p><h2>Zookeeper实现分布式锁</h2><p>除了数据库实现分布式锁的方式以外，我们还可以基于Zookeeper实现。Zookeeper是一种提供“分布式服务协调“的中心化服务，正是Zookeeper的以下两个特性，分布式应用程序才可以基于它实现分布式锁功能。</p><p><strong>顺序临时节点：</strong>Zookeeper提供一个多层级的节点命名空间（节点称为Znode），每个节点都用一个以斜杠（/）分隔的路径来表示，而且每个节点都有父节点（根节点除外），非常类似于文件系统。</p><p>节点类型可以分为持久节点（PERSISTENT ）、临时节点（EPHEMERAL），每个节点还能被标记为有序性（SEQUENTIAL），一旦节点被标记为有序性，那么整个节点就具有顺序自增的特点。一般我们可以组合这几类节点来创建我们所需要的节点，例如，创建一个持久节点作为父节点，在父节点下面创建临时节点，并标记该临时节点为有序性。</p><p><strong>Watch机制：</strong>Zookeeper还提供了另外一个重要的特性，Watcher（事件监听器）。ZooKeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知给用户。</p><p>我们熟悉了Zookeeper的这两个特性之后，就可以看看Zookeeper是如何实现分布式锁的了。</p><p>首先，我们需要建立一个父节点，节点类型为持久节点（PERSISTENT） ，每当需要访问共享资源时，就会在父节点下建立相应的顺序子节点，节点类型为临时节点（EPHEMERAL），且标记为有序性（SEQUENTIAL），并且以临时节点名称+父节点名称+顺序号组成特定的名字。</p><p>在建立子节点后，对父节点下面的所有以临时节点名称name开头的子节点进行排序，判断刚刚建立的子节点顺序号是否是最小的节点，如果是最小节点，则获得锁。</p><p>如果不是最小节点，则阻塞等待锁，并且获得该节点的上一顺序节点，为其注册监听事件，等待节点对应的操作获得锁。</p><p>当调用完共享资源后，删除该节点，关闭zk，进而可以触发监听事件，释放该锁。</p><p><img src=\"https://static001.geekbang.org/resource/image/1c/28/1c2df592672c78fd5d006cd23eb11f28.jpg?wh=1278*1274\" alt=\"\"></p><p>以上实现的分布式锁是严格按照顺序访问的并发锁。一般我们还可以直接引用Curator框架来实现Zookeeper分布式锁，代码如下：</p><pre><code>InterProcessMutex lock = new InterProcessMutex(client, lockPath);\nif ( lock.acquire(maxWait, waitUnit) ) \n{\n    try \n    {\n        // do some work inside of the critical section here\n    }\n    finally\n    {\n        lock.release();\n    }\n}\n</code></pre><p>Zookeeper实现的分布式锁，例如相对数据库实现，有很多优点。Zookeeper是集群实现，可以避免单点问题，且能保证每次操作都可以有效地释放锁，这是因为一旦应用服务挂掉了，临时节点会因为session连接断开而自动删除掉。</p><p>由于频繁地创建和删除结点，加上大量的Watch事件，对Zookeeper集群来说，压力非常大。且从性能上来说，其与接下来我要讲的Redis实现的分布式锁相比，还是存在一定的差距。</p><h2>Redis实现分布式锁</h2><p>相对于前两种实现方式，基于Redis实现的分布式锁是最为复杂的，但性能是最佳的。</p><p>大部分开发人员利用Redis实现分布式锁的方式，都是使用SETNX+EXPIRE组合来实现，在Redis 2.6.12版本之前，具体实现代码如下：</p><pre><code>public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {\n\n    Long result = jedis.setnx(lockKey, requestId);//设置锁\n    if (result == 1) {//获取锁成功\n        // 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁\n        jedis.expire(lockKey, expireTime);//通过过期时间删除锁\n        return true;\n    }\n    return false;\n}\n</code></pre><p>这种方式实现的分布式锁，是通过setnx()方法设置锁，如果lockKey存在，则返回失败，否则返回成功。设置成功之后，为了能在完成同步代码之后成功释放锁，方法中还需要使用expire()方法给lockKey值设置一个过期时间，确认key值删除，避免出现锁无法释放，导致下一个线程无法获取到锁，即死锁问题。</p><p>如果程序在设置过期时间之前、设置锁之后出现崩溃，此时如果lockKey没有设置过期时间，将会出现死锁问题。</p><p>在  Redis 2.6.12版本后SETNX增加了过期时间参数：</p><pre><code>    private static final String LOCK_SUCCESS = &quot;OK&quot;;\n    private static final String SET_IF_NOT_EXIST = &quot;NX&quot;;\n    private static final String SET_WITH_EXPIRE_TIME = &quot;PX&quot;;\n\n    /**\n     * 尝试获取分布式锁\n     * @param jedis Redis客户端\n     * @param lockKey 锁\n     * @param requestId 请求标识\n     * @param expireTime 超期时间\n     * @return 是否获取成功\n     */\n    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {\n\n        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);\n\n        if (LOCK_SUCCESS.equals(result)) {\n            return true;\n        }\n        return false;\n\n    }\n</code></pre><p>我们也可以通过Lua脚本来实现锁的设置和过期时间的原子性，再通过jedis.eval()方法运行该脚本：</p><pre><code>    // 加锁脚本\n    private static final String SCRIPT_LOCK = &quot;if redis.call('setnx', KEYS[1], ARGV[1]) == 1 then redis.call('pexpire', KEYS[1], ARGV[2]) return 1 else return 0 end&quot;;\n    // 解锁脚本\n    private static final String SCRIPT_UNLOCK = &quot;if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end&quot;;\n</code></pre><p>虽然SETNX方法保证了设置锁和过期时间的原子性，但如果我们设置的过期时间比较短，而执行业务时间比较长，就会存在锁代码块失效的问题。我们需要将过期时间设置得足够长，来保证以上问题不会出现。</p><p>这个方案是目前最优的分布式锁方案，但如果是在Redis集群环境下，依然存在问题。由于Redis集群数据同步到各个节点时是异步的，如果在Master节点获取到锁后，在没有同步到其它节点时，Master节点崩溃了，此时新的Master节点依然可以获取锁，所以多个应用服务可以同时获取到锁。</p><h3>Redlock算法</h3><p>Redisson由Redis官方推出，它是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。Redisson是基于netty通信框架实现的，所以支持非阻塞通信，性能相对于我们熟悉的Jedis会好一些。</p><p>Redisson中实现了Redis分布式锁，且支持单点模式和集群模式。在集群模式下，Redisson使用了Redlock算法，避免在Master节点崩溃切换到另外一个Master时，多个应用同时获得锁。我们可以通过一个应用服务获取分布式锁的流程，了解下Redlock算法的实现：</p><p>在不同的节点上使用单个实例获取锁的方式去获得锁，且每次获取锁都有超时时间，如果请求超时，则认为该节点不可用。当应用服务成功获取锁的Redis节点超过半数（N/2+1，N为节点数)时，并且获取锁消耗的实际时间不超过锁的过期时间，则获取锁成功。</p><p>一旦获取锁成功，就会重新计算释放锁的时间，该时间是由原来释放锁的时间减去获取锁所消耗的时间；而如果获取锁失败，客户端依然会释放获取锁成功的节点。</p><p>具体的代码实现如下：</p><p>1.首先引入jar包：</p><pre><code>&lt;dependency&gt;\n      &lt;groupId&gt;org.redisson&lt;/groupId&gt;\n      &lt;artifactId&gt;redisson&lt;/artifactId&gt;\n      &lt;version&gt;3.8.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><p>2.实现Redisson的配置文件：</p><pre><code>@Bean\npublic RedissonClient redissonClient() {\n    Config config = new Config();\n    config.useClusterServers()\n            .setScanInterval(2000) // 集群状态扫描间隔时间，单位是毫秒\n            .addNodeAddress(&quot;redis://127.0.0.1:7000).setPassword(&quot;1&quot;)\n            .addNodeAddress(&quot;redis://127.0.0.1:7001&quot;).setPassword(&quot;1&quot;)\n            .addNodeAddress(&quot;redis://127.0.0.1:7002&quot;)\n            .setPassword(&quot;1&quot;);\n    return Redisson.create(config);\n}\n</code></pre><p>3.获取锁操作：</p><pre><code>long waitTimeout = 10;\nlong leaseTime = 1;\nRLock lock1 = redissonClient1.getLock(&quot;lock1&quot;);\nRLock lock2 = redissonClient2.getLock(&quot;lock2&quot;);\nRLock lock3 = redissonClient3.getLock(&quot;lock3&quot;);\n\nRedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);\n// 同时加锁：lock1 lock2 lock3\n// 红锁在大部分节点上加锁成功就算成功，且设置总超时时间以及单个节点超时时间\nredLock.trylock(waitTimeout,leaseTime,TimeUnit.SECONDS);\n...\nredLock.unlock();\n</code></pre><h2>总结</h2><p>实现分布式锁的方式有很多，有最简单的数据库实现，还有Zookeeper多节点实现和缓存实现。我们可以分别对这三种实现方式进行性能压测，可以发现<span class=\"orange\">在同样的服务器配置下，Redis的性能是最好的，Zookeeper次之，数据库最差。</span></p><p>从实现方式和可靠性来说，Zookeeper的实现方式简单，且基于分布式集群，可以避免单点问题，具有比较高的可靠性。因此，在对业务性能要求不是特别高的场景中，我建议使用Zookeeper实现的分布式锁。</p><h2>思考题</h2><p>我们知道Redis分布式锁在集群环境下会出现不同应用服务同时获得锁的可能，而Redisson中的Redlock算法很好地解决了这个问题。那Redisson实现的分布式锁是不是就一定不会出现同时获得锁的可能呢？</p><p>期待在留言区看到你的答案。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。</p><p><span class=\"reference\"></span></p>","neighbors":{"left":{"article_title":"40 | 答疑课堂：MySQL中InnoDB的知识点串讲","id":121710},"right":{"article_title":"42 | 电商系统的分布式事务调优","id":127527}},"comments":[{"had_liked":false,"id":127321,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1566654325,"is_pvip":false,"replies":[{"id":"47296","content":"没有问题。<br><br>问题的答案：redis实现的分布式锁，都是有一个过期时间，如果一旦服务A出现stop the world的情况，有可能锁过期了，而此时服务A中仍然存在持有锁，此时另外一个服务B又获取了锁，这个时候存在两个服务同时获取锁的可能。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1566785735,"ip_address":"","comment_id":127321,"utype":1}],"discussion_count":2,"race_medal":0,"score":"117530771317","product_id":100028001,"comment_content":"老师好!基于数据库的实现，我现在项目中直接不开事务，select后插入(oeder_no做唯一约束)。try_catch 异常，重试3次。如果查到了返回成功保证密等。这么做会有问题么?<br>课后题:万一收到的N&#47;2+1节点全部挂了肯定会有问题。不知道，从新选为master节点的算法不知，如果会选择没有收到的节点做master也会有问题。<br>","like_count":27,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464439,"discussion_content":"没有问题。\n\n问题的答案：redis实现的分布式锁，都是有一个过期时间，如果一旦服务A出现stop the world的情况，有可能锁过期了，而此时服务A中仍然存在持有锁，此时另外一个服务B又获取了锁，这个时候存在两个服务同时获取锁的可能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566785735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338566,"discussion_content":"不知道，从新选为master节点的算法不知，如果会选择没有收到的节点做master也会有问题。\n这句话没看懂,能描述的详细一点吗?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609315294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136133,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1569371528,"is_pvip":false,"replies":[{"id":"52254","content":"是的，这种情况也同样存在同时获取锁的可能","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569414783,"ip_address":"","comment_id":136133,"utype":1}],"discussion_count":2,"race_medal":1,"score":"61698913672","product_id":100028001,"comment_content":"老师，zk实现的锁，不会出现redis锁一样的问题吗？<br>设想：<br>应用1和应用2两个服务分别部署到不同的服务器上。是使用zookeeper实现分布式锁。应用1获取到锁，然后开始长时间gc，应用2也开始长时间gc。应用1的zk锁由于心跳超时释放了锁，应用2结束gc获取到锁，应用1结束gc开始执行任务，此时不就有两个任务在同时执行了吗？","like_count":15,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468473,"discussion_content":"是的，这种情况也同样存在同时获取锁的可能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569414783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1762439,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e4/87/fa7438da.jpg","nickname":"卷毛","note":"","ucode":"B53D459BB63025","race_medal":3,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578189,"discussion_content":"这主要是你业务上问题，锁不超时，不就行了嘛。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656561867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127183,"user_name":"a、","can_delete":false,"product_type":"c1","uid":1532404,"ip_address":"","ucode":"590FE8DB111492","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","comment_is_top":false,"comment_ctime":1566582800,"is_pvip":false,"replies":[{"id":"47549","content":"对的，这种情况也是可能发生的，前提是c节点在宕机之前没有持久化锁。<br><br>第二zk锁的问题，如果连接session已经断开，客户端的锁是会释放的，不会存在同时获取锁的情况。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1566869685,"ip_address":"","comment_id":127183,"utype":1}],"discussion_count":2,"race_medal":0,"score":"35926321168","product_id":100028001,"comment_content":"不一定，因为如果集群中有5个redis，abcde，如果发生网络分区，abc在一个分区，de在一个分区，客户端A向abc申请锁成功，在c节点master异步同步slave的时候，master宕机了，slave接替，然后c的slave又和de在一个分区里，这时候如果客户端B来申请锁，也就可以成功了。<br>zk锁也会出现问题，如果客户端A申请zk锁成功，这时候客户端A和zk不在一个分区里，zk就会把临时节点删除，然后如果客户端B再去申请，也就可以申请成功","like_count":9,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464362,"discussion_content":"对的，这种情况也是可能发生的，前提是c节点在宕机之前没有持久化锁。\n\n第二zk锁的问题，如果连接session已经断开，客户端的锁是会释放的，不会存在同时获取锁的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566869685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006424,"avatar":"","nickname":"门窗小二","note":"","ucode":"0BF3780C247F22","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6345,"discussion_content":"坐等老师确认这个场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566863587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211498,"user_name":"Geek_cecf23","can_delete":false,"product_type":"c1","uid":1587643,"ip_address":"","ucode":"110970CDD769CC","user_header":"","comment_is_top":false,"comment_ctime":1587973836,"is_pvip":false,"replies":[{"id":"78616","content":"是的，当在RR事务级别下，在数据库中不存在当前key值的情况下，多线程竞争锁会因为意向锁的问题，导致死锁。可降低数据库隔离级别为 Read Commited，这样的话多个事务不会因为意向锁的原因导致死锁了。<br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1587989840,"ip_address":"","comment_id":211498,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27357777612","product_id":100028001,"comment_content":"老师，之前你讲过一节 36节，记一次线上SQL死锁事故，for update 使用会导致死锁问题，直接使用for update 实现分布式锁，不也会暗含了死锁的可能么","like_count":6,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493280,"discussion_content":"是的，当在RR事务级别下，在数据库中不存在当前key值的情况下，多线程竞争锁会因为意向锁的问题，导致死锁。可降低数据库隔离级别为 Read Commited，这样的话多个事务不会因为意向锁的原因导致死锁了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587989840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155820,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1574761271,"is_pvip":true,"replies":[{"id":"60145","content":"鱼和熊掌不可兼得，保证可靠性的前提下，会带来一定的性能损失。 <br><br>当在一定时间内没有获取到足够节点时，会通过定时任务将已经超时的锁通过lua脚本来释放。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1574942861,"ip_address":"","comment_id":155820,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14459663159","product_id":100028001,"comment_content":"老师您好，我有两个问题：<br>redisson会向所有的redis节点并发发起请求，获取一半以上的锁才会进行后续操作。那我的疑问是，<br>1、这样不会让整体性能变得比redis集群要差一些吗？而且redis节点越多，redisson性能越差？<br>2、redisson的客户端，如果无法获取到足够多redis节点的锁，其释放规则及防止冲突的规则又是如何处理的呢？如果没有合理的防冲突规则，感觉并发量越高，性能会越差。","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475886,"discussion_content":"鱼和熊掌不可兼得，保证可靠性的前提下，会带来一定的性能损失。 \n\n当在一定时间内没有获取到足够节点时，会通过定时任务将已经超时的锁通过lua脚本来释放。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574942861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1762439,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e4/87/fa7438da.jpg","nickname":"卷毛","note":"","ucode":"B53D459BB63025","race_medal":3,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578188,"discussion_content":"redisson 向所有的redis节点并发发起请求，那只是其中一个分布式锁： redlock。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656561678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133139,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568383442,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14453285330","product_id":100028001,"comment_content":"我们的导入功能就是用的redis分布式锁，防止多个业务操作人员同时导入，超时时间一般为五分钟。<br>出现网络分区只能二选一要A或者C，不过互联网企业基本都会选择A。","like_count":3},{"had_liked":false,"id":128634,"user_name":"rong","can_delete":false,"product_type":"c1","uid":1128740,"ip_address":"","ucode":"637A27C532D817","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/24/ab14f6cf.jpg","comment_is_top":false,"comment_ctime":1566917842,"is_pvip":false,"replies":[{"id":"47765","content":"是的，唯一索引可以实现该功能。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1566956349,"ip_address":"","comment_id":128634,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14451819730","product_id":100028001,"comment_content":"老师，使用select for update防止幻读那里，直接把order_no设置成唯一索引，事务里面只有一条insert语句就可以吧？如果之前有，插入不成功，没有的话，插入成功","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465031,"discussion_content":"是的，唯一索引可以实现该功能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566956349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204084,"user_name":"桔子","can_delete":false,"product_type":"c1","uid":1070682,"ip_address":"","ucode":"F47981A9FDE593","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/5a/8499fa98.jpg","comment_is_top":false,"comment_ctime":1586330740,"is_pvip":false,"replies":[{"id":"77121","content":"对的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1586865566,"ip_address":"","comment_id":204084,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10176265332","product_id":100028001,"comment_content":"redisson分布式锁解决单实例或多个完全互相独立master节点分布式环境获取锁的问题。但是主从或cluster集群下，异步通信导致获取锁多次获取的问题并没解决，理解对否？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491073,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586865566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136037,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1569334524,"is_pvip":false,"replies":[{"id":"52253","content":"可以，使用Redisson就好了","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569414562,"ip_address":"","comment_id":136037,"utype":1}],"discussion_count":1,"race_medal":1,"score":"10159269116","product_id":100028001,"comment_content":"老师，互联网行业，多数都是redis集群啊，如果这样，基于redis实现的分布式锁是不是就不能用了？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468427,"discussion_content":"可以，使用Redisson就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569414562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131205,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1090784,"ip_address":"","ucode":"563C4A71D80DA1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJwQvLGE4dMsF4JU0svW3DtGbodpjskbY65FdwF13JdtBYZfgL2IXHlHrdejWzHdjT0RibEIfib4QYA/132","comment_is_top":false,"comment_ctime":1567671415,"is_pvip":false,"replies":[{"id":"50226","content":"写入一个单点只实现了高可用，没有实现集群式分布式锁。单点的问题会存在单个节点挂了的情况下，不同应用服务同时获取锁的可能。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567827256,"ip_address":"","comment_id":131205,"utype":1}],"discussion_count":4,"race_medal":0,"score":"10157606007","product_id":100028001,"comment_content":"老师，想问个问题，redis集群已经分了槽，客户端写入根据算法应该写入一个节点啊，为啥要多个节点同时枷锁？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466335,"discussion_content":"写入一个单点只实现了高可用，没有实现集群式分布式锁。单点的问题会存在单个节点挂了的情况下，不同应用服务同时获取锁的可能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567827256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2172620,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/picb3nrC6rX6t4t6pHP8huAyrBa9g4lXCsY0uz2OicZsVsCfyLRg523CTWxX5AfEptxCMEC9DMuLZcia1cwzawhmg/132","nickname":"Mr.Hwang","note":"","ucode":"26EE6BF8EB1611","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345609,"discussion_content":"哈哈，我也觉得是。我想了一下，文中说的应该是集群模式，而集群模式是没有master slave一说的，是根据key的分布在不同节点槽内，所以是用三个不同的key，去获取不同节点对应的锁，只有这样才说的通。当然还是要看源码才能知道。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611753123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1070682,"avatar":"https://static001.geekbang.org/account/avatar/00/10/56/5a/8499fa98.jpg","nickname":"桔子","note":"","ucode":"F47981A9FDE593","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224962,"discussion_content":"请教下，RedissonRedLock(RLock... locks) { super(locks);}父类RedissonMultiLock将locks添加到list数组中，获取锁trylock中是循环list数组实现加锁。RLock是根据redisson客户端获取redissonClient1.getLock(&#34;lock1&#34;)。redis集群cluster模式下，难道要分别操作多个节点？key不是和槽有关吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586340100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1483912,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL4bZibSxNmZ2Ygpib7N4BWYanDZKWdX2epvXmR4G6ryHN9zsG43wUtoXb1ZtF65icTrz4SWdLiclAuicg/132","nickname":"solzs","note":"","ucode":"E8B7569A359235","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1070682,"avatar":"https://static001.geekbang.org/account/avatar/00/10/56/5a/8499fa98.jpg","nickname":"桔子","note":"","ucode":"F47981A9FDE593","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569120,"discussion_content":"应该是用hashtag 能够指定路由到某个节点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651328659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":224962,"ip_address":""},"score":569120,"extra":""}]}]},{"had_liked":false,"id":127563,"user_name":"我已经设置了昵称","can_delete":false,"product_type":"c1","uid":1364034,"ip_address":"","ucode":"ED672C5EBDBDC4","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg","comment_is_top":false,"comment_ctime":1566741664,"is_pvip":false,"replies":[{"id":"47292","content":"都会设置锁对象","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1566783393,"ip_address":"","comment_id":127563,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10156676256","product_id":100028001,"comment_content":"不太懂redission机制，每个节点各自去获取锁。超过一半以上获取成功就算成功。那是不是还有这么一步：这些一半以上的机器获取了以后，是否还要决定谁真正拿到锁，才能真正执行这个任务","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464550,"discussion_content":"都会设置锁对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566783393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206318,"user_name":"Geek_cecf23","can_delete":false,"product_type":"c1","uid":1587643,"ip_address":"","ucode":"110970CDD769CC","user_header":"","comment_is_top":false,"comment_ctime":1586839037,"is_pvip":false,"replies":[{"id":"77119","content":"会的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1586865441,"ip_address":"","comment_id":206318,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5881806333","product_id":100028001,"comment_content":"基于数据库的for update的分布锁，不会导致死锁么","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491750,"discussion_content":"会的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586865441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161162,"user_name":"Zend","can_delete":false,"product_type":"c1","uid":1053921,"ip_address":"","ucode":"80EBB0B6772E27","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/e1/ee5705a2.jpg","comment_is_top":false,"comment_ctime":1576134648,"is_pvip":false,"replies":[{"id":"61979","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1576670697,"ip_address":"","comment_id":161162,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5871101944","product_id":100028001,"comment_content":"老师在数据库实现分布式锁的例子中，保证查询和插入在同一个事务里面，就能防止幻读。是不是不指定在一个事务里，查询和插入操作虽然在一个方法里，但是两个事务。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477621,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576670697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139305,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1570607921,"is_pvip":false,"replies":[{"id":"54274","content":"分布式锁是在分布式服务的情况下保证原子性操作，而不是因为数据库产生的分布式锁。<br><br>数据库可以实现分布式锁，是一种实现方式。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1570956185,"ip_address":"","comment_id":139305,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5865575217","product_id":100028001,"comment_content":"老师，分布式锁到底锁什么呢，如果说是锁数据库表，分布式应用集群的情况下，如果是单机数据库，数据库自身的锁机制可以保证并发问题吧？难道是分布式锁只是用在数据库分库分表的情况下？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469889,"discussion_content":"分布式锁是在分布式服务的情况下保证原子性操作，而不是因为数据库产生的分布式锁。\n\n数据库可以实现分布式锁，是一种实现方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570956185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136737,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1569501006,"is_pvip":false,"replies":[{"id":"53312","content":"将以下代码提出到new Thread之外：<br>&#47;&#47;zookeeper分布式锁<br>                    CuratorFramework zk = CuratorFrameworkFactory.newClient(connUrl, retryPolicy);<br>                    zk.start();<br>                    InterProcessMutex lock = new InterProcessMutex(zk, &quot;&#47;opt&#47;uams&#47;zookeeper-3.4.7&#47;locks&quot;);","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1570352180,"ip_address":"","comment_id":136737,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5864468302","product_id":100028001,"comment_content":"老师，我试了一下zookeeper的集群分布式锁。测试代码如下：<br>public class TestZookeeperLock {<br>    private static int count = 10;<br><br>    public static void main(String[] args) {<br>        &#47;&#47;重试策略,以下写法为:重试3次，每次间隔时间为3秒<br>        final RetryPolicy retryPolicy = new RetryNTimes(3,2000);<br>        final String connUrl = &quot;192.111.111.111:2181,192.222.222.222:2181&quot;;<br>        for (int i = 0; i &lt; 10; i++) {<br>            new Thread(new Runnable() {<br>                @Override<br>                public void run() {<br>                    &#47;&#47;zookeeper分布式锁<br>                    CuratorFramework zk = CuratorFrameworkFactory.newClient(connUrl, retryPolicy);<br>                    zk.start();<br>                    InterProcessMutex lock = new InterProcessMutex(zk, &quot;&#47;opt&#47;uams&#47;zookeeper-3.4.7&#47;locks&quot;);<br>                    try {<br>                        if (lock.acquire(3, TimeUnit.SECONDS)){<br>                            get();<br>                        }<br>                    } catch (Exception e) {<br>                        e.printStackTrace();<br>                    } finally {<br>                        try {<br>                            &#47;&#47;释放锁<br>                            lock.release();<br>                        } catch (Exception e) {<br>                            e.printStackTrace();<br>                        }<br>                    }<br>                }<br>            }).start();<br>        }<br>    }<br><br>    public static void get (){<br>        count --;<br>        if (count == 3) {<br>            try {<br>                TimeUnit.SECONDS.sleep(3);&#47;&#47;这里设置该线程睡眠2秒,已达到锁住效果<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>        System.out.println(count);<br>    }<br>}<br>输出了：<br>9<br>8<br>7<br>6<br>5<br>4<br>java.lang.IllegalMonitorStateException: You do not own the lock: &#47;opt&#47;uams&#47;zookeeper-3.4.7&#47;locks<br>\tat org.apache.curator.framework.recipes.locks.InterProcessMutex.release(InterProcessMutex.java:140)<br>\tat cn.org.test.TestZookeeperLock$1.run(TestZookeeperLock.java:47)<br>\tat java.lang.Thread.run(Thread.java:745)<br>3<br>多次输出的结果一致，这是怎么回事呢?","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468781,"discussion_content":"将以下代码提出到new Thread之外：\n//zookeeper分布式锁\n                    CuratorFramework zk = CuratorFrameworkFactory.newClient(connUrl, retryPolicy);\n                    zk.start();\n                    InterProcessMutex lock = new InterProcessMutex(zk, &amp;quot;/opt/uams/zookeeper-3.4.7/locks&amp;quot;);","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570352180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131833,"user_name":"K","can_delete":false,"product_type":"c1","uid":1118374,"ip_address":"","ucode":"69831D1EFC083C","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/a6/4d2c933e.jpg","comment_is_top":false,"comment_ctime":1567929420,"is_pvip":false,"replies":[{"id":"50702","content":"RedLock算法是会去每一个节点获取锁，正常情况下，别的线程无法同时获取锁的。<br><br><br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568166925,"ip_address":"","comment_id":131833,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862896716","product_id":100028001,"comment_content":"老师好，课后问题还是没听懂，首先我理解redis集群可能同时获取锁，是因为锁时间超时了，别的线程也能拿到，是这个原因。Redlock 算法是怎样解决这个问题的呢？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466638,"discussion_content":"RedLock算法是会去每一个节点获取锁，正常情况下，别的线程无法同时获取锁的。\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568166925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130758,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1567526771,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5862494067","product_id":100028001,"comment_content":"1.锁超时，也会出现多个任务同时持有锁进行。<br>2.解决方式，守护线程续航锁持有时间。<br>3.弊端，浪费线程，开销太大。<br>4.根据业务情况设置合理的超时时间是最棒的。<br><br>5.集群环境还会导致事务失效（同时提交多个key，多个key在不同节点）挺蛋疼。","like_count":1},{"had_liked":false,"id":130666,"user_name":"再续啸傲","can_delete":false,"product_type":"c1","uid":1360184,"ip_address":"","ucode":"912987A17DCA92","user_header":"https://static001.geekbang.org/account/avatar/00/14/c1/38/e45bbb6b.jpg","comment_is_top":false,"comment_ctime":1567504304,"is_pvip":false,"replies":[{"id":"50237","content":"应该是一个线程监听，具体需要看源码实现。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567827582,"ip_address":"","comment_id":130666,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5862471600","product_id":100028001,"comment_content":"Redisson的“看门狗”watch机制，解决了业务执行时间长于锁过期时间的问题。但是为每一个获取锁的线程设置监听线程，会不会在高并发的场景下耗费过多资源呢？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466057,"discussion_content":"应该是一个线程监听，具体需要看源码实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567827582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1762439,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e4/87/fa7438da.jpg","nickname":"卷毛","note":"","ucode":"B53D459BB63025","race_medal":3,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578191,"discussion_content":"不同线程获取锁基本都会设置监听线程。\n高并发下，耗费资源不可避免。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656562173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128085,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1566829494,"is_pvip":false,"replies":[{"id":"48193","content":"是的，根据自己的需求设定。zk锁则没有超时时间问题。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567130726,"ip_address":"","comment_id":128085,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5861796790","product_id":100028001,"comment_content":"谢谢老师!STW问题之前都没想到，不过正常情况STP时间比较短的吧，除非是CMS下的超大老年代，或者代码不合理。G1分segment回收STW应该不会长吧。项目中数据库锁和redis锁用的比较多，不过超时时间都是随意设置10，20S。正常一般几十ms就能就能完成的。请问redis锁超时时间设置多少比较合理呢?项目中大部分情况锁冲突概率比较小。电商项目，商家余额这种冲突概率很大的适合用zk锁是么?","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464787,"discussion_content":"是的，根据自己的需求设定。zk锁则没有超时时间问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567130726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352935,"user_name":"summer","can_delete":false,"product_type":"c1","uid":1400915,"ip_address":"陕西","ucode":"A19365287B22D4","user_header":"https://static001.geekbang.org/account/avatar/00/15/60/53/f72e72da.jpg","comment_is_top":false,"comment_ctime":1659022782,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1659022782","product_id":100028001,"comment_content":"Red lock集群环境下单点故障，网上说延迟重启能解决，对吗","like_count":0},{"had_liked":false,"id":343476,"user_name":"亦既见止","can_delete":false,"product_type":"c1","uid":1348154,"ip_address":"","ucode":"9B8254F3D845DC","user_header":"https://static001.geekbang.org/account/avatar/00/14/92/3a/05a5a2e8.jpg","comment_is_top":false,"comment_ctime":1650868123,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650868123","product_id":100028001,"comment_content":"使用etcd锁呢？","like_count":0},{"had_liked":false,"id":328543,"user_name":"楞伽山人","can_delete":false,"product_type":"c1","uid":1142335,"ip_address":"","ucode":"5859C06DAC790D","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","comment_is_top":false,"comment_ctime":1640766714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640766714","product_id":100028001,"comment_content":"使用redlock设置每个redis节点的超时时间应该怎么设置呢","like_count":0},{"had_liked":false,"id":328541,"user_name":"楞伽山人","can_delete":false,"product_type":"c1","uid":1142335,"ip_address":"","ucode":"5859C06DAC790D","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","comment_is_top":false,"comment_ctime":1640766630,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1640766630","product_id":100028001,"comment_content":"老师 你好 这句话是怎么理解的 <br>由于频繁地创建和删除结点，加上大量的 Watch 事件，对 Zookeeper 集群来说，压力非常大","like_count":0,"discussions":[{"author":{"id":2295880,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/SYxHx9k1fVAZGanCk5cFVdzFyhx2pkNk45RdH1Yo3ITBH7dCWjwzEzibAnZaXayqF1TibW6ynBkCqIOd6p1Yhlew/132","nickname":"建锋","note":"","ucode":"50E4AF68BE4488","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589400,"discussion_content":"强一致性数据同步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664845269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327303,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1640055259,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1640055259","product_id":100028001,"comment_content":"etcd 也是可以的，比较轻量简单","like_count":0},{"had_liked":false,"id":317923,"user_name":"Sruby","can_delete":false,"product_type":"c1","uid":1016232,"ip_address":"","ucode":"A7D1B93F41DA0F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/81/a8/559afe8b.jpg","comment_is_top":false,"comment_ctime":1635059034,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1635059034","product_id":100028001,"comment_content":"在可靠性要求高的场景，如果使用redis做分布式锁，请问一般怎么设计兜底方案，避免因为锁被重复获取导致的业务出错？","like_count":0},{"had_liked":false,"id":301923,"user_name":"平民人之助","can_delete":false,"product_type":"c1","uid":2658705,"ip_address":"","ucode":"5CCEC0BAC08AEC","user_header":"https://static001.geekbang.org/account/avatar/00/28/91/91/428a27a3.jpg","comment_is_top":false,"comment_ctime":1625976428,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625976428","product_id":100028001,"comment_content":"看切换时间差吧，你说脑裂问题实际也避免不了","like_count":0},{"had_liked":false,"id":291607,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1620380491,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1620380491","product_id":100028001,"comment_content":"config.useClusterServers()<br>    .setScanInterval(2000) &#47;&#47; 集群状态扫描间隔时间，单位是毫秒<br>    .addNodeAddress(&quot;redis:&#47;&#47;127.0.0.1:7000)<br>    .addNodeAddress(&quot;redis:&#47;&#47;127.0.0.1:7001&quot;)<br>    .addNodeAddress(&quot;redis:&#47;&#47;127.0.0.1:7002&quot;)<br><br>请问老师，这三个 redis 节点，是相互独立的吧，例如：3 个 master 节点，或 3 个单独节点。","like_count":0,"discussions":[{"author":{"id":1263977,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/69/c0fcf4e8.jpg","nickname":"def","note":"","ucode":"39BDBEA0560C13","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392876,"discussion_content":"可以看成是三个master节点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631161295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279935,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1614007119,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614007119","product_id":100028001,"comment_content":"请问思考题不是很懂,请问有答案吗= . =<br>Redisson 中的 Redlock 算法很好地解决了这个问题。那 Redisson 实现的分布式锁是不是就一定不会出现同时获得锁的可能呢.<br>","like_count":0},{"had_liked":false,"id":270907,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1609315100,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609315100","product_id":100028001,"comment_content":"Lock lock1 = redissonClient1.getLock(&quot;lock1&quot;);<br>RLock lock2 = redissonClient2.getLock(&quot;lock2&quot;);<br>RLock lock3 = redissonClient3.getLock(&quot;lock3&quot;);<br>RedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);&#47;&#47; 同时加锁：lock1 lock2 lock3<br>&#47;&#47; 红锁在大部分节点上加锁成功就算成功，且设置总超时时间以及单个节点超时时间redLock.trylock(waitTimeout,leaseTime,TimeUnit.SECONDS);<br>老师的这个示例是申请了三把不同的锁吗?按照前文我理解的是三个实例申请key相同的一把锁,半数以上成功则获取锁成功.<br>为什么示例是三把不同的锁.","like_count":0},{"had_liked":false,"id":223532,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1005685,"ip_address":"","ucode":"8651661C362897","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJdic50nGmb0a4IhlUEbFOxN37ng7ziclUibx5zPRkFZVe9LKSQBeqd9J7DicTNbN63hriamcqmicqXzWVQ/132","comment_is_top":false,"comment_ctime":1591109528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591109528","product_id":100028001,"comment_content":"老师好，Redisson的实现是我看上面例子是需要提前知道redis集群有几个节点，而且可以指定不同的节点去连接。实际生产中，redis集群都是面向应用统一入口，向上透明的，有没有更友好的方式呢。","like_count":0},{"had_liked":false,"id":196428,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1585280504,"is_pvip":false,"replies":[{"id":"75250","content":"是的，redis和zk实现的分布式锁都存在同时获取到锁的可能","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1585742102,"ip_address":"","comment_id":196428,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1585280504","product_id":100028001,"comment_content":"redis、redisson 这两种设置过期时间的分布式锁，有一个共性问题，就是锁过期时间到了，自动释放锁，但应用程序没有执行完任务，还在继续操作，同时另一个应用抢到锁，执行，就存在同时操作的情况。<br>zk 锁也一样，虽然不用设置过期时间，但获取锁的应用发生 gc，zk连接断开，锁释放，另一个应用抢到锁，第一个应用gc恢复后继续执行，也是存在同时执行的情况","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489295,"discussion_content":"是的，redis和zk实现的分布式锁都存在同时获取到锁的可能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585742102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192796,"user_name":"冰河时代","can_delete":false,"product_type":"c1","uid":1098504,"ip_address":"","ucode":"F4375FB7CE4FD4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/08/28c327d0.jpg","comment_is_top":false,"comment_ctime":1584873240,"is_pvip":false,"replies":[{"id":"74161","content":"因为zookeeper临时节点有序的特性","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1585135822,"ip_address":"","comment_id":192796,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584873240","product_id":100028001,"comment_content":"基于zk的实现，为什么是有序的","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488464,"discussion_content":"因为zookeeper临时节点有序的特性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585135822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162654,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1576573680,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1576573680","product_id":100028001,"comment_content":"老师，InterProcessMutex lock = new InterProcessMutex(client, lockPath);<br>如果使用curator框架进行分布式锁的实现（针对并发修改表中的一条记录），故我对表中的id字段进行加锁，但是这个id不能放在上面的lockPath中，否则在zookeeper中就会产生成千上万个znode。所以，这个id必须是临时节点，但是InterProcessMutex中好像没有找到相应的api，是否只能走zookeeper原生的方式实现吗","like_count":0},{"had_liked":false,"id":153124,"user_name":"任鹏斌","can_delete":false,"product_type":"c1","uid":1104086,"ip_address":"","ucode":"34319B05EA6E74","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg","comment_is_top":false,"comment_ctime":1574163773,"is_pvip":false,"replies":[{"id":"59460","content":"2.6.12版本中，使用SET代替SETNX ，相当于SETNX+EXPIRE实现了原子性，不必担心SETNX成功，而EXPIRE失败的问题。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1574597162,"ip_address":"","comment_id":153124,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574163773","product_id":100028001,"comment_content":"老师我从redis官方文档的setnx命令里并没发现支持过期时间呀，setex倒是可以，您文中的代码里jedis使用的是set，这是怎么回事呢？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475051,"discussion_content":"2.6.12版本中，使用SET代替SETNX ，相当于SETNX+EXPIRE实现了原子性，不必担心SETNX成功，而EXPIRE失败的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574597162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152296,"user_name":"青春超无敌","can_delete":false,"product_type":"c1","uid":1322443,"ip_address":"","ucode":"409F5DA89B028F","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/cb/206c8a03.jpg","comment_is_top":false,"comment_ctime":1573962596,"is_pvip":false,"replies":[{"id":"58541","content":"实现原理不一样，性能不一样","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1573980912,"ip_address":"","comment_id":152296,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573962596","product_id":100028001,"comment_content":"老师，redis和zk实现分布式锁。这两种除了性能区别，还有其他方面的差别吗","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474774,"discussion_content":"实现原理不一样，性能不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573980912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151321,"user_name":"李豪","can_delete":false,"product_type":"c1","uid":1697036,"ip_address":"","ucode":"37093C3633C7AB","user_header":"https://static001.geekbang.org/account/avatar/00/19/e5/0c/a3fdafbe.jpg","comment_is_top":false,"comment_ctime":1573698922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573698922","product_id":100028001,"comment_content":"Redis setnx方式设置分布式锁存在一定的缺陷——它加锁只作用在一个Redis节点上，如果通过sentinel保证高可用，如果master节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：<br>1.客户端1在Redis的master节点上拿到了锁。<br>2.Master宕机了，存储锁的key还没有来得及同步到Slave上。<br>3.master故障，发生故障转移，slave节点升级为master节点。<br>4.客户端2从新的Master获取到了对应同一个资源的锁。<br>于是，客户端1和客户端2同时持有了同一个资源的锁。锁的安全性被打破了。","like_count":0},{"had_liked":false,"id":140831,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1571055147,"is_pvip":false,"replies":[{"id":"55138","content":"这是官方给出的一种连接redis集群的参考方式，具体作用已经写出了，类似一个心跳机制：<br>https:&#47;&#47;github.com&#47;redisson&#47;redisson&#47;wiki&#47;2.-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95#24-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1571472180,"ip_address":"","comment_id":140831,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1571055147","product_id":100028001,"comment_content":"老师，redisson实现的分布式锁。您写的例子<br> .setScanInterval(2000) &#47;&#47;集群状态的扫描时间，单位是毫秒<br>这个设置有什么用啊？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470581,"discussion_content":"这是官方给出的一种连接redis集群的参考方式，具体作用已经写出了，类似一个心跳机制：\nhttps://github.com/redisson/redisson/wiki/2.-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95#24-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571472180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140741,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1571040198,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"1571040198","product_id":100028001,"comment_content":"老师，我试了一下redisson实现的分布式锁。有两个问题请教您。<br>1 .redis的集群模式，我在一台机器上建了一个伪集群。创建集群时，一共6个节点。3主3从。从节点是自动分配的。从节点的只读模式需要改成no吗?(不改成no，往从节点写锁，就会转移到主节点上去)<br>2 .字数限制，没办法贴代码，我在您例子的基础上增加了3个节点，也就是6个节点。核心代码如下：<br>final long waitTimeout = 10;<br>        final long leaseTime = 3;<br>final RLock lock1 = redissonClient1.getLock(&quot;lock1&quot;);<br>        final RLock lock2 = redissonClient2.getLock(&quot;lock2&quot;);<br>        final RLock lock3 = redissonClient3.getLock(&quot;lock3&quot;);<br>        final RLock lock4 = redissonClient4.getLock(&quot;lock4&quot;);<br>        final RLock lock5 = redissonClient5.getLock(&quot;lock5&quot;);<br>        final RLock lock6 = redissonClient6.getLock(&quot;lock6&quot;);<br><br>for (int i = 0; i &lt; 10; i++) {<br>            new Thread(new Runnable() {<br>                @Override<br>                public void run() {<br>                    RedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3, lock4, lock5, lock6);<br>                    try {<br>                        if (redLock.tryLock(waitTimeout, leaseTime, TimeUnit.SECONDS)) {<br>                            &#47;&#47;业务逻辑<br>                        }<br>                    } catch (InterruptedException e) {<br>                        e.printStackTrace();<br>                    } finally {<br>                        redLock.unlock();<br>                    }<br>                }<br>            }).start();<br>        }<br>使用6个节点来实现redisson，但是获取锁一直失败，怎么回事呢？老师","like_count":0,"discussions":[{"author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","nickname":"行则将至","note":"","ucode":"DB972F2DF059C4","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32532,"discussion_content":"老师，在循环中，每次开启一个新的线程前，如果sleep 1秒钟的话，就可以实现锁住的效果。不知道是咋回事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571045273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132657,"user_name":"木刻","can_delete":false,"product_type":"c1","uid":1157430,"ip_address":"","ucode":"0A3226FEE3983B","user_header":"https://static001.geekbang.org/account/avatar/00/11/a9/36/972f7abf.jpg","comment_is_top":false,"comment_ctime":1568187115,"is_pvip":false,"replies":[{"id":"51129","content":"运行了代码，并没有出现死锁问题，麻烦贴出数据库脚本","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568538332,"ip_address":"","comment_id":132657,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1568187115","product_id":100028001,"comment_content":"老师你好，我尝试了下第一个，模拟并发情况下发现会有概率抛数据库异常： Deadlock found when trying to get lock; try restarting transaction<br>https:&#47;&#47;github.com&#47;mygodmele&#47;DbLock.git","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467056,"discussion_content":"运行了代码，并没有出现死锁问题，麻烦贴出数据库脚本","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568538332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1157430,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a9/36/972f7abf.jpg","nickname":"木刻","note":"","ucode":"0A3226FEE3983B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12853,"discussion_content":"报错如下：\n09:54:05.458 [Thread-2] DEBUG org.mybatis.spring.SqlSessionUtils - Transaction synchronization deregistering SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3583a763]\n09:54:05.458 [Thread-2] DEBUG org.mybatis.spring.SqlSessionUtils - Transaction synchronization closing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3583a763]\n09:54:05.458 [Thread-2] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Initiating transaction rollback\n09:54:05.458 [Thread-2] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Rolling back JDBC transaction on Connection [HikariProxyConnection@834413964 wrapping com.mysql.cj.jdbc.ConnectionImpl@7bf6846e]\n09:54:05.458 [Thread-7] DEBUG org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator - Translating SQLException with SQL state &#39;40001&#39;, error code &#39;1213&#39;, message [Deadlock found when trying to get lock; try restarting transaction] for task [\n### Error updating database.  Cause: com.mysql.cj.jdbc.exceptions.MySQLTransactionRollbackException: Deadlock found when trying to get lock; try restarting transaction\n### The error may involve com.zk.dblock.DbLock.insertAuthcode-Inline\n### The error occurred while setting parameters\n### SQL: insert into auth_key (acc_key) values (?);\n### Cause: com.mysql.cj.jdbc.exceptions.MySQLTransactionRollbackException: Deadlock found when trying to get lock; try restarting transaction\n]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568602836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1157430,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a9/36/972f7abf.jpg","nickname":"木刻","note":"","ucode":"0A3226FEE3983B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12852,"discussion_content":"老师你好，以下是数据库配置脚本，这个数据库配置了主主互备，不过测试代码的数据库不是这个配置的数据库\n[mysqld]\nsql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION\n\ndatadir=/var/lib/mysql\nsocket=/var/lib/mysql/mysql.sock\nport=3306\n\n# Disabling symbolic-links is recommended to prevent assorted security risks\nsymbolic-links=0\nmax_connections = 10000\nmax_allowed_packet = 8M\nlog-error=/var/log/mysqld.log\npid-file=/var/run/mysqld/mysqld.pid\nserver_id=13\nlog-bin=mysql-bin\n\nauto_increment_increment=2\nauto_increment_offset=2\nreplicate-do-db=talkback_db\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568602825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128942,"user_name":"zero","can_delete":false,"product_type":"c1","uid":1299615,"ip_address":"","ucode":"528DD5C8399AEC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKlwpFM3tkeG15YqyJTYWkfqkdmro9POq6SicYm57TaEFDOUZCXjoe0Z0Iz6UibGQqic3icJRsHdFzibtw/132","comment_is_top":false,"comment_ctime":1566990196,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1566990196","product_id":100028001,"comment_content":"用etcd实现锁，是不是更好呢","like_count":0,"discussions":[{"author":{"id":1099072,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c5/40/6ddb8c5c.jpg","nickname":"zzw0307","note":"","ucode":"747BE063B2D37D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221146,"discussion_content":"和zk 也差不多吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585980804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127652,"user_name":"我已经设置了昵称","can_delete":false,"product_type":"c1","uid":1364034,"ip_address":"","ucode":"ED672C5EBDBDC4","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg","comment_is_top":false,"comment_ctime":1566775326,"is_pvip":false,"replies":[{"id":"47291","content":"是的，这是一个间隙锁，可以防止两个事务插入相同订单号的数据。将查询和插入作为一个事务，是保证在查询没有订单时，然后才能插入数据。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1566783284,"ip_address":"","comment_id":127652,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1566775326","product_id":100028001,"comment_content":"数据库实现，select for update是为了放置幻读？是为了同时两个线程走到同一行查询代码，然后插入两遍的意思吗？那后面的把查询和插入放同一个事务里面的作用是什么？请老师指点下，这边还是不太懂","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464595,"discussion_content":"是的，这是一个间隙锁，可以防止两个事务插入相同订单号的数据。将查询和插入作为一个事务，是保证在查询没有订单时，然后才能插入数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566783284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","nickname":"行则将至","note":"","ucode":"DB972F2DF059C4","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20586,"discussion_content":"放入不同事务，会死锁的吧?之前老师讲了，gap lock和insert冲突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569332813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127577,"user_name":"明天更美好","can_delete":false,"product_type":"c1","uid":1180696,"ip_address":"","ucode":"F036B8718938BE","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/18/4b02510f.jpg","comment_is_top":false,"comment_ctime":1566743263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566743263","product_id":100028001,"comment_content":"我对redisson不是很了解，只是之前看过一些别的帖子，好像底层也是有用lua脚本的。如果对于原生的还好些，但是有些公司自研的分布式缓存是不支持lua的。这时候恐怕就不适用了","like_count":0},{"had_liked":false,"id":127268,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1566628890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566628890","product_id":100028001,"comment_content":"分布式锁这一块确实没有实践过，跟着老师一起学习。","like_count":0}]}