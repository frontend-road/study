{"id":182902,"title":"15 | constexpr：一个常态的世界","content":"<p>你好，我是吴咏炜。</p><p>我们已经连续讲了几讲比较累人的编译期编程了。今天我们还是继续这个话题，但是，相信今天学完之后，你会感觉比之前几讲要轻松很多。C++ 语言里的很多改进，让我们做编译期编程也变得越来越简单了。</p><h2>初识 constexpr</h2><p>我们先来看一些例子：</p><pre><code class=\"language-c++\">int sqr(int n)\n{\n  return n * n;\n}\n\nint main()\n{\n  int a[sqr(3)];\n}\n</code></pre><p>想一想，这个代码合法吗？</p><p>看过之后，再想想这个代码如何？</p><pre><code class=\"language-c++\">int sqr(int n)\n{\n  return n * n;\n}\n\nint main()\n{\n  const int n = sqr(3);\n  int a[n];\n}\n</code></pre><p>还有这个？</p><pre><code class=\"language-c++\">#include &lt;array&gt;\n\nint sqr(int n)\n{\n  return n * n;\n}\n\nint main()\n{\n  std::array&lt;int, sqr(3)&gt; a;\n}\n</code></pre><p>此外，我们前面模板元编程里的那些类里的 <code>static const int</code> 什么的，你认为它们能用在上面的几种情况下吗？</p><p>如果以上问题你都知道正确的答案，那恭喜你，你对 C++ 的理解已经到了一个不错的层次了。但问题依然在那里：这些问题的答案不直观。并且，我们需要一个比模板元编程更方便的进行编译期计算的方法。</p><p>在 C++11 引入、在 C++14 得到大幅改进的 <code>constexpr</code> 关键字就是为了解决这些问题而诞生的。它的字面意思是 constant expression，常量表达式。存在两类 <code>constexpr</code> 对象：</p><!-- [[[read_end]]] --><ul>\n<li><code>constexpr</code> 变量（唉……😓）</li>\n<li><code>constexpr</code> 函数</li>\n</ul><p>一个 <code>constexpr</code> 变量是一个编译时完全确定的常数。一个 <code>constexpr</code> 函数至少对于某一组实参可以在编译期间产生一个编译期常数。</p><p>注意一个 <code>constexpr</code> 函数不保证在所有情况下都会产生一个编译期常数（因而也是可以作为普通函数来使用的）。编译器也没法通用地检查这点。编译器唯一强制的是：</p><ul>\n<li><code>constexpr</code> 变量必须立即初始化</li>\n<li>初始化只能使用字面量或常量表达式，后者不允许调用任何非 <code>constexpr</code> 函数</li>\n</ul><p><code>constexpr</code> 的实际规则当然稍微更复杂些，而且随着 C++ 标准的演进也有着一些变化，特别是对 <code>constexpr</code> 函数如何实现的要求在慢慢放宽。要了解具体情况包括其在不同 C++ 标准中的限制，可以查看参考资料 <span class=\"orange\">[1]</span>。下面我们也会回到这个问题略作展开。</p><p>拿 <code>constexpr</code> 来改造开头的例子，下面的代码就完全可以工作了：</p><pre><code class=\"language-c++\">#include &lt;array&gt;\n\nconstexpr int sqr(int n)\n{\n  return n * n;\n}\n\nint main()\n{\n  constexpr int n = sqr(3);\n  std::array&lt;int, n&gt; a;\n  int b[n];\n}\n</code></pre><p>要检验一个 <code>constexpr</code> 函数能不能产生一个真正的编译期常量，可以把结果赋给一个 <code>constexpr</code> 变量。成功的话，我们就确认了，至少在这种调用情况下，我们能真正得到一个编译期常量。</p><h2>constexpr 和编译期计算</h2><p>上面这些当然有点用。但如果只有这点用的话，就不值得我专门来写一讲了。更强大的地方在于，使用编译期常量，就跟我们之前的那些类模板里的 <code>static const int</code> 变量一样，是可以进行编译期计算的。</p><p>以<a href=\"https://time.geekbang.org/column/article/181608\">[第 13 讲]</a> 提到的阶乘函数为例，和那个版本基本等价的写法是：</p><pre><code class=\"language-c++\">constexpr int factorial(int n)\n{\n  if (n == 0) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}\n</code></pre><p>然后，我们用下面的代码可以验证我们确实得到了一个编译期常量：</p><pre><code class=\"language-c++\">int main()\n{\n  constexpr int n = factorial(10);\n  printf(\"%d\\n\", n);\n}\n</code></pre><p>编译可以通过，同时，如果我们看产生的汇编代码的话，一样可以直接看到常量 3628800。</p><p>这里有一个问题：在这个 <code>constexpr</code> 函数里，是不能写 <code>static_assert(n &gt;= 0)</code> 的。一个 <code>constexpr</code> 函数仍然可以作为普通函数使用——显然，传入一个普通 <code>int</code> 是不能使用静态断言的。替换方法是在 <code>factorial</code> 的实现开头加入：</p><pre><code class=\"language-c++\">  if (n &lt; 0) {\n    throw std::invalid_argument(\n      \"Arg must be non-negative\");\n  }\n</code></pre><p>如果你在 <code>main</code> 里写 <code>constexpr int n = factorial(-1);</code> 的话，就会看到编译器报告抛出异常导致无法得到一个常量表达式。建议你自己尝试一下。</p><h2>constexpr 和 const</h2><p>初学 <code>constexpr</code> 时，一个很可能有的困惑是，它跟 <code>const</code> 用法上的区别到底是什么。产生这种困惑是正常的，毕竟 <code>const</code> 是个重载了很多不同含义的关键字。</p><p><code>const</code> 的原本和基础的含义，自然是表示它修饰的内容不会变化，如：</p><pre><code class=\"language-c++\">const int n = 1:\nn = 2;  // 出错！\n</code></pre><p>注意 <code>const</code> 在类型声明的不同位置会产生不同的结果。对于常见的 <code>const char*</code> 这样的类型声明，意义和 <code>char const*</code> 相同，是指向常字符的指针，指针指向的内容不可更改；但和 <code>char * const</code> 不同，那代表指向字符的常指针，指针本身不可更改。本质上，<code>const</code> 用来表示一个<strong>运行时常量</strong>。</p><p>在 C++ 里，<code>const</code> 后面渐渐带上了现在的 <code>constexpr</code> 用法，也代表<strong>编译期常数</strong>。现在——在有了 <code>constexpr</code> 之后——我们应该使用 <code>constexpr</code> 在这些用法中替换 <code>const</code> 了。从编译器的角度，为了向后兼容性，<code>const</code> 和 <code>constexpr</code> 在很多情况下还是等价的。但有时候，它们也有些细微的区别，其中之一为是否内联的问题。</p><h3>内联变量</h3><p>C++17 引入了内联（inline）变量的概念，允许在头文件中定义内联变量，然后像内联函数一样，只要所有的定义都相同，那变量的定义出现多次也没有关系。对于类的静态数据成员，<code>const</code> 缺省是不内联的，而 <code>constexpr</code> 缺省就是内联的。这种区别在你用 <code>&amp;</code> 去取一个 <code>const int</code> 值的地址、或将其传到一个形参类型为 <code>const int&amp;</code> 的函数去的时候（这在 C++ 文档里的行话叫 ODR-use），就会体现出来。</p><p>下面是个合法的完整程序：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n\nstruct magic {\n  static const int number = 42;\n};\n\nint main()\n{\n  std::cout &lt;&lt; magic::number\n            &lt;&lt; std::endl;\n}\n</code></pre><p>我们稍微改一点：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstruct magic {\n  static const int number = 42;\n};\n\nint main()\n{\n  std::vector&lt;int&gt; v;\n  // 调用 push_back(const T&amp;)\n  v.push_back(magic::number);\n  std::cout &lt;&lt; v[0] &lt;&lt; std::endl;\n}\n</code></pre><p>程序在链接时就会报错了，说找不到 <code>magic::number</code>（注意：MSVC 缺省不报错，但使用标准模式——<code>/Za</code> 命令行选项——也会出现这个问题）。这是因为 ODR-use 的类静态常量也需要有一个定义，在没有内联变量之前需要在某一个源代码文件（非头文件）中这样写：</p><pre><code class=\"language-c++\">const int magic::number;\n</code></pre><p>必须正正好好一个，多了少了都不行，所以叫 one definition rule。内联函数，现在又有了内联变量，以及模板，则不受这条规则限制。</p><p>修正这个问题的简单方法是把 <code>magic</code> 里的 <code>static const</code> 改成 <code>static constexpr</code> 或 <code>static inline const</code>。前者可行的原因是，类的静态 constexpr 成员变量默认就是内联的。const 常量和类外面的 constexpr 变量不默认内联，需要手工加 <code>inline</code> 关键字才会变成内联。</p><h3>constexpr 变量模板</h3><p>变量模板是 C++14 引入的新概念。之前我们需要用类静态数据成员来表达的东西，使用变量模板可以更简洁地表达。<code>constexpr</code> 很合适用在变量模板里，表达一个和某个类型相关的编译期常量。由此，type traits 都获得了一种更简单的表示方式。再看一下我们在<a href=\"https://time.geekbang.org/column/article/181608\">[第 13 讲]</a> 用过的例子：</p><pre><code class=\"language-c++\">template &lt;class T&gt;\ninline constexpr bool\n  is_trivially_destructible_v =\n    is_trivially_destructible&lt;\n      T&gt;::value;\n</code></pre><p>了解了变量也可以是模板之后，上面这个代码就很容易看懂了吧？这只是一个小小的语法糖，允许我们把 <code>is_trivially_destructible&lt;T&gt;::value</code> 写成 <code>is_trivially_destructible_v&lt;T&gt;</code>。</p><h3>constexpr 变量仍是 const</h3><p>一个 <code>constexpr</code> 变量仍然是 const 常类型。需要注意的是，就像 <code>const char*</code> 类型是指向常量的指针、自身不是 const 常量一样，下面这个表达式里的 <code>const</code> 也是不能缺少的：</p><pre><code class=\"language-c++\">constexpr int a = 42;\nconstexpr const int&amp; b = a;\n</code></pre><p>第二行里，<code>constexpr</code> 表示 <code>b</code> 是一个编译期常量，<code>const</code> 表示这个引用是常量引用。去掉这个 <code>const</code> 的话，编译器就会认为你是试图将一个普通引用绑定到一个常数上，报一个类似下面的错误信息：</p><blockquote>\n<p><strong>error:</strong> binding reference of type ‘<strong>int&amp;</strong>’ to ‘<strong>const int</strong>’ discards qualifiers</p>\n</blockquote><p>如果按照 const 位置的规则，<code>constexpr const int&amp; b</code> 实际该写成 <code>const int&amp; constexpr b</code>。不过，<code>constexpr</code> 不需要像 <code>const</code> 一样有复杂的组合，因此永远是写在类型前面的。</p><h2>constexpr 构造函数和字面类型</h2><p>一个合理的 <code>constexpr</code> 函数，应当至少对于某一组编译期常量的输入，能得到编译期常量的结果。为此，对这个函数也是有些限制的：</p><ul>\n<li>最早，<code>constexpr</code> 函数里连循环都不能有，但在 C++14 放开了。</li>\n<li>目前，<code>constexpr</code> 函数仍不能有 <code>try … catch</code> 语句和 <code>asm</code> 声明，但到 C++20 会放开。</li>\n<li><code>constexpr</code> 函数里不能使用 <code>goto</code> 语句。</li>\n<li>等等。</li>\n</ul><p>一个有意思的情况是一个类的构造函数。如果一个类的构造函数里面只包含常量表达式、满足对 <code>constexpr</code> 函数的限制的话（这也意味着，里面不可以有任何动态内存分配），并且类的析构函数是平凡的，那这个类就可以被称为是一个字面类型。换一个角度想，对 <code>constexpr</code> 函数——包括字面类型构造函数——的要求是，得让编译器能在编译期进行计算，而不会产生任何“副作用”，比如内存分配、输入、输出等等。</p><p>为了全面支持编译期计算，C++14 开始，很多标准类的构造函数和成员函数已经被标为 <code>constexpr</code>，以便在编译期使用。当然，大部分的容器类，因为用到了动态内存分配，不能成为字面类型。下面这些不使用动态内存分配的字面类型则可以在常量表达式中使用：</p><ul>\n<li><code>array</code></li>\n<li><code>initializer_list</code></li>\n<li><code>pair</code></li>\n<li><code>tuple</code></li>\n<li><code>string_view</code></li>\n<li><code>optional</code></li>\n<li><code>variant</code></li>\n<li><code>bitset</code></li>\n<li><code>complex</code></li>\n<li><code>chrono::duration</code></li>\n<li><code>chrono::time_point</code></li>\n<li>…</li>\n</ul><p>下面这个玩具例子，可以展示上面的若干类及其成员函数的行为：</p><pre><code class=\"language-c++\">#include &lt;array&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;string_view&gt;\n\nusing namespace std;\n\nint main()\n{\n  constexpr string_view sv{\"hi\"};\n  constexpr pair pr{sv[0], sv[1]};\n  constexpr array a{pr.first, pr.second};\n  constexpr int n1 = a[0];\n  constexpr int n2 = a[1];\n  cout &lt;&lt; n1 &lt;&lt; ' ' &lt;&lt; n2 &lt;&lt; '\\n';\n}\n</code></pre><p>编译器可以在编译期即决定 <code>n1</code> 和 <code>n2</code> 的数值；从最后结果的角度，上面程序就是输出了两个整数而已。</p><h2>if constexpr</h2><p>上一讲的结尾，我们给出了一个在类型参数 <code>C</code> 没有 <code>reserve</code> 成员函数时不能编译的代码：</p><pre><code class=\"language-c++\">template &lt;typename C, typename T&gt;\nvoid append(C&amp; container, T* ptr,\n            size_t size)\n{\n  if (has_reserve&lt;C&gt;::value) {\n    container.reserve(\n      container.size() + size);\n  }\n  for (size_t i = 0; i &lt; size;\n       ++i) {\n    container.push_back(ptr[i]);\n  }\n}\n</code></pre><p>在 C++17 里，我们只要在 <code>if</code> 后面加上 <code>constexpr</code>，代码就能工作了 <span class=\"orange\">[2]</span>。当然，它要求括号里的条件是个编译期常量。满足这个条件后，标签分发、<code>enable_if</code> 那些技巧就不那么有用了。显然，使用 <code>if constexpr</code> 能比使用其他那些方式，写出更可读的代码……</p><h2>output_container.h 解读</h2><p>到了今天，我们终于把 output_container.h（<span class=\"orange\">[3]</span>）用到的 C++ 语法特性都讲过了，我们就拿里面的代码来讲解一下，让你加深对这些特性的理解。</p><pre><code class=\"language-c++\">// Type trait to detect std::pair\ntemplate &lt;typename T&gt;\nstruct is_pair : std::false_type {};\ntemplate &lt;typename T, typename U&gt;\nstruct is_pair&lt;std::pair&lt;T, U&gt;&gt;\n  : std::true_type {};\ntemplate &lt;typename T&gt;\ninline constexpr bool is_pair_v =\n  is_pair&lt;T&gt;::value;\n</code></pre><p>这段代码利用模板特化（<a href=\"https://time.geekbang.org/column/article/179363\">[第 12 讲]</a> 、<a href=\"https://time.geekbang.org/column/article/181636\">[第 14 讲]</a>）和 <code>false_type</code>、<code>true_type</code> 类型（<a href=\"https://time.geekbang.org/column/article/181608\">[第 13 讲]</a>），定义了 <code>is_pair</code>，用来检测一个类型是不是 <code>pair</code>。随后，我们定义了内联 <code>constexpr</code> 变量（本讲）<code>is_pair_v</code>，用来简化表达。</p><pre><code class=\"language-c++\">// Type trait to detect whether an\n// output function already exists\ntemplate &lt;typename T&gt;\nstruct has_output_function {\n  template &lt;class U&gt;\n  static auto output(U* ptr)\n    -&gt; decltype(\n      std::declval&lt;std::ostream&amp;&gt;()\n        &lt;&lt; *ptr,\n      std::true_type());\n  template &lt;class U&gt;\n  static std::false_type\n  output(...);\n  static constexpr bool value =\n    decltype(\n      output&lt;T&gt;(nullptr))::value;\n};\ntemplate &lt;typename T&gt;\ninline constexpr bool\n  has_output_function_v =\n    has_output_function&lt;T&gt;::value;\n</code></pre><p>这段代码使用 SFINAE 技巧（<a href=\"https://time.geekbang.org/column/article/181636\">[第 14 讲]</a>），来检测模板参数 <code>T</code> 的对象是否已经可以直接输出到 <code>ostream</code>。然后，一样用一个内联 <code>constexpr</code> 变量来简化表达。</p><pre><code class=\"language-c++\">// Output function for std::pair\ntemplate &lt;typename T, typename U&gt;\nstd::ostream&amp; operator&lt;&lt;(\n  std::ostream&amp; os,\n  const std::pair&lt;T, U&gt;&amp; pr);\n</code></pre><p>再然后我们声明了一个 <code>pair</code> 的输出函数（标准库没有提供这个功能）。我们这儿只是声明，是因为我们这儿有两个输出函数，且可能互相调用。所以，我们要先声明其中之一。</p><p>下面会看到，<code>pair</code> 的通用输出形式是“(x, y)”。</p><pre><code class=\"language-c++\">// Element output function for\n// containers that define a key_type\n// and have its value type as\n// std::pair\ntemplate &lt;typename T, typename Cont&gt;\nauto output_element(\n  std::ostream&amp; os,\n  const T&amp; element, const Cont&amp;,\n  const std::true_type)\n  -&gt; decltype(\n    std::declval&lt;\n      typename Cont::key_type&gt;(),\n    os);\n// Element output function for other\n// containers\ntemplate &lt;typename T, typename Cont&gt;\nauto output_element(\n  std::ostream&amp; os,\n  const T&amp; element, const Cont&amp;,\n  ...) -&gt; decltype(os);\n</code></pre><p>对于容器成员的输出，我们也声明了两个不同的重载。我们的意图是，如果元素的类型是 <code>pair</code> 并且容器定义了一个 <code>key_type</code> 类型，我们就认为遇到了关联容器，输出形式为“x =&gt; y”（而不是“(x, y)”）。</p><pre><code class=\"language-c++\">// Main output function, enabled\n// only if no output function\n// already exists\ntemplate &lt;\n  typename T,\n  typename = std::enable_if_t&lt;\n    !has_output_function_v&lt;T&gt;&gt;&gt;\nauto operator&lt;&lt;(std::ostream&amp; os,\n                const T&amp; container)\n  -&gt; decltype(container.begin(),\n              container.end(), os)\n…\n</code></pre><p>主输出函数的定义。注意这儿这个函数的启用有两个不同的 SFINAE 条件：</p><ul>\n<li>用 <code>decltype</code> 返回值的方式规定了被输出的类型必须有 <code>begin()</code> 和 <code>end()</code> 成员函数。</li>\n<li>用 <code>enable_if_t</code> 规定了只在被输出的类型没有输出函数时才启用这个输出函数。否则，对于 <code>string</code> 这样的类型，编译器发现有两个可用的输出函数，就会导致编译出错。</li>\n</ul><p>我们可以看到，用 <code>decltype</code> 返回值的方式比较简单，不需要定义额外的模板。但表达否定的条件还是要靠 <code>enable_if</code>。此外，因为此处是需要避免有二义性的重载，constexpr 条件语句帮不了什么忙。</p><pre><code class=\"language-c++\">  using element_type =\n    decay_t&lt;decltype(\n      *container.begin())&gt;;\n  constexpr bool is_char_v =\n    is_same_v&lt;element_type, char&gt;;\n  if constexpr (!is_char_v) {\n    os &lt;&lt; \"{ \";\n  }\n</code></pre><p>对非字符类型，我们在开始输出时，先输出“{ ”。这儿使用了 <code>decay_t</code>，是为了把类型里的引用和 const/volatile 修饰去掉，只剩下值类型。如果容器里的成员是 <code>char</code>，这儿会把 <code>char&amp;</code> 和 <code>const char&amp;</code> 还原成 <code>char</code>。</p><p>后面的代码就比较简单了。可能唯一需要留意的是下面这句：</p><pre><code class=\"language-c++\">  output_element(\n    os, *it, container,\n    is_pair&lt;element_type&gt;());\n</code></pre><p>这儿我们使用了标签分发技巧来输出容器里的元素。要记得，<code>output_element</code> 不纯粹使用标签分发，还会检查容器是否有 <code>key_type</code> 成员类型。</p><pre><code class=\"language-c++\">template &lt;typename T, typename Cont&gt;\nauto output_element(\n  std::ostream&amp; os,\n  const T&amp; element, const Cont&amp;,\n  const std::true_type)\n  -&gt; decltype(\n    std::declval&lt;\n      typename Cont::key_type&gt;(),\n    os)\n{\n  os &lt;&lt; element.first &lt;&lt; \" =&gt; \"\n     &lt;&lt; element.second;\n  return os;\n}\n\ntemplate &lt;typename T, typename Cont&gt;\nauto output_element(\n  std::ostream&amp; os,\n  const T&amp; element, const Cont&amp;,\n  ...) -&gt; decltype(os)\n{\n  os &lt;&lt; element;\n  return os;\n}\n</code></pre><p><code>output_element</code> 的两个重载的实现都非常简单，应该不需要解释了。</p><pre><code class=\"language-c++\">template &lt;typename T, typename U&gt;\nstd::ostream&amp; operator&lt;&lt;(\n  std::ostream&amp; os,\n  const std::pair&lt;T, U&gt;&amp; pr)\n{\n  os &lt;&lt; '(' &lt;&lt; pr.first &lt;&lt; \", \"\n     &lt;&lt; pr.second &lt;&lt; ')';\n  return os;\n}\n</code></pre><p>同样，<code>pair</code> 的输出的实现也非常简单。</p><p>唯一需要留意的，是上面三个函数的输出内容可能还是容器，因此我们要将其实现放在后面，确保它能看到我们的通用输出函数。</p><p>要看一下用到 output_container 的例子，可以回顾<a href=\"https://time.geekbang.org/column/article/173167\">[第 4 讲]</a> 和<a href=\"https://time.geekbang.org/column/article/174434\">[第 5 讲]</a>。</p><h2>内容小结</h2><p>本讲我们介绍了编译期常量表达式和编译期条件语句，可以看到，这两种新特性对编译期编程有了很大的改进，可以让代码变得更直观。最后我们讨论了我们之前用到的容器输出函数 output_container 的实现，里面用到了多种我们目前讨论过的编译期编程技巧。</p><h2>课后思考</h2><p>请你仔细想一想：</p><ol>\n<li>如果没有 constexpr 条件语句，这个容器输出函数需要怎样写？</li>\n<li>这种不使用 constexpr 的写法有什么样的缺点？推而广之，constexpr 条件语句的意义是什么？</li>\n</ol><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] cppreference.com, “constexpr specifier”. <a href=\"https://en.cppreference.com/w/cpp/language/constexpr\">https://en.cppreference.com/w/cpp/language/constexpr</a> </span></p><p><span class=\"reference\">[1a] cppreference.com, “constexpr 说明符”. <a href=\"https://zh.cppreference.com/w/cpp/language/constexpr\">https://zh.cppreference.com/w/cpp/language/constexpr</a> </span></p><p><span class=\"reference\">[2] cppreference.com, “if statement”, section “constexpr if”. <a href=\"https://en.cppreference.com/w/cpp/language/if\">https://en.cppreference.com/w/cpp/language/if</a> </span></p><p><span class=\"reference\">[2a] cppreference.com, “if 语句”, “constexpr if” 部分. <a href=\"https://zh.cppreference.com/w/cpp/language/if\">https://zh.cppreference.com/w/cpp/language/if</a> </span></p><p><span class=\"reference\">[3] 吴咏炜, output_container. <a href=\"https://github.com/adah1972/output_container/blob/geektime/output_container.h\">https://github.com/adah1972/output_container/blob/geektime/output_container.h</a> </span></p>","comments":[{"had_liked":false,"id":167096,"user_name":"李亮亮","can_delete":false,"product_type":"c1","uid":1116508,"ip_address":"","ucode":"290907F930B261","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","comment_is_top":false,"comment_ctime":1577690942,"is_pvip":false,"replies":[{"id":64983,"content":"很少需要自己写的。就像学了微积分大部分人也没机会用一样😂。但一点都看不懂也是会很有问题的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577791811,"ip_address":"","comment_id":167096,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"我觉得我学习这个专栏只是为了能看懂这些新特性，写是写不出来，规则太多太复杂了。","like_count":12},{"had_liked":false,"id":175658,"user_name":"czh","can_delete":false,"product_type":"c1","uid":1159078,"ip_address":"","ucode":"649FE5C9269D69","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/a6/3f15ba2f.jpg","comment_is_top":false,"comment_ctime":1580791875,"is_pvip":false,"replies":[{"id":68270,"content":"对。一般的 if 是运行期条件语句；if constexpr 是编译期条件语句。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580792802,"ip_address":"","comment_id":175658,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师好，有个小疑问，文中提到：\n\n“上一讲的结尾，我们给出了一个在类型参数 C 没有 reserve 成员函数时不能编译的代码：”\n\n\n这里提到使用 if constexpr，可以解决上述问题。这里没有过多的解释，我理解是：使用if constexpr之后，如果没有reserve成员，那就会在编译期跳过这个if中的内容，因此不会检查container.reserve()。\n\n不知道理解是否正确？","like_count":10,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479743,"discussion_content":"很少需要自己写的。就像学了微积分大部分人也没机会用一样😂。但一点都看不懂也是会很有问题的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577791811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282389,"user_name":"geek","can_delete":false,"product_type":"c1","uid":2401422,"ip_address":"","ucode":"FF0845140D72A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","comment_is_top":false,"comment_ctime":1615211943,"is_pvip":false,"replies":[{"id":102610,"content":"嗯。再补充一个，如果你有n个不同的静态条件，你需要分发的函数数量是 2^n。🤓","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1615372637,"ip_address":"","comment_id":282389,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"试着回答一下两个思考问题：\n1 我认为不用consexpr,就要用enable_if，类似于上一节的append方法那样，在有两种可能情况时，要写两个方法，做标签分发。这种方式的一个推广就是：有多少种可能，就要写多少个对应的分发方法。\n2 不用constexpr的缺点，就是代码冗余而且不易读。那么用constexpr的优点就是代码无冗余，易读。","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482846,"discussion_content":"对。一般的 if 是运行期条件语句；if constexpr 是编译期条件语句。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580792802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3542569,"avatar":"https://static001.geekbang.org/account/avatar/00/36/0e/29/fa3601d3.jpg","nickname":"🐶的巴普洛夫","note":"","ucode":"1213DD5A056674","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609054,"discussion_content":"czh同学报一下学号，给你加平时分儿","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678798980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167123,"user_name":"Jerry Tan","can_delete":false,"product_type":"c1","uid":1625510,"ip_address":"","ucode":"FA93EAAF5926F2","user_header":"https://static001.geekbang.org/account/avatar/00/18/cd/a6/96cee976.jpg","comment_is_top":false,"comment_ctime":1577695975,"is_pvip":false,"replies":[{"id":64991,"content":"第 21 讲会讨论一点工具。不过你指的是什么工具呢？……如果你用 Windows，就从 Visual Studio 的免费 Community 版开始吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577800829,"ip_address":"","comment_id":167123,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"您好老师, 请问想学C++ 您有什么比较好的推荐的开发工具吗  谢谢 ","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516729,"discussion_content":"嗯。再补充一个，如果你有n个不同的静态条件，你需要分发的函数数量是 2^n。🤓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615372637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2401422,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","nickname":"geek","note":"","ucode":"FF0845140D72A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358497,"discussion_content":"奥，不同条件的组合会导致对应分发函数数量爆炸性增长","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615989852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334906,"user_name":"Slience-0°C","can_delete":false,"product_type":"c1","uid":1151612,"ip_address":"","ucode":"B50665EC6A80F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/92/7c/12c571b6.jpg","comment_is_top":false,"comment_ctime":1645176364,"is_pvip":false,"replies":[{"id":122433,"content":"对，这是很重要的一个概念。能编译期确定的东西才能做编译期计算。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1645419594,"ip_address":"","comment_id":334906,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"常量区分编译期？和运行期？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479752,"discussion_content":"第 21 讲会讨论一点工具。不过你指的是什么工具呢？……如果你用 Windows，就从 Visual Studio 的免费 Community 版开始吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577800829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625510,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cd/a6/96cee976.jpg","nickname":"Jerry Tan","note":"","ucode":"FA93EAAF5926F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":117215,"discussion_content":"👌","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578102923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625510,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cd/a6/96cee976.jpg","nickname":"Jerry Tan","note":"","ucode":"FA93EAAF5926F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":111595,"discussion_content":"呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577801154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625510,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cd/a6/96cee976.jpg","nickname":"Jerry Tan","note":"","ucode":"FA93EAAF5926F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":111594,"discussion_content":"我用的是macpro","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577801149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1625510,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cd/a6/96cee976.jpg","nickname":"Jerry Tan","note":"","ucode":"FA93EAAF5926F2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":111795,"discussion_content":"Xcode 和 CLion 试试啰。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577805126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":111594,"ip_address":"","group_id":0},"score":111795,"extra":""}]}]},{"had_liked":false,"id":334904,"user_name":"Slience-0°C","can_delete":false,"product_type":"c1","uid":1151612,"ip_address":"","ucode":"B50665EC6A80F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/92/7c/12c571b6.jpg","comment_is_top":false,"comment_ctime":1645176259,"is_pvip":false,"replies":[{"id":122434,"content":"像你这种用法可以考虑用 std::string_view。\n\n可参考我这个知乎回答：\n\nhttps:&#47;&#47;www.zhihu.com&#47;question&#47;483774144&#47;answer&#47;2251359893","user_name":"作者回复","user_name_real":"作者","uid":1645639,"ctime":1645419724,"ip_address":"","comment_id":334904,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师好，现代C++如何优雅的定义字符串常量？直接使用const std::string var = &quot;xxxx &quot;有些静态代码检查工具会提示可能会抛出无法捕获的异常！","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552337,"discussion_content":"对，这是很重要的一个概念。能编译期确定的东西才能做编译期计算。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645419594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290232,"user_name":"心态正常","can_delete":false,"product_type":"c1","uid":1688282,"ip_address":"","ucode":"02E2E67A787471","user_header":"https://static001.geekbang.org/account/avatar/00/19/c2/da/5818c896.jpg","comment_is_top":false,"comment_ctime":1619442754,"is_pvip":false,"replies":[{"id":105217,"content":"是可以过的。只有第三个例子，模板参数，才会要求特别严。\n\n不是考大家知道哪些行哪些不行。正如下面写的：“这些问题的答案不直观。”","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1619491381,"ip_address":"","comment_id":290232,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，您好，有个问题想请教一下，文章开头的两个示例我在centos8上使用g++ 8.3.1的编译器编译通过了，因为没有用到constexpr的特性，预期在int a[n]这一行会报错，但是实际上并没有给出错误，这是编译器做了优化处理吗？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552339,"discussion_content":"像你这种用法可以考虑用 std::string_view。\n\n可参考我这个知乎回答：\n\nhttps://www.zhihu.com/question/483774144/answer/2251359893","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645419724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273512,"user_name":"清水","can_delete":false,"product_type":"c1","uid":1569835,"ip_address":"","ucode":"41A8900039093A","user_header":"https://static001.geekbang.org/account/avatar/00/17/f4/2b/f74346da.jpg","comment_is_top":false,"comment_ctime":1610617992,"is_pvip":false,"replies":[{"id":99509,"content":"编译器太老，升级到至少支持C++14的编译器，比如GCC 7。\n\nGCC 6也许也可以，但我没有环境。毕竟，现在GCC已经发布10.2了。这门课程期望你用GCC 7以上的编译器。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1610885756,"ip_address":"","comment_id":273512,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，你好，请教个问题\n\nconstexpr int factorial(int n)\n{\n  if (n == 0) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}\n如果constexpr 修饰函数 这样是编译不过的，提示not a return-statement (至少c++11不行)\n没有尝试过是否其他编译器 多行编译 通过\n如果修改为一行表达式是没问题的，那么这是constexpr关键字 用法要求还是其他原因导致？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519142,"discussion_content":"是可以过的。只有第三个例子，模板参数，才会要求特别严。\n\n不是考大家知道哪些行哪些不行。正如下面写的：“这些问题的答案不直观。”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619491381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245006,"user_name":"talor","can_delete":false,"product_type":"c1","uid":1350638,"ip_address":"","ucode":"245EE908DA39EC","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/ee/211e86cd.jpg","comment_is_top":false,"comment_ctime":1598780049,"is_pvip":false,"replies":[{"id":90197,"content":"我大概知道你的问题了。这两句是不能放在函数体里的。constexpr 引用只能绑定到全局变量上。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1598888086,"ip_address":"","comment_id":245006,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"您好，\nconstexpr int a = 42;\nconstexpr const int&amp; b = a;\n这个例子编译不过，编译器是gcc 10.2.1","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513618,"discussion_content":"编译器太老，升级到至少支持C++14的编译器，比如GCC 7。\n\nGCC 6也许也可以，但我没有环境。毕竟，现在GCC已经发布10.2了。这门课程期望你用GCC 7以上的编译器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610885756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201268,"user_name":"g_boshu","can_delete":false,"product_type":"c1","uid":1901994,"ip_address":"","ucode":"56F59C972CE7BD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIQz0Micjv7w7z4vFcXvLSSzI3dVZLBDG83zfDWhMiaQqtkHzIWWSL276GqHGBRKWrR3xP5JjmhPpnA/132","comment_is_top":false,"comment_ctime":1585742293,"is_pvip":false,"replies":[{"id":75264,"content":"是偏特化。没有规定说偏特化一定参数更少啊。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585749351,"ip_address":"","comment_id":201268,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师您好，我对以下代码有点儿疑惑：\n\n&#47;&#47; Type trait to detect std::pair\ntemplate &lt;typename T&gt;\nstruct is_pair : std::false_type {};\ntemplate &lt;typename T, typename U&gt;\nstruct is_pair&lt;std::pair&lt;T, U&gt;&gt;\n  : std::true_type {};\ntemplate &lt;typename T&gt;\ninline constexpr bool is_pair_v =\n  is_pair&lt;T&gt;::value;\n\ntemplate &lt;typename T, typename U&gt;\nstruct is_pair&lt;std::pair&lt;T, U&gt;&gt;: std::true_type {}; 看着应该是一个偏特化，模板的参数却变多了，一般偏特化不应该是参数变少吗？谢谢","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504767,"discussion_content":"我大概知道你的问题了。这两句是不能放在函数体里的。constexpr 引用只能绑定到全局变量上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598888086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167096,"user_name":"李亮亮","can_delete":false,"product_type":"c1","uid":1116508,"ip_address":"","ucode":"290907F930B261","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","comment_is_top":false,"comment_ctime":1577690942,"is_pvip":false,"replies":[{"id":64983,"content":"很少需要自己写的。就像学了微积分大部分人也没机会用一样😂。但一点都看不懂也是会很有问题的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577791811,"ip_address":"","comment_id":167096,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"我觉得我学习这个专栏只是为了能看懂这些新特性，写是写不出来，规则太多太复杂了。","like_count":12,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479743,"discussion_content":"很少需要自己写的。就像学了微积分大部分人也没机会用一样😂。但一点都看不懂也是会很有问题的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577791811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175658,"user_name":"czh","can_delete":false,"product_type":"c1","uid":1159078,"ip_address":"","ucode":"649FE5C9269D69","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/a6/3f15ba2f.jpg","comment_is_top":false,"comment_ctime":1580791875,"is_pvip":false,"replies":[{"id":68270,"content":"对。一般的 if 是运行期条件语句；if constexpr 是编译期条件语句。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580792802,"ip_address":"","comment_id":175658,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师好，有个小疑问，文中提到：\n\n“上一讲的结尾，我们给出了一个在类型参数 C 没有 reserve 成员函数时不能编译的代码：”\n\n\n这里提到使用 if constexpr，可以解决上述问题。这里没有过多的解释，我理解是：使用if constexpr之后，如果没有reserve成员，那就会在编译期跳过这个if中的内容，因此不会检查container.reserve()。\n\n不知道理解是否正确？","like_count":10,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482846,"discussion_content":"对。一般的 if 是运行期条件语句；if constexpr 是编译期条件语句。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580792802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3542569,"avatar":"https://static001.geekbang.org/account/avatar/00/36/0e/29/fa3601d3.jpg","nickname":"🐶的巴普洛夫","note":"","ucode":"1213DD5A056674","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609054,"discussion_content":"czh同学报一下学号，给你加平时分儿","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678798980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282389,"user_name":"geek","can_delete":false,"product_type":"c1","uid":2401422,"ip_address":"","ucode":"FF0845140D72A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","comment_is_top":false,"comment_ctime":1615211943,"is_pvip":false,"replies":[{"id":102610,"content":"嗯。再补充一个，如果你有n个不同的静态条件，你需要分发的函数数量是 2^n。🤓","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1615372637,"ip_address":"","comment_id":282389,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"试着回答一下两个思考问题：\n1 我认为不用consexpr,就要用enable_if，类似于上一节的append方法那样，在有两种可能情况时，要写两个方法，做标签分发。这种方式的一个推广就是：有多少种可能，就要写多少个对应的分发方法。\n2 不用constexpr的缺点，就是代码冗余而且不易读。那么用constexpr的优点就是代码无冗余，易读。","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516729,"discussion_content":"嗯。再补充一个，如果你有n个不同的静态条件，你需要分发的函数数量是 2^n。🤓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615372637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2401422,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","nickname":"geek","note":"","ucode":"FF0845140D72A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358497,"discussion_content":"奥，不同条件的组合会导致对应分发函数数量爆炸性增长","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615989852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167123,"user_name":"Jerry Tan","can_delete":false,"product_type":"c1","uid":1625510,"ip_address":"","ucode":"FA93EAAF5926F2","user_header":"https://static001.geekbang.org/account/avatar/00/18/cd/a6/96cee976.jpg","comment_is_top":false,"comment_ctime":1577695975,"is_pvip":false,"replies":[{"id":64991,"content":"第 21 讲会讨论一点工具。不过你指的是什么工具呢？……如果你用 Windows，就从 Visual Studio 的免费 Community 版开始吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577800829,"ip_address":"","comment_id":167123,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"您好老师, 请问想学C++ 您有什么比较好的推荐的开发工具吗  谢谢 ","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479752,"discussion_content":"第 21 讲会讨论一点工具。不过你指的是什么工具呢？……如果你用 Windows，就从 Visual Studio 的免费 Community 版开始吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577800829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625510,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cd/a6/96cee976.jpg","nickname":"Jerry Tan","note":"","ucode":"FA93EAAF5926F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":117215,"discussion_content":"👌","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578102923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625510,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cd/a6/96cee976.jpg","nickname":"Jerry Tan","note":"","ucode":"FA93EAAF5926F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":111595,"discussion_content":"呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577801154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625510,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cd/a6/96cee976.jpg","nickname":"Jerry Tan","note":"","ucode":"FA93EAAF5926F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":111594,"discussion_content":"我用的是macpro","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577801149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1625510,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cd/a6/96cee976.jpg","nickname":"Jerry Tan","note":"","ucode":"FA93EAAF5926F2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":111795,"discussion_content":"Xcode 和 CLion 试试啰。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577805126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":111594,"ip_address":"","group_id":0},"score":111795,"extra":""}]}]},{"had_liked":false,"id":334906,"user_name":"Slience-0°C","can_delete":false,"product_type":"c1","uid":1151612,"ip_address":"","ucode":"B50665EC6A80F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/92/7c/12c571b6.jpg","comment_is_top":false,"comment_ctime":1645176364,"is_pvip":false,"replies":[{"id":122433,"content":"对，这是很重要的一个概念。能编译期确定的东西才能做编译期计算。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1645419594,"ip_address":"","comment_id":334906,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"常量区分编译期？和运行期？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552337,"discussion_content":"对，这是很重要的一个概念。能编译期确定的东西才能做编译期计算。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645419594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334904,"user_name":"Slience-0°C","can_delete":false,"product_type":"c1","uid":1151612,"ip_address":"","ucode":"B50665EC6A80F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/92/7c/12c571b6.jpg","comment_is_top":false,"comment_ctime":1645176259,"is_pvip":false,"replies":[{"id":122434,"content":"像你这种用法可以考虑用 std::string_view。\n\n可参考我这个知乎回答：\n\nhttps:&#47;&#47;www.zhihu.com&#47;question&#47;483774144&#47;answer&#47;2251359893","user_name":"作者回复","user_name_real":"作者","uid":1645639,"ctime":1645419724,"ip_address":"","comment_id":334904,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师好，现代C++如何优雅的定义字符串常量？直接使用const std::string var = &quot;xxxx &quot;有些静态代码检查工具会提示可能会抛出无法捕获的异常！","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552339,"discussion_content":"像你这种用法可以考虑用 std::string_view。\n\n可参考我这个知乎回答：\n\nhttps://www.zhihu.com/question/483774144/answer/2251359893","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645419724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290232,"user_name":"心态正常","can_delete":false,"product_type":"c1","uid":1688282,"ip_address":"","ucode":"02E2E67A787471","user_header":"https://static001.geekbang.org/account/avatar/00/19/c2/da/5818c896.jpg","comment_is_top":false,"comment_ctime":1619442754,"is_pvip":false,"replies":[{"id":105217,"content":"是可以过的。只有第三个例子，模板参数，才会要求特别严。\n\n不是考大家知道哪些行哪些不行。正如下面写的：“这些问题的答案不直观。”","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1619491381,"ip_address":"","comment_id":290232,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，您好，有个问题想请教一下，文章开头的两个示例我在centos8上使用g++ 8.3.1的编译器编译通过了，因为没有用到constexpr的特性，预期在int a[n]这一行会报错，但是实际上并没有给出错误，这是编译器做了优化处理吗？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519142,"discussion_content":"是可以过的。只有第三个例子，模板参数，才会要求特别严。\n\n不是考大家知道哪些行哪些不行。正如下面写的：“这些问题的答案不直观。”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619491381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273512,"user_name":"清水","can_delete":false,"product_type":"c1","uid":1569835,"ip_address":"","ucode":"41A8900039093A","user_header":"https://static001.geekbang.org/account/avatar/00/17/f4/2b/f74346da.jpg","comment_is_top":false,"comment_ctime":1610617992,"is_pvip":false,"replies":[{"id":99509,"content":"编译器太老，升级到至少支持C++14的编译器，比如GCC 7。\n\nGCC 6也许也可以，但我没有环境。毕竟，现在GCC已经发布10.2了。这门课程期望你用GCC 7以上的编译器。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1610885756,"ip_address":"","comment_id":273512,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，你好，请教个问题\n\nconstexpr int factorial(int n)\n{\n  if (n == 0) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}\n如果constexpr 修饰函数 这样是编译不过的，提示not a return-statement (至少c++11不行)\n没有尝试过是否其他编译器 多行编译 通过\n如果修改为一行表达式是没问题的，那么这是constexpr关键字 用法要求还是其他原因导致？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513618,"discussion_content":"编译器太老，升级到至少支持C++14的编译器，比如GCC 7。\n\nGCC 6也许也可以，但我没有环境。毕竟，现在GCC已经发布10.2了。这门课程期望你用GCC 7以上的编译器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610885756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245006,"user_name":"talor","can_delete":false,"product_type":"c1","uid":1350638,"ip_address":"","ucode":"245EE908DA39EC","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/ee/211e86cd.jpg","comment_is_top":false,"comment_ctime":1598780049,"is_pvip":false,"replies":[{"id":90197,"content":"我大概知道你的问题了。这两句是不能放在函数体里的。constexpr 引用只能绑定到全局变量上。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1598888086,"ip_address":"","comment_id":245006,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"您好，\nconstexpr int a = 42;\nconstexpr const int&amp; b = a;\n这个例子编译不过，编译器是gcc 10.2.1","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504767,"discussion_content":"我大概知道你的问题了。这两句是不能放在函数体里的。constexpr 引用只能绑定到全局变量上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598888086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201268,"user_name":"g_boshu","can_delete":false,"product_type":"c1","uid":1901994,"ip_address":"","ucode":"56F59C972CE7BD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIQz0Micjv7w7z4vFcXvLSSzI3dVZLBDG83zfDWhMiaQqtkHzIWWSL276GqHGBRKWrR3xP5JjmhPpnA/132","comment_is_top":false,"comment_ctime":1585742293,"is_pvip":false,"replies":[{"id":75264,"content":"是偏特化。没有规定说偏特化一定参数更少啊。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585749351,"ip_address":"","comment_id":201268,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师您好，我对以下代码有点儿疑惑：\n\n&#47;&#47; Type trait to detect std::pair\ntemplate &lt;typename T&gt;\nstruct is_pair : std::false_type {};\ntemplate &lt;typename T, typename U&gt;\nstruct is_pair&lt;std::pair&lt;T, U&gt;&gt;\n  : std::true_type {};\ntemplate &lt;typename T&gt;\ninline constexpr bool is_pair_v =\n  is_pair&lt;T&gt;::value;\n\ntemplate &lt;typename T, typename U&gt;\nstruct is_pair&lt;std::pair&lt;T, U&gt;&gt;: std::true_type {}; 看着应该是一个偏特化，模板的参数却变多了，一般偏特化不应该是参数变少吗？谢谢","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490282,"discussion_content":"是偏特化。没有规定说偏特化一定参数更少啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585749351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167218,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1577719632,"is_pvip":false,"replies":[{"id":64993,"content":"作为编译期常数，没理由认为一个 constexpr 变量一定会在数据段里的，尤其是优化编译的情况。一般而言，只有非优化编译、又有 ODR-use 才能在 data 段里找到其定义。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577801636,"ip_address":"","comment_id":167218,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"文中一开始用constexpr\n改造的例子，之所以可以，一定是在使用constexpr的地方“就地”调用了赋值运算符右侧的函数，这样才能得到一个编译期的常量，所以，“内联”是constexpr的应有之意。但是在类外，必须加上inline才可以。\n\nconst本质是一个运行时常量，constexpr才是编译期常数，除了内联展开这个含义，再根据文中ODR的表述，说明constexpr变量是切实分配了内存空间的，是一个左值对象。综合上面的考虑，constexpr意味着被声明的对象是存放在数据段里面的。\n\n\nconstexpr 变量模板表达一个和某个类型相关的编译期常量，让变量也可以是模板，这句话在本课中，我觉得理解成“把模板对象用一个变量命名”更合适，即把所有符号都绑定到了一个实体上，这样if constexpr才变得可行。解决了上一讲中说的c++中不能像Python一样写代码的问题。","like_count":1},{"had_liked":false,"id":352329,"user_name":"Chillstep","can_delete":false,"product_type":"c1","uid":3034120,"ip_address":"","ucode":"269FC6C904EC24","user_header":"https://static001.geekbang.org/account/avatar/00/2e/4c/08/96c8318a.jpg","comment_is_top":false,"comment_ctime":1658560809,"is_pvip":false,"replies":[{"id":128178,"content":"👌谢谢抓虫。我回头修正一下。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1658575285,"ip_address":"","comment_id":352329,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师您好，这一段我发现有一些疑问：&quot;这是因为 ODR-use 的类静态常量也需要有一个定义，在没有内联变量之前需要在某一个源代码文件（非头文件）中这样写：const int magic::number = 42;  &quot;这一段我实验了下发现并不能过编译，我认为number已经是const的，应该是没办法在赋值的了，这里应该只需要const int magic::number;即可，这样是可以过编译的。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479785,"discussion_content":"作为编译期常数，没理由认为一个 constexpr 变量一定会在数据段里的，尤其是优化编译的情况。一般而言，只有非优化编译、又有 ODR-use 才能在 data 段里找到其定义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577801636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316820,"user_name":"ano","can_delete":false,"product_type":"c1","uid":1783342,"ip_address":"","ucode":"7DE64BDFA78550","user_header":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","comment_is_top":false,"comment_ctime":1634559066,"is_pvip":false,"replies":[{"id":115161,"content":"没这么简单。有循环也有可能 inline 的。各个编译器的策略并不相同，优化级别也会产生影响。\n\n总体上编译器会对 inline 的效果有自己的评估方式，“值得”inline 才会 inline。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1634909300,"ip_address":"","comment_id":316820,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，我想请教一下。一个 function 标记为 inline, 但如果 function body 中有循环的话，编译器就不会在这个函数的调用处 inline? 编译器是出于什么考虑，不做这个 inline?","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581179,"discussion_content":"👌谢谢抓虫。我回头修正一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658575285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316029,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1634111395,"is_pvip":false,"replies":[{"id":114527,"content":"它继承自 true_type 或 false_type，那里面有。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1634169503,"ip_address":"","comment_id":316029,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"\n&#47;&#47; Type trait to detect std::pair\ntemplate &lt;typename T&gt;\nstruct is_pair : std::false_type {};\ntemplate &lt;typename T, typename U&gt;\nstruct is_pair&lt;std::pair&lt;T, U&gt;&gt;\n  : std::true_type {};\ntemplate &lt;typename T&gt;\ninline constexpr bool is_pair_v =\n  is_pair&lt;T&gt;::value;\n\nis_pair模板并没有定义value成员啊，为什么可以::value？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528520,"discussion_content":"没这么简单。有循环也有可能 inline 的。各个编译器的策略并不相同，优化级别也会产生影响。\n\n总体上编译器会对 inline 的效果有自己的评估方式，“值得”inline 才会 inline。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634909300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242287,"user_name":"yuchen","can_delete":false,"product_type":"c1","uid":1605025,"ip_address":"","ucode":"D4B55B57D218CB","user_header":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","comment_is_top":false,"comment_ctime":1597659938,"is_pvip":false,"replies":[{"id":89436,"content":"特化如果没有把所有的模板参数全部消掉，那就是偏特化了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1597670026,"ip_address":"","comment_id":242287,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"template &lt;typename T&gt;\nstruct is_pair : std::false_type {};\ntemplate &lt;typename T, typename U&gt;\nstruct is_pair&lt;std::pair&lt;T, U&gt;&gt;\n  : std::true_type {};\ntemplate &lt;typename T&gt;\ninline constexpr bool is_pair_v =\n  is_pair&lt;T&gt;::value;\n吴老师好，请问这里template &lt;typename T, typename U&gt;\nstruct is_pair&lt;std::pair&lt;T, U&gt;&gt;是特化还是偏特化呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528242,"discussion_content":"它继承自 true_type 或 false_type，那里面有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634169503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235012,"user_name":"O","can_delete":false,"product_type":"c1","uid":2063412,"ip_address":"","ucode":"AE2F7E50FBD3AA","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7c/34/cd10f00b.jpg","comment_is_top":false,"comment_ctime":1594869312,"is_pvip":false,"replies":[{"id":86841,"content":"就是标准的递归而已，先处理外层，看到内存是vector，继续调用，直到全部输出或遇到无法输出的内容（那就会编译报错）。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1594947939,"ip_address":"","comment_id":235012,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师好，我想问一下，想容器嵌套类似vector&lt;vector&lt;&gt;&gt;之类的，output如何判断","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503972,"discussion_content":"特化如果没有把所有的模板参数全部消掉，那就是偏特化了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597670026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1605025,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","nickname":"yuchen","note":"","ucode":"D4B55B57D218CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299871,"discussion_content":"谢谢吴老师。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597845281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182840,"user_name":"zKerry","can_delete":false,"product_type":"c1","uid":1497740,"ip_address":"","ucode":"9FB006D1A38D3F","user_header":"","comment_is_top":false,"comment_ctime":1582873823,"is_pvip":false,"replies":[{"id":70739,"content":"谢谢指出问题。这是修改中引入的问题。回头就修掉。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582899403,"ip_address":"","comment_id":182840,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"\nint sqr(int n)\n{\n  return n * n;\n}\n\nint main()\n{\n  const int n = sqr(3);\n  int a[n)];\n}\n其中：int a[n)] 没有问题？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501576,"discussion_content":"就是标准的递归而已，先处理外层，看到内存是vector，继续调用，直到全部输出或遇到无法输出的内容（那就会编译报错）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594947939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169984,"user_name":"光城~兴","can_delete":false,"product_type":"c1","uid":1188173,"ip_address":"","ucode":"55A0D25BFCDD47","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/4d/90ea92f8.jpg","comment_is_top":false,"comment_ctime":1578487756,"is_pvip":false,"replies":[{"id":65978,"content":"我并不希望把vector&lt;pair&lt;…&gt;&gt; 输出成“=&gt;”的形式。我要仅在输出map、unordered_map的元素时才使用“=&gt;”。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578496712,"ip_address":"","comment_id":169984,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"对老师的输出函数进行修改：如下\n\ntemplate&lt;typename T, typename Cont&gt;\nauto output_element(std::ostream &amp;os, const T &amp;element,\n                    const Cont &amp;)\n-&gt; typename std::enable_if&lt;is_pair&lt;typename Cont::value_type&gt;::value, bool&gt;::type {\n    os &lt;&lt; element.first &lt;&lt; &quot; =&gt; &quot; &lt;&lt; element.second;\n    return true;\n}\n\ntemplate&lt;typename T, typename Cont&gt;\nauto output_element(std::ostream &amp;os, const T &amp;element,\n                    const Cont &amp;)\n-&gt; typename std::enable_if&lt;!is_pair&lt;typename Cont::value_type&gt;::value, bool&gt;::type {\n    os &lt;&lt; element;\n    return false;\n}\n\n调用处：\noutput_element(os, elem, container);\n\n这个方法学习自老师之前讲过的SFINAE！\n\n另外，针对老师的代码有些疑问：\n老师代码调用处：\noutput_element(os, *it, container, is_pair&lt;element_type&gt;());\n实际上在这里就确定了element_type是不是pair，也就是这里传递进去直接就是true_type或者false_type，针对,map&#47;vector&#47;set等直接就可以区分开来，不需要写：std::declval&lt;typename Cont::key_type&gt;()。\n也是可以正常完成输出的，但是当传递的是true_type且容器没有key_type的时候就是SFINAE问题，调用另一个重载函数。\n问题是，一个容器元素是pair，那么is_pair&lt;element_type&gt;()就是true_type，而既然是pair了，也就有了key_type，所以这个必然成立，也就是写与不写都可以。另外，当不是pair，就是false_type，肯定调false_type的output_element重载咯，所以我得出这里写这个std::declval&lt;typename Cont::key_type&gt;()没有啥子用，并且代码测试过确实可以不写，望老师指点！","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485468,"discussion_content":"谢谢指出问题。这是修改中引入的问题。回头就修掉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582899403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169594,"user_name":"光城~兴","can_delete":false,"product_type":"c1","uid":1188173,"ip_address":"","ucode":"55A0D25BFCDD47","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/4d/90ea92f8.jpg","comment_is_top":false,"comment_ctime":1578384976,"is_pvip":false,"replies":[{"id":65792,"content":"关键是你怎么用 b。如果你需要它是编译期常量，它就应该是 constexpr。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578392824,"ip_address":"","comment_id":169594,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"constexpr变量仍是const这一块的例子：\n```cpp\nconstexpr int a = 42;\nconstexpr const int&amp; b = a;\n```\n第二行会报错 需要一个常量表达式\n去掉constexpr是不是更好？ 貌似对这一块解释没影响～\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480625,"discussion_content":"关键是你怎么用 b。如果你需要它是编译期常量，它就应该是 constexpr。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578392824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168709,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1578145461,"is_pvip":false,"replies":[{"id":65499,"content":"对，纠正得对。我回头改一下。\n\n能不能编译本身不是关键。关键是答案不明显，依赖于一些细微的 C++ 规则。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578222842,"ip_address":"","comment_id":168709,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"为什么文章开头提到的两个例子，都是合法的吗，编译运行都没问题。\n第一个例子理所当然的像应该有问题，但是仔细想了下，为什么要有问题呢，数据大小为什么就要编译器确定呢，运行期确定不行吗。而结果是确实没有问题，这里面的玄机是什么呢\n第二个例子应该是 int a[n];吧\n第二个例子是因为const常量的原因，编译器会强制sqr函数编译器运行特定参数吗\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480307,"discussion_content":"对，纠正得对。我回头改一下。\n\n能不能编译本身不是关键。关键是答案不明显，依赖于一些细微的 C++ 规则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578222842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2373149,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI30dMP7aLxM3L9sUj7xK8wVAXNoDLZHAOxa6Riacvo6KnwroR3llzxhjtXCia6ichGia93Cn9NeiaJxCg/132","nickname":"Geek_01ee79","note":"","ucode":"8BD47B4D0F6964","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363841,"discussion_content":"第一个是 C99 的特性 Variable-length arrays，C++ 标准里面似乎没有提这个，但是 g++ 后来直接把 C99 的特性支持了，所以 VLA 这种应该是不属于 C++ 标准，但是编译器通常提供了这样的扩展。https://en.cppreference.com/w/c/language/array","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617289518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167218,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1577719632,"is_pvip":false,"replies":[{"id":64993,"content":"作为编译期常数，没理由认为一个 constexpr 变量一定会在数据段里的，尤其是优化编译的情况。一般而言，只有非优化编译、又有 ODR-use 才能在 data 段里找到其定义。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577801636,"ip_address":"","comment_id":167218,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"文中一开始用constexpr\n改造的例子，之所以可以，一定是在使用constexpr的地方“就地”调用了赋值运算符右侧的函数，这样才能得到一个编译期的常量，所以，“内联”是constexpr的应有之意。但是在类外，必须加上inline才可以。\n\nconst本质是一个运行时常量，constexpr才是编译期常数，除了内联展开这个含义，再根据文中ODR的表述，说明constexpr变量是切实分配了内存空间的，是一个左值对象。综合上面的考虑，constexpr意味着被声明的对象是存放在数据段里面的。\n\n\nconstexpr 变量模板表达一个和某个类型相关的编译期常量，让变量也可以是模板，这句话在本课中，我觉得理解成“把模板对象用一个变量命名”更合适，即把所有符号都绑定到了一个实体上，这样if constexpr才变得可行。解决了上一讲中说的c++中不能像Python一样写代码的问题。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479785,"discussion_content":"作为编译期常数，没理由认为一个 constexpr 变量一定会在数据段里的，尤其是优化编译的情况。一般而言，只有非优化编译、又有 ODR-use 才能在 data 段里找到其定义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577801636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352329,"user_name":"Chillstep","can_delete":false,"product_type":"c1","uid":3034120,"ip_address":"","ucode":"269FC6C904EC24","user_header":"https://static001.geekbang.org/account/avatar/00/2e/4c/08/96c8318a.jpg","comment_is_top":false,"comment_ctime":1658560809,"is_pvip":false,"replies":[{"id":128178,"content":"👌谢谢抓虫。我回头修正一下。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1658575285,"ip_address":"","comment_id":352329,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师您好，这一段我发现有一些疑问：&quot;这是因为 ODR-use 的类静态常量也需要有一个定义，在没有内联变量之前需要在某一个源代码文件（非头文件）中这样写：const int magic::number = 42;  &quot;这一段我实验了下发现并不能过编译，我认为number已经是const的，应该是没办法在赋值的了，这里应该只需要const int magic::number;即可，这样是可以过编译的。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581179,"discussion_content":"👌谢谢抓虫。我回头修正一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658575285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316820,"user_name":"ano","can_delete":false,"product_type":"c1","uid":1783342,"ip_address":"","ucode":"7DE64BDFA78550","user_header":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","comment_is_top":false,"comment_ctime":1634559066,"is_pvip":false,"replies":[{"id":115161,"content":"没这么简单。有循环也有可能 inline 的。各个编译器的策略并不相同，优化级别也会产生影响。\n\n总体上编译器会对 inline 的效果有自己的评估方式，“值得”inline 才会 inline。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1634909300,"ip_address":"","comment_id":316820,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，我想请教一下。一个 function 标记为 inline, 但如果 function body 中有循环的话，编译器就不会在这个函数的调用处 inline? 编译器是出于什么考虑，不做这个 inline?","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528520,"discussion_content":"没这么简单。有循环也有可能 inline 的。各个编译器的策略并不相同，优化级别也会产生影响。\n\n总体上编译器会对 inline 的效果有自己的评估方式，“值得”inline 才会 inline。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634909300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316029,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1634111395,"is_pvip":false,"replies":[{"id":114527,"content":"它继承自 true_type 或 false_type，那里面有。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1634169503,"ip_address":"","comment_id":316029,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"\n&#47;&#47; Type trait to detect std::pair\ntemplate &lt;typename T&gt;\nstruct is_pair : std::false_type {};\ntemplate &lt;typename T, typename U&gt;\nstruct is_pair&lt;std::pair&lt;T, U&gt;&gt;\n  : std::true_type {};\ntemplate &lt;typename T&gt;\ninline constexpr bool is_pair_v =\n  is_pair&lt;T&gt;::value;\n\nis_pair模板并没有定义value成员啊，为什么可以::value？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528242,"discussion_content":"它继承自 true_type 或 false_type，那里面有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634169503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242287,"user_name":"yuchen","can_delete":false,"product_type":"c1","uid":1605025,"ip_address":"","ucode":"D4B55B57D218CB","user_header":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","comment_is_top":false,"comment_ctime":1597659938,"is_pvip":false,"replies":[{"id":89436,"content":"特化如果没有把所有的模板参数全部消掉，那就是偏特化了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1597670026,"ip_address":"","comment_id":242287,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"template &lt;typename T&gt;\nstruct is_pair : std::false_type {};\ntemplate &lt;typename T, typename U&gt;\nstruct is_pair&lt;std::pair&lt;T, U&gt;&gt;\n  : std::true_type {};\ntemplate &lt;typename T&gt;\ninline constexpr bool is_pair_v =\n  is_pair&lt;T&gt;::value;\n吴老师好，请问这里template &lt;typename T, typename U&gt;\nstruct is_pair&lt;std::pair&lt;T, U&gt;&gt;是特化还是偏特化呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503972,"discussion_content":"特化如果没有把所有的模板参数全部消掉，那就是偏特化了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597670026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1605025,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","nickname":"yuchen","note":"","ucode":"D4B55B57D218CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299871,"discussion_content":"谢谢吴老师。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597845281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235012,"user_name":"O","can_delete":false,"product_type":"c1","uid":2063412,"ip_address":"","ucode":"AE2F7E50FBD3AA","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7c/34/cd10f00b.jpg","comment_is_top":false,"comment_ctime":1594869312,"is_pvip":false,"replies":[{"id":86841,"content":"就是标准的递归而已，先处理外层，看到内存是vector，继续调用，直到全部输出或遇到无法输出的内容（那就会编译报错）。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1594947939,"ip_address":"","comment_id":235012,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师好，我想问一下，想容器嵌套类似vector&lt;vector&lt;&gt;&gt;之类的，output如何判断","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501576,"discussion_content":"就是标准的递归而已，先处理外层，看到内存是vector，继续调用，直到全部输出或遇到无法输出的内容（那就会编译报错）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594947939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182840,"user_name":"zKerry","can_delete":false,"product_type":"c1","uid":1497740,"ip_address":"","ucode":"9FB006D1A38D3F","user_header":"","comment_is_top":false,"comment_ctime":1582873823,"is_pvip":false,"replies":[{"id":70739,"content":"谢谢指出问题。这是修改中引入的问题。回头就修掉。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582899403,"ip_address":"","comment_id":182840,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"\nint sqr(int n)\n{\n  return n * n;\n}\n\nint main()\n{\n  const int n = sqr(3);\n  int a[n)];\n}\n其中：int a[n)] 没有问题？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485468,"discussion_content":"谢谢指出问题。这是修改中引入的问题。回头就修掉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582899403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169984,"user_name":"光城~兴","can_delete":false,"product_type":"c1","uid":1188173,"ip_address":"","ucode":"55A0D25BFCDD47","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/4d/90ea92f8.jpg","comment_is_top":false,"comment_ctime":1578487756,"is_pvip":false,"replies":[{"id":65978,"content":"我并不希望把vector&lt;pair&lt;…&gt;&gt; 输出成“=&gt;”的形式。我要仅在输出map、unordered_map的元素时才使用“=&gt;”。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578496712,"ip_address":"","comment_id":169984,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"对老师的输出函数进行修改：如下\n\ntemplate&lt;typename T, typename Cont&gt;\nauto output_element(std::ostream &amp;os, const T &amp;element,\n                    const Cont &amp;)\n-&gt; typename std::enable_if&lt;is_pair&lt;typename Cont::value_type&gt;::value, bool&gt;::type {\n    os &lt;&lt; element.first &lt;&lt; &quot; =&gt; &quot; &lt;&lt; element.second;\n    return true;\n}\n\ntemplate&lt;typename T, typename Cont&gt;\nauto output_element(std::ostream &amp;os, const T &amp;element,\n                    const Cont &amp;)\n-&gt; typename std::enable_if&lt;!is_pair&lt;typename Cont::value_type&gt;::value, bool&gt;::type {\n    os &lt;&lt; element;\n    return false;\n}\n\n调用处：\noutput_element(os, elem, container);\n\n这个方法学习自老师之前讲过的SFINAE！\n\n另外，针对老师的代码有些疑问：\n老师代码调用处：\noutput_element(os, *it, container, is_pair&lt;element_type&gt;());\n实际上在这里就确定了element_type是不是pair，也就是这里传递进去直接就是true_type或者false_type，针对,map&#47;vector&#47;set等直接就可以区分开来，不需要写：std::declval&lt;typename Cont::key_type&gt;()。\n也是可以正常完成输出的，但是当传递的是true_type且容器没有key_type的时候就是SFINAE问题，调用另一个重载函数。\n问题是，一个容器元素是pair，那么is_pair&lt;element_type&gt;()就是true_type，而既然是pair了，也就有了key_type，所以这个必然成立，也就是写与不写都可以。另外，当不是pair，就是false_type，肯定调false_type的output_element重载咯，所以我得出这里写这个std::declval&lt;typename Cont::key_type&gt;()没有啥子用，并且代码测试过确实可以不写，望老师指点！","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480795,"discussion_content":"我并不希望把vector&amp;lt;pair&amp;lt;…&amp;gt;&amp;gt; 输出成“=&amp;gt;”的形式。我要仅在输出map、unordered_map的元素时才使用“=&amp;gt;”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578496712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188173,"avatar":"https://static001.geekbang.org/account/avatar/00/12/21/4d/90ea92f8.jpg","nickname":"光城~兴","note":"","ucode":"55A0D25BFCDD47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":126737,"discussion_content":"对的，我试了的，去掉是没有影响的，对这个结果输出没有影响～～～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578535018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1188173,"avatar":"https://static001.geekbang.org/account/avatar/00/12/21/4d/90ea92f8.jpg","nickname":"光城~兴","note":"","ucode":"55A0D25BFCDD47","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129765,"discussion_content":"我测过的，如果把：\n\ntemplate <typename T, typename Cont>\nauto output_element(std::ostream&amp; os, const T&amp; element,\n                    const Cont&amp;, const std::true_type)\n    -> decltype(std::declval<typename Cont::key_type>(), os)\n\n改成\n\ntemplate <typename T, typename Cont>\nstd::ostream&amp; output_element(std::ostream&amp; os, const T&amp; element,\n                             const Cont&amp;, const std::true_type)\n\n那么对于：\n\nvector<pair<int, int>> v{{1, 2}, {3, 4}};\ncout << v << endl;\n\n输出就从\n\n{ (1, 2), (3, 4) }\n\n变成了\n\n{ 1 => 2, 3 => 4 }\n\n我希望的是\n\n{ (1, 2), (3, 4) }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578736654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":126737,"ip_address":"","group_id":0},"score":129765,"extra":""}]}]},{"had_liked":false,"id":169594,"user_name":"光城~兴","can_delete":false,"product_type":"c1","uid":1188173,"ip_address":"","ucode":"55A0D25BFCDD47","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/4d/90ea92f8.jpg","comment_is_top":false,"comment_ctime":1578384976,"is_pvip":false,"replies":[{"id":65792,"content":"关键是你怎么用 b。如果你需要它是编译期常量，它就应该是 constexpr。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578392824,"ip_address":"","comment_id":169594,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"constexpr变量仍是const这一块的例子：\n```cpp\nconstexpr int a = 42;\nconstexpr const int&amp; b = a;\n```\n第二行会报错 需要一个常量表达式\n去掉constexpr是不是更好？ 貌似对这一块解释没影响～\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480795,"discussion_content":"我并不希望把vector&amp;lt;pair&amp;lt;…&amp;gt;&amp;gt; 输出成“=&amp;gt;”的形式。我要仅在输出map、unordered_map的元素时才使用“=&amp;gt;”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578496712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188173,"avatar":"https://static001.geekbang.org/account/avatar/00/12/21/4d/90ea92f8.jpg","nickname":"光城~兴","note":"","ucode":"55A0D25BFCDD47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":126737,"discussion_content":"对的，我试了的，去掉是没有影响的，对这个结果输出没有影响～～～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578535018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1188173,"avatar":"https://static001.geekbang.org/account/avatar/00/12/21/4d/90ea92f8.jpg","nickname":"光城~兴","note":"","ucode":"55A0D25BFCDD47","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129765,"discussion_content":"我测过的，如果把：\n\ntemplate <typename T, typename Cont>\nauto output_element(std::ostream&amp; os, const T&amp; element,\n                    const Cont&amp;, const std::true_type)\n    -> decltype(std::declval<typename Cont::key_type>(), os)\n\n改成\n\ntemplate <typename T, typename Cont>\nstd::ostream&amp; output_element(std::ostream&amp; os, const T&amp; element,\n                             const Cont&amp;, const std::true_type)\n\n那么对于：\n\nvector<pair<int, int>> v{{1, 2}, {3, 4}};\ncout << v << endl;\n\n输出就从\n\n{ (1, 2), (3, 4) }\n\n变成了\n\n{ 1 => 2, 3 => 4 }\n\n我希望的是\n\n{ (1, 2), (3, 4) }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578736654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":126737,"ip_address":"","group_id":0},"score":129765,"extra":""}]}]},{"had_liked":false,"id":168709,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1578145461,"is_pvip":false,"replies":[{"id":65499,"content":"对，纠正得对。我回头改一下。\n\n能不能编译本身不是关键。关键是答案不明显，依赖于一些细微的 C++ 规则。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578222842,"ip_address":"","comment_id":168709,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"为什么文章开头提到的两个例子，都是合法的吗，编译运行都没问题。\n第一个例子理所当然的像应该有问题，但是仔细想了下，为什么要有问题呢，数据大小为什么就要编译器确定呢，运行期确定不行吗。而结果是确实没有问题，这里面的玄机是什么呢\n第二个例子应该是 int a[n];吧\n第二个例子是因为const常量的原因，编译器会强制sqr函数编译器运行特定参数吗\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480625,"discussion_content":"关键是你怎么用 b。如果你需要它是编译期常量，它就应该是 constexpr。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578392824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167073,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1577684751,"is_pvip":false,"replies":[{"id":64981,"content":"是，然后要么会有重复的代码，要么得再封装函数来复用。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577791582,"ip_address":"","comment_id":167073,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"如果没有consrexpr条件语句那输出函数就应该写两个吧，也是用sfinae，用那种enable_if形式，true or false","like_count":0},{"had_liked":false,"id":167073,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1577684751,"is_pvip":false,"replies":[{"id":64981,"content":"是，然后要么会有重复的代码，要么得再封装函数来复用。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577791582,"ip_address":"","comment_id":167073,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"如果没有consrexpr条件语句那输出函数就应该写两个吧，也是用sfinae，用那种enable_if形式，true or false","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479734,"discussion_content":"是，然后要么会有重复的代码，要么得再封装函数来复用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577791582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}