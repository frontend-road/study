{"id":740781,"title":"第 16 章 解析器(2)","content":"<h2 id=\"nav_point_157\">16.5　解析属性</h2>\n<p>上一节中介绍的 <code>parseTag</code> 解析函数会消费整个开始标签，这意味着该函数需要有能力处理开始标签中存在属性与指令，例如：</p>\n<pre class=\"code-rows\"><code> &lt;div id=\"foo\" v-show=\"display\"/&gt;\n</code></pre>\n<p>上面这段模板中的 <code>div</code> 标签存在一个 <code>id</code> 属性和一个 <code>v-show</code> 指令。为了处理属性和指令，我们需要在 <code>parseTag</code> 函数中增加 <code>parseAttributes</code> 解析函数，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function parseTag(context, type = 'start') {\n   const { advanceBy, advanceSpaces } = context\n<p>const match = type === ‘start’<br />\n? /^&lt;([a-z][^\\t\\r\\n\\f /&gt;]<em>)/i.exec(context.source)<br />\n: /^&lt;/([a-z][^\\t\\r\\n\\f /&gt;]</em>)/i.exec(context.source)<br />\nconst tag = match[1]</p>\n<p>advanceBy(match[0].length)<br />\nadvanceSpaces()<br />\n// 调用 parseAttributes 函数完成属性与指令的解析，并得到 props 数组，<br />\n// props 数组是由指令节点与属性节点共同组成的数组<br />\nconst props = parseAttributes(context)</p>\n<p>const isSelfClosing = context.source.startsWith(‘/&gt;’)<br />\nadvanceBy(isSelfClosing ? 2 : 1)</p>\n<p>return {<br />\ntype: ‘Element’,<br />\ntag,<br />\nprops, // 将 props 数组添加到标签节点上<br />\nchildren: [],<br />\nisSelfClosing<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>上面这段代码的关键点之一是，我们需要在消费标签的“开始部分”和无用的空白字符之后，再调用 <code>parseAttribute</code> 函数。举个例子，假设标签的内容如下：</p>\n<pre class=\"code-rows\"><code> &lt;div id=\"foo\" v-show=\"display\" &gt;\n</code></pre>\n<p>标签的“开始部分”指的是字符串 <code>&lt;div</code>，所以当消耗标签的“开始部分”以及无用空白字符后，剩下的内容为：</p>\n<pre class=\"code-rows\"><code> id=\"foo\" v-show=\"display\" &gt;\n</code></pre>\n<p>上面这段内容才是 <code>parseAttributes</code> 函数要处理的内容。由于该函数只用来解析属性和指令，因此它会不断地消费上面这段模板内容，直到遇到标签的“结束部分”为止。其中，结束部分指的是字符 <code>&gt;</code> 或者字符串 <code>/&gt;</code>。据此我们可以给出 <code>parseAttributes</code> 函数的整体框架，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function parseAttributes(context) {\n   // 用来存储解析过程中产生的属性节点和指令节点\n   const props = []\n<p>// 开启 while 循环，不断地消费模板内容，直至遇到标签的“结束部分”为止<br />\nwhile (<br />\n!context.source.startsWith(‘&gt;’) &amp;&amp;<br />\n!context.source.startsWith(‘/&gt;’)<br />\n) {<br />\n// 解析属性或指令<br />\n}<br />\n// 将解析结果返回<br />\nreturn props<br />\n}<br />\n</code></pre></p>\n<p>实际上，<code>parseAttributes</code> 函数消费模板内容的过程，就是不断地解析属性名称、等于号、属性值的过程，如图 16-17 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00649.jpeg\" alt=\"\" width=\"75%\" style=\"width: 75%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-17　属性的格式</strong></p>\n<p><code>parseAttributes</code> 函数会按照从左到右的顺序不断地消费字符串。以图 16-17 为例，该函数的解析过程如下。</p>\n<ul>\n<li><p>首先，解析出第一个属性的名称 <code>id</code>，并消费字符串 <code>'id'</code>。此时剩余模板内容为：</p>\n<pre class=\"code-rows\"><code> =\"foo\" v-show=\"display\" &gt;\n</code></pre>\n<p>在解析属性名称时，除了要消费属性名称之外，还要消费属性名称后面可能存在的空白字符。如下面这段模板中，属性名称和等于号之间存在空白字符：</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code> id  =  \"foo\" v-show=\"display\" &gt;\n</code></pre>\n<p>但无论如何，在属性名称解析完毕之后，模板剩余内容一定是以等于号开头的，即</p>\n<pre class=\"code-rows\"><code> =  \"foo\" v-show=\"display\" &gt;\n</code></pre>\n<p>如果消费属性名称之后，模板内容不以等于号开头，则说明模板内容不合法，我们可以选择性地抛出错误。</p>\n</li>\n<li><p>接着，我们需要消费等于号字符。由于等于号和属性值之间也可能存在空白字符，所以我们也需要消费对应的空白字符。在这一步操作过后，模板的剩余内容如下：</p>\n<pre class=\"code-rows\"><code> \"foo\" v-show=\"display\" &gt;\n</code></pre>\n</li>\n<li><p>接下来，到了处理属性值的环节。模板中的属性值存在三种情况。</p>\n<ul>\n<li>属性值被双引号包裹：<code>id=\"foo\"</code>。</li>\n<li>属性值被单引号包裹：<code>id='foo'</code>。</li>\n<li>属性值没有引号包裹：<code>id=foo</code>。</li>\n</ul>\n<p>按照上述例子，此时模板的内容一定以双引号（<code>\"</code>）开头。因此我们可以通过检查当前模板内容是否以引号开头来确定属性值是否被引用。如果属性值被引号引用，则消费引号。此时模板的剩余内容为：</p>\n<pre class=\"code-rows\"><code> foo\" v-show=\"display\" &gt;\n</code></pre>\n<p>既然属性值被引号引用了，就意味着在剩余模板内容中，下一个引号之前的内容都应该被解析为属性值。在这个例子中，属性值的内容是字符串 <code>foo</code>。于是，我们消费属性值及其后面的引号。当然，如果属性值没有被引号引用，那么在剩余模板内容中，下一个空白字符之前的所有字符都应该作为属性值。</p>\n<p>当属性值和引号被消费之后，由于属性值与下一个属性名称之间可能存在空白字符，所以我们还要消费对应的空白字符。在这一步处理过后，剩余模板内容为：</p>\n<pre class=\"code-rows\"><code> v-show=\"display\" &gt;\n</code></pre>\n<p>可以看到，经过上述操作之后，第一个属性就处理完毕了。</p>\n</li>\n<li><p>此时模板中还剩下一个指令，我们只需重新执行上述步骤，即可完成 <code>v-show</code> 指令的解析。当 <code>v-show</code> 指令解析完毕后，将会遇到标签的“结束部分”，即字符 <code>&gt;</code>。这时，<code>parseAttributes</code> 函数中的 <code>while</code> 循环将会停止，完成属性和指令的解析。</p>\n</li>\n</ul>\n<p>下面的 <code>parseAttributes</code> 函数给出了上述逻辑的具体实现：</p>\n<pre class=\"code-rows\"><code> function parseAttributes(context) {\n   const { advanceBy, advanceSpaces } = context\n   const props = []\n<p>while (<br />\n!context.source.startsWith(‘&gt;’) &amp;&amp;<br />\n!context.source.startsWith(‘/&gt;’)<br />\n) {<br />\n// 该正则用于匹配属性名称<br />\nconst match = /^[^\\t\\r\\n\\f /&gt;][^\\t\\r\\n\\f /&gt;=]*/.exec(context.source)<br />\n// 得到属性名称<br />\nconst name = match[0]</p>\n<pre><code> // 消费属性名称\n advanceBy(name.length)\n // 消费属性名称与等于号之间的空白字符\n advanceSpaces()\n // 消费等于号\n advanceBy(1)\n // 消费等于号与属性值之间的空白字符\n advanceSpaces()\n\n // 属性值\n let value = ''\n\n // 获取当前模板内容的第一个字符\n const quote = context.source[0]\n // 判断属性值是否被引号引用\n const isQuoted = quote === '&quot;' || quote === &quot;'&quot;\n\n if (isQuoted) {\n   // 属性值被引号引用，消费引号\n   advanceBy(1)\n   // 获取下一个引号的索引\n   const endQuoteIndex = context.source.indexOf(quote)\n   if (endQuoteIndex &amp;gt; -1) {\n     // 获取下一个引号之前的内容作为属性值\n     value = context.source.slice(0, endQuoteIndex)\n     // 消费属性值\n     advanceBy(value.length)\n     // 消费引号\n     advanceBy(1)\n   } else {\n     // 缺少引号错误\n     console.error('缺少引号')\n   }\n } else {\n   // 代码运行到这里，说明属性值没有被引号引用\n   // 下一个空白字符之前的内容全部作为属性值\n   const match = /^[^\\t\\r\\n\\f &amp;gt;]+/.exec(context.source)\n   // 获取属性值\n   value = match[0]\n   // 消费属性值\n   advanceBy(value.length)\n }\n // 消费属性值后面的空白字符\n advanceSpaces()\n\n // 使用属性名称 + 属性值创建一个属性节点，添加到 props 数组中\n props.push({\n   type: 'Attribute',\n   name,\n   value\n })\n</code></pre>\n<p>}<br />\n// 返回<br />\nreturn props<br />\n}<br />\n</code></pre></p>\n<p>在上面这段代码中，有两个重要的正则表达式：</p>\n<ul>\n<li><code>/^[^\\t\\r\\n\\f /&gt;][^\\t\\r\\n\\f /&gt;=]*/</code>，用来匹配属性名称；</li>\n<li><code>/^[^\\t\\r\\n\\f &gt;]+/</code>，用来匹配没有使用引号引用的属性值。</li>\n</ul>\n<p>我们分别来看看这两个正则表达式是如何工作的。图 16-18 给出了用于匹配属性名称的正则表达式的匹配原理。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00650.jpeg\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-18　用于匹配属性的正则</strong></p>\n<p>如图 16-18 所示，我们可以将这个正则表达式分为 A、B 两个部分来看。</p>\n<ul>\n<li>部分 A 用于匹配一个位置，这个位置不能是空白字符，也不能是字符 <code>/</code> 或字符 <code>&gt;</code>，并且字符串要以该位置开头。</li>\n<li>部分 B 则用于匹配 0 个或多个位置，这些位置不能是空白字符，也不能是字符 <code>/</code>、<code>&gt;</code>、<code>=</code>。注意，这些位置不允许出现等于号（<code>=</code>）字符，这就实现了只匹配等于号之前的内容，即属性名称。</li>\n</ul>\n<p>图 16-19 给出了第二个正则表达式的匹配原理。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00651.jpeg\" alt=\"\" width=\"70%\" style=\"width: 70%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-19　第二个正则表达式的匹配原理</strong></p>\n<p>该正则表达式从字符串的开始位置进行匹配，并且会匹配一个或多个非空白字符、非字符 <code>&gt;</code>。换句话说，该正则表达式会一直对字符串进行匹配，直到遇到空白字符或字符 <code>&gt;</code> 为止，这就实现了属性值的提取。</p>\n<p>配合 <code>parseAttributes</code> 函数，假设给出如下模板：</p>\n<pre class=\"code-rows\"><code> &lt;div id=\"foo\" v-show=\"display\"&gt;&lt;/div&gt;\n</code></pre>\n<p>解析上面这段模板，将会得到如下 AST：</p>\n<pre class=\"code-rows\"><code> const ast = {\n   type: 'Root',\n   children: [\n     {\n       type: 'Element'\n       tag: 'div',\n       props: [\n         // 属性\n         { type: 'Attribute', name: 'id', value: 'foo' },\n         { type: 'Attribute', name: 'v-show', value: 'display' }\n       ]\n     }\n   ]\n }\n</code></pre>\n<p>可以看到，在 <code>div</code> 标签节点的 <code>props</code> 属性中，包含两个类型为 <code>Attribute</code> 的节点，这两个节点就是 <code>parseAttributes</code> 函数的解析结果。</p>\n<p>我们可以增加更多在 Vue.js 中常见的属性和指令进行测试，如以下模板所示：</p>\n<pre class=\"code-rows\"><code> &lt;div :id=\"dynamicId\" @click=\"handler\" v-on:mousedown=\"onMouseDown\" &gt;&lt;/div&gt;\n</code></pre>\n<p>上面这段模板经过解析后，得到如下 AST：</p>\n<pre class=\"code-rows\"><code> const ast = {\n   type: 'Root',\n   children: [\n     {\n       type: 'Element'\n       tag: 'div',\n       props: [\n         // 属性\n         { type: 'Attribute', name: ':id', value: 'dynamicId' },\n         { type: 'Attribute', name: '@click', value: 'handler' },\n         { type: 'Attribute', name: 'v-on:mousedown', value: 'onMouseDown' }\n       ]\n     }\n   ]\n }\n</code></pre>\n<p>可以看到，在类型为 <code>Attribute</code> 的属性节点中，其 <code>name</code> 字段完整地保留着模板中编写的属性名称。我们可以对属性名称做进一步的分析，从而得到更具体的信息。例如，属性名称以字符 <code>@</code> 开头，则认为它是一个 <code>v-on</code> 指令绑定。我们甚至可以把以 <code>v-</code> 开头的属性看作指令绑定，从而为它赋予不同的节点类型，例如：</p>\n<pre class=\"code-rows\"><code> // 指令，类型为 Directive\n { type: 'Directive', name: 'v-on:mousedown', value: 'onMouseDown' }\n { type: 'Directive', name: '@click', value: 'handler' }\n // 普通属性\n { type: 'Attribute', name: 'id', value: 'foo' }\n</code></pre>\n<p>不仅如此，为了得到更加具体的信息，我们甚至可以进一步分析指令节点的数据，也可以设计更多语法规则，这完全取决于框架设计者在语法层面的设计，以及为框架赋予的能力。</p>\n<h2 id=\"nav_point_158\">16.6　解析文本与解码 HTML 实体</h2>\n<h3 id=\"nav_point_159\">16.6.1　解析文本</h3>\n<p>本节我们将讨论文本节点的解析。给出如下模板：</p>\n<pre class=\"code-rows\"><code> const template = '&lt;div&gt;Text&lt;/div&gt;'\n</code></pre>\n<p>解析器在解析上面这段模板时，会先经过 <code>parseTag</code> 函数的处理，这会消费标签的开始部分 <code>'&lt;div&gt;'</code>。处理完毕后，剩余模板内容为：</p>\n<pre class=\"code-rows\"><code> const template = 'Text&lt;/div&gt;'\n</code></pre>\n<p>紧接着，解析器会调用 <code>parseChildren</code> 函数，开启一个新的状态机来处理这段模板。我们来回顾一下状态机的状态迁移过程，如图 16-20 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00652.jpeg\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-20　<code>parseChildren</code> 函数在解析模板过程中的状态迁移过程</strong></p>\n<p>状态机始于“状态 1”。在“状态 1”下，读取模板的第一个字符 <code>T</code>，由于该字符既不是字符 <code>&lt;</code>，也不是插值定界符 <code>{{</code>，因此状态机会进入“状态 7”，即调用 <code>parseText</code> 函数处理文本内容。此时解析器会在模板中寻找下一个 <code>&lt;</code> 字符或插值定界符 <code>{{</code> 的位置索引，记为索引 <code>I</code>。然后，解析器会从模板的头部到索引 <code>I</code> 的位置截取内容，这段截取出来的字符串将作为文本节点的内容。以下面的模板内容为例：</p>\n<pre class=\"code-rows\"><code> const template = 'Text&lt;/div&gt;'\n</code></pre>\n<p><code>parseText</code> 函数会尝试在这段模板内容中找到第一个出现的字符 <code>&lt;</code> 的位置索引。在这个例子中，字符 <code>&lt;</code> 的索引值为 <code>4</code>。然后，<code>parseText</code> 函数会截取介于索引 <code>[0, 4)</code> 的内容作为文本内容。在这个例子中，文本内容就是字符串 <code>'Text'</code>。</p>\n<p>假设模板中存在插值，如下面的模板所示：</p>\n<pre class=\"code-rows\"><code> const template = 'Text-{{ val }}&lt;/div&gt;'\n</code></pre>\n<p>在处理这段模板时，<code>parseText</code> 函数会找到第一个插值定界符 <code>{{</code> 出现的位置索引。在这个例子中，定界符的索引为 <code>5</code>。于是，<code>parseText</code> 函数会截取介于索引 <code>[0, 5)</code> 的内容作为文本内容。在这个例子中，文本内容就是字符串 <code>'Text-'</code>。</p>\n<p>下面的 <code>parseText</code> 函数给出了具体实现：</p>\n<pre class=\"code-rows\"><code> function parseText(context) {\n   // endIndex 为文本内容的结尾索引，默认将整个模板剩余内容都作为文本内容\n   let endIndex = context.source.length\n   // 寻找字符 &lt; 的位置索引\n   const ltIndex = context.source.indexOf('&lt;')\n   // 寻找定界符 {{ 的位置索引\n   const delimiterIndex = context.source.indexOf('{{')\n<p>// 取 ltIndex 和当前 endIndex 中较小的一个作为新的结尾索引<br />\nif (ltIndex &gt; -1 &amp;&amp; ltIndex &lt; endIndex) {<br />\nendIndex = ltIndex<br />\n}<br />\n// 取 delimiterIndex 和当前 endIndex 中较小的一个作为新的结尾索引<br />\nif (delimiterIndex &gt; -1 &amp;&amp; delimiterIndex &lt; endIndex) {<br />\nendIndex = delimiterIndex<br />\n}</p>\n<p>// 此时 endIndex 是最终的文本内容的结尾索引，调用 slice 函数截取文本内容<br />\nconst content = context.source.slice(0, endIndex)<br />\n// 消耗文本内容<br />\ncontext.advanceBy(content.length)</p>\n<p>// 返回文本节点<br />\nreturn {<br />\n// 节点类型<br />\ntype: ‘Text’,<br />\n// 文本内容<br />\ncontent<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>如上面的代码所示，由于字符 <code>&lt;</code> 与定界符 <code>{{</code> 的出现顺序是未知的，所以我们需要取两者中较小的一个作为文本截取的终点。有了截取终点后，只需要调用字符串的 <code>slice</code> 函数对字符串进行截取即可，截取出来的内容就是文本节点的文本内容。最后，我们创建一个类型为 <code>Text</code> 的文本节点，将其作为 <code>parseText</code> 函数的返回值。</p>\n<p>配合上述 <code>parseText</code> 函数解析如下模板：</p>\n<pre class=\"code-rows\"><code> const ast = parse(`&lt;div&gt;Text&lt;/div&gt;`)\n</code></pre>\n<p>得到如下 AST：</p>\n<pre class=\"code-rows\"><code> const ast = {\n   type: 'Root',\n   children: [\n     {\n       type: 'Element',\n       tag: 'div',\n       props: [],\n       isSelfClosing: false,\n       children: [\n         // 文本节点\n         { type: 'Text', content: 'Text' }\n       ]\n     }\n   ]\n }\n</code></pre>\n<p>这样，我们就实现了对文本节点的解析。解析文本节点本身并不复杂，复杂点在于，我们需要对解析后的文本内容进行 HTML 实体的解码工作。为此，我们有必要先了解什么是 HTML 实体。</p>\n<h3 id=\"nav_point_160\">16.6.2　解码命名字符引用</h3>\n<p>HTML 实体是一段以字符 <code>&amp;</code> 开始的文本内容。实体用来描述 HTML 中的保留字符和一些难以通过普通键盘输入的字符，以及一些不可见的字符。例如，在 HTML 中，字符 <code>&lt;</code> 具有特殊含义，如果希望以普通文本的方式来显示字符 <code>&lt;</code>，需要通过实体来表达：</p>\n<pre class=\"code-rows\"><code> &lt;div&gt;A&amp;lt;B&lt;/div&gt;\n</code></pre>\n<p>其中字符串 <code>&amp;lt;</code> 就是一个 HTML 实体，用来表示字符 <code>&lt;</code>。如果我们不用 HTML 实体，而是直接使用字符 <code>&lt;</code>，那么将会产生非法的 HTML 内容：</p>\n<pre class=\"code-rows\"><code> &lt;div&gt;A&lt;B&lt;/div&gt;\n</code></pre>\n<p>这会导致浏览器的解析结果不符合预期。</p>\n<p>HTML 实体总是以字符 <code>&amp;</code> 开头，以字符 <code>;</code> 结尾。在 Web 诞生的初期，HTML 实体的数量较少，因此允许省略其中的尾分号。但随着 HTML 字符集越来越大，HTML 实体出现了包含的情况，例如 <code>&amp;lt</code> 和 <code>&amp;ltcc</code> 都是合法的实体，如果不加分号，浏览器将无法区分它们。因此，WHATWG 规范中明确规定，如果不为实体加分号，将会产生解析错误。但考虑到历史原因（互联网上存在大量省略分号的情况），现代浏览器都能够解析早期规范中定义的那些可以省略分号的 HTML 实体。</p>\n<p>HTML 实体有两类，一类叫作<strong>命名字符引用</strong>（named character reference），也叫<strong>命名实体</strong>（named entity），顾名思义，这类实体具有特定的名称，例如上文中的 <code>&amp;lt;</code>。WHATWG 规范中给出了全部的命名字符引用，有 2000 多个，可以通过命名字符引用表查询。下面列出了部分内容：</p>\n<pre class=\"code-rows\"><code> // 共 2000+\n {\n   \"GT\": \"&gt;\",\n   \"gt\": \"&gt;\",\n   \"LT\": \"&lt;\",\n   \"lt\": \"&lt;\",\n   // 省略部分代码\n   \"awint;\": \"⨑\",\n   \"bcong;\": \"≌\",\n   \"bdquo;\": \"„\",\n   \"bepsi;\": \"϶\",\n   \"blank;\": \"␣\",\n   \"blk12;\": \"▒\",\n   \"blk14;\": \"░\",\n   \"blk34;\": \"▓\",\n   \"block;\": \"█\",\n   \"boxDL;\": \"╗\",\n   \"boxDl;\": \"╖\",\n   \"boxdL;\": \"╕\",\n   // 省略部分代码\n }\n</code></pre>\n<p>除了命名字符引用之外，还有一类字符引用没有特定的名称，只能用数字表示，这类实体叫作<strong>数字字符引用</strong>（numeric character reference）。与命名字符引用不同，数字字符引用以字符串 <code>&amp;#</code> 开头，比命名字符引用的开头部分多出了字符 <code>#</code>，例如 <code>&amp;#60;</code>。实际上，<code>&amp;#60;</code> 对应的字符也是 <code>&lt;</code>，换句话说，<code>&amp;#60;</code> 与 <code>&amp;lt;</code> 是等价的。数字字符引用既可以用十进制来表示，也可以使用十六进制来表示。例如，十进制数字 <code>60</code> 对应的十六进制值为 <code>3c</code>，因此实体 <code>&amp;#60;</code> 也可以表示为 <code>&amp;#x3c;</code>。可以看到，当使用十六进制数表示实体时，需要以字符串 <code>&amp;#x</code> 开头。</p>\n<p>理解了 HTML 实体后，我们再来讨论为什么 Vue.js 模板的解析器要对文本节点中的 HTML 实体进行解码。为了理解这个问题，我们需要先明白一个大前提：在 Vue.js 模板中，文本节点所包含的 HTML 实体不会被浏览器解析。这是因为模板中的文本节点最终将通过如 <code>el.textContent</code> 等文本操作方法设置到页面，而通过 <code>el.textContent</code> 设置的文本内容是不会经过 HTML 实体解码的，例如：</p>\n<pre class=\"code-rows\"><code> el.textContent = '&amp;lt;'\n</code></pre>\n<p>最终 <code>el</code> 的文本内容将会原封不动地呈现为字符串 <code>'&amp;lt;'</code>，而不会呈现字符 <code>&lt;</code>。这就意味着，如果用户在 Vue.js 模板中编写了 HTML 实体，而模板解析器不对其进行解码，那么最终渲染到页面的内容将不符合用户的预期。因此，我们应该在解析阶段对文本节点中存在的 HTML 实体进行解码。</p>\n<p>模板解析器的解码行为应该与浏览器的行为一致。因此，我们应该按照 WHATWG 规范实现解码逻辑。规范中明确定义了解码 HTML 实体时状态机的状态迁移流程。图 16-21 给出了简化版的状态迁移流程，我们会在后文中对其进行补充。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00653.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-21　解析字符引用的状态机</strong></p>\n<p>假定状态机当前处于初始的 <code>DATA</code> 模式。由图 16-21 可知，当解析器遇到字符 <code>&amp;</code> 时，会进入“字符引用状态”，并消费字符 <code>&amp;</code>，接着解析下一个字符。如果下一个字符是 ASCII 字母或数字（ASCII alphanumeric），则进入“命名字符引用状态”，其中 ASCII 字母或数字指的是 <code>0</code>~<code>9</code> 这十个数字以及字符集合 <code>a</code>~<code>z</code> 再加上字符集合 <code>A</code>~<code>Z</code>。当然，如果下一个字符是 <code>#</code>，则进入“数字字符引用状态”。</p>\n<p>一旦状态机进入命名字符引用状态，解析器将会执行比较复杂的匹配流程。我们通过几个例子来直观地感受一下这个过程。假设文本内容为：</p>\n<pre class=\"code-rows\"><code> a&amp;ltb\n</code></pre>\n<p>上面这段文本会被解析为：</p>\n<pre class=\"code-rows\"><code> a&lt;b\n</code></pre>\n<p>为什么会得到这样的解析结果呢？接下来，我们分析整个解析过程。</p>\n<ul>\n<li>首先，当解析器遇到字符 <code>&amp;</code> 时，会进入字符引用状态。接着，解析下一个字符 <code>l</code>，这会使得解析器进入命名字符引用状态，并在命名字符引用表（后文简称“引用表”）中查找以字符 <code>l</code> 开头的项。由于引用表中存在诸多以字符 <code>l</code> 开头的项，例如 <code>lt</code>、<code>lg</code>、<code>le</code> 等，因此解析器认为此时是“匹配”的。</li>\n<li>于是开始解析下一个字符 <code>t</code>，并尝试去引用表中查找以 <code>lt</code> 开头的项。由于引用表中也存在多个以 <code>lt</code> 开头的项，例如 <code>lt</code>、<code>ltcc;</code>、<code>ltri;</code> 等，因此解析器认为此时也是“匹配”的。</li>\n<li>于是又开始解析下一个字符 <code>b</code>，并尝试去引用表中查找以 <code>ltb</code> 开头的项，结果发现引用表中不存在符合条件的项，至此匹配结束。</li>\n</ul>\n<p>当匹配结束时，解析器会检查最后一个匹配的字符。如果该字符是分号（<code>;</code>），则会产生一个合法的匹配，并渲染对应字符。但在上例中，最后一个匹配的字符是字符 <code>t</code>，并不是分号（<code>;</code>），因此会产生一个解析错误，但由于历史原因，浏览器仍然能够解析它。在这种情况下，浏览器的解析规则是：最短原则。其中“最短”指的是命名字符引用的名称最短。举个例子，假设文本内容为：</p>\n<pre class=\"code-rows\"><code> a&amp;ltcc;\n</code></pre>\n<p>我们知道 <code>&amp;ltcc;</code> 是一个合法的命名字符引用，因此上述文本会被渲染为：<code>a</code>⪦。但如果去掉上述文本中的分号，即</p>\n<pre class=\"code-rows\"><code> a&amp;ltcc\n</code></pre>\n<p>解析器在处理这段文本中的实体时，最后匹配的字符将不再是分号，而是字符 <code>c</code>。按照“最短原则”，解析器只会渲染名称更短的字符引用。在字符串 <code>&amp;ltcc</code> 中，<code>&amp;lt</code> 的名称要短于 <code>&amp;ltcc</code>，因此最终会将 <code>&amp;lt</code> 作为合法的字符引用来渲染，而字符串 <code>cc</code> 将作为普通字符来渲染。所以上面的文本最终会被渲染为：<code>a&lt;cc</code>。</p>\n<p>需要说明的是，上述解析过程仅限于不用作属性值的普通文本。换句话说，用作属性值的文本会有不同的解析规则。举例来说，给出如下 HTML 文本：</p>\n<pre class=\"code-rows\"><code> &lt;a href=\"foo.com?a=1&amp;lt=2\"&gt;foo.com?a=1&amp;lt=2&lt;/a&gt;\n</code></pre>\n<p>可以看到，<code>a</code> 标签的 <code>href</code> 属性值与它的文本子节点具有同样的内容，但它们被解析之后的结果不同。其中属性值中出现的 <code>&amp;lt</code> 将原封不动地展示，而文本子节点中出现的 <code>&amp;lt</code> 将会被解析为字符 <code>&lt;</code>。这也是符合期望的，很明显，<code>&amp;lt=2</code> 将构成链接中的查询参数，如果将其中的 <code>&amp;lt</code> 解码为字符 <code>&lt;</code>，将会破坏用户的 URL。实际上，WHATWG 规范中对此也有完整的定义，出于历史原因的考虑，对于属性值中的字符引用，如果最后一个匹配的字符不是分号，并且该匹配的字符的下一个字符是等于号、ASCII 字母或数字，那么该匹配项将作为普通文本被解析。</p>\n<p>明白了原理，我们就着手实现。我们面临的第一个问题是，如何处理省略分号的情况？关于字符引用中的分号，我们可以总结如下。</p>\n<ul>\n<li>当存在分号时：执行完整匹配。</li>\n<li>当省略分号时：执行最短匹配。</li>\n</ul>\n<p>为此，我们需要精心设计命名字符引用表。由于命名字符引用的数量非常多，因此这里我们只取其中一部分作为命名字符引用表的内容，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const namedCharacterReferences = {\n   \"gt\": \"&gt;\",\n   \"gt;\": \"&gt;\",\n   \"lt\": \"&lt;\",\n   \"lt;\": \"&lt;\",\n   \"ltcc;\": \"⪦\"\n }\n</code></pre>\n<p>上面这张表是经过精心设计的。观察 <code>namedCharacterReferences</code> 对象可以发现，相同的字符对应的实体会有多个，即带分号的版本和不带分号的版本，例如 <code>\"gt\"</code> 和 <code>\"gt;\"</code>。另外一些实体则只有带分号的版本，因为这些实体不允许省略分号，例如 <code>\"ltcc;\"</code>。我们可以根据这张表来实现实体的解码逻辑。假设我们有如下文本内容：</p>\n<pre class=\"code-rows\"><code> a&amp;ltccbbb\n</code></pre>\n<p>在解码这段文本时，我们首先根据字符 <code>&amp;</code> 将文本分为两部分。</p>\n<ul>\n<li>一部分是普通文本：<code>a</code>。</li>\n<li>另一部分则是：<code>&amp;ltccbbb</code>。</li>\n</ul>\n<p>对于普通文本部分，由于它不需要被解码，因此索引原封不动地保留。而对于可能是字符引用的部分，执行解码工作。</p>\n<ul>\n<li>第一步：计算出命名字符引用表中实体名称的最大长度。由于在 <code>namedCharacterReferences</code> 对象中，名称最长的实体是 <code>ltcc;</code>，它具有 <code>5</code> 个字符，因此最大长度是 <code>5</code>。</li>\n<li>第二步：根据最大长度截取字符串 <code>ltccbbb</code>，即 <code>'ltccbbb'.slice(0, 5)</code>，最终结果是：<code>'ltccb'</code></li>\n<li>第三步：用截取后的字符串 <code>'ltccb'</code> 作为键去命名字符引用表中查询对应的值，即解码。由于引用表 <code>namedCharacterReferences</code> 中不存在键值为 <code>'ltccb'</code> 的项，因此不匹配。</li>\n<li><p>第四步：当发现不匹配时，我们将最大长度减 <code>1</code>，并重新执行第二步，直到找到匹配项为止。在上面这个例子中，最终的匹配项将会是 <code>'lt'</code>。因此，上述文本最终会被解码为：</p>\n<pre class=\"code-rows\"><code> a&lt;ccbbb\n</code></pre>\n</li>\n</ul>\n<p>这样，我们就实现了当字符引用省略分号时按照“最短原则”进行解码。</p>\n<p>下面的 <code>decodeHtml</code> 函数给出了具体实现：</p>\n<pre class=\"code-rows\"><code> // 第一个参数为要被解码的文本内容\n // 第二个参数是一个布尔值，代表文本内容是否作为属性值\n function decodeHtml(rawText, asAttr = false) {\n   let offset = 0\n   const end = rawText.length\n   // 经过解码后的文本将作为返回值被返回\n   let decodedText = ''\n   // 引用表中实体名称的最大长度\n   let maxCRNameLength = 0\n<p>// advance 函数用于消费指定长度的文本<br />\nfunction advance(length) {<br />\noffset += length<br />\nrawText = rawText.slice(length)<br />\n}</p>\n<p>// 消费字符串，直到处理完毕为止<br />\nwhile (offset &lt; end) {<br />\n// 用于匹配字符引用的开始部分，如果匹配成功，那么 head[0] 的值将有三种可能：<br />\n// 1. head[0] === ‘&amp;’，这说明该字符引用是命名字符引用<br />\n// 2. head[0] === ‘&amp;#’，这说明该字符引用是用十进制表示的数字字符引用<br />\n// 3. head[0] === ‘&amp;#x’，这说明该字符引用是用十六进制表示的数字字符引用<br />\nconst head = /&amp;(?:#x?)?/i.exec(rawText)<br />\n// 如果没有匹配，说明已经没有需要解码的内容了<br />\nif (!head) {<br />\n// 计算剩余内容的长度<br />\nconst remaining = end - offset<br />\n// 将剩余内容加到 decodedText 上<br />\ndecodedText += rawText.slice(0, remaining)<br />\n// 消费剩余内容<br />\nadvance(remaining)<br />\nbreak<br />\n}</p>\n<pre><code> // head.index 为匹配的字符 &amp;amp; 在 rawText 中的位置索引\n // 截取字符 &amp;amp; 之前的内容加到 decodedText 上\n decodedText += rawText.slice(0, head.index)\n // 消费字符 &amp;amp; 之前的内容\n advance(head.index)\n\n // 如果满足条件，则说明是命名字符引用，否则为数字字符引用\n if (head[0] === '&amp;amp;') {\n   let name = ''\n   let value\n   // 字符 &amp;amp; 的下一个字符必须是 ASCII 字母或数字，这样才是合法的命名字符引用\n   if (/[0-9a-z]/i.test(rawText[1])) {\n     // 根据引用表计算实体名称的最大长度，\n     if (!maxCRNameLength) {\n       maxCRNameLength = Object.keys(namedCharacterReferences).reduce(\n         (max, name) =&amp;gt; Math.max(max, name.length),\n         0\n       )\n     }\n     // 从最大长度开始对文本进行截取，并试图去引用表中找到对应的项\n     for (let length = maxCRNameLength; !value &amp;amp;&amp;amp; length &amp;gt; 0; --length) {\n       // 截取字符 &amp;amp; 到最大长度之间的字符作为实体名称\n       name = rawText.substr(1, length)\n       // 使用实体名称去索引表中查找对应项的值\n       value = (namedCharacterReferences)[name]\n     }\n     // 如果找到了对应项的值，说明解码成功\n     if (value) {\n       // 检查实体名称的最后一个匹配字符是否是分号\n       const semi = name.endsWith(';')\n       // 如果解码的文本作为属性值，最后一个匹配的字符不是分号，\n       // 并且最后一个匹配字符的下一个字符是等于号（=）、ASCII 字母或数字，\n       // 由于历史原因，将字符 &amp;amp; 和实体名称 name 作为普通文本\n       if (\n         asAttr &amp;amp;&amp;amp;\n         !semi &amp;amp;&amp;amp;\n         /[=a-z0-9]/i.test(rawText[name.length + 1] || '')\n       ) {\n         decodedText += '&amp;amp;' + name\n         advance(1 + name.length)\n       } else {\n         // 其他情况下，正常使用解码后的内容拼接到 decodedText 上\n         decodedText += value\n         advance(1 + name.length)\n       }\n     } else {\n       // 如果没有找到对应的值，说明解码失败\n       decodedText += '&amp;amp;' + name\n       advance(1 + name.length)\n     }\n   } else {\n     // 如果字符 &amp;amp; 的下一个字符不是 ASCII 字母或数字，则将字符 &amp;amp; 作为普通文本\n     decodedText += '&amp;amp;'\n     advance(1)\n   }\n }\n</code></pre>\n<p>}<br />\nreturn decodedText<br />\n}<br />\n</code></pre></p>\n<p>有了 <code>decodeHtml</code> 函数之后，我们就可以在解析文本节点时通过它对文本内容进行解码：</p>\n<pre class=\"code-rows\"><code> function parseText(context) {\n   // 省略部分代码\n<p>return {<br />\ntype: ‘Text’,<br />\ncontent: decodeHtml(content) // 调用 decodeHtml 函数解码内容<br />\n}<br />\n}<br />\n</code></pre></p>\n<h3 id=\"nav_point_161\">16.6.3　解码数字字符引用</h3>\n<p>在上一节中，我们使用下面的正则表达式来匹配一个文本中字符引用的开始部分：</p>\n<pre class=\"code-rows\"><code> const head = /&amp;(?:#x?)?/i.exec(rawText)\n</code></pre>\n<p>我们可以根据该正则的匹配结果，来判断字符引用的类型。</p>\n<ul>\n<li>如果 <code>head[0] === '&amp;'</code>，则说明匹配的是命名字符引用。</li>\n<li>如果 <code>head[0] === '&amp;#'</code>，则说明匹配的是以十进制表示的数字字符引用。</li>\n<li>如果 <code>head[0] === '&amp;#x'</code>，则说明匹配的是以十六进制表示的数字字符引用。</li>\n</ul>\n<p>数字字符引用的格式是：前缀 + Unicode 码点。解码数字字符引用的关键在于，如何提取字符引用中的 Unicode 码点。考虑到数字字符引用的前缀可以是以十进制表示（<code>&amp;#</code>），也可以是以十六进制表示（<code>&amp;#x</code>），所以我们使用下面的代码来完成码点的提取：</p>\n<pre class=\"code-rows\"><code> // 判断是以十进制表示还是以十六进制表示\n const hex = head[0] === '&amp;#x'\n // 根据不同进制表示法，选用不同的正则\n const pattern = hex ? /^&amp;#x([0-9a-f]+);?/i : /^&amp;#([0-9]+);?/\n // 最终，body[1] 的值就是 Unicode 码点\n const body = pattern.exec(rawText)\n</code></pre>\n<p>有了 Unicode 码点之后，只需要调用 <code>String.fromCodePoint</code> 函数即可将其解码为对应的字符：</p>\n<pre class=\"code-rows\"><code> if (body) {\n   // 根据对应的进制，将码点字符串转换为数字\n   const cp = parseInt(body[1], hex ? 16 : 10)\n   // 解码\n   const char = String.fromCodePoint(cp)\n }\n</code></pre>\n<p>不过，在真正进行解码前，需要对码点的值进行合法性检查。WHATWG 规范中对此也有明确的定义。</p>\n<ul>\n<li>如果码点值为 <code>0x00</code>，即十进制的数字 <code>0</code>，它在 Unicode 中代表空字符（<code>NULL</code>），这将是一个解析错误，解析器会将码点值替换为 <code>0xFFFD</code>。</li>\n<li>如果码点值大于 <code>0x10FFFF</code>（<code>0x10FFFF</code> 为 Unicode 的最大值），这也是一个解析错误，解析器会将码点值替换为 <code>0xFFFD</code>。</li>\n<li>如果码点值处于<strong>代理对</strong>（surrogate pair）范围内，这也是一个解析错误，解析器会将码点值替换为 <code>0xFFFD</code>，其中 surrogate pair 是预留给 UTF-16 的码位，其范围是：<code>[0xD800, 0xDFFF]</code>。</li>\n<li>如果码点值是 <code>noncharacter</code>，这也是一个解析错误，但什么都不需要做。这里的 <code>noncharacter</code> 代表 Unicode 永久保留的码点，用于 Unicode 内部，它的取值范围是：<code>[0xFDD0, 0xFDEF]</code>，还包括：<code>0xFFFE</code>、<code>0xFFFF</code>、<code>0x1FFFE</code>、<code>0x1FFFF</code>、<code>0x2FFFE</code>、<code>0x2FFFF</code>、<code>0x3FFFE</code>、<code>0x3FFFF</code>、<code>0x4FFFE</code>、<code>0x4FFFF</code>、<code>0x5FFFE</code>、<code>0x5FFFF</code>、<code>0x6FFFE</code>、<code>0x6FFFF</code>、<code>0x7FFFE</code>、<code>0x7FFFF</code>、<code>0x8FFFE</code>、<code>0x8FFFF</code>、<code>0x9FFFE</code>、<code>0x9FFFF</code>、<code>0xAFFFE</code>、<code>0xAFFFF</code>、<code>0xBFFFE</code>、<code>0xBFFFF</code>、<code>0xCFFFE</code>、<code>0xCFFFF</code>、<code>0xDFFFE</code>、<code>0xDFFFF</code>、<code>0xEFFFE</code>、<code>0xEFFFF</code>、<code>0xFFFFE</code>、<code>0xFFFFF</code>、<code>0x10FFFE</code>、<code>0x10FFFF</code>。</li>\n<li><p>如果码点值对应的字符是回车符（<code>0x0D</code>），或者码点值为<strong>控制字符集</strong>（control character）中的非 ASCII 空白符（ASCII whitespace），则是一个解析错误。这时需要将码点作为索引，在下表中查找对应的替换码点：</p>\n<pre class=\"code-rows\"><code> const CCR_REPLACEMENTS = {\n   0x80: 0x20ac,\n   0x82: 0x201a,\n   0x83: 0x0192,\n   0x84: 0x201e,\n   0x85: 0x2026,\n   0x86: 0x2020,\n   0x87: 0x2021,\n   0x88: 0x02c6,\n   0x89: 0x2030,\n   0x8a: 0x0160,\n   0x8b: 0x2039,\n   0x8c: 0x0152,\n   0x8e: 0x017d,\n   0x91: 0x2018,\n   0x92: 0x2019,\n   0x93: 0x201c,\n   0x94: 0x201d,\n   0x95: 0x2022,\n   0x96: 0x2013,\n   0x97: 0x2014,\n   0x98: 0x02dc,\n   0x99: 0x2122,\n   0x9a: 0x0161,\n   0x9b: 0x203a,\n   0x9c: 0x0153,\n   0x9e: 0x017e,\n   0x9f: 0x0178\n }\n</code></pre>\n<p>如果存在对应的替换码点，则渲染该替换码点对应的字符，否则直接渲染原码点对应的字符。</p>\n</li>\n</ul>\n<p>上述关于码点合法性检查的具体实现如下：</p>\n<pre class=\"code-rows\"><code> if (body) {\n   // 根据对应的进制，将码点字符串转换为数字\n   const cp = parseInt(body[1], hex ? 16 : 10)\n   // 检查码点的合法性\n   if (cp === 0) {\n     // 如果码点值为 0x00，替换为 0xfffd\n     cp = 0xfffd\n   } else if (cp &gt; 0x10ffff) {\n     // 如果码点值超过 Unicode 的最大值，替换为 0xfffd\n     cp = 0xfffd\n   } else if (cp &gt;= 0xd800 &amp;&amp; cp &lt;= 0xdfff) {\n     // 如果码点值处于 surrogate pair 范围内，替换为 0xfffd\n     cp = 0xfffd\n   } else if ((cp &gt;= 0xfdd0 &amp;&amp; cp &lt;= 0xfdef) || (cp &amp; 0xfffe) === 0xfffe) {\n     // 如果码点值处于 noncharacter 范围内，则什么都不做，交给平台处理\n     // noop\n   } else if (\n     // 控制字符集的范围是：[0x01, 0x1f] 加上 [0x7f, 0x9f]\n     // 去掉 ASICC 空白符：0x09(TAB)、0x0A(LF)、0x0C(FF)\n     // 0x0D(CR) 虽然也是 ASICC 空白符，但需要包含\n     (cp &gt;= 0x01 &amp;&amp; cp &lt;= 0x08) ||\n     cp === 0x0b ||\n     (cp &gt;= 0x0d &amp;&amp; cp &lt;= 0x1f) ||\n     (cp &gt;= 0x7f &amp;&amp; cp &lt;= 0x9f)\n   ) {\n     // 在 CCR_REPLACEMENTS 表中查找替换码点，如果找不到，则使用原码点\n     cp = CCR_REPLACEMENTS[cp] || cp\n   }\n   // 最后进行解码\n   const char = String.fromCodePoint(cp)\n }\n</code></pre>\n<p>在上面这段代码中，我们完整地还原了码点合法性检查的逻辑，它有如下几个关键点。</p>\n<ul>\n<li>其中<strong>控制字符集</strong>（control character）的码点范围是：<code>[0x01, 0x1f]</code> 和 <code>[0x7f, 0x9f]</code>。这个码点范围包含了 ASCII 空白符：<code>0x09(TAB)</code>、<code>0x0A(LF)</code>、<code>0x0C(FF)</code> 和 <code>0x0D(CR)</code>，但 WHATWG 规范中要求包含 <code>0x0D(CR)</code>。</li>\n<li>码点 <code>0xfffd</code> 对应的符号是 �。你一定在出现“乱码”的情况下见过这个字符，它是 Unicode 中的替换字符，通常表示在解码过程中出现“错误”，例如使用了错误的解码方式等。</li>\n</ul>\n<p>最后，我们将上述代码整合到 <code>decodeHtml</code> 函数中，这样就实现一个完善的 HTML 文本解码函数：</p>\n<pre class=\"code-rows\"><code> function decodeHtml(rawText, asAttr = false) {\n   // 省略部分代码\n<p>// 消费字符串，直到处理完毕为止<br />\nwhile (offset &lt; end) {<br />\n// 省略部分代码</p>\n<pre><code> // 如果满足条件，则说明是命名字符引用，否则为数字字符引用\n if (head[0] === '&amp;amp;') {\n   // 省略部分代码\n } else {\n   // 判断是十进制表示还是十六进制表示\n   const hex = head[0] === '&amp;amp;#x'\n   // 根据不同进制表示法，选用不同的正则\n   const pattern = hex ? /^&amp;amp;#x([0-9a-f]+);?/i : /^&amp;amp;#([0-9]+);?/\n   // 最终，body[1] 的值就是 Unicode 码点\n   const body = pattern.exec(rawText)\n\n   // 如果匹配成功，则调用 String.fromCodePoint 函数进行解码\n   if (body) {\n     // 根据对应的进制，将码点字符串转换为数字\n     const cp = Number.parseInt(body[1], hex ? 16 : 10)\n     // 码点的合法性检查\n     if (cp === 0) {\n       // 如果码点值为 0x00，替换为 0xfffd\n       cp = 0xfffd\n     } else if (cp &amp;gt; 0x10ffff) {\n       // 如果码点值超过 Unicode 的最大值，替换为 0xfffd\n       cp = 0xfffd\n     } else if (cp &amp;gt;= 0xd800 &amp;amp;&amp;amp; cp &amp;lt;= 0xdfff) {\n       // 如果码点值处于 surrogate pair 范围内，替换为 0xfffd\n       cp = 0xfffd\n     } else if ((cp &amp;gt;= 0xfdd0 &amp;amp;&amp;amp; cp &amp;lt;= 0xfdef) || (cp &amp;amp; 0xfffe) === 0xfffe) {\n       // 如果码点值处于 noncharacter 范围内，则什么都不做，交给平台处理\n       // noop\n     } else if (\n       // 控制字符集的范围是：[0x01, 0x1f] 加上 [0x7f, 0x9f]\n       // 去掉 ASICC 空白符：0x09(TAB)、0x0A(LF)、0x0C(FF)\n       // 0x0D(CR) 虽然也是 ASICC 空白符，但需要包含\n       (cp &amp;gt;= 0x01 &amp;amp;&amp;amp; cp &amp;lt;= 0x08) ||\n       cp === 0x0b ||\n       (cp &amp;gt;= 0x0d &amp;amp;&amp;amp; cp &amp;lt;= 0x1f) ||\n       (cp &amp;gt;= 0x7f &amp;amp;&amp;amp; cp &amp;lt;= 0x9f)\n     ) {\n       // 在 CCR_REPLACEMENTS 表中查找替换码点，如果找不到，则使用原码点\n       cp = CCR_REPLACEMENTS[cp] || cp\n     }\n     // 解码后追加到 decodedText 上\n     decodedText += String.fromCodePoint(cp)\n     // 消费整个数字字符引用的内容\n     advance(body[0].length)\n   } else {\n     // 如果没有匹配，则不进行解码操作，只是把 head[0] 追加到 decodedText 上并消费\n     decodedText += head[0]\n     advance(head[0].length)\n   }\n }\n</code></pre>\n<p>}<br />\nreturn decodedText<br />\n}<br />\n</code></pre></p>\n<h2 id=\"nav_point_162\">16.7　解析插值与注释</h2>\n<p>文本插值是 Vue.js 模板中用来渲染动态数据的常用方法：</p>\n<pre class=\"code-rows\"><code> {{ count }}\n</code></pre>\n<p>默认情况下，插值以字符串 <code>{{</code> 开头，并以字符串 <code>}}</code> 结尾。我们通常将这两个特殊的字符串称为定界符。定界符中间的内容可以是任意合法的 JavaScript 表达式，例如：</p>\n<pre class=\"code-rows\"><code> {{ obj.foo }}\n</code></pre>\n<p>或</p>\n<pre class=\"code-rows\"><code> {{ obj.fn() }}\n</code></pre>\n<p>解析器在遇到文本插值的起始定界符(<code>{{</code>)时，会进入文本“插值状态 6”，并调用 <code>parseInterpolation</code> 函数来解析插值内容，如图 16-22 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00654.jpeg\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-22　<code>parseChildren</code> 函数在解析模板过程中的状态迁移过程</strong></p>\n<p>解析器在解析插值时，只需要将文本插值的开始定界符与结束定界符之间的内容提取出来，作为 JavaScript 表达式即可，具体实现如下：</p>\n<pre class=\"code-rows\"><code> function parseInterpolation(context) {\n   // 消费开始定界符\n   context.advanceBy('{{'.length)\n   // 找到结束定界符的位置索引\n   closeIndex = context.source.indexOf('}}')\n   if (closeIndex &lt; 0) {\n     console.error('插值缺少结束定界符')\n   }\n   // 截取开始定界符与结束定界符之间的内容作为插值表达式\n   const content = context.source.slice(0, closeIndex)\n   // 消费表达式的内容\n   context.advanceBy(content.length)\n   // 消费结束定界符\n   context.advanceBy('}}'.length)\n<p>// 返回类型为 Interpolation 的节点，代表插值节点<br />\nreturn {<br />\ntype: ‘Interpolation’,<br />\n// 插值节点的 content 是一个类型为 Expression 的表达式节点<br />\ncontent: {<br />\ntype: ‘Expression’,<br />\n// 表达式节点的内容则是经过 HTML 解码后的插值表达式<br />\ncontent: decodeHtml(content)<br />\n}<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>配合上面的 <code>parseInterpolation</code> 函数，解析如下模板内容：</p>\n<pre class=\"code-rows\"><code> const ast = parse(`&lt;div&gt;foo {{ bar }} baz&lt;/div&gt;`)\n</code></pre>\n<p>最终将得到如下 AST：</p>\n<pre class=\"code-rows\"><code> const ast = {\n   type: 'Root',\n   children: [\n     {\n       type: 'Element',\n       tag: 'div',\n       isSelfClosing: false,\n       props: [],\n       children: [\n         { type: 'Text', content: 'foo ' },\n         // 插值节点\n         {\n           type: 'Interpolation',\n           content: [\n             type: 'Expression',\n             content: ' bar '\n           ]\n         },\n         { type: 'Text', content: ' baz' }\n       ]\n     }\n   ]\n }\n</code></pre>\n<p>解析注释的思路与解析插值非常相似，如下面的 <code>parseComment</code> 函数所示：</p>\n<pre class=\"code-rows\"><code> function parseComment(context) {\n   // 消费注释的开始部分\n   context.advanceBy('&lt;!--'.length)\n   // 找到注释结束部分的位置索引\n   closeIndex = context.source.indexOf('--&gt;')\n   // 截取注释节点的内容\n   const content = context.source.slice(0, closeIndex)\n   // 消费内容\n   context.advanceBy(content.length)\n   // 消费注释的结束部分\n   context.advanceBy('--&gt;'.length)\n   // 返回类型为 Comment 的节点\n   return {\n     type: 'Comment',\n     content\n   }\n }\n</code></pre>\n<p>配合 <code>parseComment</code> 函数，解析如下模板内容：</p>\n<pre class=\"code-rows\"><code> const ast = parse(`&lt;div&gt;&lt;!-- comments --&gt;&lt;/div&gt;`)\n</code></pre>\n<p>最终得到如下 AST：</p>\n<pre class=\"code-rows\"><code> const ast = {\n   type: 'Root',\n   children: [\n     {\n       type: 'Element',\n       tag: 'div',\n       isSelfClosing: false,\n       props: [],\n       children: [\n         { type: 'Comment', content: ' comments ' }\n       ]\n     }\n   ]\n }\n</code></pre>\n<h2 id=\"nav_point_163\">16.8　总结</h2>\n<p>在本章中，我们首先讨论了解析器的文本模式及其对解析器的影响。文本模式指的是解析器在工作时所进入的一些特殊状态，如 <code>RCDATA</code> 模式、<code>CDATA</code> 模式、<code>RAWTEXT</code> 模式，以及初始的 <code>DATA</code> 模式等。在不同模式下，解析器对文本的解析行为会有所不同。</p>\n<p>接着，我们讨论了如何使用递归下降算法构造模板 AST。在 <code>parseChildren</code> 函数运行的过程中，为了处理标签节点，会调用 <code>parseElement</code> 解析函数，这会间接地调用 <code>parseChildren</code> 函数，并产生一个新的状态机。随着标签嵌套层次的增加，新的状态机也会随着 <code>parseChildren</code> 函数被递归地调用而不断创建，这就是“递归下降”中“递归”二字的含义。而上级 <code>parseChildren</code> 函数的调用用于构造上级模板 AST 节点，被递归调用的下级 <code>parseChildren</code> 函数则用于构造下级模板 AST 节点。最终会构造出一棵树型结构的模板 AST，这就是“递归下降”中“下降”二字的含义。</p>\n<p>在解析模板构建 AST 的过程中，<code>parseChildren</code> 函数是核心。每次调用 <code>parseChildren</code> 函数，就意味着新状态机的开启。状态机的结束时机有两个。</p>\n<ul>\n<li>第一个停止时机是当模板内容被解析完毕时。</li>\n<li>第二个停止时机则是遇到结束标签时，这时解析器会取得父级节点栈栈顶的节点作为父节点，检查该结束标签是否与父节点的标签同名，如果相同，则状态机停止运行。</li>\n</ul>\n<p>我们还讨论了文本节点的解析。解析文本节点本身并不复杂，它的复杂点在于，我们需要对解析后的文本内容进行 HTML 实体的解码工作。WHATWG 规范中也定义了解码 HTML 实体过程中的状态迁移流程。HTML 实体类型有两种，分别是命名字符引用和数字字符引用。命名字符引用的解码方案可以总结为两种。</p>\n<ul>\n<li>当存在分号时：执行完整匹配。</li>\n<li>当省略分号时：执行最短匹配。</li>\n</ul>\n<p>对于数字字符引用，则需要按照 WHATWG 规范中定义的规则逐步实现。</p>\n<br style=\"page-break-after:always\" />","comments":[]}