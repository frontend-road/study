{"id":98134,"title":"40 | 案例分析（三）：高性能队列Disruptor","content":"<p>我们在<a href=\"https://time.geekbang.org/column/article/90201\">《20 | 并发容器：都有哪些“坑”需要我们填？》</a>介绍过Java SDK提供了2个有界队列：ArrayBlockingQueue 和 LinkedBlockingQueue，它们都是基于ReentrantLock实现的，在高并发场景下，锁的效率并不高，那有没有更好的替代品呢？有，今天我们就介绍一种性能更高的有界队列：Disruptor。</p><p><strong>Disruptor是一款高性能的有界内存队列</strong>，目前应用非常广泛，Log4j2、Spring Messaging、HBase、Storm都用到了Disruptor，那Disruptor的性能为什么这么高呢？Disruptor项目团队曾经写过一篇论文，详细解释了其原因，可以总结为如下：</p><ol>\n<li>内存分配更加合理，使用RingBuffer数据结构，数组元素在初始化时一次性全部创建，提升缓存命中率；对象循环利用，避免频繁GC。</li>\n<li>能够避免伪共享，提升缓存利用率。</li>\n<li>采用无锁算法，避免频繁加锁、解锁的性能消耗。</li>\n<li>支持批量消费，消费者可以无锁方式消费多个消息。</li>\n</ol><p>其中，前三点涉及到的知识比较多，所以今天咱们重点讲解前三点，不过在详细介绍这些知识之前，我们先来聊聊Disruptor如何使用，好让你先对Disruptor有个感官的认识。</p><!-- [[[read_end]]] --><p>下面的代码出自官方示例，我略做了一些修改，相较而言，Disruptor的使用比Java SDK提供BlockingQueue要复杂一些，但是总体思路还是一致的，其大致情况如下：</p><ul>\n<li>在Disruptor中，生产者生产的对象（也就是消费者消费的对象）称为Event，使用Disruptor必须自定义Event，例如示例代码的自定义Event是LongEvent；</li>\n<li>构建Disruptor对象除了要指定队列大小外，还需要传入一个EventFactory，示例代码中传入的是<code>LongEvent::new</code>；</li>\n<li>消费Disruptor中的Event需要通过handleEventsWith()方法注册一个事件处理器，发布Event则需要通过publishEvent()方法。</li>\n</ul><pre><code>//自定义Event\nclass LongEvent {\n  private long value;\n  public void set(long value) {\n    this.value = value;\n  }\n}\n//指定RingBuffer大小,\n//必须是2的N次方\nint bufferSize = 1024;\n\n//构建Disruptor\nDisruptor&lt;LongEvent&gt; disruptor \n  = new Disruptor&lt;&gt;(\n    LongEvent::new,\n    bufferSize,\n    DaemonThreadFactory.INSTANCE);\n\n//注册事件处理器\ndisruptor.handleEventsWith(\n  (event, sequence, endOfBatch) -&gt;\n    System.out.println(&quot;E: &quot;+event));\n\n//启动Disruptor\ndisruptor.start();\n\n//获取RingBuffer\nRingBuffer&lt;LongEvent&gt; ringBuffer \n  = disruptor.getRingBuffer();\n//生产Event\nByteBuffer bb = ByteBuffer.allocate(8);\nfor (long l = 0; true; l++){\n  bb.putLong(0, l);\n  //生产者生产消息\n  ringBuffer.publishEvent(\n    (event, sequence, buffer) -&gt; \n      event.set(buffer.getLong(0)), bb);\n  Thread.sleep(1000);\n}\n</code></pre><h2>RingBuffer如何提升性能</h2><p>Java SDK中ArrayBlockingQueue使用<strong>数组</strong>作为底层的数据存储，而Disruptor是使用<strong>RingBuffer</strong>作为数据存储。RingBuffer本质上也是数组，所以仅仅将数据存储从数组换成RingBuffer并不能提升性能，但是Disruptor在RingBuffer的基础上还做了很多优化，其中一项优化就是和内存分配有关的。</p><p>在介绍这项优化之前，你需要先了解一下程序的局部性原理。简单来讲，<strong>程序的局部性原理指的是在一段时间内程序的执行会限定在一个局部范围内</strong>。这里的“局部性”可以从两个方面来理解，一个是时间局部性，另一个是空间局部性。<strong>时间局部性</strong>指的是程序中的某条指令一旦被执行，不久之后这条指令很可能再次被执行；如果某条数据被访问，不久之后这条数据很可能再次被访问。而<strong>空间局部性</strong>是指某块内存一旦被访问，不久之后这块内存附近的内存也很可能被访问。</p><p>CPU的缓存就利用了程序的局部性原理：CPU从内存中加载数据X时，会将数据X缓存在高速缓存Cache中，实际上CPU缓存X的同时，还缓存了X周围的数据，因为根据程序具备局部性原理，X周围的数据也很有可能被访问。从另外一个角度来看，如果程序能够很好地体现出局部性原理，也就能更好地利用CPU的缓存，从而提升程序的性能。Disruptor在设计RingBuffer的时候就充分考虑了这个问题，下面我们就对比着ArrayBlockingQueue来分析一下。</p><p>首先是ArrayBlockingQueue。生产者线程向ArrayBlockingQueue增加一个元素，每次增加元素E之前，都需要创建一个对象E，如下图所示，ArrayBlockingQueue内部有6个元素，这6个元素都是由生产者线程创建的，由于创建这些元素的时间基本上是离散的，所以这些元素的内存地址大概率也不是连续的。</p><p><img src=\"https://static001.geekbang.org/resource/image/84/90/848fd30644355ea86f3f91b06bfafa90.png?wh=1142*393\" alt=\"\"></p><center><span class=\"reference\">ArrayBlockingQueue内部结构图</span></center><p>下面我们再看看Disruptor是如何处理的。Disruptor内部的RingBuffer也是用数组实现的，但是这个数组中的所有元素在初始化时是一次性全部创建的，所以这些元素的内存地址大概率是连续的，相关的代码如下所示。</p><pre><code>for (int i=0; i&lt;bufferSize; i++){\n  //entries[]就是RingBuffer内部的数组\n  //eventFactory就是前面示例代码中传入的LongEvent::new\n  entries[BUFFER_PAD + i] \n    = eventFactory.newInstance();\n}\n</code></pre><p>Disruptor内部RingBuffer的结构可以简化成下图，那问题来了，数组中所有元素内存地址连续能提升性能吗？能！为什么呢？因为消费者线程在消费的时候，是遵循空间局部性原理的，消费完第1个元素，很快就会消费第2个元素；当消费第1个元素E1的时候，CPU会把内存中E1后面的数据也加载进Cache，如果E1和E2在内存中的地址是连续的，那么E2也就会被加载进Cache中，然后当消费第2个元素的时候，由于E2已经在Cache中了，所以就不需要从内存中加载了，这样就能大大提升性能。</p><p><img src=\"https://static001.geekbang.org/resource/image/33/37/33bc0d35615f5d5f7869871e0cfed037.png?wh=1142*568\" alt=\"\"></p><center><span class=\"reference\">Disruptor内部RingBuffer结构图</span></center><p>除此之外，在Disruptor中，生产者线程通过publishEvent()发布Event的时候，并不是创建一个新的Event，而是通过event.set()方法修改Event， 也就是说RingBuffer创建的Event是可以循环利用的，这样还能避免频繁创建、删除Event导致的频繁GC问题。</p><h2>如何避免“伪共享”</h2><p>高效利用Cache，能够大大提升性能，所以要努力构建能够高效利用Cache的内存结构。而从另外一个角度看，努力避免不能高效利用Cache的内存结构也同样重要。</p><p>有一种叫做“伪共享（False sharing）”的内存布局就会使Cache失效，那什么是“伪共享”呢？</p><p>伪共享和CPU内部的Cache有关，Cache内部是按照缓存行（Cache Line）管理的，缓存行的大小通常是64个字节；CPU从内存中加载数据X，会同时加载X后面（64-size(X)）个字节的数据。下面的示例代码出自Java SDK的ArrayBlockingQueue，其内部维护了4个成员变量，分别是队列数组items、出队索引takeIndex、入队索引putIndex以及队列中的元素总数count。</p><pre><code>/** 队列数组 */\nfinal Object[] items;\n/** 出队索引 */\nint takeIndex;\n/** 入队索引 */\nint putIndex;\n/** 队列中元素总数 */\nint count;\n</code></pre><p>当CPU从内存中加载takeIndex的时候，会同时将putIndex以及count都加载进Cache。下图是某个时刻CPU中Cache的状况，为了简化，缓存行中我们仅列出了takeIndex和putIndex。</p><p><img src=\"https://static001.geekbang.org/resource/image/fd/5c/fdccf96bda79453e55ed75e418864b5c.png?wh=1142*681\" alt=\"\"></p><center><span class=\"reference\">CPU缓存示意图</span></center><p>假设线程A运行在CPU-1上，执行入队操作，入队操作会修改putIndex，而修改putIndex会导致其所在的所有核上的缓存行均失效；此时假设运行在CPU-2上的线程执行出队操作，出队操作需要读取takeIndex，由于takeIndex所在的缓存行已经失效，所以CPU-2必须从内存中重新读取。入队操作本不会修改takeIndex，但是由于takeIndex和putIndex共享的是一个缓存行，就导致出队操作不能很好地利用Cache，这其实就是<strong>伪共享</strong>。简单来讲，<strong>伪共享指的是由于共享缓存行导致缓存无效的场景</strong>。</p><p>ArrayBlockingQueue的入队和出队操作是用锁来保证互斥的，所以入队和出队不会同时发生。如果允许入队和出队同时发生，那就会导致线程A和线程B争用同一个缓存行，这样也会导致性能问题。所以为了更好地利用缓存，我们必须避免伪共享，那如何避免呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/d5/27/d5d5afc11fe6b1aaf8c9be7dba643827.png?wh=1142*679\" alt=\"\"></p><center><span class=\"reference\">CPU缓存失效示意图</span></center><p>方案很简单，<strong>每个变量独占一个缓存行、不共享缓存行</strong>就可以了，具体技术是<strong>缓存行填充</strong>。比如想让takeIndex独占一个缓存行，可以在takeIndex的前后各填充56个字节，这样就一定能保证takeIndex独占一个缓存行。下面的示例代码出自Disruptor，Sequence 对象中的value属性就能避免伪共享，因为这个属性前后都填充了56个字节。Disruptor中很多对象，例如RingBuffer、RingBuffer内部的数组都用到了这种填充技术来避免伪共享。</p><pre><code>//前：填充56字节\nclass LhsPadding{\n    long p1, p2, p3, p4, p5, p6, p7;\n}\nclass Value extends LhsPadding{\n    volatile long value;\n}\n//后：填充56字节\nclass RhsPadding extends Value{\n    long p9, p10, p11, p12, p13, p14, p15;\n}\nclass Sequence extends RhsPadding{\n  //省略实现\n}\n</code></pre><h2>Disruptor中的无锁算法</h2><p>ArrayBlockingQueue是利用管程实现的，中规中矩，生产、消费操作都需要加锁，实现起来简单，但是性能并不十分理想。Disruptor采用的是无锁算法，很复杂，但是核心无非是生产和消费两个操作。Disruptor中最复杂的是入队操作，所以我们重点来看看入队操作是如何实现的。</p><p>对于入队操作，最关键的要求是不能覆盖没有消费的元素；对于出队操作，最关键的要求是不能读取没有写入的元素，所以Disruptor中也一定会维护类似出队索引和入队索引这样两个关键变量。Disruptor中的RingBuffer维护了入队索引，但是并没有维护出队索引，这是因为在Disruptor中多个消费者可以同时消费，每个消费者都会有一个出队索引，所以RingBuffer的出队索引是所有消费者里面最小的那一个。</p><p>下面是Disruptor生产者入队操作的核心代码，看上去很复杂，其实逻辑很简单：如果没有足够的空余位置，就出让CPU使用权，然后重新计算；反之则用CAS设置入队索引。</p><pre><code>//生产者获取n个写入位置\ndo {\n  //cursor类似于入队索引，指的是上次生产到这里\n  current = cursor.get();\n  //目标是在生产n个\n  next = current + n;\n  //减掉一个循环\n  long wrapPoint = next - bufferSize;\n  //获取上一次的最小消费位置\n  long cachedGatingSequence = gatingSequenceCache.get();\n  //没有足够的空余位置\n  if (wrapPoint&gt;cachedGatingSequence || cachedGatingSequence&gt;current){\n    //重新计算所有消费者里面的最小值位置\n    long gatingSequence = Util.getMinimumSequence(\n        gatingSequences, current);\n    //仍然没有足够的空余位置，出让CPU使用权，重新执行下一循环\n    if (wrapPoint &gt; gatingSequence){\n      LockSupport.parkNanos(1);\n      continue;\n    }\n    //从新设置上一次的最小消费位置\n    gatingSequenceCache.set(gatingSequence);\n  } else if (cursor.compareAndSet(current, next)){\n    //获取写入位置成功，跳出循环\n    break;\n  }\n} while (true);\n</code></pre><h2>总结</h2><p>Disruptor在优化并发性能方面可谓是做到了极致，优化的思路大体是两个方面，一个是利用无锁算法避免锁的争用，另外一个则是将硬件（CPU）的性能发挥到极致。尤其是后者，在Java领域基本上属于经典之作了。</p><p>发挥硬件的能力一般是C这种面向硬件的语言常干的事儿，C语言领域经常通过调整内存布局优化内存占用，而Java领域则用的很少，原因在于Java可以智能地优化内存布局，内存布局对Java程序员的透明的。这种智能的优化大部分场景是很友好的，但是如果你想通过填充方式避免伪共享就必须绕过这种优化，关于这方面Disruptor提供了经典的实现，你可以参考。</p><p>由于伪共享问题如此重要，所以Java也开始重视它了，比如Java 8中，提供了避免伪共享的注解：@sun.misc.Contended，通过这个注解就能轻松避免伪共享（需要设置JVM参数-XX:-RestrictContended）。不过避免伪共享是以牺牲内存为代价的，所以具体使用的时候还是需要仔细斟酌。</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","neighbors":{"left":{"article_title":"39 | 案例分析（二）：高性能网络应用框架Netty","id":97622},"right":{"article_title":"41 | 案例分析（四）：高性能数据库连接池HiKariCP","id":98491}},"comments":[{"had_liked":false,"id":99335,"user_name":"Juc","can_delete":false,"product_type":"c1","uid":1217566,"ip_address":"","ucode":"EF82A73FAA7F8D","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/1e/973cda79.jpg","comment_is_top":false,"comment_ctime":1559195494,"is_pvip":false,"replies":[{"id":"35741","content":"数组连续，数组里只有引用，e1 e2这些对象的地址不连续","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1559226899,"ip_address":"","comment_id":99335,"utype":1}],"discussion_count":2,"race_medal":0,"score":"212012592998","product_id":100023901,"comment_content":"希望老师解释下，为什么创建元素的时间离散会导致元素的内存地址不是连续的?这些元素不是存在数组中的吗？数组初始化不是已经连续分配内存了吗？","like_count":50,"discussions":[{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48054,"discussion_content":"明白了，也就是基础类型的数组，数组是连续的，数组里的值也是连续的；若是对象数组，则数组引用是连续的，数组里存放的元素是离散的","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1573444752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452064,"discussion_content":"数组连续，数组里只有引用，e1 e2这些对象的地址不连续","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1559226899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110090,"user_name":"冰激凌的眼泪","can_delete":false,"product_type":"c1","uid":1087945,"ip_address":"","ucode":"5DCB974667E93A","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg","comment_is_top":false,"comment_ctime":1562169558,"is_pvip":false,"replies":[{"id":"39894","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1562199332,"ip_address":"","comment_id":110090,"utype":1}],"discussion_count":5,"race_medal":0,"score":"91756482774","product_id":100023901,"comment_content":"前后56个字节保证了目标字段总是独占一个cache line，不受周围变量缓存失效的影响","like_count":21,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456718,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562199332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2329635,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8c/23/f1c5bee0.jpg","nickname":"wang.yu","note":"","ucode":"CCA775784B3EB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387083,"discussion_content":"为什么是56个字节","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627977091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1589055,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKKKdCyib4iblXC6JIH7HWDfIFVweTb7SgEOuRjquic3GiaiaGInFSiaU8w2y2bjvZjgiaA3IEQuyibXTaeHQ/132","nickname":"10xiaohu","note":"","ucode":"CAB39DBB93E608","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2329635,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8c/23/f1c5bee0.jpg","nickname":"wang.yu","note":"","ucode":"CCA775784B3EB3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538443,"discussion_content":"56+8=64，long 8个字节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639406040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":387083,"ip_address":""},"score":538443,"extra":""}]},{"author":{"id":1636963,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fa/63/24640b68.jpg","nickname":"张小伙子","note":"","ucode":"FA6844F58ECD39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587467,"discussion_content":"为什么前后都需要56个字节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663069050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2028946,"avatar":"","nickname":"Geek3443","note":"","ucode":"C6351639FD0633","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1636963,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fa/63/24640b68.jpg","nickname":"张小伙子","note":"","ucode":"FA6844F58ECD39","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588057,"discussion_content":"因为，这样就保证了这个对象中，每个属性都肯定都对应一个缓存行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663509341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":587467,"ip_address":"北京"},"score":588057,"extra":""}]}]},{"had_liked":false,"id":268925,"user_name":"万历十五年","can_delete":false,"product_type":"c1","uid":1122150,"ip_address":"","ucode":"3D8CF5DF847AE8","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg","comment_is_top":false,"comment_ctime":1608434760,"is_pvip":false,"replies":[{"id":"97552","content":"������������","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1608465056,"ip_address":"","comment_id":268925,"utype":1}],"discussion_count":1,"race_medal":0,"score":"74622878792","product_id":100023901,"comment_content":"单机提升性能不外乎是围绕CPU，内存和IO想办法。<br>CPU: <br>1.避免线程切换：单线程，对于多线程进行线程绑定，使用CAS无锁技术<br>2.利用CPU缓存，还有缓存填充，设计数据结构和算法<br>内存：<br>1.多级缓存：应用缓存，第三方缓存，系统缓存<br>2.数组优于链表<br>3.避免频繁内存碎片：利用池思想复用对象<br>解决IO产生的速度差:<br>1.多路复用<br>2.队列削峰<br>3.协程","like_count":17,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512084,"discussion_content":"������������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608465056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244133,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1598407590,"is_pvip":false,"replies":[{"id":"90176","content":"👍🏻","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1598870194,"ip_address":"","comment_id":244133,"utype":1}],"discussion_count":2,"race_medal":0,"score":"61727949734","product_id":100023901,"comment_content":"if (wrapPoint&gt;cachedGatingSequence || cachedGatingSequence&gt;current)这个位置的判断原本不明白,看了几遍总算是明白了.    环形队列,生产者从0生产 消费者从0消费.  wrapPoint是指生产了一圈 又达到了 消费者消费的最小的位置   如果此时继续生产,那么消费最少的消费者还未消费的消息将会被生产者覆盖,所以此处要停止.  而 最小消费位置大于生产者当前生产位置的话,说明消费到了生产者还未生产消息的位置,所以等待消息的生产,要停止.","like_count":14,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504494,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598870194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2070984,"avatar":"","nickname":"dominiczhu","note":"","ucode":"9C87F77CCE06C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387533,"discussion_content":"谢谢解答，但是第二个判断条件里，消费者怎么会消费到了未生产消息的位置，什么会造成这种情况呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628235861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99352,"user_name":"LW","can_delete":false,"product_type":"c1","uid":1325297,"ip_address":"","ucode":"89820332658E98","user_header":"https://static001.geekbang.org/account/avatar/00/14/38/f1/996a070d.jpg","comment_is_top":false,"comment_ctime":1559198561,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53098806113","product_id":100023901,"comment_content":"RingBuffer是一个环形队列？","like_count":12},{"had_liked":false,"id":99296,"user_name":"孙志强","can_delete":false,"product_type":"c1","uid":1325997,"ip_address":"","ucode":"9C070F1E4EC6FF","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/ad/31193b83.jpg","comment_is_top":false,"comment_ctime":1559187422,"is_pvip":true,"discussion_count":8,"race_medal":0,"score":"44508860382","product_id":100023901,"comment_content":"程序局部性原理的空间局部性是不是cpu分支预测?缓存行一般是64字节,takeIndex那为何前后填充56个字节,大于64了,怎么独占缓存行?","like_count":10,"discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373215,"discussion_content":"56字节（前），8字节（value），56字节（后）。64字节一个cache line的话不管怎样切都能保证value在一个cache line","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1620652665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179565,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/ad/5020a8c5.jpg","nickname":"Farewell丶","note":"","ucode":"A0D69893C5375C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224768,"discussion_content":"前后填充是想让保证字段独占一行，也就是说我一个人左边或者右边都没有空位的时候，我就肯定是独占一行了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586330541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194853,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3b/65/3a4fc8cf.jpg","nickname":"prepared","note":"","ucode":"00E54A5C7CDCBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336799,"discussion_content":"只加前一个56或者后一个56，并不能保证数据独占一行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608704831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1620479,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b9/ff/ea6c2e86.jpg","nickname":"景梦园","note":"","ucode":"0A17708457ACB2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311177,"discussion_content":"个人理解和分支预测不是一回事，可以参考StackOverflow的经典问题： https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602244463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1496998,"avatar":"https://static001.geekbang.org/account/avatar/00/16/d7/a6/1e94e96f.jpg","nickname":"zojian","note":"","ucode":"5EAFEB779BE5C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217178,"discussion_content":"感觉前填充是填充其他数据的，后填充才是填充自己那一行的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585524873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1106090,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e0/aa/68a7921b.jpg","nickname":"常清","note":"","ucode":"EA6975FDFD4D11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167310,"discussion_content":"Java中int类型自己占8个字节，加上56，刚好等于64","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581476058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1118952,"avatar":"https://static001.geekbang.org/account/avatar/00/11/12/e8/aa60f7f1.jpg","nickname":"赵存金","note":"","ucode":"89D69F8D2DF269","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1106090,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e0/aa/68a7921b.jpg","nickname":"常清","note":"","ucode":"EA6975FDFD4D11","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320873,"discussion_content":"4个字节 老哥","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1604495473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":167310,"ip_address":""},"score":320873,"extra":""}]},{"author":{"id":1008065,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/61/c1/9ad88d67.jpg","nickname":"Mr_杨","note":"","ucode":"AD31C2320DF6A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49538,"discussion_content":"还有数据本身吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573611421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99414,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1559209964,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31623981036","product_id":100023901,"comment_content":"mysql也利用了程序的局部性原理来减少磁盘的io，百度开源的分布式唯一id生成器也使用了RingBuffer，将提前生成的id缓存到RingBuffer中。","like_count":7},{"had_liked":false,"id":199825,"user_name":"😜哈哈","can_delete":false,"product_type":"c1","uid":1069001,"ip_address":"","ucode":"1FF58FB3A91135","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/c9/88837387.jpg","comment_is_top":false,"comment_ctime":1585496535,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"27355300311","product_id":100023901,"comment_content":"小米将disruptor用于秒杀场景","like_count":6,"discussions":[{"author":{"id":1736807,"avatar":"","nickname":"Geek_8593e5","note":"","ucode":"B316E40C400CC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549870,"discussion_content":"请问具体场景是怎么用的？多节点部署吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644285342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2288362,"avatar":"https://static001.geekbang.org/account/avatar/00/22/ea/ea/77a59153.jpg","nickname":"耶马","note":"","ucode":"3A3CF67B016CDB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547183,"discussion_content":"利用Disruptor将并发请求串行化，同时避免了多线程编程复杂度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642572695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129150,"user_name":"xinglichea","can_delete":false,"product_type":"c1","uid":1176447,"ip_address":"","ucode":"986DA07BF3CA89","user_header":"https://static001.geekbang.org/account/avatar/00/11/f3/7f/2dd9409b.jpg","comment_is_top":false,"comment_ctime":1567050156,"is_pvip":false,"replies":[{"id":"48086","content":"我觉得从官方提供注解这一行为来看，应该不至于不靠谱，不过java程序员都习惯于不关注硬件。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1567074453,"ip_address":"","comment_id":129150,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18746919340","product_id":100023901,"comment_content":"老师，感觉填充的模式不是很靠谱，程序的健壮性要强依赖于CPU的缓存行的实现，打个比如，如果以后CPU缓存行变成了128个字节，那企不要写Disruptor的实现源码，然后原来实现的代码仍然会有伪共享的问题！！！","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465305,"discussion_content":"我觉得从官方提供注解这一行为来看，应该不至于不靠谱，不过java程序员都习惯于不关注硬件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567074453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99458,"user_name":"锦","can_delete":false,"product_type":"c1","uid":1468298,"ip_address":"","ucode":"CB0EB4B68C468B","user_header":"https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg","comment_is_top":false,"comment_ctime":1559220671,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18739089855","product_id":100023901,"comment_content":"disruptor高性能主要是以下几点设计：<br>1，仅维护一个共享变量(入队索引)，减少锁竞争，并利用填充行技术解决共享变量的伪共享问题。<br>2，底层使用循环数组作为存储结构，开辟一组连续的内存空间，循环利用减少gc次数，并充分利用了程序局部性原理。<br>3，入队时支持一次性获取多个索引，然后在当前线程写入数据，减少锁竞争，消费时一样。<br>不知道我理解的对不对？","like_count":4,"discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373216,"discussion_content":"环形队列的优势相比非环形队列 数据搬移是0(1)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620652933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248546,"user_name":"那月真美","can_delete":false,"product_type":"c1","uid":1441895,"ip_address":"","ucode":"CEF1AF65C6064E","user_header":"https://static001.geekbang.org/account/avatar/00/16/00/67/e24dd940.jpg","comment_is_top":false,"comment_ctime":1600219708,"is_pvip":false,"replies":[{"id":"91343","content":"Disruptor 内部的 RingBuffer 也是用数组实现的，但是这个数组中的所有元素在初始化时是一次性全部创建的，所以这些元素的内存地址大概率是连续的。一次性全部创建，大概率事关键词。参考文中LongEvent的例子，生产用的是set方法，而不是add方法","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1600346737,"ip_address":"","comment_id":248546,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14485121596","product_id":100023901,"comment_content":"老师，数组内存地址连续，数组里面的引用对象怎么做到连续呢？它不是由生产者产生的吗？何时生产只能由生产者决定，初始化数组的时候怎么一次性初始化数组元素啊？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505678,"discussion_content":"Disruptor 内部的 RingBuffer 也是用数组实现的，但是这个数组中的所有元素在初始化时是一次性全部创建的，所以这些元素的内存地址大概率是连续的。一次性全部创建，大概率事关键词。参考文中LongEvent的例子，生产用的是set方法，而不是add方法","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600346737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99844,"user_name":"爱吃回锅肉的瘦子","can_delete":false,"product_type":"c1","uid":1233867,"ip_address":"","ucode":"24DBDDC62B2276","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/cb/f8157ad8.jpg","comment_is_top":false,"comment_ctime":1559321005,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14444222893","product_id":100023901,"comment_content":"难度指数提升😔只能得多看几遍","like_count":3},{"had_liked":false,"id":270729,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1609230473,"is_pvip":true,"replies":[{"id":"98268","content":"数组里所有的对象的引用一定是连续的，但是对象不一定连续","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1609303383,"ip_address":"","comment_id":270729,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10199165065","product_id":100023901,"comment_content":"1.if (wrapPoint&gt;cachedGatingSequence || cachedGatingSequence&gt;current) 这点开始一直没看懂，之前写过环形队列，每次索引都会重置，就是一直在0-9之间，然后看了下RingBuffer 好像它的索引是一直累加的。这样就好懂多了。<br>2.关于ArrayBlockQueue 添加的对象是不连续的还是不太明白，数组初始化 不是在内存种开辟出一段连续的内存空间吗？ 还是按照有的同学留言所说的，如果是引用对象不一定是连续的。","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512733,"discussion_content":"数组里所有的对象的引用一定是连续的，但是对象不一定连续","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609303383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125183,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1566113622,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10156048214","product_id":100023901,"comment_content":"有个地方没看懂，if (wrapPoint&gt;cachedGatingSequence || cachedGatingSequence&gt;current)，这个条件里面，为何需要cachedGatingSequence&gt;current这个限制呢？<br>是当current突破最大值变为0之后，要等到cachedGatingSequence追上来才继续生产吗？","like_count":2},{"had_liked":false,"id":101037,"user_name":"郑晨Cc","can_delete":false,"product_type":"c1","uid":1324942,"ip_address":"","ucode":"57146E444D6329","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/8e/cf0b4575.jpg","comment_is_top":false,"comment_ctime":1559703926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10149638518","product_id":100023901,"comment_content":"全他妈的是干货 满足！","like_count":2},{"had_liked":false,"id":232641,"user_name":"junshuaizhang","can_delete":false,"product_type":"c1","uid":1101502,"ip_address":"","ucode":"5734A9BEA03149","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/be/5cf3f1a0.jpg","comment_is_top":false,"comment_ctime":1594077535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5889044831","product_id":100023901,"comment_content":"看到最后，我感觉自己拿了一个假学历","like_count":1},{"had_liked":false,"id":224113,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1063734,"ip_address":"","ucode":"EA31201A7C5AE1","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/36/2d61e080.jpg","comment_is_top":false,"comment_ctime":1591277549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886244845","product_id":100023901,"comment_content":"关于伪共享，可以参考这篇文章<br>https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;109874","like_count":1},{"had_liked":false,"id":155711,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1574741130,"is_pvip":false,"replies":[{"id":"65945","content":"缓存导致的可见性问题靠的是HB规则，锁是靠HB规则解决缓存问题的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1578489098,"ip_address":"","comment_id":155711,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5869708426","product_id":100023901,"comment_content":"ArrayBlockingQueue 的入队和出队操作是用锁来保证互斥的，所以入队和出队不会同时发生。如果允许入队和出队同时发生，那就会导致线程 A 和线程 B 争用同一个缓存行，这样也会导致性能问题。<br><br>想问下加锁了就没有缓存干扰了吗！为啥？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475845,"discussion_content":"缓存导致的可见性问题靠的是HB规则，锁是靠HB规则解决缓存问题的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578489098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287273,"discussion_content":"加锁之后，入队出队都串行化了。同时根据HB规则，解锁操作HB后续同一个锁的加锁操作，也就是说，解锁会强行刷缓存，所以没有缓存干扰的问题，","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1593410394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100198,"user_name":"码农Kevin亮","can_delete":false,"product_type":"c1","uid":1116630,"ip_address":"","ucode":"D34562461CA0A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","comment_is_top":false,"comment_ctime":1559476938,"is_pvip":false,"replies":[{"id":"36136","content":"共享，指的是多个核能共享缓存，避免伪共享后，多个核是可以共享缓存的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1559541937,"ip_address":"","comment_id":100198,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5854444234","product_id":100023901,"comment_content":"老师，避免伪共享的逻辑有点困惑：<br>伪共享逻辑上就是没实现共享，而disruptor用行填充也是没实现共享。那么为什么避免伪共享就能提升性能呢？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452445,"discussion_content":"共享，指的是多个核能共享缓存，避免伪共享后，多个核是可以共享缓存的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559541937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99308,"user_name":"henry","can_delete":false,"product_type":"c1","uid":1075941,"ip_address":"","ucode":"0ACD12F363F8DE","user_header":"http://thirdqq.qlogo.cn/qqapp/101418266/D6DD8CB1004D442B48914656340277F3/100","comment_is_top":false,"comment_ctime":1559189419,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5854156715","product_id":100023901,"comment_content":"我用过apache storm，之前想了解底层原理，在网上查资料说是用到了disruptor, 然后看到网上的资料说它快的原因就是用到了伪共享，但是网上都没有说到点上，就是把伪共享的原理说了一遍。。。看的云里雾里的，看了老师的文章总算是明白了，主要是针对入队和出队索引，让它们分别独占行，不够字节数的补全","like_count":1},{"had_liked":false,"id":99186,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1559175998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5854143294","product_id":100023901,"comment_content":"打卡！","like_count":1},{"had_liked":false,"id":353434,"user_name":"Peter Yu","can_delete":false,"product_type":"c1","uid":1077598,"ip_address":"浙江","ucode":"D56786A6E85321","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/5e/5393a76d.jpg","comment_is_top":false,"comment_ctime":1659434472,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1659434472","product_id":100023901,"comment_content":"老师好，disruptor当队列满了，生产者入队的时候是不是阻塞的，我看是cas不断循环尝试的，这种情况很耗cpu资源的吧","like_count":0},{"had_liked":false,"id":352642,"user_name":"全麦小面包","can_delete":false,"product_type":"c1","uid":1086413,"ip_address":"北京","ucode":"823C65BF366097","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/cd/dbafc7d1.jpg","comment_is_top":false,"comment_ctime":1658828064,"is_pvip":false,"replies":[{"id":"130236","content":"没有这种机制","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1663649706,"ip_address":"北京","comment_id":352642,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1658828064","product_id":100023901,"comment_content":"老师，有个问题哈。Disruptor创建的event不是业务数据类，里面set的东西才是业务需要的。但set对象的创建还是离散的，难道set对象的引用，能和event一起缓存？？java有这种机制吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588283,"discussion_content":"没有这种机制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663649706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333313,"user_name":"Geek_8593e5","can_delete":false,"product_type":"c1","uid":1736807,"ip_address":"","ucode":"B316E40C400CC8","user_header":"","comment_is_top":false,"comment_ctime":1644285637,"is_pvip":false,"replies":[{"id":"123948","content":"适用于对队列性能要求高的场景，一般情况不建议用","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1647949666,"ip_address":"","comment_id":333313,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1644285637","product_id":100023901,"comment_content":"请问下老师，这个队列可以用于替换ArrayBlockingQueue的场景对吧？还有一些什么场景可以用呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557744,"discussion_content":"适用于对队列性能要求高的场景，一般情况不建议用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647949666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307436,"user_name":"simple_孙","can_delete":false,"product_type":"c1","uid":1873629,"ip_address":"","ucode":"A77203E242D652","user_header":"https://static001.geekbang.org/account/avatar/00/1c/96/dd/1620a744.jpg","comment_is_top":false,"comment_ctime":1629100823,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629100823","product_id":100023901,"comment_content":"long wrapPoint = next - bufferSize;<br>应该是<br>long wrapPoint = next % bufferSize;<br>吧？","like_count":0},{"had_liked":false,"id":292211,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1620721942,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620721942","product_id":100023901,"comment_content":"程序的局部性原理   设计思想有点类似于Mysql的预读机制","like_count":0},{"had_liked":false,"id":279243,"user_name":"foggerwoody","can_delete":false,"product_type":"c1","uid":1582174,"ip_address":"","ucode":"DEF5829A10ABEA","user_header":"","comment_is_top":false,"comment_ctime":1613694147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613694147","product_id":100023901,"comment_content":"请问老师入队操作的时候应该需要两个操作：set event 和 set 入队index。 文中代码例子set 入队index用的是cas，那么如何保证其和set event的原子性呢？","like_count":0},{"had_liked":false,"id":220375,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1008071,"ip_address":"","ucode":"9FE5F43055D3AB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/61/c7/b64ac05e.jpg","comment_is_top":false,"comment_ctime":1590229564,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1590229564","product_id":100023901,"comment_content":"根据代码:<br>current = cursor.get();<br>  &#47;&#47;目标是在生产n个<br>  next = current + n;<br>  &#47;&#47;减掉一个循环<br>  long wrapPoint = next - bufferSize;<br>  &#47;&#47;获取上一次的最小消费位置<br>  long cachedGatingSequence = gatingSequenceCache.get();<br><br>环状的话<br>wrapPoint&gt;cachedGatingSequence 认为是满了 能理解<br><br>cachedGatingSequence&gt;current 为什么也是满了? 不理解了 , 最小消费位置 比当前写入位置大,不是应该 环状中间有空隙 是可以写入么?","like_count":0,"discussions":[{"author":{"id":1736807,"avatar":"","nickname":"Geek_8593e5","note":"","ucode":"B316E40C400CC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549917,"discussion_content":"这个表示最小消费位置超过了生产者生产位置，要停止","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644293332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":209744,"user_name":"侧耳倾听","can_delete":false,"product_type":"c1","uid":1512642,"ip_address":"","ucode":"5BF2A2440B54F0","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","comment_is_top":false,"comment_ctime":1587607862,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587607862","product_id":100023901,"comment_content":"Disruptor是不是限定同一时点，只能有一个生产者入队？多个生产者的场合，入队的动作还需要加锁互斥，这样子的话，Disruptor的极限性能应该是只有一个生产者","like_count":0},{"had_liked":false,"id":209729,"user_name":"侧耳倾听","can_delete":false,"product_type":"c1","uid":1512642,"ip_address":"","ucode":"5BF2A2440B54F0","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","comment_is_top":false,"comment_ctime":1587605813,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587605813","product_id":100023901,"comment_content":"伪共享就是C语言里位字段的对齐特性，不过没考虑过用在java语言里，受教了","like_count":0},{"had_liked":false,"id":205342,"user_name":"于是","can_delete":false,"product_type":"c1","uid":1186843,"ip_address":"","ucode":"6FB1BF6B692B0F","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/1b/dceaa378.jpg","comment_is_top":false,"comment_ctime":1586595587,"is_pvip":false,"replies":[{"id":"78697","content":"拷贝地址就可以了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1588033778,"ip_address":"","comment_id":205342,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586595587","product_id":100023901,"comment_content":"disruptor中的数组结构，如果我放入一个引用对象，这个被引用对象的内存地址已经确定了。是需要拷贝到他创建的那段连续内存中吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491452,"discussion_content":"拷贝地址就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588033778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172917,"user_name":"kennyji","can_delete":false,"product_type":"c1","uid":1347446,"ip_address":"","ucode":"DAA1BCBCB9C169","user_header":"https://static001.geekbang.org/account/avatar/00/14/8f/76/1d8be696.jpg","comment_is_top":false,"comment_ctime":1579357749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579357749","product_id":100023901,"comment_content":"太赞了！！","like_count":0},{"had_liked":false,"id":155734,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1574746228,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574746228","product_id":100023901,"comment_content":"“ArrayBlockingQueue 的入队和出队操作是用锁来保证互斥的，所以入队和出队不会同时发生。如果允许入队和出队同时发生，那就会导致线程 A 和线程 B 争用同一个缓存行，这样也会导致性能问题。所以为了更好地利用缓存，我们必须避免伪共享，那如何避免呢？”<br><br>JMM关于synchronized的两条规定：<br>　　1）线程解锁前，必须把共享变量的最新值刷新到主内存中<br>　　2）线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值<br><br>这样来看，由于 cpu 读取数据是按照缓存行读取的，那么虽然加锁了，但还是会按照缓存行读取啊，如果我加锁后访问了多个变量，后面依然会全部读取进来吧。<br><br>这种情况不是也是伪共享嘛？？依然是有性能问题的吧。。。<br><br>那对于加锁的情况，使用缓存行填充是否也可以优化性能呢？","like_count":0},{"had_liked":false,"id":154423,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1574427275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574427275","product_id":100023901,"comment_content":"第一次知道伪共享","like_count":0},{"had_liked":false,"id":119138,"user_name":"青铜5 周群力","can_delete":false,"product_type":"c1","uid":1111965,"ip_address":"","ucode":"EA80B442EC8A68","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/9d/c7295d17.jpg","comment_is_top":false,"comment_ctime":1564530743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564530743","product_id":100023901,"comment_content":"对内存优化部分有质疑:<br>1申请内存要经过jvm，经过操作系统，经过层层的优化、内存管理，填充缓存行有没有用只靠逻辑推理是推理不出来的吧，有没有数据证明这个技术真的有用?<br>2.预先申请所有元素对象真的有用吗，因为每个元素引用的数据对象还在离散的内存空间，取数据对象还要访问内存，会发生cache line淘汰。所以有什么数据能证明这个技术有用吗","like_count":0},{"had_liked":false,"id":118753,"user_name":"小予","can_delete":false,"product_type":"c1","uid":1442580,"ip_address":"","ucode":"3F5EAEE1746074","user_header":"https://static001.geekbang.org/account/avatar/00/16/03/14/e9ca2d09.jpg","comment_is_top":false,"comment_ctime":1564445447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564445447","product_id":100023901,"comment_content":"关于第4点，批量消费，一个线程一次读取n个元素，那另外一个线程想要读取元素时，必须等前一个线程的n个元素读取完，不明白这样为何能提高性能，希望老师解答下","like_count":0},{"had_liked":false,"id":101981,"user_name":"空知","can_delete":false,"product_type":"c1","uid":1013283,"ip_address":"","ucode":"C448E98238DD36","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg","comment_is_top":false,"comment_ctime":1560085639,"is_pvip":false,"replies":[{"id":"36775","content":"适用，只是避免一个缓存行内互相干扰而已","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1560127049,"ip_address":"","comment_id":101981,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560085639","product_id":100023901,"comment_content":"老师问下 <br>缓存行填充之后，缓存行里加载的不是真实需要的数据 是填充数据  程序局部性会不会不适用了? ","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453203,"discussion_content":"适用，只是避免一个缓存行内互相干扰而已","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560127049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101670,"user_name":"nico","can_delete":false,"product_type":"c1","uid":1209075,"ip_address":"","ucode":"DDB5EFE9F3A70E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Pr8laRQY3skrzzgen37ZIt4HQvtaThAcqvyK8eAzc9DRiak803q5HS7gCnXFxpx6CWibqT1Sic0h1TLMmVNUpJRibA/132","comment_is_top":false,"comment_ctime":1559908128,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1559908128","product_id":100023901,"comment_content":"老师，问下，多个生产者同时生产时，如果前面申请成功但是生产失败了，后面的生产成功了，中间空出来的位置怎么处理？<br>","like_count":0},{"had_liked":false,"id":100345,"user_name":"在下令狐冲","can_delete":false,"product_type":"c1","uid":1178651,"ip_address":"","ucode":"6228893CCF8C09","user_header":"https://static001.geekbang.org/account/avatar/00/11/fc/1b/7fa5823c.jpg","comment_is_top":false,"comment_ctime":1559531773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559531773","product_id":100023901,"comment_content":"缓存行填充可以看看这篇文章，简单明了<br>http:&#47;&#47;ifeve.com&#47;disruptor-cacheline-padding&#47;","like_count":0},{"had_liked":false,"id":99500,"user_name":"遇见阳光","can_delete":false,"product_type":"c1","uid":1203576,"ip_address":"","ucode":"378E5D37B3CD0E","user_header":"https://static001.geekbang.org/account/avatar/00/12/5d/78/f011d586.jpg","comment_is_top":false,"comment_ctime":1559230672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559230672","product_id":100023901,"comment_content":"LinkedBlockingQueue在插入或者删除对象时候会产生额外的对象Node  插入时会创建node对象，删除时如何理解","like_count":0},{"had_liked":false,"id":99433,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1559212746,"is_pvip":false,"replies":[{"id":"35738","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1559226644,"ip_address":"","comment_id":99433,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559212746","product_id":100023901,"comment_content":"厉害了我的哥，尽然看懂了，又学到了谢谢老师","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452108,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559226644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99242,"user_name":"Rancood","can_delete":false,"product_type":"c1","uid":1204333,"ip_address":"","ucode":"052BDF2221F480","user_header":"https://static001.geekbang.org/account/avatar/00/12/60/6d/e2576fda.jpg","comment_is_top":false,"comment_ctime":1559181136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559181136","product_id":100023901,"comment_content":"填充技术代码没有看懂，能否在具体解释一下","like_count":0},{"had_liked":false,"id":99219,"user_name":"周治慧","can_delete":false,"product_type":"c1","uid":1335293,"ip_address":"","ucode":"7D56C4E66BEE17","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","comment_is_top":false,"comment_ctime":1559178901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559178901","product_id":100023901,"comment_content":"思想很不错值得学习，一次性缓存防止缓存同一行导致失效用填充方式来弥补，cas的无锁机制👍🏻👍🏻👍🏻👍🏻","like_count":0},{"had_liked":false,"id":99217,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1559178869,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1559178869","product_id":100023901,"comment_content":"对Disruptor的无锁并发算法还是一知半解。而且担心cpu使用率会不会很高，像老师代码中LockSupport.parkNanos(1); 休息很少的时间就回来重新争取cpu，而Disruptor中有个策略中使用Thread.yield( )，交出cpu后马上回来争夺，这样会不会是cpu使用率飙升呢","like_count":0,"discussions":[{"author":{"id":1736807,"avatar":"","nickname":"Geek_8593e5","note":"","ucode":"B316E40C400CC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549872,"discussion_content":"所以它提供了好几种等待策略，主要看具体场景是追求low latency还是稳定性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644285566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99191,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1559176520,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1559176520","product_id":100023901,"comment_content":"通过初始化数组的时候将所有元素初始化，这个感觉很依赖于jvm或者操作系统的内存分配策略呀，而且对象数组中不也有引用吗，所以就算能缓存友好，那也是一层而已，为什么不能直接在堆中搞一块区域就直接存这些个东东呢。","like_count":0},{"had_liked":false,"id":99151,"user_name":"搏未来","can_delete":false,"product_type":"c1","uid":1034079,"ip_address":"","ucode":"4A339B35E3B419","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/5f/2028aae5.jpg","comment_is_top":false,"comment_ctime":1559171658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559171658","product_id":100023901,"comment_content":"以前只知道缓存行的好处，这次知道了缓存行可能的坏处，受教了！","like_count":0}]}