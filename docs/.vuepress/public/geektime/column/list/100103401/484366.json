{"id":484366,"title":"春节刷题计划（三）| 一题双解，搞定求解方程","content":"<p>你好，我是朱涛。初二过年好！</p><p>在上节课里，我给你留了一个作业，那就是：用Kotlin来完成 <a href=\"https://leetcode-cn.com/problems/solve-the-equation/\">LeetCode的640号题《求解方程》</a>。那么这节课，我就来讲讲我的解题思路，我们互相学习。</p><p>这道题也非常容易理解，程序的输入是一个“一元一次方程”，我们需要根据输入的方程，计算出正确的结果。根据输入方程的不同，结果可能有三种情况：</p><ul>\n<li><strong>方程仅有一个解</strong>，这时，我们只需要按照格式返回结果即可，比如输入“2x=4”，那么输出就应该是“x=2”。</li>\n<li><strong>方程有无数个解</strong>，比如输入“x=x”，那么输出就应该是“Infinite solutions”。</li>\n<li><strong>方程无解</strong>，比如输入“x=x+5”，那么输出结果就应该是“No solution”。</li>\n</ul><p>另外，对于程序的<strong>输入格式</strong>，其实我们还有几个问题需要弄清楚。只有弄清楚了这些问题，我们才能开始写代码：</p><ul>\n<li>方程当中的未知数只会用x表示，不会是y，也不会是大写的“X”。</li>\n<li>方程当中不会出现空格，比如“2x=4”，不会出现“2x   =  4   ”的情况。</li>\n<li>方程当中只会有加减法，不会出现乘除法。</li>\n<li>方程当中的数字，一定是整数，不会出现分数、小数。</li>\n<li>输入的方程一定是一个正确的方程，不会出现“x=…”之类的脏数据。</li>\n</ul><p>好，问题的细节都弄清楚了，下面我们来分析一下解题的思路。</p><!-- [[[read_end]]] --><p>对于这种简单的一元一次方程的解法，其实我们在小学就学过了，概括起来，就是分为三个步骤。</p><ul>\n<li>第一步，<strong>移项</strong>。将含有x的式子全部移到等式的左边，将数字全部都移到等式的右边。另外，移项的时候符号要变。比如“3x-4=x+2”这个方程，移项以后，就会变成这样：“3x-x=2+4”。</li>\n<li>第二步，<strong>合并同类项</strong>。这里其实就是将等式的左边与右边合并起来，对于“3x-x=2+4”这个式子，合并完以后，就会变成“2x=6”。</li>\n<li>第三步，<strong>系数化为一</strong>。这时候，我们就需要拿右边的数字，除以左边的系数。比如上面的式子“2x=6”，系数化为一之后，就会变成“x=3”，这就是我们想要的方程解。当然，这只是方程只有一个解的情况，其实在系数化为一之前，还存在其他的情况，比如“x=x+5”最终会变成“0=5”，这时候左边是零，右边不是零，这时候就代表方程无解；对于“2x=2x”这样的方程，它最终会变成“0=0”，这种两边都等于零的情况，就代表了方程有无数个解。</li>\n</ul><p>好，如何求解方程的思路我们已经知道了，那么代码该如何写呢？这里，我们仍然有两种解法，这两种解法的思路是一致的，只是其中一种是偏命令式的，另一种是偏函数式的。</p><p>这里，我照样是制作了一张动图，给你展示下程序运行的整体思路：</p><p><img src=\"https://static001.geekbang.org/resource/image/4b/91/4bbc7f1f21cd04e1b17f8032304a2691.gif?wh=1080x608\" alt=\"图片\"></p><h2>解法一：命令式</h2><p>首先，我们按照前面分析的思路，把待实现的程序分为以下几个步骤：</p><pre><code class=\"language-plain\">fun solveEquation(equation: String): String {\n    // ① 分割等号\n    // ② 遍历左边的等式，移项，合并同类项\n    // ③ 遍历右边的等式，移项，合并同类项\n    // ④ 系数化为一，返回结果\n}\n</code></pre><p>根据注释，我们很容易就能完成其中①、④两个步骤的代码：</p><pre><code class=\"language-plain\">fun solveEquation(equation: String): String {\n        // ① 分割等号\n        val list = equation.split(\"=\")\n\n        // ② 遍历左边的等式，移项，合并同类项\n        // ③ 遍历右边的等式，移项，合并同类项\n\n        // ④ 系数化为一,返回结果\n        return when {\n            leftSum == 0 &amp;&amp; rightSum == 0 -&gt; \"Infinite solutions\"\n            leftSum == 0 &amp;&amp; rightSum != 0 -&gt; \"No solution\"\n            else -&gt; \"x=${rightSum / leftSum}\"\n        }\n    }\n</code></pre><p>现在，关键还是在于②、③两个步骤的代码。这里，list[0]其实就代表了左边的式子，list[1]就代表了右边的式子。</p><p>按照之前的思路分析，我们其实用两个for循环，分别遍历它们，然后顺便完成移项与合并同类项就行了。具体的代码如下：</p><pre><code class=\"language-plain\">var leftSum = 0\nvar rightSum = 0\n\nval leftList = splitByOperator(list[0])\nval rightList = splitByOperator(list[1])\n\n// ② 遍历左边的等式，移项，合并同类项\nleftList.forEach {\n    if (it.contains(\"x\")) {\n        leftSum += xToInt(it)\n    } else {\n        rightSum -= it.toInt()\n    }\n}\n\n// ③ 遍历右边的等式，移项，合并同类项\nrightList.forEach{\n    if (it.contains(\"x\")) {\n        leftSum -= xToInt(it)\n    } else {\n        rightSum += it.toInt()\n    }\n}\n</code></pre><p>这段代码的逻辑其实也比较清晰了，leftList、rightList是根据“+”、“-”分割出来的元素。在完成分割以后，我们再对它们进行了遍历，从而完成了移项与合并同类项。</p><p>并且，这里我们还用到了另外两个方法，分别是splitByOperator()、xToInt()，它们具体的代码如下：</p><pre><code class=\"language-plain\">private fun splitByOperator(list: String): List&lt;String&gt; {\n    val result = mutableListOf&lt;String&gt;()\n    var temp = \"\"\n    list.forEach {\n        if (it == '+' || it == '-') {\n            if (temp.isNotEmpty()) {\n                result.add(temp)\n            }\n            temp = it.toString()\n        } else {\n            temp += it\n        }\n    }\n\n    result.add(temp)\n    return result\n}\n\nprivate fun xToInt(x: String) =\n    when (x) {\n        \"x\",\n        \"+x\" -&gt; 1\n        \"-x\" -&gt; -1\n        else -&gt; x.replace(\"x\", \"\").toInt()\n    }\n</code></pre><p>从以上代码中，我们可以看到splitByOperator()就是使用“+”、“-”作为分隔符，将字符串类型的式子，分割成一个个的元素。而xToInt()的作用则是为了提取x的系数，比如“2x”，提取系数以后，就是“2”；而“-2x”的系数就是“-2”。</p><p>最后，我们再来看看整体的代码：</p><pre><code class=\"language-plain\">fun solveEquation(equation: String): String {\n    // ① 分割等号\n    val list = equation.split(\"=\")\n\n    var leftSum = 0\n    var rightSum = 0\n\n    val leftList = splitByOperator(list[0])\n    val rightList = splitByOperator(list[1])\n\n    // ② 遍历左边的等式，移项，合并同类项\n    leftList.forEach {\n        if (it.contains(\"x\")) {\n            leftSum += xToInt(it)\n        } else {\n            rightSum -= it.toInt()\n        }\n    }\n\n    // ③ 遍历右边的等式，移项，合并同类项\n    rightList.forEach{\n        if (it.contains(\"x\")) {\n            leftSum -= xToInt(it)\n        } else {\n            rightSum += it.toInt()\n        }\n    }\n\n    // ④ 系数化为一,返回结果\n    return when {\n        leftSum == 0 &amp;&amp; rightSum == 0 -&gt; \"Infinite solutions\"\n        leftSum == 0 &amp;&amp; rightSum != 0 -&gt; \"No solution\"\n        else -&gt; \"x=${rightSum / leftSum}\"\n    }\n}\n\n// 根据“+”、“-”分割式子\nprivate fun splitByOperator(list: String): List&lt;String&gt; {\n    val result = mutableListOf&lt;String&gt;()\n    var temp = \"\"\n    list.forEach {\n        if (it == '+' || it == '-') {\n            if (temp.isNotEmpty()) {\n                result.add(temp)\n            }\n            temp = it.toString()\n        } else {\n            temp += it\n        }\n    }\n\n    result.add(temp)\n    return result\n}\n\n// 提取x的系数：“-2x” -&gt;“-2”\nprivate fun xToInt(x: String) =\n    when (x) {\n        \"x\",\n        \"+x\" -&gt; 1\n        \"-x\" -&gt; -1\n        else -&gt; x.replace(\"x\", \"\").toInt()\n    }\n</code></pre><p>至此，偏命令式的代码就完成了，接下来我们看看偏函数式的代码该怎么写。</p><h2>解法二：函数式</h2><p>这里你要注意了，函数式的思路呢，和命令式的思路其实是<strong>一样</strong>的。解方程的步骤是不会变的，仍然是移项、合并同类项、系数化为一。只不过，对比前面的实现方式，我们这里会更多地<strong>借助Kotlin的标准库函数</strong>。</p><p>首先，我们来看看第一部分的代码怎么写：</p><pre><code class=\"language-plain\">fun solveEquation(equation: String): String {\n    val list = equation\n        .replace(\"-\", \"+-\") // 预处理逻辑\n        .split(\"=\")\n\n    // 用“+”分割字符串\n    val leftList = list[0].split(\"+\")\n    val rightList = list[1].split(\"+\")\n\n    // 省略\n}\n</code></pre><p>这里，为了可以直接使用Kotlin的库函数split来实现算式的分割，我使用了一种<strong>数据预处理</strong>的办法。你可以看到，在上面代码的注释处，<code>replace(\"-\", \"+-\")</code> 的作用是将算式当中的所有“-”替换成“<code>+-</code>”，这就是预处理。经过这个预处理后，我们就可以直接使用 <code>split(\"+\")</code> 来分割算式了。</p><p>为了体现这个细节，我这里也做了一个动图，你可以看看：</p><p><img src=\"https://static001.geekbang.org/resource/image/b5/e9/b54e8c509be711cea6d3a0c1f22617e9.gif?wh=1080x425\" alt=\"图片\"></p><p>这样一来，我们得到的leftList、rightList其实就是干净的、独立的数字和x式子了。以“x+5-3+x=6+x-2”为例，<code>leftList=[\"x\",\"5\",\"-3\",\"x\"]</code>，而<code>rightList=[\"6\",\"x\",\"-2\"]</code>。</p><p>既然它们两者都是普通的集合，那么我们接下来，就完全可以借助Kotlin强大的库函数来做剩下的事情了。我们只需要将所有x的式子挪到左边，所有数字挪到右边，然后合并，最后系数化为一即可。大致代码如下：</p><pre><code class=\"language-plain\">leftList\n    .filter { it.hasX() }\n    .map { xToInt(it) } // ①\n    .toMutableList() \n    .apply {\n        rightList\n            .filter { it.hasX() }\n            .map { xToInt(it).times(-1) } // ②\n            .let { addAll(it) } \n    }.sum() // ③\n    .let { leftSum = it }\n\nrightList\n    .filter { it.isNumber() }\n    .map { it.toInt() } // ④\n    .toMutableList()\n    .apply {\n        leftList\n            .filter { it.isNumber() }\n            .map { it.toInt().times(-1) } // ⑤\n            .let { addAll(it) } \n    }.sum() // ⑥\n    .let { rightSum = it }\n\n// 返回结果\nreturn when {\n    leftSum == 0 &amp;&amp; rightSum == 0 -&gt; \"Infinite solutions\"\n    leftSum == 0 &amp;&amp; rightSum != 0 -&gt; \"No solution\"\n    else -&gt; \"x=${rightSum / leftSum}\" // ⑦\n}\n</code></pre><p>上面这段代码中，一共有6个注释，我们一个个看：</p><ul>\n<li>注释①，我们提取出了左边式子里所有x的系数，这里不需要移项，因为它本来就在左边。</li>\n<li>注释②，我们提取了右边式子里所有x的系数，由于这里涉及到移项，因此需要变号，这里我们通过乘以一个“-1”来实现的。</li>\n<li>注释③，我们将所有x的系数合并到了一起，得到了左边x的系数之和。</li>\n<li>注释④，我们收集了右边式子里所有的数字，这里也不需要移项，因为它本来就在右边。</li>\n<li>注释⑤，我们收集了左边式子里所有的数字，这里要移项，所以要变号。</li>\n<li>注释⑥，我们将所有数字求和了。</li>\n<li>注释⑦，如果方程有解的话，我们通过“rightSum / leftSum”就可以计算出来了。</li>\n</ul><p>另外，以上代码其实还涉及到三个辅助的函数，需要我们自己实现，它们的逻辑都很简单：</p><pre><code class=\"language-plain\">private fun String.isNumber(): Boolean =\n    this != \"\" &amp;&amp; !this.contains(\"x\")\n\nprivate fun String.hasX(): Boolean =\n    this != \"\" &amp;&amp; this.contains(\"x\")\n\n// 提取x的系数：“-2x” -&gt;“-2”\nprivate fun xToInt(x: String) =\n    when (x) {\n        \"x\" -&gt; 1\n        \"-x\" -&gt; -1\n        else -&gt; x.replace(\"x\", \"\").toInt()\n    }\n</code></pre><p>xToInt()这个函数和之前的逻辑是相似的，isNumber()和hasX()这两个扩展函数，它们是用来判断式子是纯数字、还是含有x的，这是因为我们要把x放到等式左边，而数字要放到等式右边。</p><p>最后，我们再来看看整体的代码：</p><pre><code class=\"language-plain\">fun solveEquation(equation: String): String {\n    val leftSum: Int\n    val rightSum: Int\n\n    val list = equation\n        .replace(\"-\", \"+-\") // 预处理数据\n        .split(\"=\")\n\n    val leftList = list[0].split(\"+\")\n    val rightList = list[1].split(\"+\")\n\n    // 求出所有x的系数之和\n    leftList\n        .filter { it.hasX() }\n        .map { xToInt(it) }\n        .toMutableList()\n        .apply {\n            rightList\n                .filter { it.hasX() }\n                .map { xToInt(it).times(-1) }\n                .let { addAll(it) }\n        }.sum()\n        .let { leftSum = it }\n\n    // 求出所有数字之和\n    rightList\n        .filter { it.isNumber() }\n        .map { it.toInt() }\n        .toMutableList()\n        .apply {\n            leftList\n                .filter { it.isNumber() }\n                .map { it.toInt().times(-1) }\n                .let { addAll(it) }\n        }.sum()\n        .let { rightSum = it }\n\n    // 返回结果\n    return when {\n        leftSum == 0 &amp;&amp; rightSum == 0 -&gt; \"Infinite solutions\"\n        leftSum == 0 &amp;&amp; rightSum != 0 -&gt; \"No solution\"\n        else -&gt; \"x=${rightSum / leftSum}\"\n    }\n}\n\nprivate fun String.isNumber(): Boolean =\n    this != \"\" &amp;&amp; !this.contains(\"x\")\n\nprivate fun String.hasX(): Boolean =\n    this != \"\" &amp;&amp; this.contains(\"x\")\n\n// 提取x的系数：“-2x” -&gt;“-2”\nprivate fun xToInt(x: String) =\n    when (x) {\n        \"x\" -&gt; 1\n        \"-x\" -&gt; -1\n        else -&gt; x.replace(\"x\", \"\").toInt()\n    }\n</code></pre><h2>小结</h2><p>这节课，我们用两种方式实现了<a href=\"https://leetcode-cn.com/problems/solve-the-equation/\">LeetCode的640号题《求解方程》</a>。这两种解法的核心思路其实是一致的，不过前者是偏命令式的，后者是偏函数式的。而你要清楚，即使它们是用的一种思路，也仍然是各有优劣的。</p><ul>\n<li>解法一，命令式的代码，它的时间复杂度和空间复杂度要稍微好一些，但总体差距不大，所以不一定能体现出运行时的差异。这种方式的劣势在于，逻辑相对复杂，可读性稍差，且编码过程中容易出错。</li>\n<li>解法二，偏函数式的代码，它的优势在于，代码逻辑相对清晰，并且，由于运用了大量Kotlin库函数，没那么容易出错。</li>\n</ul><h2>小作业</h2><p>好，最后，我还是给你留一个小作业，请你用Kotlin来完成 <a href=\"https://leetcode-cn.com/problems/fraction-addition-and-subtraction/\">LeetCode的592号题《分数加减运算》</a>，下节课我也会给出我的答案。</p>","comments":[{"had_liked":false,"id":336608,"user_name":"白乾涛","can_delete":false,"product_type":"c1","uid":1339841,"ip_address":"","ucode":"0C704B0B90C8D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","comment_is_top":false,"comment_ctime":1646236150,"is_pvip":false,"replies":[{"id":"123030","content":"很符合直觉的思路，不过略显繁琐。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646275731,"ip_address":"","comment_id":336608,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646236150","product_id":100103401,"comment_content":"fun solveEquation(equation: String): String { &#47;&#47; x+5-3+2x=6+x-2<br>    var xCount = 0   &#47;&#47; 移到左边的 x 系数之和<br>    var addValue = 0 &#47;&#47; 移到右边的数字之和<br>    val equalIndex = equation.indexOf(&#39;=&#39;) &#47;&#47; 等号的位置<br>    var i = 0<br>    while (i &lt; equation.length) {<br>        val fromIndex = i<br>        if (i == 0) {<br>            i++<br>        }<br>        for (j in i until equation.length) {<br>            val c: Char = equation[j]<br>            if (c == &#39;+&#39; || c == &#39;-&#39; || c == &#39;=&#39;) {<br>                break<br>            }<br>            i++<br>        }<br>        var subString = equation.substring(if (fromIndex == 0) fromIndex else fromIndex - 1, i)<br>        subString = if (subString.startsWith(&quot;=&quot;)) subString.substring(1) else subString<br>        println(&quot;值为：$subString&quot;)<br>        if (subString.endsWith(&quot;x&quot;)) {<br>            subString = subString.substring(0, subString.length - 1)<br>            val tempCount = if (subString.isEmpty()) 1 &#47;&#47; x<br>            else {<br>                if (subString.length == 1 &amp;&amp; (subString.startsWith(&quot;+&quot;) || subString.startsWith(&quot;-&quot;))) { &#47;&#47; +x 或 -x<br>                    if (subString[0] == &#39;+&#39;) 1 else -1<br>                } else subString.toInt() &#47;&#47; +5x 或 5x 或 53x 或 -2x<br>            }<br>            xCount = if (i &gt; equalIndex) xCount - tempCount else xCount + tempCount &#47;&#47; 左正右负<br>        } else if (subString.isNotEmpty()) { &#47;&#47; 过滤掉 = 产生的一个空字符串<br>            val tempValue = subString.toInt()<br>            addValue = if (i &gt; equalIndex) addValue + tempValue else addValue - tempValue &#47;&#47; 左负右正<br>        }<br>        i++<br>    }<br>    println(&quot;结果：${xCount}x = $addValue&quot;)<br>    return if (xCount == 0) if (addValue == 0) &quot;Infinite solutions&quot; else &quot;No solution&quot;<br>    else &quot;x=&quot; + addValue &#47; xCount<br>}","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554234,"discussion_content":"很符合直觉的思路，不过略显繁琐。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646275731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335078,"user_name":"Geek_Adr","can_delete":false,"product_type":"c1","uid":2876897,"ip_address":"","ucode":"129E17B7D3EB88","user_header":"https://static001.geekbang.org/account/avatar/00/2b/e5/e1/a5064f88.jpg","comment_is_top":false,"comment_ctime":1645286620,"is_pvip":false,"replies":[{"id":"122397","content":"代码写的挺好的，大家可以参考看看。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1645369651,"ip_address":"","comment_id":335078,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1645286620","product_id":100103401,"comment_content":"符号处理复杂了，其它与 @郑峰 略同<br>    &#47;&#47; 分数的数据结构 symbol为-1 1<br>    &#47;&#47; 注意分子&#47;分母为正整数<br>    data class Fraction(val numerator: Int, val denominator: Int, val symbol: Int)<br>    fun fractionAddition(expression: String): String {<br>        return expression.replace(&quot;-&quot;, &quot;+-&quot;) &#47;&#47; &quot;-&quot;前增加+，方便split处理<br>            .split(&quot;+&quot;) &#47;&#47; 按&quot;+&quot;分隔<br>            .filter { it.isNotBlank() } &#47;&#47; 去掉可能为空的部分<br>            .map { &#47;&#47; 处理成分数实例<br>                var symbol = if (it.startsWith(&quot;-&quot;)) -1 else 1<br>                val ss = it.replace(&quot;-&quot;, &quot;&quot;).split(&quot;&#47;&quot;)<br>                Fraction(ss[0].toInt(), ss[1].toInt(), symbol)<br>            }.run {<br>                &#47;&#47; 算出分母的最小公倍数，作为分母<br>                val denominator = map { it.denominator }.reduce { a, b -&gt; lcm(a, b) }<br>                &#47;&#47; 按最小公倍数计算分子结果<br>                var numerator = map { it.symbol * it.numerator * denominator &#47; it.denominator }.reduce { a, b -&gt; a + b }<br>                val symbol = if (numerator &lt; 0) -1 else 1<br>                numerator *= symbol &#47;&#47; 转正<br>                val gcd = gcd(numerator, denominator) &#47;&#47; 结果可能可约分<br>                Fraction(numerator &#47; gcd, denominator &#47; gcd, symbol)<br>            }.run { &quot;${if (symbol &lt; 0) &quot;-&quot; else &quot;&quot;}${numerator}&#47;${denominator}&quot; }<br><br>    }<br><br>    &#47;&#47; 最小公倍数<br>    private fun lcm(m: Int, n: Int): Int {<br>        return m * n &#47; gcd(m, n)<br>    }<br><br>    &#47;&#47; 最大公约数<br>    private fun gcd(m: Int, n: Int): Int {<br>        return if (m % n == 0) n else gcd(n, m % n)<br>    }<br>","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552256,"discussion_content":"代码写的挺好的，大家可以参考看看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645369651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332923,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1643817477,"is_pvip":true,"replies":[{"id":"121693","content":"这种思路也很巧妙，值得大家学习。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643986281,"ip_address":"","comment_id":332923,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1643817477","product_id":100103401,"comment_content":"尝试用正则分割<br><br>```kotlin<br>&#47;&#47; 根据“+”、“-”分割式子<br>private fun splitByOperator(list: String) =<br>    list.split(Regex(&quot;(?=[+-])&quot;)).filter { it.isNotEmpty() }<br>```<br><br>或者<br><br>```kotlin<br>&#47;&#47; 根据“+”、“-”分割式子<br>private fun splitByOperator(list: String): Sequence&lt;String&gt; =<br>    Regex(&quot;&quot;&quot;[+-]?(\\d*x|\\d+)&quot;&quot;&quot;).findAll(list).map { it.value }<br>```<br>","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549442,"discussion_content":"这种思路也很巧妙，值得大家学习。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643986281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332869,"user_name":"郑峰","can_delete":false,"product_type":"c1","uid":1112517,"ip_address":"","ucode":"4D4C0C020E507C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/c5/95b97dfa.jpg","comment_is_top":false,"comment_ctime":1643773269,"is_pvip":false,"replies":[{"id":"121692","content":"这代码很不错，比我提供的解法更加的简洁。这种不拘泥与特定编程范式，并且融合双方优势的写法，看起来真的很舒服。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643985915,"ip_address":"","comment_id":332869,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1643773269","product_id":100103401,"comment_content":"```Kotlin<br>fun fractionAddition(expression: String): String {<br>  &#47;&#47; Split the expression to several pairs of numerator and denominator<br>  val numbers = expression<br>    .replace(&quot;-&quot;, &quot;+-&quot;)<br>    .split(&quot;+&quot;)<br>    .filter { it.isNotEmpty() }<br>    .map { it.split(&quot;&#47;&quot;).take(2).map(String::toInt) }<br><br>  &#47;&#47; Calculate the lcm of all denominators<br>  val rawDenominator = numbers.map { it[1] }.fold(1) { x, y -&gt; lcm(x, y) }<br>  &#47;&#47; Calculate the sum of all numerators<br>  val rawNumerator = numbers.sumOf { it[0] * rawDenominator &#47; it[1] }<br><br>  &#47;&#47; Reformat numerator and denominator through their gcd<br>  val gcd = abs(gcd(rawNumerator, rawDenominator))<br>  val denominator = rawDenominator &#47; gcd<br>  val numerator = rawNumerator &#47; gcd<br>  return &quot;$numerator&#47;$denominator&quot;<br>}<br><br>fun gcd(x: Int, y: Int): Int = if (y == 0) x else gcd(y, x % y)<br>fun lcm(x: Int, y: Int): Int = x * y &#47; gcd(x, y)<br>```","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549440,"discussion_content":"这代码很不错，比我提供的解法更加的简洁。这种不拘泥与特定编程范式，并且融合双方优势的写法，看起来真的很舒服。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643985915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1112517,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f9/c5/95b97dfa.jpg","nickname":"郑峰","note":"","ucode":"4D4C0C020E507C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549459,"discussion_content":"谢谢。其实我大部分写法都是很直接的，很少考虑复用，很少考虑抽象。这对工程化影响比较大。代码量的多少有时代表着简洁与否，有时代表可扩展性。关键在于代码设计吧。对于Kotlin的学习，我认为应该了解Kotlin设计的思路，以及如何利用Kotlin的语法优势代替Java繁杂的设计模式实现。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1643990177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}