{"id":724776,"title":"10｜再探trait：带类型参数的trait及trait object","content":"<p>你好，我是Mike，今天我们继续学习trait相关知识。</p><p>回顾一下我们上一节课中类型参数出现的地方。</p><ul>\n<li>用 trait 对 Ｔ 作类型空间的约束，比如<code>T: TraitA</code>。</li>\n<li>blanket implementation 时的 T，比如 <code>impl&lt;T: TraitB&gt; TraitA for T {}</code>。</li>\n<li>函数里的 T 参数，比如 <code>fn doit&lt;T&gt;(a: T) {}</code>。</li>\n</ul><p>你要注意区分不同位置的 T。它的基础意义都是类型参数，但是放在不同的位置其侧重的意义有所不同。</p><ul>\n<li><code>T: TraitA</code> 里的T表示类型参数，强调“参数”，使用TraitA来削减它的类型空间。</li>\n<li><code>impl&lt;T: TraitB&gt; TraitA for T {}</code> 末尾的T更强调类型参数的“类型”部分，为某些类型实现 TraitA。</li>\n<li><code>doit&lt;T&gt;(a: T) {}</code> 中第二个T表示某种类型，更强调类型参数的“类型”部分。</li>\n</ul><p>这节课我们要讲的是另外一个东西，它里面也带T参数。我们一起来看一下，它与之前这几种形式有什么不同。</p><h2>trait上带类型参数</h2><p>trait上也是可以带类型参数的，形式像下面这样：</p><pre><code class=\"language-plain\">trait TraitA&lt;T&gt; {}\n</code></pre><p>表示这个trait里面的函数或方法，可能会用到这个类型参数。在定义trait的时候，还没确定这个类型参数的具体类型。要等到impl甚至使用类型方法的时候，才会具体化这个T的具体类型。</p><!-- [[[read_end]]] --><p>注意，这个时候 <code>TraitA&lt;T&gt;</code> 是一个整体，表示一个trait。比如  <code>TraitA&lt;u8&gt;</code> 和 <code>TraitA&lt;u32&gt;</code> 就是两个不同的trait，这里单独把TraitA拿出来说是没有意义的。</p><p>实现时需要在impl后面先定义类型参数，比如：</p><pre><code class=\"language-plain\">impl&lt;T&gt; TraitA&lt;T&gt; for Atype {}\n</code></pre><p>当然也可以在对类型实现时，将T参数具体化，比如：</p><pre><code class=\"language-plain\">impl TraitA&lt;u8&gt; for Atype {}\n</code></pre><p>而如果被实现的类型上自身也带类型参数，那么情况会更复杂。</p><pre><code class=\"language-plain\">trait TraitA&lt;T&gt; {}\nstruct Atype&lt;U&gt; {\n&nbsp; &nbsp; a: U,\n}\nimpl&lt;T, U&gt; TraitA&lt;T&gt; for Atype&lt;U&gt; {}\n</code></pre><p>这些类型参数都是可以在impl时被约束的，像下面这样：</p><pre><code class=\"language-plain\">use std::fmt::Debug;\n\ntrait TraitA&lt;T&gt; {}\nstruct Atype&lt;U&gt; {\n    a: U,\n}\nimpl&lt;T, U&gt; TraitA&lt;T&gt; for Atype&lt;U&gt; \nwhere\n    T: Debug,      // 在 impl 时添加了约束\n    U: PartialEq,  // 在 impl 时添加了约束\n{}\n</code></pre><p><span class=\"reference\">注：以上代码都是可以放到playground中编译通过的。</span></p><h3>impl 示例</h3><p>下面我们通过一个具体的实例体会一下带类型参数的trait的威力。</p><p>我们现在要实现一个模型。</p><ol>\n<li>平面上的一个点与平面上的另一个点相加，形成一个新的点。算法是两个点的x分量和y分量分别相加。</li>\n<li>平面上的一个点加一个整数i32，形成一个新的点。算法是分别在x分量和y分量上面加这个i32参数。</li>\n</ol><p><span class=\"reference\">本示例借鉴了：<a href=\"https://github.com/pretzelhammer/rust-blog/blob/master/posts/tour-of-rusts-standard-library-traits.md#generic-types-vs-associated-types\">https://github.com/pretzelhammer/rust-blog/blob/master/posts/tour-of-rusts-standard-library-traits.md#generic-types-vs-associated-types</a></span></p><p>代码如下：</p><pre><code class=\"language-plain\">// 定义一个带类型参数的trait\ntrait Add&lt;T&gt; {\n    type Output;\n    fn add(self, rhs: T) -&gt; Self::Output;\n}\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\n// 为 Point 实现 Add&lt;Point&gt; 这个 trait\nimpl Add&lt;Point&gt; for Point {\n    type Output = Self;\n    fn add(self, rhs: Point) -&gt; Self::Output {\n        Point {\n            x: self.x + rhs.x,\n            y: self.y + rhs.y,\n        }\n    }\n}\n\n// 为 Point 实现 Add&lt;i32&gt; 这个 trait\nimpl Add&lt;i32&gt; for Point { \n    type Output = Self;\n    fn add(self, rhs: i32) -&gt; Self::Output {\n        Point {\n            x: self.x + rhs,\n            y: self.y + rhs,\n        }\n    }\n}\n\nfn main() {\n    let p1 = Point { x: 1, y: 1 };\n    let p2 = Point { x: 2, y: 2 };\n    let p3 = p1.add(p2);  // 两个Point实例相加\n    assert_eq!(p3.x, 3);\n    assert_eq!(p3.y, 3);\n    \n    let p1 = Point { x: 1, y: 1 };\n    let delta = 2;\n    let p3 = p1.add(delta);   // 一个Point实例加一个i32\n    assert_eq!(p3.x, 3);\n    assert_eq!(p3.y, 3);\n}\n</code></pre><p>我们详细解释一下这个示例。<code>Add&lt;T&gt;</code> 这个trait，带一个类型参数T，还带一个关联类型 Output。</p><p>对Point类型，我们实现了两个trait：<code>Add&lt;Point&gt;</code> 和 <code>Add&lt;i32&gt;</code>。注意这已经是两个不同的trait了，所以能对同一个类型实现。前面我们反复强调过，同一个trait只能对一个类型实现一次。</p><p>根据需求，运算后的类型也是Point，所以看到两个trait中的关联类型都是 Self。请注意两个trait中实现的不同算法。</p><p>通过这种形式，我们在同一个类型上实现了同名方法（add方法）参数类型的多种形态。在这里看起来就是，Point实例的add方法既可以接收Point参数，又可以接收i32参数，Rustc小助手可以根据不同的参数类型自动找到对应的方法调用。在Java、C++这些语言中，有语言层面的函数重载特性来支持这种功能，Rust中自身并不直接支持函数重载特性，但是它用trait就轻松实现了同样的效果，这是一种全新的思路。</p><h3>trait 类型参数的默认实现</h3><p>定义带类型参数的trait的时候，可以为类型参数指定一个默认类型，比如 <code>trait TraitA&lt;T = u64&gt; {}</code>。这样使用时，<code>impl TraitA for SomeType {}</code> 就等价于 <code>impl TraitA&lt;u64&gt; for SomeType {}</code>。</p><p>我们来看一个完整的例子。</p><pre><code class=\"language-plain\">// Self可以用在默认类型位置上\ntrait TraitA&lt;T = Self&gt; {\n&nbsp; &nbsp; fn func(t: T) {}\n}\n\n// 这个默认类型为i32\ntrait TraitB&lt;T = i32&gt; {\n&nbsp; &nbsp; fn func2(t: T) {}\n}\n\nstruct SomeType;\n\n// 这里省略了类型参数，所以这里的T为Self\n// 进而T就是SomeType本身\nimpl TraitA for SomeType {\n&nbsp; &nbsp; fn func(t: SomeType) {}\n}\n// 这里省略了类型参数，使用默认类型i32\nimpl TraitB for SomeType {\n&nbsp; &nbsp; fn func2(t: i32) {}\n}\n// 这里不省略类型参数，明确指定类型参数为String\nimpl TraitA&lt;String&gt; for SomeType {\n&nbsp; &nbsp; fn func(t: String) {}\n}\n// 这里不省略类型参数，明确指定类型参数为String\nimpl TraitB&lt;String&gt; for SomeType {\n&nbsp; &nbsp; fn func2(t: String) {}\n}\n</code></pre><p>默认参数给表达上带来了一定程度的简洁，但是增加了初学者识别和理解上的困难。</p><p>你还记得上一节课讲关联类型时我们提到过在使用约束时可以具化关联类型。那里也是用的＝号。比如：</p><pre><code class=\"language-plain\">trait TraitA {\n    type Item;\n}\n// 这里，定义结构体类型时，用到了TraitA作为约束\nstruct Foo&lt;T: TraitA&lt;Item=String&gt;&gt; {\n    x: T\n}\n</code></pre><p>初看这里容易混淆。区别在于，<strong>关联类型的具化是在应用约束时，类型参数的默认类型指定是在定义trait时</strong>，通过trait出现的场景可以区分它们。</p><h3>trait中的类型参数与关联类型的区别</h3><p>现在你可能会有些疑惑：trait上的类型参数和关联类型都具有延迟具化的特点，那么它们的区别是什么呢？为什么要设计两种不同的机制呢？</p><p>首先要明确的一点是，Rust本身也在持续演化过程中。有些特性先出现，有些特性是后出现的。最后演化出功能相似但是不完全一样的特性是完全有可能的。</p><p>具体到这两者来说，它们主要有两点不同。</p><ol>\n<li>类型参数可以在impl 类型的时候具化，也可以延迟到使用的时候具化。而关联类型在被impl时就必须具化。</li>\n<li>由于类型参数和trait名一起组成了完整的trait名字，不同的具化类型会构成不同的trait，所以看起来同一个定义可以在目标类型上实现“多次”。而关联类型没有这个作用。</li>\n</ol><p>下面我们分别举例说明。</p><p>对于第一点，请看下面的示例：</p><pre><code class=\"language-plain\">use std::fmt::Debug;\n\ntrait TraitA&lt;T&gt; \nwhere\n    T: Debug,  // 定义TraitA&lt;T&gt;的时候，对T作了约束\n{\n    fn play(&amp;self, _t: T) {}\n}\nstruct Atype;\n\nimpl&lt;T&gt; TraitA&lt;T&gt; for Atype\nwhere\n    T: Debug + PartialEq,  // 将TraitA&lt;T&gt;实现到类型Atype上时，加强了约束\n{}\n\nfn main() {\n    let a = Atype;\n    a.play(10u32);  // 在使用时，通过实例方法传入的参数类型具化T\n}\n</code></pre><p>这个示例展示了几个要点。</p><ol>\n<li>定义带类型参数的trait时可以用where表达，并提供约束。</li>\n<li>impl trait时可以对类型参数加强约束，对应例子中的 Debug + PartialEq。</li>\n<li>impl trait时可以不具化类型参数。</li>\n<li>可以在使用方法时具化类型参数。例子里的 <code>a.play(10u32)</code>，把T具象化成了u32。</li>\n</ol><p>当然，在impl的时候也可以指定成u32类型，所以下面的代码也可以。</p><pre><code class=\"language-plain\">use std::fmt::Debug;\n\ntrait TraitA&lt;T&gt; \nwhere\n    T: Debug,\n{\n    fn play(&amp;self, _t: T) {}\n}\nstruct Atype;\n\nimpl TraitA&lt;u32&gt; for Atype {} // 这里具化成了 TraitA&lt;u32&gt;\n\nfn main() {\n    let a = Atype;\n    a.play(10u32);\n}\n</code></pre><p>但是这样就没前面那么灵活了，比如 <code>a.play(10u64)</code> 就不行了。</p><p>对应的，对关联类型来说，如果你在impl时不对其具化，就无法编译通过。所以对于第二点，我也给出一个例子来解释。我们把前面对Point类型实现Add的模型尝试用关联类型实现一遍。</p><pre><code class=\"language-plain\">trait Add {\n    type ToAdd;    // 多定义一个关联类型\n    type Output;\n    fn add(self, rhs: Self::ToAdd) -&gt; Self::Output;\n}\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type ToAdd = Point;\n    type Output = Point;\n    fn add(self, rhs: Point) -&gt; Point {\n        Point {\n            x: self.x + rhs.x,\n            y: self.y + rhs.y,\n        }\n    }\n}\n\nimpl Add for Point { // 这里重复impl了同一个trait，无法编译通过\n    type ToAdd = i32;\n    type Output = Point;\n    fn add(self, rhs: i32) -&gt; Point {\n        Point {\n            x: self.x + rhs,\n            y: self.y + rhs,\n        }\n    }\n}\n\nfn main() {\n    let p1 = Point { x: 1, y: 1 };\n    let p2 = Point { x: 2, y: 2 };\n    let p3 = p1.add(p2);\n    assert_eq!(p3.x, 3);\n    assert_eq!(p3.y, 3);\n    \n    let p1 = Point { x: 1, y: 1 };\n    let delta = 2;\n    let p3 = p1.add(delta); // 这句是错的\n    assert_eq!(p3.x, 3);\n    assert_eq!(p3.y, 3);\n</code></pre><p>编译器会抱怨：</p><pre><code class=\"language-plain\">error[E0119]: conflicting implementations of trait `Add` for type `Point`:\n  --&gt; src/main.rs:23:1\n   |\n12 | impl Add for Point {\n   | ------------------ first implementation here\n...\n23 | impl Add for Point {\n   | ^^^^^^^^^^^^^^^^^^ conflicting implementation for `Point`\n</code></pre><p>提示说，对Point类型实现了多次Add，导致冲突。编译不通过。所以这个模型仅用关联类型来实现，是写不出来的。</p><p>这么看起来，好像带类型参数的trait功能更强大，那用这个不就够了？但关联类型也有它的优点，比如关联类型没有类型参数，不存在多引入了一个参数的问题，而类型参数是具有传染性的，特别是在一个调用层次很深的系统中，增删一个类型参数可能会导致整个项目文件到处都需要改，非常头疼。</p><p>而关联类型没有这个问题。在一些场合下，关联类型正好是减少类型参数数量的一种方法。更不要说，有时模型比较简单，不需要多态特性，这时用关联类型就更简洁，代码可读性更好。</p><h2>trait object</h2><p>下面我们开始讲trait object。</p><p>我们从一个函数要返回不同的类型说起。比如一个常见的需求，要在一个Rust函数中返回可能的多种类型，应该怎么写？</p><p>如果我们写成返回固定类型的函数签名，那么它就只能返回那个类型。比如：</p><pre><code class=\"language-plain\">struct Atype;\nstruct Btype;\nstruct Ctype;\nfn doit() -&gt; Atype {\n&nbsp; &nbsp; let a = Atype;\n&nbsp; &nbsp; a\n}\n</code></pre><p>你想到的第一个办法可能是利用enum。</p><pre><code class=\"language-plain\">struct Atype;\nstruct Btype;\nstruct Ctype;\n\nenum TotalType {\n  A(Atype),    // 用变体把目标类型包起来\n  B(Btype),\n  C(Ctype),\n}\n\nfn doit(i: u32) -&gt; TotalType {  // 返回枚举类型\n  if i == 0 {\n    let a = Atype;\n    TotalType::A(a)    // 在这个分支中返回变体A\n  } else if i == 1 {\n    let b = Btype;\n    TotalType::B(b)    // 在这个分支中返回变体B\n  } else {\n    let c = Ctype;\n    TotalType::C(c)    // 在这个分支中返回变体C\n  }\n}\n</code></pre><p><strong>enum 常用于聚合类型</strong>。这些类型之间可以没有任何关系，用enum可以<strong>无脑+强行</strong>把它们揉在一起。enum聚合类型是编码时已知的类型，也就是说在聚合前，需要知道待聚合类型的边界，一旦定义完成，之后运行时就不能改动了，它是<strong>封闭类型集</strong>。</p><p>第二种办法是利用类型参数，我们试着引入一个类型参数，改写一下。</p><pre><code class=\"language-plain\">struct Atype;\nstruct Btype;\nstruct Ctype;\nfn doit&lt;T&gt;() -&gt; T {\n  let a = Atype;\n  a\n}\n</code></pre><p>很明显，这种代码无法通过编译。提示：</p><pre><code class=\"language-plain\">error[E0308]: mismatched types\n --&gt; src/lib.rs:6:3\n  |\n4 | fn doit&lt;T&gt;() -&gt; T {\n  |         -       - expected `T` because of return type\n  |         |\n  |         this type parameter\n5 |   let a = Atype;\n6 |   a\n  |   ^ expected type parameter `T`, found `Atype`\n  |\n  = note: expected type parameter `T`\n                     found struct `Atype`\n</code></pre><p>因为这里这个类型参数T是在这个函数调用时指定，而不是在这个函数定义时指定的。所以针对我们的需求，你没法在这里直接返回一个具体的类型代入T。只能尝试用T来返回，于是我们改出第二个版本。</p><pre><code class=\"language-plain\">struct Atype;\nstruct Btype;\nstruct Ctype;\n\nimpl Atype {\n&nbsp; &nbsp; fn new() -&gt; Atype {\n&nbsp; &nbsp; &nbsp; &nbsp; Atype\n&nbsp; &nbsp; }\n}\n\nimpl Btype {\n&nbsp; &nbsp; fn new() -&gt; Btype {\n&nbsp; &nbsp; &nbsp; &nbsp; Btype\n&nbsp; &nbsp; }\n}\n\nimpl Ctype {\n&nbsp; &nbsp; fn new() -&gt; Ctype {\n&nbsp; &nbsp; &nbsp; &nbsp; Ctype\n&nbsp; &nbsp; }\n}\n\nfn doit&lt;T&gt;() -&gt; T {\n&nbsp; T::new()\n}\n</code></pre><p>编译还是报错。</p><pre><code class=\"language-plain\">error[E0599]: no function or associated item named `new` found for type parameter `T` in the current scope\n  --&gt; src/main.rs:24:6\n   |\n23 | fn doit&lt;T&gt;() -&gt; T {\n   |         - function or associated item `new` not found for this type parameter\n24 |   T::new()\n   |      ^^^ function or associated item not found in `T`\n\n</code></pre><p>也就是说，Rustc小助手并不知道我们定义这个类型参数T里面有new这个关联函数。联想到我们前面学过的，可以用trait来定义这个协议，让Rust认识它。</p><p>第三个版本：</p><pre><code class=\"language-plain\">struct Atype;\nstruct Btype;\nstruct Ctype;\n\ntrait TraitA {\n    fn new() -&gt; Self;    // TraitA中定义了new()函数\n}\n\nimpl TraitA for Atype {\n    fn new() -&gt; Atype {\n        Atype\n    }\n}\n\nimpl TraitA for Btype {\n    fn new() -&gt; Btype {\n        Btype\n    }\n}\n\nimpl TraitA for Ctype {\n    fn new() -&gt; Ctype {\n        Ctype\n    }\n}\n\nfn doit&lt;T: TraitA&gt;() -&gt; T {\n  T::new()\n}\n\nfn main() {\n    let a: Atype = doit::&lt;Atype&gt;();\n    let b: Btype = doit::&lt;Btype&gt;();\n    let c: Ctype = doit::&lt;Ctype&gt;();\n}\n</code></pre><p>这个版本顺利通过编译。在这个示例中，我们认识到了引入trait的必要性，就是让Rustc小助手知道我们在协议层面有一个new()函数，一旦类型参数被trait约束后，它就可以去trait中寻找协议定义的函数和方法。</p><p>为了解决上面那个问题，我们真的是费了不少力气。实际上，Rust提供了更优雅的方案来解决这个需求。Rust利用trait提供了一种特殊语法 impl trait，你可以看一下示例。</p><pre><code class=\"language-plain\">struct Atype;\nstruct Btype;\nstruct Ctype;\n\ntrait TraitA {}\n\nimpl TraitA for Atype {}\nimpl TraitA for Btype {}\nimpl TraitA for Ctype {}\n\nfn doit() -&gt; impl TraitA {  // 注意这一行的函数返回类型\n  let a = Atype;\n  a\n  // 或\n  // let b = Btype;\n  // b\n  // 或\n  // let c = Ctype;\n  // c\n}\n</code></pre><p>可以看到，这种表达非常简洁，同一个函数签名可以返回多种不同的类型，并且在函数定义时就可以返回具体的类型的实例。更重要的是消除了类型参数T。</p><p>上述代码已经很有用了，但是还是不够灵活，比如我们要用if逻辑选择不同的分支返回不同的类型，就会遇到问题。</p><pre><code class=\"language-plain\">struct Atype;\nstruct Btype;\nstruct Ctype;\n\ntrait TraitA {}\n\nimpl TraitA for Atype {}\nimpl TraitA for Btype {}\nimpl TraitA for Ctype {}\n\nfn doit(i: u32) -&gt; impl TraitA {  \n  if i == 0 {\n    let a = Atype;\n    a                    // 在这个分支中返回类型a\n  } else if i == 1 {\n    let b = Btype;\n    b                    // 在这个分支中返回类型b\n  } else {\n    let c = Ctype;\n    c                    // 在这个分支中返回类型c\n  }\n}\n</code></pre><p>提示：</p><pre><code class=\"language-plain\">error[E0308]: `if` and `else` have incompatible types\n  --&gt; src/lib.rs:22:5\n   |\n17 |     } else if i == 1 {\n   |  __________-\n18 | |     let b = Btype;\n19 | |     b\n   | |     - expected because of this\n20 | |   } else {\n21 | |     let c = Ctype;\n22 | |     c\n   | |     ^ expected `Btype`, found `Ctype`\n23 | |   }\n   | |___- `if` and `else` have incompatible types\n</code></pre><p>if else 要求返回同一种类型，Rust检查确实严格。不过我们可以通过加return跳过 if else 的限制。</p><pre><code class=\"language-plain\">struct Atype;\nstruct Btype;\nstruct Ctype;\n\ntrait TraitA {}\n\nimpl TraitA for Atype {}\nimpl TraitA for Btype {}\nimpl TraitA for Ctype {}\n\nfn doit(i: u32) -&gt; impl TraitA {\n  if i == 0 {\n    let a = Atype;\n    return a;          // 这里用return语句直接从函数返回\n  } else if i == 1 {\n    let b = Btype;\n    return b;\n  } else {\n    let c = Ctype;\n    return c;\n  }\n}\n</code></pre><p>但是还是报错。</p><pre><code class=\"language-plain\">error[E0308]: mismatched types\n  --&gt; src/lib.rs:19:12\n   |\n13 | fn doit(i: u32) -&gt; impl TraitA {  // 这一行\n   |                    ----------- expected `Atype` because of return type\n...\n19 |     return b\n   |            ^ expected `Atype`, found `Btype`\n\n</code></pre><p>它说期望Atype，却得到了Btype。这个报错其实有点奇怪，它们不是都满足 impl TraitA 吗？</p><p>原来问题在于，impl TraitA 作为函数返回值这种语法，其实也只是<strong>指代某一种类型</strong>而已，而这种类型是在函数体中由返回值的类型来自动推导出来的。例子中，Rustc小助手遇到Atype这个分支时，就已经确定了函数返回类型为Atype，因此当它分析到后面的Btype分支时，就发现类型不匹配了。问题就在这里。你可以将条件分支顺序换一下，看一下报错的提示，加深印象。</p><p>那我们应该怎么处理这种问题呢？</p><p>好在，Rust还给我们提供了进一步的措施：<strong>trait object</strong>。形式上，就是在trait名前加 dyn 关键字修饰，在这个例子里就是 dyn TraitA。<strong>dyn TraitName 本身就是一种类型</strong>，它和 TraitName 这个 trait 相关，但是它们不同，dyn TraitName 是一个独立的类型。</p><p>我们使用dyn TraitA改写上面的代码。</p><pre><code class=\"language-plain\">struct Atype;\nstruct Btype;\nstruct Ctype;\n\ntrait TraitA {}\n\nimpl TraitA for Atype {}\nimpl TraitA for Btype {}\nimpl TraitA for Ctype {}\n\nfn doit(i: u32) -&gt; dyn TraitA { // 注意这里的返回类型换成了 dyn TraitA\n&nbsp; if i == 0 {\n&nbsp; &nbsp; let a = Atype;\n&nbsp; &nbsp; return a\n&nbsp; } else if i == 1 {\n&nbsp; &nbsp; let b = Btype;\n&nbsp; &nbsp; return b\n&nbsp; } else {\n&nbsp; &nbsp; let c = Ctype;\n&nbsp; &nbsp; return c\n&nbsp; }\n}\n</code></pre><p>但是编译会报错。</p><pre><code class=\"language-plain\">error[E0746]: return type cannot have an unboxed trait object\n  --&gt; src/lib.rs:13:20\n   |\n13 | fn doit(i: u32) -&gt; dyn TraitA {\n   |                    ^^^^^^^^^^ doesn't have a size known at compile-time\n   |\nhelp: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n   |\n13 | fn doit(i: u32) -&gt; impl TraitA {\n   |                    ~~~~\nhelp: box the return type, and wrap all of the returned values in `Box::new`\n   |\n13 ~ fn doit(i: u32) -&gt; Box&lt;dyn TraitA&gt; {\n14 |   if i == 0 {\n15 |     let a = Atype;\n16 ~     return Box::new(a)\n17 |   } else if i == 1 {\n18 |     let b = Btype;\n19 ~     return Box::new(b)\n20 |   } else {\n21 |     let c = Ctype;\n22 ~     return Box::new(c)\n</code></pre><p>这段提示很经典，我们来仔细阅读一下。</p><p>它说 dyn TraitA 编译时尺寸未知。dyn trait确实不是一个固定尺寸类型。然后给出了第一个建议：你可以用 impl TraitA 来解决，前提是所有分支返回同一类型。随后给出了第二个建议，你可以用Box把dyn TraitA包起来。</p><p><span class=\"reference\">（👨‍🏫：有没有ChatGPT的即时感，聪明得不太像一个编译器。）</span></p><p>第一个建议我们已经试过了，Pass，我们按照第二种建议改一下试试。</p><pre><code class=\"language-plain\">struct Atype;\nstruct Btype;\nstruct Ctype;\n\ntrait TraitA {}\n\nimpl TraitA for Atype {}\nimpl TraitA for Btype {}\nimpl TraitA for Ctype {}\n\nfn doit(i: u32) -&gt; Box&lt;dyn TraitA&gt; {\n&nbsp; &nbsp; if i == 0 {\n&nbsp; &nbsp; &nbsp; &nbsp; let a = Atype;\n&nbsp; &nbsp; &nbsp; &nbsp; Box::new(a)\n&nbsp; &nbsp; } else if i == 1 {\n&nbsp; &nbsp; &nbsp; &nbsp; let b = Btype;\n&nbsp; &nbsp; &nbsp; &nbsp; Box::new(b)\n&nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; let c = Ctype;\n&nbsp; &nbsp; &nbsp; &nbsp; Box::new(c)\n&nbsp; &nbsp; }\n}\n</code></pre><p>这下完美了，编译通过，达成目标，我们成功地将不同类型的实例在同一个函数中返回了。</p><p>这里我们引入了一个新的东西 <code>Box&lt;T&gt;</code>。<code>Box&lt;T&gt;</code> 的作用是可以保证获得里面值的所有权，必要的时候会进行内存的复制，比如把栈上的值复制到堆中去。一旦值到了堆中，就很容易掌握到它的所有权。</p><p>具体到这个示例中，因为a、b、c都是函数中的局部变量，这里如果返回引用 <code>&amp;dyn TraitA</code> 的话是万万不能的，因为违反了所有权规则。而 <code>Box&lt;T&gt;</code> 就能满足这里的要求。后续我们在智能指针一讲中会继续讲解 <code>Box&lt;T&gt;</code>。</p><p>这里我们先暂停，我希望你可以用一点时间来回顾一下整个推导过程，这次令人印象深刻的类型“体操”值得我们多品味几次。</p><h3>利用trait object传参</h3><p>impl trait 和 dyn trait 也可以用于函数传参。</p><p>impl trait的示例：</p><pre><code class=\"language-plain\">struct Atype;\nstruct Btype;\nstruct Ctype;\n\ntrait TraitA {}\n\nimpl TraitA for Atype {}\nimpl TraitA for Btype {}\nimpl TraitA for Ctype {}\n\nfn doit(x: impl TraitA) {}\n// 等价于\n// fn doit&lt;T: TraitA&gt;(x: T) {}\n\nfn main() {\n    let a = Atype;\n    doit(a);\n    let b = Btype;\n    doit(b);\n    let c = Ctype;\n    doit(c);\n}\n</code></pre><p>dyn trait的示例：</p><pre><code class=\"language-plain\">struct Atype;\nstruct Btype;\nstruct Ctype;\n\ntrait TraitA {}\n\nimpl TraitA for Atype {}\nimpl TraitA for Btype {}\nimpl TraitA for Ctype {}\n\nfn doit(x: &amp;dyn TraitA) {}  // 注意这里用了引用形式 &amp;dyn TraitA\n\nfn main() {\n    let a = Atype;\n    doit(&amp;a);\n    let b = Btype;\n    doit(&amp;b);\n    let c = Ctype;\n    doit(&amp;c);\n}\n</code></pre><p>两种都可以。那么它们的区别是什么呢？</p><p>impl trait用的是编译器静态展开，也就是编译时具化（单态化）。上面那个impl trait示例展开后类似于下面这个样子。</p><pre><code class=\"language-plain\">struct Atype;\nstruct Btype;\nstruct Ctype;\n\ntrait TraitA {}\n\nimpl TraitA for Atype {}\nimpl TraitA for Btype {}\nimpl TraitA for Ctype {}\n\nfn doit_a(x: Atype) {}\nfn doit_b(x: Btype) {}\nfn doit_c(x: Ctype) {}\n\nfn main() {\n    let a = Atype;\n    doit_a(a);\n    let b = Btype;\n    doit_b(b);\n    let c = Ctype;\n    doit_c(c);\n}\n</code></pre><p>而 dyn trait的版本不会在编译期间做任何展开，dyn TraitA 自己就是一个类型，这个类型相当于一个代理类型，用于在运行时代理相关类型及调用对应方法。既然是代理，也就是调用方法的时候需要多跳转一次，从性能上来说，当然要比在编译期直接展开一步到位调用对应函数要慢一点。</p><p>静态展开也有问题，就是会使编译出来的内容体积增大，而dyn trait就不会。所以它们各有利弊，可以根据需求视情况选择。另外，<strong>impl trait和dyn trait都是消除类型参数的办法</strong>。</p><p>那它们和enum相比呢？</p><p>enum是封闭类型集，可以把没有任何关系的任意类型包裹成一个统一的单一类型。后续的任何变动，都需要改这个统一类型，以及基于这个enum的模式匹配等相关代码。而impl trait和dyn trait是开放类型集。只要对新的类型实现trait，就可以传入使用了impl trait或dyn trait的函数，其函数签名不用变。</p><p>上述区别对于库的提供者非常重要。如果你提供了一个库，里面的多类型使用的enum包装，那么库的使用者没办法对你的enum进行扩展。因为一般来说，我们不鼓励去修改库里面的代码。而用 impl trait 或 dyn trait 就可以让接口具有可扩展性。用户只需要给他们的类型实现你的库提供的trait，就可以代入库的接口使用了。</p><p>而对于impl trait来说，它目前只能用于少数几个地方。一个是函数参数，另一个是函数返回值。其他的静态展开场景就得用类型参数形式了。</p><p>dyn trait本身是一种非固定尺寸类型，这就注定了相比于 impl trait 它能应用于更多场合，比如利用trait obj把不同的类型装进集合里。</p><h3>利用trait obj将不同的类型装进集合里</h3><p>我们看下面的示例，我们想把三种类型装进一个Vec里面。</p><pre><code class=\"language-plain\">struct Atype;\nstruct Btype;\nstruct Ctype;\n\ntrait TraitA {}\n\nimpl TraitA for Atype {}\nimpl TraitA for Btype {}\nimpl TraitA for Ctype {}\n\nfn main() {\n    let a = Atype;\n    let b = Btype;\n    let c = Ctype;\n    \n    let v = vec![a, b, c];\n}\n</code></pre><p>报错：</p><pre><code class=\"language-plain\">error[E0308]: mismatched types\n  --&gt; src/main.rs:19:21\n   |\n19 |     let v = vec![a, b, c];\n   |                     ^ expected `Atype`, found `Btype`\n</code></pre><p>因为Vec中要求每一个元素是同一种类型，不能将不同的类型实例放入同一个Vec。而利用trait object，我们可以“绕”过这个限制。</p><p>请看示例：</p><pre><code class=\"language-plain\">struct Atype;\nstruct Btype;\nstruct Ctype;\n\ntrait TraitA {}\n\nimpl TraitA for Atype {}\nimpl TraitA for Btype {}\nimpl TraitA for Ctype {}\n\nfn main() {\n    let a = Atype;\n    let b = Btype;\n    let c = Ctype;\n    let v: Vec&lt;&amp;dyn TraitA&gt; = vec![&amp;a, &amp;b, &amp;c];\n}\n</code></pre><p>成功了，不同类型的实例（实际是实例的引用）竟然被放进了同一个Vec中，强大！你可以自己尝试一下，将不同类型的实例放入HashMap中。</p><p>既然trait object这么好用，那是不是可以随便使用呢？不是的。除了前面提到的性能损失之外，还有一个问题，不是所有的trait都可以做dyn化，也就是说，不是所有的trait都能转成trait object使用。</p><h3>哪些trait能用作trait object？</h3><p>只有满足对象安全（object safety）的trait才能被用作trait object。Rust参考手册上有关于 <a href=\"https://doc.rust-lang.org/beta/reference/items/traits.html?highlight=object#object-safety\">object safety</a> 的详细规则，比较复杂。这里我们了解常用的模式就行。</p><p>安全的trait object：</p><pre><code class=\"language-plain\">trait TraitA {\n    fn foo(&amp;self) {}\n    fn foo_mut(&amp;mut self) {}\n    fn foo_box(self: Box&lt;Self&gt;) {}\n}\n</code></pre><p>不安全的trait object：</p><pre><code class=\"language-plain\">trait NotObjectSafe {\n    const CONST: i32 = 1;  // 不能包含关联常量\n\n    fn foo() {}  // 不能包含这样的关联函数\n    fn selfin(self); // 不能将Self所有权传入\n    fn returns(&amp;self) -&gt; Self; // 不能返回Self\n    fn typed&lt;T&gt;(&amp;self, x: T) {} // 方法中不能有类型参数\n}\n</code></pre><p>规则确实比较复杂，你可以简单记住几种场景。</p><ol>\n<li>不要在trait里面定义构造函数，比如new这种返回Self的关联函数。你可以发现，确实在整个Rust生态中都没有将构造函数定义在trait中的习惯。</li>\n<li>trait里面尽量定义传引用 &amp;self 或 &amp;mut self的方法，而不要定义传值 self 的方法。</li>\n</ol><p>并不是所有的trait都能以trait object形式（dyn trait）使用，实际上，以dyn trait使用的场景可能是少数。所以你可以在遇到编译器报错的时候再回头来审视trait定义得是否合理。大部分情况下可以放心使用。</p><h2>小结</h2><p><img src=\"https://static001.geekbang.org/resource/image/49/82/4951a0fdf2c4636f357702ac837c3382.jpg?wh=1390x1048\" alt=\"\"></p><p>在这节课的前半部分，我们讲解了trait中带类型参数的情况。各种符号组合起来，确实越来越复杂了。不过还是那句话，模式就那几种，只要花点时间熟悉理解，其实并不难。开始的时候能认识就行，后面在实践中再慢慢掌握。</p><p>我们使用带类型参数的trait实现了其他语言中函数重载的功能。看起来途径有点曲折，但是带给了我们一条全新的思路：以往的语言必须给自身添加各种特性来满足用户的要求，在Rust中，用好trait就能搞定。这让我们对Rust的未来充满期待，随着时间的发展，它不会像C++、Java那样永不停歇地添加可能会导致组合爆炸的新特性，而让自身越来越臃肿。</p><p>我们还讨论了带类型参数的trait与关联类型的区别。它们之间并不存在绝对优势的一方，在合适的场景下选择合适的方案是最重要的。</p><p>然后我们通过一个问题：如何让一个Rust函数返回可能的多种类型？推导出了引入trait object方案的必要性。整个推导过程比较曲折，同时也是对Rust类型系统的一次精彩探索。在这个探索过程中，我们和Rustc小助手成为了好朋友，在它的协助下，我们找到了最佳方案。</p><p>最后我们了解了trait object的一些用途，并讨论了trait object、impl trait，还有使用枚举对类型进行聚合这三种方式之间的区别。类型系统（类型+ trait）是Rust的大脑，你可以多加练习，熟悉它的形式，掌握它的用法。</p><h2>思考题</h2><p>请谈谈在函数参数中传入 <code>&amp;dyn TraitA</code> 与 <code>Box&lt;dyn TraitA&gt;</code> 两种类型的区别。</p><p>欢迎你把思考后的结果分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"09｜初识trait：协议约束与能力配置","id":723496},"right":{"article_title":"11｜常见trait解析：标准库中的常见trait应该怎么用？","id":724942}},"comments":[{"had_liked":false,"id":383755,"user_name":"哄哄","can_delete":false,"product_type":"c1","uid":3779530,"ip_address":"北京","ucode":"F75FB23BEDC60A","user_header":"https://static001.geekbang.org/account/avatar/00/39/ab/ca/32d6c05d.jpg","comment_is_top":false,"comment_ctime":1699578301,"is_pvip":false,"replies":[{"id":139953,"content":"真不错👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699591105,"ip_address":"重庆","comment_id":383755,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"rust生命周期的独特设计，导致了该语言需要设计一些处理方式应对特殊情况，比如生命周期的标注（主要是给编译器进行代码处理时的提示）。事实上，我们在日常开发中应该避免一些陷入复杂情况的方式：比如，传入参数都用引用（borrow），传出结果都应该是owner。rust也为我们提供了处理各种情况的工具。所以，一般来说，我们应该在传入参数的时候用&amp;dyn T，传出结果用Box&lt;dyn T&gt;。","like_count":18,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631474,"discussion_content":"真不错👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699591105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1624977,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cb/91/14398631.jpg","nickname":"王超","note":"","ucode":"3CE4B6863C28A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636923,"discussion_content":"Box目测和go的逃逸分析有点类似","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1707264693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"中国澳门","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383758,"user_name":"鸠摩智","can_delete":false,"product_type":"c1","uid":1106201,"ip_address":"江苏","ucode":"853E584FC4CD64","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/19/c756aaed.jpg","comment_is_top":false,"comment_ctime":1699581172,"is_pvip":true,"replies":[{"id":139956,"content":"对的","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699591193,"ip_address":"重庆","comment_id":383758,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"&amp;dyn TraitA没有所有权，而Box&lt;dyn TraitA&gt;有所有权。","like_count":6,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631477,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699591193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383753,"user_name":"哄哄","can_delete":false,"product_type":"c1","uid":3779530,"ip_address":"北京","ucode":"F75FB23BEDC60A","user_header":"https://static001.geekbang.org/account/avatar/00/39/ab/ca/32d6c05d.jpg","comment_is_top":false,"comment_ctime":1699573759,"is_pvip":false,"replies":[{"id":139954,"content":"思考方式很棒！","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699591177,"ip_address":"重庆","comment_id":383753,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"关联类型之所以要单独设计，因为编译器可以通过输入判断具体类型，而无法推断出输出类型，所以，输出的类型需要明确指定","like_count":6,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631475,"discussion_content":"思考方式很棒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699591177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1445744,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0f/70/f59db672.jpg","nickname":"槑·先生","note":"","ucode":"897F0475592E3A","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635511,"discussion_content":"在方法调用处接住了返回值也是可以做一些推断的吧，不过确实相比输入参数，这里的上下文要更复杂一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704898291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383804,"user_name":"鸠摩智","can_delete":false,"product_type":"c1","uid":1106201,"ip_address":"江苏","ucode":"853E584FC4CD64","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/19/c756aaed.jpg","comment_is_top":false,"comment_ctime":1699672121,"is_pvip":true,"replies":[{"id":139962,"content":"非常赞同你的学习方法，慢就是快！最精髓的地方就那么几个，花5倍时间理解透，未来可以节省500，5000，50000倍的时间，还能站🉐️更高。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699706032,"ip_address":"重庆","comment_id":383804,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"这篇文章真不错，值得反复看。慢就是快，学习不能浮躁，妄想速成，一知半解反而给后边的学习造成很多障碍。","like_count":4,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631536,"discussion_content":"非常赞同你的学习方法，慢就是快！最精髓的地方就那么几个，花5倍时间理解透，未来可以节省500，5000，50000倍的时间，还能站🉐️更高。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699706032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383774,"user_name":"-","can_delete":false,"product_type":"c1","uid":1546505,"ip_address":"北京","ucode":"7B34258D346793","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/09/29c46a7b.jpg","comment_is_top":false,"comment_ctime":1699604194,"is_pvip":false,"replies":[{"id":139995,"content":"这里面的设计原理确实比较dirty了。我先给出三篇文章参考，你可以深入下去研究：https:&#47;&#47;rustcc.cn&#47;article?id=e80a98d7-4adb-4d39-bf0a-4e079bcb1835  https:&#47;&#47;segmentfault.com&#47;a&#47;1190000022104780  https:&#47;&#47;rust-lang.github.io&#47;rfcs&#47;0255-object-safety.html ","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699848288,"ip_address":"重庆","comment_id":383774,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"最后安全的trait object听的似懂非懂，为什么是安全的，为什么是不安全的？希望具体讲下原因","like_count":2,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631623,"discussion_content":"这里面的设计原理确实比较dirty了。我先给出三篇文章参考，你可以深入下去研究：https://rustcc.cn/article?id=e80a98d7-4adb-4d39-bf0a-4e079bcb1835  https://segmentfault.com/a/1190000022104780  https://rust-lang.github.io/rfcs/0255-object-safety.html ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699848288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1979955,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/36/33/3411df0d.jpg","nickname":"seven9t","note":"","ucode":"B7CA7D62C56938","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":635158,"discussion_content":"可以从使用上层角度说下不这么做的话会导致什么问题，否则意思就是它就是选择这样实现的了（即可能存在其他实现方式可以不设这些约束","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704449484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":631623,"ip_address":"广东","group_id":0},"score":635158,"extra":""}]},{"author":{"id":1287406,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a4/ee/b960a322.jpg","nickname":"mihello","note":"","ucode":"4B1E7B7A141606","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635085,"discussion_content":"https://doc.rust-lang.org/reference/items/traits.html 补充","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704378733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1287406,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a4/ee/b960a322.jpg","nickname":"mihello","note":"","ucode":"4B1E7B7A141606","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635068,"discussion_content":"最近两章，加上这几篇文章醍醐灌顶。怪不得rust这么难，难出天际...，收获良多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704372369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385454,"user_name":"superggn","can_delete":false,"product_type":"c1","uid":3623568,"ip_address":"北京","ucode":"831CCD98B393FE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","comment_is_top":false,"comment_ctime":1702634091,"is_pvip":false,"replies":[{"id":140563,"content":"真棒！","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1703123324,"ip_address":"重庆","comment_id":385454,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"笔记：\n\n\n\ntrait 可以带泛型 generics\n\ntrait 关联类型 associated type 跟泛型类似， 但必须在 impl 的时候就具化\n\n泛型就随便啥时候具化都行了\n\n\n\n\n\n`fn doit(i: u32) -&gt; impl TraitA` =&gt; 某一种实现了 TraitA 的类型\n\n`fn doit(i: u32) -&gt; Box&lt;dyn TraitA&gt;` =&gt; 多种实现了 TraitA 的类型\n\n\n\n前两次刷 rbe 和 rustbook 的时候都没反应过来为啥叫 trait object, 看这课终于明白了， 原来 trait obejct 指的是 typeOuter 的 OuterSizedObj, 然后这个 OuterSizedObj 里面可以包裹各种实现了 traitA 的 type 对应 obj\n\n还是得多刷点儿资料， 多看对于同一概念的不同表达， 明白的快\n\n\n\n","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634239,"discussion_content":"真棒！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1703123324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385453,"user_name":"superggn","can_delete":false,"product_type":"c1","uid":3623568,"ip_address":"北京","ucode":"831CCD98B393FE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","comment_is_top":false,"comment_ctime":1702634061,"is_pvip":false,"replies":[{"id":140474,"content":"对的。👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1702702168,"ip_address":"重庆","comment_id":385453,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"思考题： &amp;dyn traitA 和 Box&lt;dyn traitA&gt; 严格来说都是指向 actual object 的指针， 只不过 `&amp;` 叫做引用， `Box` 叫做智能指针, 这俩都是固定大小的， 所以都能用在 trait object\n\n区别：\n&amp;dyn traitA 是一个不拿所有权的指针 =&gt; 所以经常用在参数里\nBox&lt;dyn traitA&gt; 是拥有内部数据所有权的指针 =&gt; 所以经常用在返回值里， 参数里应该也能用\n\n\n","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633877,"discussion_content":"对的。👍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1702702168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":387433,"user_name":"李诗涛","can_delete":false,"product_type":"c1","uid":2307830,"ip_address":"上海","ucode":"F0F8A0CFE815F8","user_header":"https://static001.geekbang.org/account/avatar/00/23/36/f6/7945e06f.jpg","comment_is_top":false,"comment_ctime":1707272144,"is_pvip":false,"replies":[{"id":141262,"content":"你可以再仔细理解一下impl trait 放在入参位置的示例和放在返回值位置的区别。它们实际都是编译期展开的应用，但是逻辑会有区别。由于返回值的if是运行时才有值来判断，因此在每次调用实例时，它无法在编译期推导出准确的返回值类型。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1708823204,"ip_address":"加拿大","comment_id":387433,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"老师老师，我有一个问题。就是您说impl trait目前有两个使用的地方，分别是函数入参和返回。但给出的例子里，在入参使用impl trait时编译器会自动展开。但在出返回值使用impl trait时，若是返回了不同的类型却会报错。这是怎么理解？","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":637687,"discussion_content":"你可以再仔细理解一下impl trait 放在入参位置的示例和放在返回值位置的区别。它们实际都是编译期展开的应用，但是逻辑会有区别。由于返回值的if是运行时才有值来判断，因此在每次调用实例时，它无法在编译期推导出准确的返回值类型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1708823204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"加拿大","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385946,"user_name":"小可爱(`へ´*)ノ","can_delete":false,"product_type":"c1","uid":1016404,"ip_address":"四川","ucode":"E75189846F6616","user_header":"https://static001.geekbang.org/account/avatar/00/0f/82/54/b9cd3674.jpg","comment_is_top":false,"comment_ctime":1703725267,"is_pvip":false,"replies":[{"id":140658,"content":"好滴, 记下了，后面会持续输出。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1703770679,"ip_address":"重庆","comment_id":385946,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"基础部分非常详细，建议老师可以深入讲一下trait object的内存相关知识，以及trait object会丢失本身类型信息这些注意点。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634658,"discussion_content":"好滴, 记下了，后面会持续输出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703770679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384240,"user_name":"-Hedon🍭","can_delete":false,"product_type":"c1","uid":3176234,"ip_address":"湖北","ucode":"FAE541E7A2B88F","user_header":"https://static001.geekbang.org/account/avatar/00/30/77/2a/0cd4c373.jpg","comment_is_top":false,"comment_ctime":1700569701,"is_pvip":false,"replies":[{"id":140227,"content":"👍👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700707942,"ip_address":"重庆","comment_id":384240,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"思考题：&amp;dyn TraitA 是借用，Box&lt;dyn TraitA&gt; 会转移所有权。\n\n通过下面的程序可以测试出来：\n\nfn doit3(t1: &amp;dyn TraitA, t2: Box&lt;dyn TraitA&gt;) {\n    println!(&quot;{:?}&quot;, t1);\n    println!(&quot;{:?}&quot;, t2)\n}\n\nfn main() {\n    let a = AType;\n    let b = BType;\n    doit3(&amp;a, Box::new(b));\n    println!(&quot;{:?}&quot;, a);\n    println!(&quot;{:?}&quot;, b);\n}\n\n输出：\n\nerror[E0382]: borrow of moved value: `b`\n  --&gt; examples&#47;trait_object.rs:29:22\n   |\n26 |     let b = BType;\n   |         - move occurs because `b` has type `BType`, which does not implement the `Copy` trait\n27 |     doit3(&amp;a, Box::new(b));\n   |                        - value moved here\n28 |     println!(&quot;{:?}&quot;, a);\n29 |     println!(&quot;{:?}&quot;, b);\n   |                      ^ value borrowed here after move\n","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632354,"discussion_content":"👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700707942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384216,"user_name":"老大","can_delete":false,"product_type":"c1","uid":1109637,"ip_address":"河南","ucode":"1134808B441F74","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/85/c0cf6544.jpg","comment_is_top":false,"comment_ctime":1700547913,"is_pvip":false,"replies":[{"id":140221,"content":"观察得很细致，上面的例子主要是为了展现可能出现的写法。后面的说明加入了object safty的因素，以及社区的约定，所以看起来好像不一致，实际是一致的。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700707386,"ip_address":"重庆","comment_id":384216,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"不要在 trait 里面定义构造函数，比如 new 这种返回 Self 的关联函数。你可以发现，确实在整个 Rust 生态中都没有将构造函数定义在 trait 中的习惯。\n这句话，在上面的例子中 确实有在trait中定义了new函数返回self的。怎么就感觉有冲突呢？","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632347,"discussion_content":"观察得很细致，上面的例子主要是为了展现可能出现的写法。后面的说明加入了object safty的因素，以及社区的约定，所以看起来好像不一致，实际是一致的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700707386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384108,"user_name":"Ransang","can_delete":false,"product_type":"c1","uid":1133041,"ip_address":"上海","ucode":"DB67566A627DF2","user_header":"https://static001.geekbang.org/account/avatar/00/11/49/f1/bd61dbb1.jpg","comment_is_top":false,"comment_ctime":1700308493,"is_pvip":false,"replies":[{"id":140164,"content":"👍，这种探索的方式很棒。&#39;static 确实起这个作用。在 Rust 中，&#39;static 生命期是整个程序的持续时间。当你在类型前面加上 &#39;static 时，你告诉 Rust 编译器这个引用应该在整个程序运行期间都有效。\n\n但是这并不意味着你可以返回一个指向局部变量的 &#39;static 引用。这是因为局部变量在函数返回时就会被销毁，所以任何指向它们的引用在函数返回后都将变得无效。这个 &#39;static 告诉 Rust 编译器这个引用应该在整个程序运行期间都有效，于是Rust就信了，即使实际上这是不可能的，所以还是要用Box。从这一点也能看出Rust编译器也不完美。\n\n然后第20讲会讲生命期的概念，但是也不会特别深入。初学Rust的时候，先不用花大量时间在这上面，可以把这个问题留到后面去。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700541856,"ip_address":"重庆","comment_id":384108,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"struct Atype;\nstruct Btype;\nstruct Ctype;\n\ntrait TraitA {}\n\nimpl TraitA for Atype {}\nimpl TraitA for Btype {}\nimpl TraitA for Ctype {}\n\nfn doit(i: u32) -&gt; &amp;&#39;static dyn TraitA { &#47;&#47; 注意这里的返回类型换成了 dyn TraitA\n  if i == 0 {\n    return &amp;Atype\n  } else if i == 1 {\n    return &amp;Btype\n  } else {\n    return &amp;Ctype\n  }\n}\n老师 我这种也能通过编译 ，我一开始尝试用&amp;dyn TraitA没通过编译，小助手报错error[E0106]: missing lifetime specifier并提示我用&amp;&#39;static dyn TraitA，在字符串那节您提过 &#39;static 表示这个引用可以贯穿整个程序的生命周期，想问下您这段代码为什么加了&#39;static就可以通过编译，以及这个生命周期的概念又是怎么回事，谢谢了","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632179,"discussion_content":"👍，这种探索的方式很棒。&#39;static 确实起这个作用。在 Rust 中，&#39;static 生命期是整个程序的持续时间。当你在类型前面加上 &#39;static 时，你告诉 Rust 编译器这个引用应该在整个程序运行期间都有效。\n\n但是这并不意味着你可以返回一个指向局部变量的 &#39;static 引用。这是因为局部变量在函数返回时就会被销毁，所以任何指向它们的引用在函数返回后都将变得无效。这个 &#39;static 告诉 Rust 编译器这个引用应该在整个程序运行期间都有效，于是Rust就信了，即使实际上这是不可能的，所以还是要用Box。从这一点也能看出Rust编译器也不完美。\n\n然后第20讲会讲生命期的概念，但是也不会特别深入。初学Rust的时候，先不用花大量时间在这上面，可以把这个问题留到后面去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700541856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383985,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"四川","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1700042365,"is_pvip":false,"replies":[{"id":140098,"content":"源码地址发来瞧瞧👀","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700121465,"ip_address":"重庆","comment_id":383985,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"老师，actix-web-4.4.0 的router.rs中的to方法： pub fn to&lt;F, Args&gt;(mut self, handler: F) -&gt; Self ，这个handler为什么可以接收一个async函数作为参数(async函数并未实现F trait的方法)呢？实在想不明白。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631905,"discussion_content":"源码地址发来瞧瞧👀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700121466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3737988,"avatar":"https://static001.geekbang.org/account/avatar/00/39/09/84/9e7aafcf.jpg","nickname":"《抡语》-中国","note":"","ucode":"A22E8C8807E7F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632426,"discussion_content":"蛙趣，大哥这个强的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700748198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383783,"user_name":"PEtFiSh","can_delete":false,"product_type":"c1","uid":1765926,"ip_address":"上海","ucode":"C4922398A92E05","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLO6XvxfFPMGcVSSX8uIZY2yib29qlyat178pU4QM3gIic5GXZ8PC0tzRiazP3FiajXbTj19SE4ZhV0gQ/132","comment_is_top":false,"comment_ctime":1699611152,"is_pvip":false,"replies":[{"id":139994,"content":"👍。初学者可以这样理解。最重要的是对所有权的理解。在具体实现上，dyn TraitA本身会构建一个vitual table进行代理过渡。你可以从这里了解到更细节的信息。https:&#47;&#47;docs.rs&#47;vptr&#47;latest&#47;vptr&#47;","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699847502,"ip_address":"重庆","comment_id":383783,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"&amp;dyn TraitA 是实现了TraitA的类型的对象的引用，Box&lt;dyn Trait&gt;则是获取了该对象的所有权。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631622,"discussion_content":"👍。初学者可以这样理解。最重要的是对所有权的理解。在具体实现上，dyn TraitA本身会构建一个vitual table进行代理过渡。你可以从这里了解到更细节的信息。https://docs.rs/vptr/latest/vptr/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699847502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383759,"user_name":"一个人旅行","can_delete":false,"product_type":"c1","uid":2555864,"ip_address":"北京","ucode":"A708238B10B44B","user_header":"https://static001.geekbang.org/account/avatar/00/26/ff/d8/d48d6088.jpg","comment_is_top":false,"comment_ctime":1699582940,"is_pvip":false,"replies":[{"id":139993,"content":"👍。初学者可以这样理解。最重要的是对所有权的理解。在具体实现上，dyn TraitA本身会构建一个vitual table进行代理过渡。你可以从这里了解到更细节的信息。https:&#47;&#47;docs.rs&#47;vptr&#47;latest&#47;vptr&#47;","user_name":"作者回复","user_name_real":"作者","uid":2186062,"ctime":1699847287,"ip_address":"重庆","comment_id":383759,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"1. &amp;dyn TraitA 是一个引用，引用指向实现了TraitA特征的具体类型，没有这个具体类型的所有权，相当于借用。\n2. Box&lt;dyn TraitA&gt; 是一个智能指针，将实现了TraitA特征的具体类型保存在堆上，并且拥有这个具体类型的所有权。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631621,"discussion_content":"👍。初学者可以这样理解。最重要的是对所有权的理解。在具体实现上，dyn TraitA本身会构建一个vitual table进行代理过渡。你可以从这里了解到更细节的信息。https://docs.rs/vptr/latest/vptr/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699847287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":396253,"user_name":":-O","can_delete":false,"product_type":"c1","uid":2067731,"ip_address":"浙江","ucode":"20EF422CAB2875","user_header":"https://static001.geekbang.org/account/avatar/00/1f/8d/13/943a4759.jpg","comment_is_top":false,"comment_ctime":1733760878,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"很棒的文章，我看懂trait了","like_count":0}]}