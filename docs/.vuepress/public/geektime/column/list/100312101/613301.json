{"id":613301,"title":"03｜隐式传递：如何精准找出一次请求的全部日志？","content":"<p>你好，我是何辉。</p><p>上一讲我们学习了如何把一些耗时的业务进行异步化改造，核心三要素就是开启异步模式、衔接上下文信息、将结果写入到上下文中，这也是Dubbo的异步实现原理。</p><p>今天我们继续探索Dubbo框架的第二道特色风味，隐式传递。</p><p>在我们痛并快乐着的日常开发工作中，修bug已经是很常见一环了，当编写的功能出了bug，我们一般会先根据现象分析可能存在的问题，如果没头绪，就会继续根据用户提供的有限关键字信息，去查看相关日志希望能找到蛛丝马迹。</p><p>在这个环节，如果关键字信息比较独特且唯一，我们比较容易排查出问题，但如果关键字不那么独特，我们很可能需要从检索出来的一堆日志中继续痛苦地分析。</p><p>然而痛苦才刚刚开始，实际开发会涉及很多系统，如果出问题的功能调用流程非常复杂，你可能都不确定找到的日志是不是出问题时的日志，也可能只是找到了出问题时日志体系中的小部分，还可能找到一堆与问题毫无关系的日志。比如下面这个复杂调用关系：</p><p><img src=\"https://static001.geekbang.org/resource/image/33/47/33b9bcba4120a1e2cbd081f98ce69447.jpg?wh=1920x817\" alt=\"图片\"></p><p>图中描述了一种多系统合作的链路，一个请求调用了系统A，接着系统A分别调用了系统B和系统D，然后系统B还调用了系统C。</p><p>通过请求中的关键字，我们在A、B、C、D系统中找到了相关日志：</p><pre><code class=\"language-java\">2022-10-28 23:29:01.302 [系统A,DubboServerHandler-1095] INFO com.XxxJob - [JOB] calling start [emp_airOrderNoticeJob]&nbsp;\n2022-10-28 23:29:02.523 [系统B,DubboServerHandler-1093] INFO WARN XxxImpl - queryUser 入参参数为: xxxx&nbsp;\n2022-10-28 23:30:23.257 [系统C,DubboServerHandler-1096] INFO ABCImpl - recv Request...&nbsp;\n2022-10-28 23:30:25.679 [系统D,DubboServerHandler-1094] INFO XyzImpl - doQuery Start...&nbsp;\n2022-10-28 23:31:18.310 [系统B,DubboServerHandler-1093] INFO WARN XxxImpl - queryUser 入参参数不正确\n</code></pre><!-- [[[read_end]]] --><p>说明一下，这段日志信息是方便我们具体分析问题模拟出来的，但日常你看到的日志格式也是大同小异。看系统B的 DubboServerHandler-1093 线程打印的两行日志，第一眼从打印内容的上下文关系上看，我们会误认为这就是要找的错误信息。</p><p>但实际开发中一定要考虑不同请求、不同线程这两个因素，<strong>你能确定这两行日志一定是同一次请求、同一个线程打印出来的么？</strong></p><p>其实并不能，那有什么更好的办法来区分出来呢。</p><h2>日志检索问题</h2><p>现在的主要问题就变成了一次请求调用系统A、B、C、D，如何精准找出一次请求所打印的全部日志？</p><p>其实思路也很简单，类似田径400米接力赛跑，一个请求，如果有一个序列号，而且序列号还能被“接棒”传到系统A、B、C、D，那么我们就可以利用这个序列号，将这次请求的日志全部检索出来。</p><p><img src=\"https://static001.geekbang.org/resource/image/f7/93/f73c30db757a51c0aaeff59b7cd81793.jpg?wh=1920x817\" alt=\"图片\"></p><p>结合刚才的例子，系统B的 DubboServerHandler-1093 线程打印的两行日志，如果有一个序列号的体现，我们就能确定是不是同一次请求所打印的。</p><p>可是该怎么把一次请求动态生成的序列号，传递到此次请求所涉及的所有系统中去呢？</p><h3>1. 显式传递</h3><p>最显而易见的方案就是显式传参。我们可以在所有系统接收请求的对象中，统一添加一个序列号字段，让大家都按照一定的规约进行编码传递。来草拟一个抽象请求基类：</p><pre><code class=\"language-java\">@Setter\n@Getter\n@ToString\npublic class AbstractRequest implements Serializable {\n    \n    /** &lt;h2&gt;请求流水号，打印日志使用，而且还是必填字段&lt;/h2&gt; **/\n    @NotBlank\n    private String reqNo;\n}\n</code></pre><p>在代码中定义一个 AbstractRequest 抽象的请求类，再定义一个请求流水号字段，并且标明是必填字段，让系统所有接收请求的对象都继承这个 AbstractRequest 抽象类。<br>\n这样一来，因为继承关系，每个接收请求的对象都相当于有了 reqNo 字段，最后告诉调用方按照要求传参就可以了。</p><p>思路很美好，但这个时候相信你一定发现了第一个盲点：<strong>考虑方案的落地，已有对象如何修改呢？</strong></p><p>我们顺着这个思路先比划比划流程：</p><p><img src=\"https://static001.geekbang.org/resource/image/34/f0/343af91420f4582ec87743739c64b9f0.jpg?wh=1920x580\" alt=\"图片\"></p><p>把系统中所有接收请求的对象找出来，然后挨个修改这些对象的继承属性，改为继承 AbstractRequest 类，最后在打印日志的时候顺便把 reqNo 字段值打印出来。</p><p>但是需要修改多少个接收请求对象的类呢？系统中有10个对象就要改10个，有100个对象那就改100个，但系统中有10000个对象，要改10000个？不太实际，而且在开发环境中，系统中接收请求对象的个数是不可估量的，我们光改个继承关系，就能改上几天几夜，还无法保证不出问题。</p><p>哪怕假设修改量不大，我们在打印日志的时候还会遇到第二个更难处理的问题。</p><p>打印的一般思路是在处理业务逻辑之前，将入参 req 对象中的 reqNo 字段值打印出来：</p><pre><code class=\"language-java\">@DubboService\n@Component\npublic class UserQueryFacadeImpl implements UserQueryFacade {\n    private Logger logger = LoggerFactory.getLogger(UserQueryFacadeImpl.class);\n    @Override\n    public QueryUserInfoUserResp queryUserInfo(QueryUserInfoReq req) {\n        logger.info(\"reqNo: {}, queryUser 入参参数为: {}\", req.getReqNo(), req);\n        \n        // 省略其他逻辑...\n    }\n}\n</code></pre><p>看起来不错，至少可以通过流水号来检索出日志了。但问题是我们只有在 queryUserInfo 当前的方法体中才能拿到 req 对象。</p><p><strong>万一其他接口的请求对象不是 QueryUserInfoReq 这种类型，而是 String、Integer 这种类型的话，该怎么继承呢？</strong>String、Integer 都是 JDK 中非常基础的类，根本无法修改，即便能修改，我们也不敢改，毕竟这些类在代码中遍地都是，一旦修改影响面根本无法预估。</p><p>而且为了确保在代码的任何一个角落都能拿到 reqNo 字段值，如果想在子方法、子子方法中继续打印 reqNo 字段，还得把 req 对象传下去，我们都能想像到将来代码中遍地都是各种 req 对象传来传去惨不忍睹的画面，代码的可读性非常糟糕。</p><p>如果 queryUserInfo 还需要调用下游系统，还得想办法把 QueryUserInfoReq 对象中的 reqNo 字段值取出来，然后赋值到下游的请求对象中，这又得把所有涉及下游系统请求对象的代码又全部改一遍。</p><p>所以，按显式方式处理序列号越想问题越多，我们不但得一顿大改，还会把整个工程代码整得鸡犬不宁，乌烟瘴气。既然显式传参不行，有没有其他方案呢？</p><h3>2.隐式传递</h3><p>现在的问题就转变为，既不能改动方法的请求入参对象，也不能在工程中遍地开花地修改代码，还要能在日志中看到序列号，似乎有点困难。</p><p>但是仔细分析这个需求，你就能找到突破点。请求入参对象，都是一些处理业务功能需要的对象，但是这个序列号参数，业务其实并不需要，因为业务不关心日志怎么打印，也不关心开发人员怎么排查问题。</p><p>所以序列号和业务对象在一定程度上划分了界限，我们可以<strong>把业务对象划分到业务属性，把请求序列号划分到技术属性</strong>。以一次简单的请求发送为例：</p><p><img src=\"https://static001.geekbang.org/resource/image/bb/28/bbc733e24580345846cfda3362c18528.jpg?wh=1920x580\" alt=\"图片\"></p><p>HTTP请求在向系统A发起请求时，需要想办法将技术属性和业务属性都发送给系统A，怎么编写代码发送HTTP请求的呢？</p><p>回忆平时发送HTTP请求的逻辑步骤：</p><ol>\n<li>将业务对象设置到HTTP的请求体中；</li>\n<li>将一些Content-Type、Content-Length属性等设置到请求头中；</li>\n<li>设置URL，发起HTTP请求。</li>\n</ol><p>所以我们可以将业务属性放到请求体中，将技术属性放到请求头中，这样不就把技术属性和业务属性一起发送出去了么。</p><p><strong>可是系统A与系统B、C、D之间是Dubbo调用的，又该怎么解决技术属性的传递问题呢？</strong></p><p>同样地，我们回忆平时编写代码进行Dubbo远程调用时的流程链路：</p><p><img src=\"https://static001.geekbang.org/resource/image/22/05/22e6b83e56f00123cd7c5db848e3e005.jpg?wh=1920x823\" alt=\"图片\"></p><p>这是一个比较简单的消费者调用提供者的链路图，在消费者调用的过程中，一些附加的信息可以设置到RpcContext上下文中去，然后RpcContext中的信息就会随着远程调用去往提供者那边。</p><p>可以看到，调用链路图中的附带参数设置形式和HTTP的请求头设置形式，几乎是如出一辙。所以我们可以考虑将序列号设置到RpcContext中，这样就能既不改动方法的请求入参对象，又不用大范围进行修改了。</p><p>那如何把参数设置到RpcContext中呢？我们进入今天的高潮环节——隐式传参的实现。</p><h2>编码实现</h2><p>对于技术属性的设置，现在的你肯定知道是不能大肆在代码各个角落进行操作的，也不现实，我们需要有一个集中的环节可以进行操作，那么这个集中环节在哪里呢？</p><p>再来看调用链路图：</p><p><img src=\"https://static001.geekbang.org/resource/image/53/9b/53da04ab9bb2d105779ecb45c9d3d49b.jpg?wh=1920x823\" alt=\"图片\"></p><p>为了尽可能降低侵入性，我们最好能在系统的入口和出口，把接收数据的操作以及发送数据的操作进行完美衔接。这就意味着需要在接收请求的内部、发送请求的内部做好数据的交换。</p><p>再结合前面的消费者调用提供者的链路图，编写业务代码无感知的“过滤器”，似乎能完美满足需求：</p><ul>\n<li>系统A接收请求，站在提供者的角度，在处理接口实现逻辑之前会经过滤器处理。</li>\n<li>系统A发送请求，站在消费者的角度，一样会经过滤器处理。</li>\n</ul><p>所以我们只需要定义一个消费者维度的序列号过滤器，然后再定义一个提供者维度的序列号过滤器，就可以把序列号在调用链路中完美衔接起来了。</p><p>来看代码实现：</p><pre><code class=\"language-java\">@Activate(group = PROVIDER, order = -9000)\npublic class ReqNoProviderFilter implements Filter {\n    public static final String TRACE_ID = \"TRACE-ID\";\n    @Override\n    public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException {\n        // 获取入参的跟踪序列号值\n        Map&lt;String, Object&gt; attachments = invocation.getObjectAttachments();\n        String reqTraceId = attachments != null ? (String) attachments.get(TRACE_ID) : null;\n        \n        // 若 reqTraceId 为空则重新生成一个序列号值，序列号在一段相对长的时间内唯一足够了\n        reqTraceId = reqTraceId == null ? generateTraceId() : reqTraceId;\n        \n        // 将序列号值设置到上下文对象中\n        RpcContext.getServerAttachment().setObjectAttachment(TRACE_ID, reqTraceId);\n        \n        // 并且将序列号设置到日志打印器中，方便在日志中体现出来\n        MDC.put(TRACE_ID, reqTraceId);\n        \n        // 继续后面过滤器的调用\n        return invoker.invoke(invocation);\n    }\n}\n\n@Activate(group = CONSUMER, order = Integer.MIN_VALUE + 1000)\npublic class ReqNoConsumerFilter implements Filter, Filter.Listener {\n    public static final String TRACE_ID = \"TRACE-ID\";\n    @Override\n    public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException {\n        // 从上下文对象中取出跟踪序列号值\n        String existsTraceId = RpcContext.getServerAttachment().getAttachment(TRACE_ID);\n        \n        // 然后将序列号值设置到请求对象中\n        invocation.getObjectAttachments().put(TRACE_ID, existsTraceId);\n        RpcContext.getClientAttachment().setObjectAttachment(TRACE_ID, existsTraceId);\n        \n        // 继续后面过滤器的调用\n        return invoker.invoke(invocation);\n    }\n}\n</code></pre><p>思路也很清晰，主要新增了两个过滤器：</p><ul>\n<li>ReqNoProviderFilter 为提供者维度的过滤器，主要接收请求参数中的 traceId，并将 traceId 的值放置到RpcContext上下文对象中。</li>\n<li>ReqNoConsumerFilter 为消费者维度的过滤器，主要从RpcContext上下文对象中取出 traceId 的值，并放置到 invocation 请求对象中。</li>\n</ul><p>然后遵循Dubbo的SPI特性将两个过滤器添加到 META-INF/dubbo/org.apache.dubbo.rpc.Filter 配置文件中：</p><pre><code class=\"language-markdown\">reqNoConsumerFilter=com.hmilyylimh.cloud.ReqNoConsumerFilter\nreqNoProviderFilter=com.hmilyylimh.cloud.ReqNoProviderFilter\n</code></pre><p>最后修改一下日志器的打印日志模式：</p><pre><code class=\"language-makefile\">%d{yyyy-MM-dd HH:mm:ss.SSS} [${APP_NAME}, %thread, %X{X-TraceId}] %-5level %c{1} -%msg%n\n</code></pre><p>经过改造后，我们看到的日志就会是这样的：</p><pre><code class=\"language-java\">2022-10-29 14:29:01.302 [系统A,DubboServerHandler-1095,5a2e67913efee084] INFO com.XxxJob - [JOB] calling start [emp_airOrderNoticeJob]&nbsp;\n2022-10-29 14:29:02.523 [系统B,DubboServerHandler-1093,9b42e2bf4bc2808e] INFO WARN XxxImpl - queryUser 入参参数为: xxxx&nbsp;\n2022-10-29 14:30:23.257 [系统C,DubboServerHandler-1096,6j40e2mn4bc4508e] INFO ABCImpl - recv Request...&nbsp;\n2022-10-29 14:30:25.679 [系统D,DubboServerHandler-1094,wx92bn9f4bc2m8z4] INFO XyzImpl - doQuery Start...&nbsp;\n2022-10-29 14:31:18.310 [系统B,DubboServerHandler-1093,9b42e2bf4bc2808e] INFO WARN XxxImpl - queryUser 入参参数不正确\n</code></pre><p>看系统B的DubboServerHandler-1093线程打印的两行日志，1093后面都是 9b42e2bf4bc2808e 这个序列号值，说明这一定是同一次请求、同一个线程打印出来的日志。</p><p>有了这样的日志检索能力支撑，之前比较难排查的问题，基本上我们只需要两步就能很快搞定：</p><ul>\n<li>第一步，通过用户提供的少许关键字，检索出符合条件的日志，从这些日志中大致筛选出符合用户出问题的日志，然后从中随机拷贝一行日志的跟踪号。</li>\n<li>第二步，用拷贝的跟踪号继续检索所有日志，就可以将跟踪号这一次请求的所有日志全部检索出来，再来着重分析问题。</li>\n</ul><h2>隐式传递的应用</h2><p>显式传递，我们都知道，一般是在明确业务意义的一种接口契约形式，大家都按照接口契约各自行事。那今天学习的隐式传递，在我们的日常开发中，又有哪些应用场景呢？</p><p>第一，传递请求流水号，分布式应用中通过链路追踪号来全局检索日志。</p><p>第二，传递用户信息，以便不同系统在处理业务逻辑时可以获取用户层面的一些信息。</p><p>第三，传递凭证信息，以便不同系统可以有选择性地取出一些数据做业务逻辑，比如Cookie、Token等。</p><p>总体来说传递的都是一些技术属性数据，和业务属性没有太大关联，为了方便开发人员更为灵活地扩展系统能力，来更好地支撑业务的发展。</p><h2>总结</h2><p>今天，我们从一个检索日志困难的问题开始，分析了显式传递和隐式传递两种不同方案带来的问题和影响。</p><p>显式传递，会导致所有请求对象大改造、请求对象为String类型的局限性、调用下游系统设置入参逻辑大改造等，所以我们考虑通过隐式传递来处理。</p><p>类比HTTP协议的设计理念，我们发现技术属性与业务属性的区别，再结合Dubbo调用的流程图，在调用过程中，可以将技术属性设置到RpcContext中进行系统间传递，这样既不需要大改代码，也不需要和业务属性混在一起，最终通过自定义两个过滤器从代码层面落实方案。</p><p>这里也总结一下自定义过滤器的四个步骤：</p><ul>\n<li>首先，创建一个自定义的类，并实现 org.apache.dubbo.rpc.Filter 接口；</li>\n<li>其次，在自定义类上通过 @Activate 注解标识是提供方维度的过滤器，还是消费方维度的过滤器；</li>\n<li>然后，在自定义类中的 invoke 方法中实现传递逻辑，提供方过滤器从 invocation 取出 traceId 并设置到 ClientAttachment、MDC 中，消费方过滤器从 ClientAttachment 取出 traceId 并设置到 invocation 中；</li>\n<li>最后，将自定义的类路径添加到 META-INF/dubbo/org.apache.dubbo.rpc.Filter 文件中，并取个别名。</li>\n</ul><p>隐式传递的应用场景主要有3类，传递链路追踪号、传递用户信息、传递凭证信息。</p><h3>思考题</h3><p>你已经学会了使用RpcContext设置技术属性并传递到不同的系统中去，而 RpcContext 这个类也确实在实际开发中很常用。源码中是这么描述它的：</p><pre><code class=\"language-markdown\">RpcContext is a temporary state holder. States in RpcContext changes every time when request is sent or received.\n</code></pre><p>由此可见，RpcContext是临时状态的保持器，每次发送或接收请求时，RpcContext中的状态都会发生变化。<br>\nRpcContext有4个重要属性和你设置隐式的技术属性有关，分别是 SERVER_LOCAL、CLIENT_ATTACHMENT、SERVER_ATTACHMENT、SERVICE_CONTEXT，你知道它们的生命周期吗？</p><p>期待看到你的思考，如果你对隐式传递还有什么困惑，欢迎在留言区提问，我会第一时间回复。</p><p>如果觉得今天的内容对你有帮助，也欢迎分享给身边的朋友一起讨论。我们下一讲见。</p><h3>02思考题参考</h3><p>上一期的问题是利用 CompletableFuture 中的一些 API ，将复杂的多任务场景通过编写代码计算出累加和。解答此题我们关注3点：</p><ol>\n<li>任务执行完成后再并发执行其他任务，可以使用 thenXxxAsync 这样的方法，并且执行完成之后还得返回结果值，那么我们就可以采用 thenApplyAsync 方法。</li>\n<li>合并两个线程任务的结果，并做进一步累加和处理，这里我们可以采用 thenCombine 方法。</li>\n<li>两个线程任务并发执行，谁先执行完成就以谁为准，这里我们可以采用 applyToEither 方法。</li>\n</ol><p>最终实现的代码如下：</p><pre><code class=\"language-java\">public static void main(String[] args) throws Throwable {\n    ///////////////////////////////////////////////////\n    // 任务一执行流程\n    ///////////////////////////////////////////////////\n    // 执行 taskA1\n    CompletableFuture&lt;Integer&gt; taskA1 = CompletableFuture.supplyAsync(() -&gt; 1);\n    // taskA1 执行完后，再并发执行 taskB1、taskC1\n    CompletableFuture&lt;Integer&gt; taskB1 = taskA1.thenApplyAsync(integer -&gt; 2);\n    CompletableFuture&lt;Integer&gt; taskC1 = taskA1.thenApplyAsync(integer -&gt; 3);\n    // 任务一的结果\n    CompletableFuture&lt;Integer&gt; result1 =\n            // 等到 taskB2、taskC2 都执行完并合并结果后\n            taskB1.thenCombine(taskC1, Integer::sum)\n            // 再合并 taskA1 的结果后\n            .thenCombine(taskA1, Integer::sum)\n            // 再异步执行 taskD1\n            .thenApplyAsync(integer -&gt; integer + 4);\n            \n    ///////////////////////////////////////////////////\n    // 任务二执行流程\n    ///////////////////////////////////////////////////\n    // 执行 taskA2\n    CompletableFuture&lt;Integer&gt; taskA2 = CompletableFuture.supplyAsync(() -&gt; 1);\n    // taskA2 执行完后，再并发执行 taskB2、taskC2\n    CompletableFuture&lt;Integer&gt; taskB2 = taskA2.thenApplyAsync(integer -&gt; 2);\n    CompletableFuture&lt;Integer&gt; taskC2 = taskA2.thenApplyAsync(integer -&gt; 3);\n    // 任务二的结果\n    CompletableFuture&lt;Integer&gt; result2 =\n            // 等到 taskB2、taskC2 任意其中一个有结果后\n            taskB2.applyToEither(taskC2, Function.identity())\n            // 再合并 taskA2 的结果后\n            .thenCombine(taskA2, Integer::sum)\n            // 再异步执行 taskD2\n            .thenApplyAsync(integer -&gt; integer + 4);\n            \n    ///////////////////////////////////////////////////\n    // 任务一 + 任务二，合并结果\n    ///////////////////////////////////////////////////\n    CompletableFuture&lt;Integer&gt; result = result1.thenCombine(result2, Integer::sum);\n    try {\n        // 任务总超时时间设置为5s\n        System.out.println(result.get(5, TimeUnit.SECONDS));\n    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n        // 超时则打印0\n        System.out.println(0);\n        e.printStackTrace();\n    }\n}\n</code></pre><p>到这里，我们就用代码将图中的多任务场景实现完了，最终打印的结果为 17 或者 18，结果为 0 的概率非常非常低。</p>","neighbors":{"left":{"article_title":"02｜异步化实践：莫名其妙出现线程池耗尽怎么办？","id":611392},"right":{"article_title":"04｜泛化调用：三步教你搭建通用的泛化调用框架","id":613308}},"comments":[{"had_liked":false,"id":365104,"user_name":"小白","can_delete":false,"product_type":"c1","uid":1202143,"ip_address":"广东","ucode":"717B408EDC07FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Z8t0JKFjnmdx4s4wuRePZXRL2L9awEpicp0rjT9rfXmZKOBIleZuOC86OzZE0tSdkfy3LWWa7YU67MicWeiaFd3jA/132","comment_is_top":false,"comment_ctime":1672111443,"is_pvip":false,"replies":[{"id":132952,"content":"你好，小白：org.apache.dubbo.rpc.RpcContext#get()、org.apache.dubbo.rpc.RpcContext#set、org.apache.dubbo.rpc.RpcContext#remove、org.apache.dubbo.rpc.RpcContext#get(java.lang.String) 等等 API 已经在 RpcContext 中被标注 @Deprecated 注解，说明在新版本是不再建议使用了。\n\n而是使用更加明确的获取方式（invocation.getObjectAttachments()、RpcContext.getClientAttachment()），从 invocation 中获取数据是明确表示该数据一定是从接收的参数中获取的，这是一种见名知意的写代码表述方式而已。\n\n但是这里你还要结合 ContextFilter、ConsumerContextFilter 来看，你要把数据放对就行了。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1672187788,"ip_address":"广东","comment_id":365104,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"老师，还有一个问题，为什么不直接用RpcContext进行get 和 set 传递呢？为什么还要涉及到invocation，这块不是很理解。","like_count":3,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597694,"discussion_content":"你好，小白：org.apache.dubbo.rpc.RpcContext#get()、org.apache.dubbo.rpc.RpcContext#set、org.apache.dubbo.rpc.RpcContext#remove、org.apache.dubbo.rpc.RpcContext#get(java.lang.String) 等等 API 已经在 RpcContext 中被标注 @Deprecated 注解，说明在新版本是不再建议使用了。\n\n而是使用更加明确的获取方式（invocation.getObjectAttachments()、RpcContext.getClientAttachment()），从 invocation 中获取数据是明确表示该数据一定是从接收的参数中获取的，这是一种见名知意的写代码表述方式而已。\n\n但是这里你还要结合 ContextFilter、ConsumerContextFilter 来看，你要把数据放对就行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672187789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365508,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"广东","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1672714232,"is_pvip":false,"replies":[{"id":133140,"content":"你好，张三丰：你站在的角度是消费者应用一定是请求的源头，所以你会这么理解。若消费方是前端呢？难道需要前端来生成traceId么？\n\n只是站在看问题的角度不同罢了，不过也挺好的，说明至少是认真在思考这个traceId传递衔接的问题，挺棒的。\n\n我这里引用我之前回答过的内容，如下：\n\n说消费方还有点不太准确，精准点说，应该是从接收请求的那个源头就可以考虑生成traceId。\n\n比如接收前端请求，Web容器比如Tomcat的Filter是最能第一时间感知请求的存在，可以在这里进行拦截直接生成TraceId，至于Tomcat在Filter之后的一些处理环节，就可以直接拿到TraceId了。再进入Controller调用下游Dubbo接口的话，消费方发现上下文没有 traceId 的也是可以考虑生成，也是一种兼容考虑方法，挺好的。\n\n比如 A -&gt;B -&gt; C，抛开Web容器来看待的话，A 的消费方过滤器其实拿到的 traceId 是 null 值，但是 B 所能很好衔接 traceId 的话，那么 B 在发起调用 C 的时候，B 的消费方过滤器是能正常拿到 traceId 的。\n","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1672720622,"ip_address":"广东","comment_id":365508,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"感觉文中获取traceid的地方有问题，不应该在提供者处生成，应该在消费端生成是traceid，再把traceid传给提供者，如果提供者拿到了traceid就打印出来，如果拿不到再生成traceid返回给消费者","like_count":2,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598263,"discussion_content":"你好，张三丰：你站在的角度是消费者应用一定是请求的源头，所以你会这么理解。若消费方是前端呢？难道需要前端来生成traceId么？\n\n只是站在看问题的角度不同罢了，不过也挺好的，说明至少是认真在思考这个traceId传递衔接的问题，挺棒的。\n\n我这里引用我之前回答过的内容，如下：\n\n说消费方还有点不太准确，精准点说，应该是从接收请求的那个源头就可以考虑生成traceId。\n\n比如接收前端请求，Web容器比如Tomcat的Filter是最能第一时间感知请求的存在，可以在这里进行拦截直接生成TraceId，至于Tomcat在Filter之后的一些处理环节，就可以直接拿到TraceId了。再进入Controller调用下游Dubbo接口的话，消费方发现上下文没有 traceId 的也是可以考虑生成，也是一种兼容考虑方法，挺好的。\n\n比如 A -&gt;B -&gt; C，抛开Web容器来看待的话，A 的消费方过滤器其实拿到的 traceId 是 null 值，但是 B 所能很好衔接 traceId 的话，那么 B 在发起调用 C 的时候，B 的消费方过滤器是能正常拿到 traceId 的。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672720623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1701455,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM6BVsSS2KsmwrcCKv3xyb6icrhbodyfNhXL5Q5AziaROdBDickkibSyWjL1WSq5dLliaHicIHVS3oiaLhHqg/132","nickname":"jdom","note":"","ucode":"058F92792875CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600986,"discussion_content":"服务提供方生成traceId会好些吧，不然定时平台调用时会没有traceId。另外controller层（最开始的消费方）一般来说几乎没有逻辑代码，基本就是调用dubbo接口，就算报错也不怎么需要traceId来排查问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674981840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104601,"avatar":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","nickname":"浩仔是程序员","note":"","ucode":"A7E5CF9E1571A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598324,"discussion_content":"老师，我觉得由前端生成这个traceId或者reqId也是可行的，有些时候确实需要前端提供reqId去排查问题，一般做法由前端发起的请求由前端生成reqId，而后端服务间的调用由调用方生成traceId，如果由接收方生成对排查问题会找不到根源","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672753331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1159084,"avatar":"https://static001.geekbang.org/account/avatar/00/11/af/ac/dd36cf29.jpg","nickname":"on the way","note":"","ucode":"17AAAAF068EA68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1104601,"avatar":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","nickname":"浩仔是程序员","note":"","ucode":"A7E5CF9E1571A2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599247,"discussion_content":"可以通过把traceId返回给前端来解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673420814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":598324,"ip_address":"四川","group_id":0},"score":599247,"extra":""}]}]},{"had_liked":false,"id":380927,"user_name":"高级按摩师 👁 ^ 👁⃢*","can_delete":false,"product_type":"c1","uid":1435006,"ip_address":"广东","ucode":"31518306EF81B6","user_header":"https://static001.geekbang.org/account/avatar/00/15/e5/7e/5190f9b2.jpg","comment_is_top":false,"comment_ctime":1694447383,"is_pvip":false,"replies":[{"id":138794,"content":"你好，高级按摩师：了解下 ThreadLocal 这个东西，就是靠它来进行衔接的。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1694644396,"ip_address":"北京","comment_id":380927,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"RPCConext是怎么传递的，服务之间调用，上下文怎么传递的呢","like_count":1,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627878,"discussion_content":"你好，高级按摩师：了解下 ThreadLocal 这个东西，就是靠它来进行衔接的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694644396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369327,"user_name":"Lum","can_delete":false,"product_type":"c1","uid":3231352,"ip_address":"北京","ucode":"7EF828425E685A","user_header":"https://static001.geekbang.org/account/avatar/00/31/4e/78/ee4e12cc.jpg","comment_is_top":false,"comment_ctime":1677412361,"is_pvip":false,"replies":[{"id":134869,"content":"你好，Lum：你刚刚所描述的场景，其实就是【任务一】虚线框中的场景，这种是比较单一的，对于单一的场景，大可以拿着一堆的 Future 列表挨个调用 get 方法，但是如果 Future 与 Future 之间如果有先后顺序、结果聚合、逻辑计算等等，那一直使用 get 操作就玩不转了~","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1678193259,"ip_address":"广东","comment_id":369327,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"请问一下 CompleteableFuture那些并行计算的意义是什么呢？项目中比如从多个系统中取数据，一般我都用了5,6个CompletableFuture，然后直接每个都get了。。。  没怎么用到上面的那些api","like_count":1,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607938,"discussion_content":"你好，Lum：你刚刚所描述的场景，其实就是【任务一】虚线框中的场景，这种是比较单一的，对于单一的场景，大可以拿着一堆的 Future 列表挨个调用 get 方法，但是如果 Future 与 Future 之间如果有先后顺序、结果聚合、逻辑计算等等，那一直使用 get 操作就玩不转了~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678193259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364969,"user_name":"王巍","can_delete":false,"product_type":"c1","uid":1023106,"ip_address":"广东","ucode":"F65F2E72C98D62","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9c/82/6073884b.jpg","comment_is_top":false,"comment_ctime":1671801036,"is_pvip":false,"replies":[{"id":132915,"content":"你好，王巍：你问得这个细节非常 nice，进程中多线程的 traceId 传递，是另外一个话题。\n\n这里我给个大概思路，你可以单独将这些多线程之间如何传递 traceId 做成一个插件，比如可以横切Spring的AsyncTaskExecutor的方法，比如统一指定公司规范使用某几种 Runnable&#47;Callable 来操作线程，比如 MQ&#47;Job 在触发时刻的源头直接自动横切一刀赋上traceId，等等等等，总之旨在将方法执行前与方法执行后的traceId衔接起来。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1672025660,"ip_address":"广东","comment_id":364969,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"多线程的情况下，线程也能获取到正确的 traceId 吗？","like_count":1,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597564,"discussion_content":"你好，王巍：你问得这个细节非常 nice，进程中多线程的 traceId 传递，是另外一个话题。\n\n这里我给个大概思路，你可以单独将这些多线程之间如何传递 traceId 做成一个插件，比如可以横切Spring的AsyncTaskExecutor的方法，比如统一指定公司规范使用某几种 Runnable/Callable 来操作线程，比如 MQ/Job 在触发时刻的源头直接自动横切一刀赋上traceId，等等等等，总之旨在将方法执行前与方法执行后的traceId衔接起来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672025661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366715,"user_name":"乌凌先森","can_delete":false,"product_type":"c1","uid":1179862,"ip_address":"广西","ucode":"52ED46F8C6208C","user_header":"https://static001.geekbang.org/account/avatar/00/12/00/d6/e49c6ac2.jpg","comment_is_top":false,"comment_ctime":1674099553,"is_pvip":false,"replies":[{"id":133612,"content":"你好，乌凌先森：这俩注解各自解决的问题不一样：\n\n1.@DubboService 解决的是在编码层面时接口实现类可以处理Dubbo的接收请求。\n\n2.@Component 解决的是在 Spring 框架中该接口实现类变成单实例对象以便后续可以被 @Autowired、@Resource 进行注入使用。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1674133008,"ip_address":"湖南","comment_id":366715,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"老师你好，@DubboService + @Component 这种使用方式有啥好处？","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600250,"discussion_content":"你好，乌凌先森：这俩注解各自解决的问题不一样：\n\n1.@DubboService 解决的是在编码层面时接口实现类可以处理Dubbo的接收请求。\n\n2.@Component 解决的是在 Spring 框架中该接口实现类变成单实例对象以便后续可以被 @Autowired、@Resource 进行注入使用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1674133008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1198895,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4b/2f/a93ff216.jpg","nickname":"天宇星旋","note":"","ucode":"69D10D5F4EB782","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":612784,"discussion_content":"老师，@DubboService 注解本身在解析的时候就会被注入Spring容器中管理，再加上@Component 注解是种冗余了吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680938148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":600250,"ip_address":"上海","group_id":0},"score":612784,"extra":""}]}]},{"had_liked":false,"id":364977,"user_name":"Geek_10086","can_delete":false,"product_type":"c1","uid":1635976,"ip_address":"广东","ucode":"EAEB2F7B59EAC0","user_header":"https://static001.geekbang.org/account/avatar/00/18/f6/88/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1671842671,"is_pvip":false,"replies":[{"id":132916,"content":"你好，Geek_10086：说消费方还有点不太准确，精准点说，应该是从接收请求的那个源头就可以考虑生成traceId。\n\n比如接收前端请求，Web容器比如Tomcat的Filter是最能第一时间感知请求的存在，可以在这里进行拦截直接生成TraceId，至于Tomcat在Filter之后的一些处理环节，就可以直接拿到TraceId了。再进入Controller调用下游Dubbo接口的话，消费方发现上下文没有 traceId 的也是可以考虑生成，也是一种兼容考虑方法，挺好的。\n\n至于你说的消费方过滤器默认为 null 的情况，一半对一半不对，比如 A -&gt;B -&gt; C，抛开Web容器来看待的话，A 的消费方过滤器其实拿到的 traceId 是 null 值，但是 B 所能很好衔接 traceId 的话，那么 B 在发起调用 C 的时候，B 的消费方过滤器是能正常拿到 traceId 的。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1672026349,"ip_address":"广东","comment_id":364977,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"老师您好，traceId是不是应该在消费者端（ReqNoConsumerFilter）生成，通过隐式传递到服务提供端（ReqNoProviderFilter），文中代码在ReqNoConsumerFilter中从上下文获取应该是null吧","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597565,"discussion_content":"你好，Geek_10086：说消费方还有点不太准确，精准点说，应该是从接收请求的那个源头就可以考虑生成traceId。\n\n比如接收前端请求，Web容器比如Tomcat的Filter是最能第一时间感知请求的存在，可以在这里进行拦截直接生成TraceId，至于Tomcat在Filter之后的一些处理环节，就可以直接拿到TraceId了。再进入Controller调用下游Dubbo接口的话，消费方发现上下文没有 traceId 的也是可以考虑生成，也是一种兼容考虑方法，挺好的。\n\n至于你说的消费方过滤器默认为 null 的情况，一半对一半不对，比如 A -&gt;B -&gt; C，抛开Web容器来看待的话，A 的消费方过滤器其实拿到的 traceId 是 null 值，但是 B 所能很好衔接 traceId 的话，那么 B 在发起调用 C 的时候，B 的消费方过滤器是能正常拿到 traceId 的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672026349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}