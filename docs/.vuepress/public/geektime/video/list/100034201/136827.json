{"id":136827,"title":"25 | Raft协议解析","content":"<p><strong>课前预习</strong></p><p>为了有更好的学习效果，建议大家在看视频前把下面的资料看一下：</p><ul>\n<li><a href=\"http://thesecretlivesofdata.com/raft/\">The Secret Lives of Data</a></li>\n<li><a href=\"https://raft.github.io/raft.pdf\">In Search of an Understandable Consensus Algorithm (Extended Version)</a> 的前5节</li>\n</ul><p><strong>课件和Demo地址</strong></p><p><a href=\"https://gitee.com/geektime-geekbang/geekbang-zk-course\">https://gitee.com/geektime-geekbang/geekbang-zk-course</a></p>","comments":[{"had_liked":false,"id":137515,"user_name":"13761642169","can_delete":false,"product_type":"c3","uid":1232334,"ip_address":"","ucode":"68137695FC2120","user_header":"","comment_is_top":false,"comment_ctime":1569758293,"is_pvip":false,"replies":[{"id":52910,"content":"Etcd支持以下两种read：\n\n1. Linearizable read(默认): 需要由Leader发起，Leader发送一个请求给所有节点，在收到多数节点的响应之后，才把结果返回给客户端。如果一个follower收到linearizable read的请求，需要转发给leader来处理。\n2. Serializable read（使用Get API的话要加WithSerializable选项）: Leader和follower都可以在本地处理，时延低。\n\n只有Etcd的leader才能处理write。Follower在接到write请求后，要转发给leader来处理。\n\n参见https:&#47;&#47;github.com&#47;etcd-io&#47;etcd&#47;blob&#47;master&#47;Documentation&#47;faq.md#do-clients-have-to-send-requests-to-the-etcd-leader：\n&gt; Raft is leader-based; the leader handles all client requests which need cluster consensus. However, the client does not need to know which node is the leader. Any request that requires consensus sent to a follower is automatically forwarded to the leader. Requests that do not require consensus (e.g., serialized reads) can be processed by any cluster member.","user_name":"作者回复","user_name_real":"Geek_215586","uid":1591870,"ctime":1569823661,"ip_address":"","comment_id":137515,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100034201,"comment_content":"使用raft协议的系统，只有leader可以接受写请求，follower接受读请求？","like_count":2,"discussions":[{"author":{"id":1591870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJyDiaaDJrwRsdUia9HxA8EuWaDVLr4E1gMG5y2ZTxV7BNUhdNABCmH3GMZTzib796X5duibiaeuRmNXeg/132","nickname":"Geek_215586","note":"","ucode":"5916AC9CC5FBE2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469131,"discussion_content":"Etcd支持以下两种read：\n\n1. Linearizable read(默认): 需要由Leader发起，Leader发送一个请求给所有节点，在收到多数节点的响应之后，才把结果返回给客户端。如果一个follower收到linearizable read的请求，需要转发给leader来处理。\n2. Serializable read（使用Get API的话要加WithSerializable选项）: Leader和follower都可以在本地处理，时延低。\n\n只有Etcd的leader才能处理write。Follower在接到write请求后，要转发给leader来处理。\n\n参见https://github.com/etcd-io/etcd/blob/master/Documentation/faq.md#do-clients-have-to-send-requests-to-the-etcd-leader：\n&amp;gt; Raft is leader-based; the leader handles all client requests which need cluster consensus. However, the client does not need to know which node is the leader. Any request that requires consensus sent to a follower is automatically forwarded to the leader. Requests that do not require consensus (e.g., serialized reads) can be processed by any cluster member.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569823661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177152,"user_name":"Goober","can_delete":false,"product_type":"c3","uid":1561436,"ip_address":"","ucode":"1EA87A42CF5E1A","user_header":"","comment_is_top":false,"comment_ctime":1581304652,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100034201,"comment_content":"这里存在一个问题就是 是协议微调的：s5 下线后，s1 上线 这时候已经是（4，3），那么s5 不会再成为leader 所以不存在（3，2）覆盖 （2，2）","like_count":2}]}