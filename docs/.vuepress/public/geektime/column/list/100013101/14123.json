{"id":14123,"title":"09 | 字典的操作和约束","content":"<p>至今为止，我们讲过的集合类的高级数据类型都属于针对单一元素的容器。</p><p>它们或用连续存储，或用互存指针的方式收纳元素，这里的每个元素都代表了一个从属某一类型的独立值。</p><p>我们今天要讲的字典（map）却不同，它能存储的不是单一值的集合，而是键值对的集合。</p><blockquote>\n<p><span class=\"reference\">什么是键值对？它是从英文key-value pair直译过来的一个词。顾名思义，一个键值对就代表了一对键和值。</span></p>\n<p><span class=\"reference\">注意，一个“键”和一个“值”分别代表了一个从属于某一类型的独立值，把它们两个捆绑在一起就是一个键值对了。</span></p>\n</blockquote><p>在Go语言规范中，应该是为了避免歧义，他们将键值对换了一种称呼，叫做：“键-元素对”。我们也沿用这个看起来更加清晰的词来讲解。</p><h2>知识前导：为什么字典的键类型会受到约束？</h2><p>Go语言的字典类型其实是一个哈希表（hash table）的特定实现，在这个实现中，键和元素的最大不同在于，键的类型是受限的，而元素却可以是任意类型的。</p><p>如果要探究限制的原因，我们就先要了解哈希表中最重要的一个过程：映射。</p><p>你可以把键理解为元素的一个索引，我们可以在哈希表中通过键查找与它成对的那个元素。</p><p>键和元素的这种对应关系，在数学里就被称为“映射”，这也是“map”这个词的本意，哈希表的映射过程就存在于对键-元素对的增、删、改、查的操作之中。</p><!-- [[[read_end]]] --><pre><code>aMap := map[string]int{\n\t&quot;one&quot;:    1,\n\t&quot;two&quot;:    2,\n\t&quot;three&quot;: 3,\n}\nk := &quot;two&quot;\nv, ok := aMap[k]\nif ok {\n\tfmt.Printf(&quot;The element of key %q: %d\\n&quot;, k, v)\n} else {\n\tfmt.Println(&quot;Not found!&quot;)\n}\n</code></pre><p>比如，我们要在哈希表中查找与某个键值对应的那个元素值，那么我们需要先把键值作为参数传给这个哈希表。</p><p>哈希表会先用哈希函数（hash function）把键值转换为哈希值。哈希值通常是一个无符号的整数。一个哈希表会持有一定数量的桶（bucket），我们也可以叫它哈希桶，这些哈希桶会均匀地储存其所属哈希表收纳的键-元素对。</p><p>因此，哈希表会先用这个键哈希值的低几位去定位到一个哈希桶，然后再去这个哈希桶中，查找这个键。</p><p>由于键-元素对总是被捆绑在一起存储的，所以一旦找到了键，就一定能找到对应的元素值。随后，哈希表就会把相应的元素值作为结果返回。</p><p>只要这个键-元素对存在哈希表中就一定会被查找到，因为哈希表增、改、删键-元素对时的映射过程，与前文所述如出一辙。</p><p><strong>现在我们知道了，映射过程的第一步就是：把键值转换为哈希值。</strong></p><p>在Go语言的字典中，每一个键值都是由它的哈希值代表的。也就是说，字典不会独立存储任何键的值，但会独立存储它们的哈希值。</p><p>你是不是隐约感觉到了什么？我们接着往下看。</p><p><strong>我们今天的问题是：字典的键类型不能是哪些类型？</strong></p><p>这个问题你可以在Go语言规范中找到答案，但却没那么简单。它的典型回答是：Go语言字典的键类型不可以是函数类型、字典类型和切片类型。</p><h2>问题解析</h2><p>我们来解析一下这个问题。</p><p>Go语言规范规定，在键类型的值之间必须可以施加操作符<code>==</code>和<code>!=</code>。换句话说，键类型的值必须要支持判等操作。由于函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。</p><p>另外，如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型，否则在程序运行过程中会引发panic（即运行时恐慌）。</p><p>我们举个例子：</p><pre><code>var badMap2 = map[interface{}]int{\n\t&quot;1&quot;:   1,\n\t[]int{2}: 2, // 这里会引发panic。\n\t3:    3,\n}\n</code></pre><p>这里的变量<code>badMap2</code>的类型是键类型为<code>interface{}</code>、值类型为<code>int</code>的字典类型。这样声明并不会引起什么错误。或者说，我通过这样的声明躲过了Go语言编译器的检查。</p><p>注意，我用字面量在声明该字典的同时对它进行了初始化，使它包含了三个键-元素对。其中第二个键-元素对的键值是<code>[]int{2}</code>，元素值是<code>2</code>。这样的键值也不会让Go语言编译器报错，因为从语法上说，这样做是可以的。</p><p>但是，当我们运行这段代码的时候，Go语言的运行时（runtime）系统就会发现这里的问题，它会抛出一个panic，并把根源指向字面量中定义第二个键-元素对的那一行。我们越晚发现问题，修正问题的成本就会越高，所以最好不要把字典的键类型设定为任何接口类型。如果非要这么做，请一定确保代码在可控的范围之内。</p><p>还要注意，如果键的类型是数组类型，那么还要确保该类型的元素类型不是函数类型、字典类型或切片类型。</p><p>比如，由于类型<code>[1][]string</code>的元素类型是<code>[]string</code>，所以它就不能作为字典类型的键类型。另外，如果键的类型是结构体类型，那么还要保证其中字段的类型的合法性。无论不合法的类型被埋藏得有多深，比如<code>map[[1][2][3][]string]int</code>，Go语言编译器都会把它揪出来。</p><p>你可能会有疑问，为什么键类型的值必须支持判等操作？我在前面说过，Go语言一旦定位到了某一个哈希桶，那么就会试图在这个桶中查找键值。具体是怎么找的呢？</p><p>首先，每个哈希桶都会把自己包含的所有键的哈希值存起来。Go语言会用被查找键的哈希值与这些哈希值逐个对比，看看是否有相等的。如果一个相等的都没有，那么就说明这个桶中没有要查找的键值，这时Go语言就会立刻返回结果了。</p><p>如果有相等的，那就再用键值本身去对比一次。为什么还要对比？原因是，不同值的哈希值是可能相同的。这有个术语，叫做“哈希碰撞”。</p><p>所以，即使哈希值一样，键值也不一定一样。如果键类型的值之间无法判断相等，那么此时这个映射的过程就没办法继续下去了。最后，只有键的哈希值和键值都相等，才能说明查找到了匹配的键-元素对。</p><p>以上内容涉及的示例都在demo18.go中。</p><h2>知识扩展</h2><p><strong>问题1：应该优先考虑哪些类型作为字典的键类型？</strong></p><p>你现在已经清楚了，在Go语言中，有些类型的值是支持判等的，有些是不支持的。那么在这些值支持判等的类型当中，哪些更适合作为字典的键类型呢？</p><p>这里先抛开我们使用字典时的上下文，只从性能的角度看。在前文所述的映射过程中，“把键值转换为哈希值”以及“把要查找的键值与哈希桶中的键值做对比”， 明显是两个重要且比较耗时的操作。</p><p>因此，可以说，<strong>求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。</strong></p><p>对于所有的基本类型、指针类型，以及数组类型、结构体类型和接口类型，Go语言都有一套算法与之对应。这套算法中就包含了哈希和判等。以求哈希的操作为例，宽度越小的类型速度通常越快。对于布尔类型、整数类型、浮点数类型、复数类型和指针类型来说都是如此。对于字符串类型，由于它的宽度是不定的，所以要看它的值的具体长度，长度越短求哈希越快。</p><p>类型的宽度是指它的单个值需要占用的字节数。比如，<code>bool</code>、<code>int8</code>和<code>uint8</code>类型的一个值需要占用的字节数都是<code>1</code>，因此这些类型的宽度就都是<code>1</code>。</p><p>以上说的都是基本类型，再来看高级类型。对数组类型的值求哈希实际上是依次求得它的每个元素的哈希值并进行合并，所以速度就取决于它的元素类型以及它的长度。细则同上。</p><p>与之类似，对结构体类型的值求哈希实际上就是对它的所有字段值求哈希并进行合并，所以关键在于它的各个字段的类型以及字段的数量。而对于接口类型，具体的哈希算法，则由值的实际类型决定。</p><p>我不建议你使用这些高级数据类型作为字典的键类型，不仅仅是因为对它们的值求哈希，以及判等的速度较慢，更是因为在它们的值中存在变数。</p><p>比如，对一个数组来说，我可以任意改变其中的元素值，但在变化前后，它却代表了两个不同的键值。</p><p>对于结构体类型的值情况可能会好一些，因为如果我可以控制其中各字段的访问权限的话，就可以阻止外界修改它了。把接口类型作为字典的键类型最危险。</p><p>还记得吗？如果在这种情况下Go运行时系统发现某个键值不支持判等操作，那么就会立即抛出一个panic。在最坏的情况下，这足以使程序崩溃。</p><p>那么，在那些基本类型中应该优先选择哪一个？答案是，优先选用数值类型和指针类型，通常情况下类型的宽度越小越好。如果非要选择字符串类型的话，最好对键值的长度进行额外的约束。</p><p>那什么是不通常的情况？笼统地说，Go语言有时会对字典的增、删、改、查操作做一些优化。</p><p>比如，在字典的键类型为字符串类型的情况下；又比如，在字典的键类型为宽度为<code>4</code>或<code>8</code>的整数类型的情况下。</p><p><strong>问题2：在值为<code>nil</code>的字典上执行读操作会成功吗，那写操作呢？</strong></p><p>好了，为了避免烧脑太久，我们再来说一个简单些的问题。由于字典是引用类型，所以当我们仅声明而不初始化一个字典类型的变量的时候，它的值会是<code>nil</code>。</p><p>在这样一个变量上试图通过键值获取对应的元素值，或者添加键-元素对，会成功吗？这个问题虽然简单，但却是我们必须铭记于心的，因为这涉及程序运行时的稳定性。</p><p>我来说一下答案。除了添加键-元素对，我们在一个值为<code>nil</code>的字典上做任何操作都不会引起错误。当我们试图在一个值为<code>nil</code>的字典中添加键-元素对的时候，Go语言的运行时系统就会立即抛出一个panic。你可以运行一下demo19.go文件试试看。</p><p><strong>总结</strong></p><p>我们这次主要讨论了与字典类型有关的，一些容易让人困惑的问题。比如，为什么字典的键类型会受到约束？又比如，我们通常应该选取什么样的类型作为字典的键类型。</p><p>我以Go语言规范为起始，并以Go语言源码为依据回答了这些问题。认真看了这篇文章之后，你应该对字典中的映射过程有了一定的理解。</p><p>另外，对于Go语言在那些合法的键类型上所做的求哈希和判等的操作，你也应该有所了解了。</p><p>再次强调，永远要注意那些可能引发panic的操作，比如像一个值为<code>nil</code>的字典添加键-元素对。</p><p><strong>思考题</strong></p><p>今天的思考题是关于并发安全性的。更具体地说，在同一时间段内但在不同的goroutine（或者说go程）中对同一个值进行操作是否是安全的。这里的安全是指，该值不会因这些操作而产生混乱，或其它不可预知的问题。</p><p>具体的思考题是：字典类型的值是并发安全的吗？如果不是，那么在我们只在字典上添加或删除键-元素对的情况下，依然不安全吗？感谢你的收听，我们下期再见。</p><p><a href=\"https://github.com/hyper0x/Golang_Puzzlers\">戳此查看Go语言专栏文章配套详细代码。</a></p><p></p>","comments":[{"had_liked":false,"id":22546,"user_name":"江山如画","can_delete":false,"product_type":"c1","uid":1188280,"ip_address":"","ucode":"BEB6228E6135B5","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/b8/aca814dd.jpg","comment_is_top":false,"comment_ctime":1535781345,"is_pvip":false,"replies":[{"id":"8104","content":"说得很对","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1535801502,"ip_address":"","comment_id":22546,"utype":1}],"discussion_count":3,"race_medal":0,"score":"555586562529","product_id":100013101,"comment_content":"非原子操作需要加锁， map并发读写需要加锁，map操作不是并发安全的，判断一个操作是否是原子的可以使用 go run race 命令做数据的竞争检测","like_count":129,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423156,"discussion_content":"说得很对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535801502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2028147,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/8zic34LrvBNhsUqd7xBhkZGSxodfHMQntAhn1OtABxAUoLLWufbicIrpCY3LMuNScowBHAmfMYKcibiaZUJLOR6ESQ/132","nickname":"李显坤","note":"","ucode":"0CFECFACB3B5A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294247,"discussion_content":"go run race怎么用\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595839151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099513,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/f9/caf27bd3.jpg","nickname":"大王叫我来巡山","note":"","ucode":"1B8D0C701BC95E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9734,"discussion_content":"主要是读写操作都不是原子性的，都要先计算hash才能进行下一步操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568210584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22522,"user_name":"杨赛","can_delete":false,"product_type":"c1","uid":1029376,"ip_address":"","ucode":"E26AF8930F78E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b5/00/4093f39a.jpg","comment_is_top":false,"comment_ctime":1535766592,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"353723084864","product_id":100013101,"comment_content":"希望有点深度。","like_count":82,"discussions":[{"author":{"id":2837359,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/4b/6f/28cd35f7.jpg","nickname":"工程师kiki c++","note":"","ucode":"EF7D9899BDFDC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532312,"discussion_content":"你来，我们听","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637572430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22472,"user_name":"张民","can_delete":false,"product_type":"c1","uid":1112820,"ip_address":"","ucode":"6E635C1BE2511F","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/f4/506b9460.jpg","comment_is_top":false,"comment_ctime":1535693036,"is_pvip":false,"replies":[{"id":"8105","content":"哈希桶里的结构是，“键的哈希值-内部结构”对的集合，这个内部结构的结构是“键1元素1键2元素2键3元素3”，是一块连续的内存。在通过键的哈希值定位找到哈希桶和那个“键的哈希值-内部结构”对之后，就开始在这个内部结构里找有没有这个键。后边的事情你应该都知道了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1535802013,"ip_address":"","comment_id":22472,"utype":1}],"discussion_count":4,"race_medal":0,"score":"207694123244","product_id":100013101,"comment_content":"郝大，有个疑问:文中描述“也就是说，字典不会存储任何键值，只会存储它们的哈希值。“ 但是在查找的时候，根据键值的哈希找到后，又去比较键值，防止哈希碰撞。但是键值没有存储怎么比较？","like_count":48,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423134,"discussion_content":"哈希桶里的结构是，“键的哈希值-内部结构”对的集合，这个内部结构的结构是“键1元素1键2元素2键3元素3”，是一块连续的内存。在通过键的哈希值定位找到哈希桶和那个“键的哈希值-内部结构”对之后，就开始在这个内部结构里找有没有这个键。后边的事情你应该都知道了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535802013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1069548,"avatar":"https://static001.geekbang.org/account/avatar/00/10/51/ec/3d51d5e6.jpg","nickname":"上校","note":"","ucode":"DEE1CEE9E4C680","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":254749,"discussion_content":"哈希表：通过数组存hash，每个hash对应一个链表，hash定位数组，再通过数组元素对应的链表找具体的值","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1588342826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2881168,"avatar":"","nickname":"Geek_c036f8","note":"","ucode":"18F93E76742408","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542946,"discussion_content":"在go的使用场景中，hash碰撞的概率高么？为啥还要引入这个内部的二级桶结构？当时go的设计者有相关数据么？\n这个是语言规范要求，还是只是编译器/运行时当前的一个实现这么做。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640911964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389581,"discussion_content":"那就这个应该是根据键的hash值去找到具体的bucket, 然后在桶里对比键值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629346759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50461,"user_name":"hiyanxu","can_delete":false,"product_type":"c1","uid":1221750,"ip_address":"","ucode":"FA46A318154812","user_header":"https://static001.geekbang.org/account/avatar/00/12/a4/76/585dc6b3.jpg","comment_is_top":false,"comment_ctime":1544973812,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"147573861876","product_id":100013101,"comment_content":"在map的创建中：<br>直接声明“var m map[int]string”的形式声明出来的m为nil；<br>采用make函数创建的map不为nil，可以进行添加键值对的操作。","like_count":34},{"had_liked":false,"id":22437,"user_name":"zs阿帅","can_delete":false,"product_type":"c1","uid":1141173,"ip_address":"","ucode":"07A54AE7F1CAFF","user_header":"https://static001.geekbang.org/account/avatar/00/11/69/b5/1e1731cc.jpg","comment_is_top":false,"comment_ctime":1535676582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"143269597350","product_id":100013101,"comment_content":"能不能在深剖析下go map底层实现机制，配合源码讲解","like_count":33},{"had_liked":false,"id":22459,"user_name":"melon","can_delete":false,"product_type":"c1","uid":1023773,"ip_address":"","ucode":"7A80C20EBCAAA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/1d/ec173090.jpg","comment_is_top":false,"comment_ctime":1535686790,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"121794771078","product_id":100013101,"comment_content":"goroutine 并发读写 map 会触发 fatal error: concurrent map read and map write 这样的运行时错误 ，可以试一下下面这个例子看效果：<br>package main<br><br>import (<br>    &quot;fmt&quot;<br>    &quot;time&quot;<br>)<br><br>func main() {<br>    m := map[int]string {<br>        1 : &quot;haha&quot;,<br>    }<br><br>    go read(m)<br>    time.Sleep(time.Second)<br>    go write(m)<br>    time.Sleep(30*time.Second)<br>    fmt.Println(m)<br>}<br><br>func read(m map[int]string) {<br>    for {<br>        _ = m[1]<br>        time.Sleep(1)<br>    }<br>}<br><br>func write(m map[int]string) {<br>    for {<br>        m[1] = &quot;write&quot; <br>        time.Sleep(1)<br>    }<br>}<br><br>可以通过 go run -race 来检测代码是否存在这种潜在的并发读写<br>通过 sync.Map 或自己使用sync.RWMutex自己实现并发互斥逻辑","like_count":28},{"had_liked":false,"id":22445,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1535679223,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"91729992439","product_id":100013101,"comment_content":"字典并发并不安全，对字典操作最好用1.9之后新加入的sync.Map，如果不用的话需要对goroutine加读写锁了。","like_count":21,"discussions":[{"author":{"id":2445536,"avatar":"https://static001.geekbang.org/account/avatar/00/25/50/e0/b6a11ffb.jpg","nickname":"Vector","note":"","ucode":"F2ECD6AC87A0DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384187,"discussion_content":"sync.Map实际上没那么好用，业务中协程查找多改动少的时候用sync.Map还好，改动频繁还不如直接mutex","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626418999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378675,"discussion_content":"sync.Map只有特定场景适用，好像也不常用。可以用其他开源并发安全的map","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623330284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24386,"user_name":"慢熊胖胖跑","can_delete":false,"product_type":"c1","uid":1065065,"ip_address":"","ucode":"58523B53D45C7F","user_header":"https://static001.geekbang.org/account/avatar/00/10/40/69/f86a1526.jpg","comment_is_top":false,"comment_ctime":1536968284,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40191673948","product_id":100013101,"comment_content":"Go 语言的字典类型其实是一个哈希表（hash table）的特定实现。<br>————————————————-<br>为啥都是hash表了 那为啥map range遍历key还是无序的呢？","like_count":9,"discussions":[{"author":{"id":1351215,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/AyccJq7eg6w3aCn7AxpicdplGhhY2xYOJLd9q2Xcjqxdbb6HO7rU4p37oxCjUnrcydpQVjNgcIhxOLKsI4w2KWQ/132","nickname":"Iflei","note":"","ucode":"812264ADE9CB33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57537,"discussion_content":"哈希表本来就无序呀，红黑树中续遍历是有序的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574610971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22460,"user_name":"balancer","can_delete":false,"product_type":"c1","uid":1145758,"ip_address":"","ucode":"A865FAFF2FE1FA","user_header":"https://static001.geekbang.org/account/avatar/00/11/7b/9e/37d69ff0.jpg","comment_is_top":false,"comment_ctime":1535687214,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35895425582","product_id":100013101,"comment_content":"希望后面层层深入，深入到，go的并发实现原理核内存管理（听到有开发者遇到内存持续不降的问题，这一点我猜测是gc上面）、错误处理、运行时多态、模板","like_count":8},{"had_liked":false,"id":65647,"user_name":"Geek_1ed70f","can_delete":false,"product_type":"c1","uid":1394112,"ip_address":"","ucode":"B9A1928A6967B1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erNhKGpqicibpQO3tYvl9vwiatvBzn27ut9y5lZ8hPgofPCFC24HX3ko7LW5mNWJficgJncBCGKpGL2jw/132","comment_is_top":false,"comment_ctime":1549534681,"is_pvip":false,"replies":[{"id":"25252","content":"你这个时间成本是值得的。真正的学习没有捷径啊。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1551181602,"ip_address":"","comment_id":65647,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27319338457","product_id":100013101,"comment_content":"不知道是理解能力差,还是基础差,以前只会随便用用,现在读您的文章,读完第一遍似懂非懂,然后用一下午时间翻源码,看解释,弄原理...再回头一读豁然开朗,.....精学了,但是好费时间啊,~~~~~老师如何评价进度与学习成本的取舍呢","like_count":6,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438535,"discussion_content":"你这个时间成本是值得的。真正的学习没有捷径啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551181602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35644,"user_name":"🄽🄸🅇🅄🅂","can_delete":false,"product_type":"c1","uid":1000060,"ip_address":"","ucode":"853763C229A5AA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/7c/8ef14715.jpg","comment_is_top":false,"comment_ctime":1540724954,"is_pvip":false,"replies":[{"id":"13306","content":"可以对m直接用索引表达式添加啊。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1541481568,"ip_address":"","comment_id":35644,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27310528730","product_id":100013101,"comment_content":"nil的map，既然不能添加key-element，是否也就意味着这样的map是没有任何意义的？在使用中，应避免用`var m map[string]int` 这种方式来声明map呢？","like_count":6,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427611,"discussion_content":"可以对m直接用索引表达式添加啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541481568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22912,"user_name":"星云","can_delete":false,"product_type":"c1","uid":1055894,"ip_address":"","ucode":"00325D63F7DE6E","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/96/0fc7aacf.jpg","comment_is_top":false,"comment_ctime":1536033208,"is_pvip":true,"replies":[{"id":"8290","content":"好吧，可以说，不会独立存储键的值。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1536062128,"ip_address":"","comment_id":22912,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27305836984","product_id":100013101,"comment_content":"&quot;也就是说，字典不会存储任何键值，只会存储它们的哈希值。&quot;  我也觉得这个说法不严谨，既然，&quot;内部结构&quot;是将键值对捆绑存的，那字典就是存了键，除非&quot;内部结构&quot;不属于字典？ 可能没理解到，请郝大指点迷津","like_count":6,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423318,"discussion_content":"好吧，可以说，不会独立存储键的值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536062128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184660,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1583378861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23058215341","product_id":100013101,"comment_content":"总结一下关于今天的内容<br>首先字典是一个以键值对的形式存在的引用类型集合，底层依赖于hash表<br>从以下几方面分析map<br>1. 插入<br>   因为底层是hash表，所以会把键转换成hash值再对应到hash表中去，所以引发什么样的类型适合key?<br>   首先 转变成hash值的哈希函数的计算不能太耗时 所以最好选择基础数据类型做为key,并且宽度越小计算得越快,推荐使用数值类型和指针<br>2. 查询,删除，修改<br>   他们都涉及到一个查询操作，而go语言map的查询操作又分为如下几步<br>   2.1 把key转换成hash值 找到对应的val<br>   2.2 通过2.1步的hash值定位到hash val 此时再和key进行判等操作 如果相等才算找到了<br>   由操作步骤分析 查询的耗时点在把key转换成hash值 然后key得判等操作，同时必须要支持判等操作的类型才能作为key<br>  3. 不适合作为key的类型 <br>  切片 函数 字典类型<br>  4. 总结 以上1 2 3点得出<br>   map的key要支持判等操作 并且类型所占的宽度(占用内存大小)越小 计算hash值的过程越快,然后动态数据类型最好不要用来作为key因为它的内容随时都可能被改变 所以最好用数值和指针<br>5. 数值类型的hash值计算方式<br>    是把数组中所有元素求hash值并且组合起来,所以如果数组中某个元素发生了改变 算出来的hash值就不同了(所以数组最好不用来做key)<br>6. 结构体类型的hash值计算<br>    是把结构体里面的所有成员的hash值组合起来，也不太适合做key,原因同数组<br>7. 空切片 interface{}的hash值计算<br>   是根据实际类型来计算hash值<br>重点来了 最好进制空切片类型interface{}作为key map[interface{}] v 这个时候任何数据类型都可以插入到该字典map当中，如果插入了一个字典或者函数 或者切片 虽然可以绕过编译器的检查，但是肯定会引起恐慌<br>关于思考题 根据我的工作经验来看肯定不安全 肯定不安全 解决方案加锁","like_count":5},{"had_liked":false,"id":22854,"user_name":"extraterrestrial！！","can_delete":false,"product_type":"c1","uid":1017987,"ip_address":"","ucode":"74AE07CA68F6B6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/GDYkD2X7pXSKUSaUFC8u3TBPaakaibnOBV2NYDc2TNfb8Su9icFMwSod6iaQX5iaGU2gT6xkPuhXeWvY8KaVEZAYzg/132","comment_is_top":false,"comment_ctime":1536019908,"is_pvip":true,"replies":[{"id":"8282","content":"这是Go语言的规定，没必要纠结，你完全用类型断言去判断啊。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1536061483,"ip_address":"","comment_id":22854,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23010856388","product_id":100013101,"comment_content":"函数类型为啥不能判等呢，函数头相同就认为相等不行么？","like_count":5,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423296,"discussion_content":"这是Go语言的规定，没必要纠结，你完全用类型断言去判断啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536061483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92255,"user_name":"Timo","can_delete":false,"product_type":"c1","uid":1223829,"ip_address":"","ucode":"6A7FEB30B09797","user_header":"https://static001.geekbang.org/account/avatar/00/12/ac/95/9b3e3859.jpg","comment_is_top":false,"comment_ctime":1557215094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18737084278","product_id":100013101,"comment_content":"哈哈，看了评论才知道底层具体是如何存储字典的。<br>因为有可能哈希值相同，所以键-元素对，就有可能绑在一块，譬如下面的键1和键15的哈希值是一样的，它们绑在一块的是一个连续的内存区域<br>哈希值1----&gt; 键1元素1键15元素15<br>哈希值2-----&gt; 键a元素a<br>哈希值3-----&gt; 键b元素b","like_count":4},{"had_liked":false,"id":31120,"user_name":"kuzan","can_delete":false,"product_type":"c1","uid":1006773,"ip_address":"","ucode":"4A6CCE0629D4AE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/b5/0737c1f2.jpg","comment_is_top":false,"comment_ctime":1539095299,"is_pvip":false,"replies":[{"id":"11829","content":"没有，sync.Map也不是分段锁实现的，如果想看分段锁实现可以看我的《Go并发编程实战》第二版中的例子。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1539578742,"ip_address":"","comment_id":31120,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18718964483","product_id":100013101,"comment_content":"go里面有没有分段锁的字典实现呢","like_count":4,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426238,"discussion_content":"没有，sync.Map也不是分段锁实现的，如果想看分段锁实现可以看我的《Go并发编程实战》第二版中的例子。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539578742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33557,"user_name":"顾骨","can_delete":false,"product_type":"c1","uid":1131165,"ip_address":"","ucode":"3F6BA592AB7723","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/9d/c36b7ef7.jpg","comment_is_top":false,"comment_ctime":1539825257,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"14424727145","product_id":100013101,"comment_content":"“哈希桶里的结构是，“键的哈希值-内部结构”对的集合，这个内部结构的结构是“键1元素1键2元素2键3元素3”，是一块连续的内存。在通过键的哈希值定位找到哈希桶和那个“键的哈希值-内部结构”对之后，就开始在这个内部结构里找有没有这个键。后边的事情你应该都知道了。”<br><br>引用下，内部结构的结构是“键1元素1键2元素2键3元素3”的存储方式，那怎么知道键的宽度是多少呢？会不会将键和元素一起当做一个键来处理了？","like_count":3,"discussions":[{"author":{"id":1957184,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/dd/40/ea203b9a.jpg","nickname":"logoiny🇨🇳","note":"","ucode":"EF3BA5A1C5D36A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369068,"discussion_content":"实际存储形式是k1k2...v1v2...最多存8对，所以不存在这种对齐的困惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618919043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1053662,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/de/1528c683.jpg","nickname":"fanjl","note":"","ucode":"AB717E5AC9E783","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1957184,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/dd/40/ea203b9a.jpg","nickname":"logoiny🇨🇳","note":"","ucode":"EF3BA5A1C5D36A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369898,"discussion_content":"为什么要存多对？这几对的键值的哈希都是一样的？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1619189919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":369068,"ip_address":""},"score":369898,"extra":""}]}]},{"had_liked":false,"id":26474,"user_name":"colonel","can_delete":false,"product_type":"c1","uid":1200916,"ip_address":"","ucode":"F71EE1C23A8D83","user_header":"https://static001.geekbang.org/account/avatar/00/12/53/14/2b93d757.jpg","comment_is_top":false,"comment_ctime":1537615172,"is_pvip":false,"replies":[{"id":"9667","content":"这些文章里都有写。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1537690541,"ip_address":"","comment_id":26474,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14422517060","product_id":100013101,"comment_content":"哈希桶怎么存储的，是数组吗？碰撞之后的键值又是怎么存储的，形成链表吗？删除机制中，是删除链表中节点吗？<br>建议，不要大篇幅讨论存储性能，可以对内部数据存储，插入，删除，读取机制更多分享","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424644,"discussion_content":"这些文章里都有写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537690541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24147,"user_name":"SuperP ❤ 飝","can_delete":false,"product_type":"c1","uid":1203011,"ip_address":"","ucode":"FCA4E2C5BECB8F","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/43/edf22486.jpg","comment_is_top":false,"comment_ctime":1536824075,"is_pvip":false,"replies":[{"id":"8931","content":"我记得文章里讲了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1536975608,"ip_address":"","comment_id":24147,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14421725963","product_id":100013101,"comment_content":"一个哈希表会持有一定数量的桶（bucket），那个新增加一个键值得时候，怎么去划分桶的？","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423860,"discussion_content":"我记得文章里讲了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536975608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253079,"user_name":"我的腿腿","can_delete":false,"product_type":"c1","uid":1239277,"ip_address":"","ucode":"2AAA36A7C3AD75","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/ed/f9347e5e.jpg","comment_is_top":false,"comment_ctime":1602586810,"is_pvip":false,"replies":[{"id":"92511","content":"因为 map 内部的元素值的存储地址是会不定期自动变化的（因为会 rehash），所以不可寻址。这也是Go语言规范里说明的。<br><br>你不可以直接对 map 中的元素值取址，比如：&amp;map1[&quot;a&quot;] ，但是你可以先 var1 := map1[&quot;a&quot;] 再 &amp;var1 啊，或者索性把 map1 的元素类型设置成那个结构体的指针类型。<br><br>从编码层面是可以这么解决的。而从程序设计层面，你需要想想“你为什么要这么取址？”，以及“是不是哪里设计得不够好？”。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1602646592,"ip_address":"","comment_id":253079,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10192521402","product_id":100013101,"comment_content":"结构体作为map的元素时，不能够直接赋值给结构体的某个字段，也就是map中的struct中的字段不能够直接寻址，请问为什么，该怎么处理？","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506968,"discussion_content":"因为 map 内部的元素值的存储地址是会不定期自动变化的（因为会 rehash），所以不可寻址。这也是Go语言规范里说明的。\n\n你不可以直接对 map 中的元素值取址，比如：&amp;amp;map1[&amp;quot;a&amp;quot;] ，但是你可以先 var1 := map1[&amp;quot;a&amp;quot;] 再 &amp;amp;var1 啊，或者索性把 map1 的元素类型设置成那个结构体的指针类型。\n\n从编码层面是可以这么解决的。而从程序设计层面，你需要想想“你为什么要这么取址？”，以及“是不是哪里设计得不够好？”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602646592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212483,"user_name":"1287","can_delete":false,"product_type":"c1","uid":1950498,"ip_address":"","ucode":"C91D3AD48298A4","user_header":"https://static001.geekbang.org/account/avatar/00/1d/c3/22/8520be75.jpg","comment_is_top":false,"comment_ctime":1588131652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10178066244","product_id":100013101,"comment_content":"个人感觉这章可以更有深度，go map底层数据结构、实现等觉得还是有必要了解的。","like_count":2},{"had_liked":false,"id":145985,"user_name":"leitiannet","can_delete":false,"product_type":"c1","uid":1205197,"ip_address":"","ucode":"18BDC6A6406C59","user_header":"https://static001.geekbang.org/account/avatar/00/12/63/cd/fd2778c0.jpg","comment_is_top":false,"comment_ctime":1572412769,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"10162347361","product_id":100013101,"comment_content":"go规范中slice&#47;map&#47;func不可以比较，为什么chan可以比较呢？处于什么考虑呢？","like_count":2,"discussions":[{"author":{"id":1957184,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/dd/40/ea203b9a.jpg","nickname":"logoiny🇨🇳","note":"","ucode":"EF3BA5A1C5D36A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369073,"discussion_content":"你可以认为map持有的是chan的指针，chan声明后其指针和类型都是确定不变的，并且chan中元素的变化不会影响自身的指针值和作为map的键值，而slice自扩容的情况下会导致自身持有的指针变化。基于这一点slice无法作为map的键。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618920545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205197,"avatar":"https://static001.geekbang.org/account/avatar/00/12/63/cd/fd2778c0.jpg","nickname":"leitiannet","note":"","ucode":"18BDC6A6406C59","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42098,"discussion_content":"chan不可以比较？但是使用chan int是可以作为map的key呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572585782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1446512,"avatar":"https://static001.geekbang.org/account/avatar/00/16/12/70/10faf04b.jpg","nickname":"Lywane","note":"","ucode":"2B0027AA069CE9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1205197,"avatar":"https://static001.geekbang.org/account/avatar/00/12/63/cd/fd2778c0.jpg","nickname":"leitiannet","note":"","ucode":"18BDC6A6406C59","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":204469,"discussion_content":"我也有这个疑问，此外我还发现两个channel判等一直等于false","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584176927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":42098,"ip_address":""},"score":204469,"extra":""}]}]},{"had_liked":false,"id":22767,"user_name":"谁谁","can_delete":false,"product_type":"c1","uid":1203114,"ip_address":"","ucode":"9651913B7B7ECC","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/aa/777d7f88.jpg","comment_is_top":false,"comment_ctime":1535962200,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10125896792","product_id":100013101,"comment_content":"go中有接口类型，java中也有，python中的接口好像是说要定义成抽象基类！能说下这个接口到底是个什么东西吗？不太了解！","like_count":2},{"had_liked":false,"id":22430,"user_name":"Jowin","can_delete":false,"product_type":"c1","uid":1114356,"ip_address":"","ucode":"19017F7D06C22A","user_header":"https://static001.geekbang.org/account/avatar/00/11/00/f4/cc5f0896.jpg","comment_is_top":false,"comment_ctime":1535675538,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10125610130","product_id":100013101,"comment_content":"hash的实现通常用的是链表，这就没有办法并发操作","like_count":2},{"had_liked":false,"id":22424,"user_name":"小小笑儿","can_delete":false,"product_type":"c1","uid":1040354,"ip_address":"","ucode":"CA63CC50DC2091","user_header":"https://static001.geekbang.org/account/avatar/00/0f/df/e2/823a04b4.jpg","comment_is_top":false,"comment_ctime":1535675232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10125609824","product_id":100013101,"comment_content":"不是，要并发安全的应该用sync.Map","like_count":2},{"had_liked":false,"id":22406,"user_name":"深白色","can_delete":false,"product_type":"c1","uid":1123171,"ip_address":"","ucode":"C4B26AB70D8A6D","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/63/4fb6fee0.jpg","comment_is_top":false,"comment_ctime":1535672237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10125606829","product_id":100013101,"comment_content":"非原子操作的都不是并发安全的，map并不保证并发安全。哈希值的低几位是用来索性桶的，那高位咧？哈希碰撞是如何解决的？","like_count":2},{"had_liked":false,"id":291989,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1620638531,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"5915605827","product_id":100013101,"comment_content":"“键-元素对”确实比“键值对”更符合 Golang 的语义。<br><br>Go 语言的字典类型是用哈希表实现的，那么 Java 等其他语言应该也是采用类似的哈希映射的方式实现的吧，需要再深入了解一下。<br><br>Go 语言字典的键类型不能是函数、字典和切片，主要就是因为没有办法做哈希映射，或者说没有办法比较（判等？）。<br><br>对于思考题，我认为，字典类型的值应该不是并发安全的，如果有两个进程同时修改同一个字典的键-元素对。如果只在字典上添加或或删除键-元素对的情况下，依旧不安全，因为可能会添加重复的键-元素对，或者删除不存在的键-元素对。<br><br>看了一下参考答案，没有想到“字典值内部有时候会根据需要进行存储方面的调整。”这一条。<br><br>如果有机会的话，确实应该去看一下 map.go 的源码。","like_count":1},{"had_liked":false,"id":260200,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1202243,"ip_address":"","ucode":"AE0634E9585A98","user_header":"https://static001.geekbang.org/account/avatar/00/12/58/43/1a2c9328.jpg","comment_is_top":false,"comment_ctime":1604939844,"is_pvip":false,"replies":[{"id":"94504","content":"<br>流程上基本正确，但是细节不准确。<br><br>键的hash用于定位bucket和bucket中的key。<br><br>但定位只是定位，“定位”与“获取”是分开的，对于bucket和key都是这样。获取操作直接通过偏移量找到对应的内存地址，然后直接取出地址中的数据。因为固定类型的值所占用的内存大小也是固定的，所以通过偏移量找目标很容易。<br><br>map对性能要求很严苛，所以，其中存数据的地方并没有使用“数组”这个结构，而是直接用连续的内存空间紧密地存储所有数据（虽然本质上是差不多）。<br><br>当然了，一些短小且非核心的数据（比如部分hash值），这个map使用的是“数组”结构。<br><br>最后，注意你写的最后一句话是不对的。这里没有遍历，也不会检查value是否一致（应该是比较key，是你的笔误吗？）。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1604983047,"ip_address":"","comment_id":260200,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5899907140","product_id":100013101,"comment_content":"老师好，我对他的数据结构的理解是他底层使用了两个数组， 一个是hash桶数组， 存储的都是hash值，另一个是键值对数组，两个数组的长度一致， 并且相同的hash值对应的key-value对他们的数组下标也一致， 这样先在桶里找到hash值对应的数组下标，再去key-value数组对应的下标去元素， 如果有哈希冲突的，会再便利取出来的value，比较value是否一致，不知道我的理解是否正确？","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509131,"discussion_content":"\n流程上基本正确，但是细节不准确。\n\n键的hash用于定位bucket和bucket中的key。\n\n但定位只是定位，“定位”与“获取”是分开的，对于bucket和key都是这样。获取操作直接通过偏移量找到对应的内存地址，然后直接取出地址中的数据。因为固定类型的值所占用的内存大小也是固定的，所以通过偏移量找目标很容易。\n\nmap对性能要求很严苛，所以，其中存数据的地方并没有使用“数组”这个结构，而是直接用连续的内存空间紧密地存储所有数据（虽然本质上是差不多）。\n\n当然了，一些短小且非核心的数据（比如部分hash值），这个map使用的是“数组”结构。\n\n最后，注意你写的最后一句话是不对的。这里没有遍历，也不会检查value是否一致（应该是比较key，是你的笔误吗？）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604983047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102429,"user_name":"Hector","can_delete":false,"product_type":"c1","uid":1496889,"ip_address":"","ucode":"110CAF87ADDC01","user_header":"https://static001.geekbang.org/account/avatar/00/16/d7/39/6698b6a9.jpg","comment_is_top":false,"comment_ctime":1560220029,"is_pvip":false,"replies":[{"id":"36976","content":"它会把 buckets 字段的值赋给 oldbuckets 字段，然后把新的值赋给 buckets 字段。另外，键值对的复制是增量式的。等都复制完了， oldbuckets 字段会被置为 nil。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1560234611,"ip_address":"","comment_id":102429,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5855187325","product_id":100013101,"comment_content":"郝大，想问一下，map扩容时，是不是把原来的buckets的数组复制到了oldbuckets中，在buckets中重新生成一个２倍大的新数组？还是重新生成一个hmap的数据结构，其中的buckets是原来的两倍？","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453420,"discussion_content":"它会把 buckets 字段的值赋给 oldbuckets 字段，然后把新的值赋给 buckets 字段。另外，键值对的复制是增量式的。等都复制完了， oldbuckets 字段会被置为 nil。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560234611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1149022,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","nickname":"scmath","note":"","ucode":"641023BB246C29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284764,"discussion_content":"原型设计模式？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592630876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358341,"user_name":"haiker","can_delete":false,"product_type":"c1","uid":1131183,"ip_address":"北京","ucode":"4C4C799CACCF79","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/af/8c37ca95.jpg","comment_is_top":false,"comment_ctime":1664208614,"is_pvip":false,"replies":[{"id":"130667","content":"通道类型也是不能作为键类型的。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1665387381,"ip_address":"北京","comment_id":358341,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1664208614","product_id":100013101,"comment_content":"除了切片类型，函数类型和字典类型？还有其他类型不能做键类型吗？通道是否可以作为键类型呢？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589898,"discussion_content":"通道类型也是不能作为键类型的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665387381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342038,"user_name":"小麦","can_delete":false,"product_type":"c1","uid":1632797,"ip_address":"","ucode":"9E986363140EB4","user_header":"https://static001.geekbang.org/account/avatar/00/18/ea/1d/efddaad6.jpg","comment_is_top":false,"comment_ctime":1649986674,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649986674","product_id":100013101,"comment_content":"hash原理，画个图其实就很容易懂了，文字讲了很多不如一张图来的通俗易懂","like_count":0},{"had_liked":false,"id":338086,"user_name":"6km","can_delete":false,"product_type":"c1","uid":1263050,"ip_address":"","ucode":"6262BBEC4D9F81","user_header":"https://static001.geekbang.org/account/avatar/00/13/45/ca/38d35ce8.jpg","comment_is_top":false,"comment_ctime":1647271598,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647271598","product_id":100013101,"comment_content":"指针类型做key<br>a := &amp;[]int{1}<br>b := map[*[]int]string{a: &quot;test&quot;}<br>for _, v := range b {<br>\tfmt.Println(v)<br>}","like_count":0},{"had_liked":false,"id":323135,"user_name":"leesper","can_delete":false,"product_type":"c1","uid":1351104,"ip_address":"","ucode":"CC76320571BECA","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/c0/cb5341ec.jpg","comment_is_top":false,"comment_ctime":1637740487,"is_pvip":false,"replies":[{"id":"117300","content":"从源码级别讲，你说的对，每个hash值对应一小块内存，这一小块内存中连续存储着hash值相同的键以及与之对应的元素。这样存储是最高效的，操作起来也最方便。<br><br>这也是“有些类型的值不能作为键”的原因。因为如果这个类型的值占用的空间不固定，就没办法像上述那样紧密的存储了。<br><br>然而，从数据结构整体概念的级别讲，我们会说键值对或者“键-元素对”。因为这样更好理解。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1637823076,"ip_address":"","comment_id":323135,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637740487","product_id":100013101,"comment_content":"老师，读了源码我发现map存储的不是“键-元素”对，确切地说是把键-元素对的指针捆绑在一起存储了对吧，都是unsafe.Pointer类型","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533241,"discussion_content":"从源码级别讲，你说的对，每个hash值对应一小块内存，这一小块内存中连续存储着hash值相同的键以及与之对应的元素。这样存储是最高效的，操作起来也最方便。\n\n这也是“有些类型的值不能作为键”的原因。因为如果这个类型的值占用的空间不固定，就没办法像上述那样紧密的存储了。\n\n然而，从数据结构整体概念的级别讲，我们会说键值对或者“键-元素对”。因为这样更好理解。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637823076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321192,"user_name":"jeremie.liu","can_delete":false,"product_type":"c1","uid":1726839,"ip_address":"","ucode":"6A277B7DA20295","user_header":"https://static001.geekbang.org/account/avatar/00/1a/59/77/33b0b990.jpg","comment_is_top":false,"comment_ctime":1636703333,"is_pvip":false,"replies":[{"id":"116627","content":"这句话紧接着有举例：<br><br>比如，在字典的键类型为字符串类型的情况下；又比如，在字典的键类型为宽度为4或8的整数类型的情况下。<br><br>不过，这种优化会随着版本的更新而微调或改动，所以不用太过关注。或者可以每次版本更新的时候都去看看源码。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1636714157,"ip_address":"","comment_id":321192,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636703333","product_id":100013101,"comment_content":"那什么是不通常的情况？笼统地说，Go 语言有时会对字典的增、删、改、查操作做一些优化。<br>这个优化是什么优化？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530241,"discussion_content":"这句话紧接着有举例：\n\n比如，在字典的键类型为字符串类型的情况下；又比如，在字典的键类型为宽度为4或8的整数类型的情况下。\n\n不过，这种优化会随着版本的更新而微调或改动，所以不用太过关注。或者可以每次版本更新的时候都去看看源码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636714157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187629,"user_name":"Lywane","can_delete":false,"product_type":"c1","uid":1446512,"ip_address":"","ucode":"2B0027AA069CE9","user_header":"https://static001.geekbang.org/account/avatar/00/16/12/70/10faf04b.jpg","comment_is_top":false,"comment_ctime":1584176971,"is_pvip":false,"replies":[{"id":"72683","content":"channel的判等规则超级简单：如果两个channel是由同一个make函数调用产生的（也就是说它们根本就是同一个channel），或者都是nil，那么它们就是相等的。<br><br>所以说，对于channel之间的比较，并不会涉及到它们里面暂存的元素值（以及其他的即时状态），所以把某个channel类型作为map的key类型并不会引起什么问题。<br><br>","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1584344725,"ip_address":"","comment_id":187629,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584176971","product_id":100013101,"comment_content":"老师，请问channel的判等是怎么判断的。为什么它也能作为字典的key呢","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487171,"discussion_content":"channel的判等规则超级简单：如果两个channel是由同一个make函数调用产生的（也就是说它们根本就是同一个channel），或者都是nil，那么它们就是相等的。\n\n所以说，对于channel之间的比较，并不会涉及到它们里面暂存的元素值（以及其他的即时状态），所以把某个channel类型作为map的key类型并不会引起什么问题。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584344725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156746,"user_name":"先听","can_delete":false,"product_type":"c1","uid":1151409,"ip_address":"","ucode":"82D8DA7A2FEB4B","user_header":"https://static001.geekbang.org/account/avatar/00/11/91/b1/fb117c21.jpg","comment_is_top":false,"comment_ctime":1574946802,"is_pvip":false,"replies":[{"id":"60202","content":"哈希值是独立存储的，但键值不是。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1574996831,"ip_address":"","comment_id":156746,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1574946802","product_id":100013101,"comment_content":"记得前面有个地方说“不会存储键值，只会存储哈希值”，但是后面说为了解决哈希碰撞 会比较完哈希值再比较一遍键值。可是 没有存储键值的话，没办法比较啊","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476221,"discussion_content":"哈希值是独立存储的，但键值不是。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574996831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1151409,"avatar":"https://static001.geekbang.org/account/avatar/00/11/91/b1/fb117c21.jpg","nickname":"先听","note":"","ucode":"82D8DA7A2FEB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65491,"discussion_content":"把“不是独立存储”错当成“不存储了”。谢谢回复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575006014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142929,"user_name":"瞌睡的咸鱼","can_delete":false,"product_type":"c1","uid":1059784,"ip_address":"","ucode":"6D1C8D4B417B1A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRCtuJkpyy2I29LxUsXwZGjicyzDAb3lo76KLX8gxUfawgSeNdQOibjibF0VNXEv7t2DiaIrBU4KcHyQ/132","comment_is_top":false,"comment_ctime":1571588394,"is_pvip":false,"replies":[{"id":"55275","content":"这问题太笼统了，我没法回答啊。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1571627777,"ip_address":"","comment_id":142929,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571588394","product_id":100013101,"comment_content":"请教老师，Go语言会对增删查改做哪些优化呢？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471330,"discussion_content":"这问题太笼统了，我没法回答啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571627777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98469,"user_name":"鱼鱼","can_delete":false,"product_type":"c1","uid":1343562,"ip_address":"","ucode":"7EC873BAD0E392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/kC4X5YKgOj5yGibYGBbVfBtf2tvKiaFhY5lk0bdZ1O104flDHBpjdMzUFHjqgl44sHXrzmNsLaz6Sqx1iaLAy6TDA/132","comment_is_top":false,"comment_ctime":1559007594,"is_pvip":false,"replies":[{"id":"35235","content":"不是链表，而是用连续内存存储 key1value1key2value2。我在早先的评论里解释过了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1559010971,"ip_address":"","comment_id":98469,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559007594","product_id":100013101,"comment_content":"哈希桶内部存储了 哈希值-内部结构这样的对，也看了一些评论，可以这样理解内部结构吗，每个哈希值节点也是一个链表，指向哈希值相同的键值对内存。 ","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451700,"discussion_content":"不是链表，而是用连续内存存储 key1value1key2value2。我在早先的评论里解释过了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559010971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75708,"user_name":"❤某人❤","can_delete":false,"product_type":"c1","uid":1255926,"ip_address":"","ucode":"2F8FC06D03BF20","user_header":"https://static001.geekbang.org/account/avatar/00/13/29/f6/71a1d24b.jpg","comment_is_top":false,"comment_ctime":1552453780,"is_pvip":false,"replies":[{"id":"28886","content":"这是根据源码描述的。对于哈希值相同的键来说，它是这么存储的：<br><br>key1value1key2value2key3value3<br><br>这是一块连续的内存。所以我说它不是单独存储某一个键值的。而且这种存储方式对于键值的判等也很方便。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1553399934,"ip_address":"","comment_id":75708,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552453780","product_id":100013101,"comment_content":"为什么说字典不单独存储键值， 但后面又说， 键值哈希值命中后， 还要判断键值是否相等，防止哈希碰撞的清空。那判断的时候键值又是哪来的呢？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442993,"discussion_content":"这是根据源码描述的。对于哈希值相同的键来说，它是这么存储的：\n\nkey1value1key2value2key3value3\n\n这是一块连续的内存。所以我说它不是单独存储某一个键值的。而且这种存储方式对于键值的判等也很方便。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553399934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43203,"user_name":"吴承祖","can_delete":false,"product_type":"c1","uid":1199747,"ip_address":"","ucode":"8E7DD23FE18E34","user_header":"https://static001.geekbang.org/account/avatar/00/12/4e/83/5338bd77.jpg","comment_is_top":false,"comment_ctime":1543195896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543195896","product_id":100013101,"comment_content":"希望剖析一下golang中哈希表的底层结构，似乎与常见的哈希链表实现方式很不一样","like_count":0},{"had_liked":false,"id":37316,"user_name":"A1李自飞","can_delete":false,"product_type":"c1","uid":1045911,"ip_address":"","ucode":"A9B79309349BC0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/97/04a57966.jpg","comment_is_top":false,"comment_ctime":1541549986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541549986","product_id":100013101,"comment_content":"如果在讲解的时候能结合实战就更好了，比如字典的键类型约束，能结合实际给初学者建议就更好了，不应该是把所有可能讲完了，初学者你自己领悟去吧","like_count":0},{"had_liked":false,"id":26840,"user_name":"RISE","can_delete":false,"product_type":"c1","uid":1201956,"ip_address":"","ucode":"00E99CCA142E83","user_header":"https://static001.geekbang.org/account/avatar/00/12/57/24/909bb6ef.jpg","comment_is_top":false,"comment_ctime":1537759921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537759921","product_id":100013101,"comment_content":"想问一下如果并发只读一个 map 的话会不会报错？","like_count":0},{"had_liked":false,"id":23708,"user_name":"T、","can_delete":false,"product_type":"c1","uid":1214090,"ip_address":"","ucode":"11713A25556241","user_header":"https://static001.geekbang.org/account/avatar/00/12/86/8a/cb3b4b0f.jpg","comment_is_top":false,"comment_ctime":1536599273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536599273","product_id":100013101,"comment_content":"讲的不错","like_count":0},{"had_liked":false,"id":22550,"user_name":"我爱探索","can_delete":false,"product_type":"c1","uid":1202924,"ip_address":"","ucode":"CEBD4F996747B5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3IrblACSCxr7ianvicQXRexScIaZ1zXVQYc1eLUlia6WkhPNKPzMoIJRgfVHe1BHskfTx8E9FCmicYGCeZic6HrGbRA/132","comment_is_top":false,"comment_ctime":1535784014,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1535784014","product_id":100013101,"comment_content":"我就想把语音和文档保存在本地作为资料保存呀","like_count":0},{"had_liked":false,"id":22427,"user_name":"多米","can_delete":false,"product_type":"c1","uid":1005563,"ip_address":"","ucode":"A51148663381E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/fb/02039e8b.jpg","comment_is_top":false,"comment_ctime":1535675383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1535675383","product_id":100013101,"comment_content":"Map的值也需要比较 是不是也要和键一样 slice 函数 map 同样不能作为值了(以及包含上面的嵌套的复杂值)了？","like_count":0}]}