{"id":740978,"title":"第 8 章 用领域模型指导实现(2)","content":"<h2 id=\"nav_point_189\">8.5　限界上下文</h2>\n<p>在本章前 4 节中，我们介绍了如何使用领域模型指导软件实现，但是刻意忽略了一个重要的方面：在实现软件系统时首先是按照问题域进行切分，而不是直接分层。本书已经在 5.2 节讨论了子域划分，可如何在具体实现中体现对问题域的分解呢？本节我们介绍领域驱动设计的限界上下文概念，并把它和子域的关系说明清楚。</p>\n<h3 id=\"nav_point_190\">8.5.1　限界上下文的理想边界</h3>\n<p>限界上下文这个名字看起来多少有些费解。Eric Evans 在《领域驱动设计》一书中用细胞做了比喻，来说明限界上下文是什么。细胞有什么特点呢？它功能完备，自成一个系统，最关键的是有一层细胞膜，能把细胞和外部世界隔离开来。同理，限界上下文本质上是一个自治的小世界，它有完备的职责，还有清晰的边界。</p>\n<p>完备的职责和清晰的边界这种描述多少有些模糊，不那么容易把握。但是，5.2 节的设计原则表明，架构设计优先要按问题域划分。结合第 4 章关于领域和子域的介绍，限界上下文的最理想边界也就很清楚了。</p>\n<blockquote>\n<p>限界上下文的最理想边界是子域的边界。</p>\n</blockquote>\n<h3 id=\"nav_point_191\">8.5.2　把一切都封装在限界上下文中</h3>\n<p>切分合理、边界清晰的限界上下文会带来巨大的收益，在易于理解、易于复用和易于演进方面皆是如此。例如，如果你在一个业务中需要发送短信，那么大概率你不会自己实现这个功能，而是会直接找一个可以发送短信的服务提供商，使用公开的 API 或者 SDK 完成。这个短信服务就包裹在一个限界上下文中，对你来说，仅需要了解它的公开接口。</p><!-- [[[read_end]]] -->\n<p>如果你不能使用在线服务，又需要在一个客户端程序中嵌入聊天界面，那么最好的选择是集成一个第三方包。就算需要源码，你也希望能有一个干干净净、包括且仅包括自己所需的那部分代码的代码库。对你来说，这个第三方包（如果需要，那么还包含它的源码）就是一个限界上下文。你不会把自己的代码写入这个限界上下文中，而是会刻意守护它的边界。</p>\n<p>那么，数据库呢？为了集成别人的服务而去创建一个庞大的数据库，里面包含许多自己并不需要的表，相信这绝非你所愿。我们自然希望数据库也遵循同样的边界定义。这个数据库显然也要放置在特定的限界上下文中，才能维持它的完整性。</p>\n<p>这样的例子不胜枚举。刚才讲的例子都是利用别人的服务，对于自己对外提供的服务，逻辑也是一样的。归纳一下就是：一个子域的一切资产，包括领域模型、数据库、包、可执行程序、接口声明等，都应该封装在限界上下文中，避免跨越边界。</p>\n<p>只要遵循这样的原则，一个限界上下文就成为了一个完备的整体，它可以独立演化，可以被随时替换，可以让第三方轻松复用。</p>\n<h3 id=\"nav_point_192\">8.5.3　尽量建立清晰而一致的边界</h3>\n<p>一旦建立了限界上下文，在分析领域模型、实现代码、系统运维等阶段就需要保持它的边界，即始终知道我现在工作在哪个限界上下文中。不要把不相干的概念、不相干的业务逻辑引入所定义的边界中。</p>\n<blockquote>\n<p>保持所工作的限界上下文的整洁和内聚。</p>\n</blockquote>\n<p>我们可以采取一些工程上的手段来帮助划分边界。例如，使用不同的代码库或者代码目录、使用不同的数据库或者数据库表等。此外，从部署结构上看，微服务<sup>[43]</sup>在企业级应用和互联网应用中已经渐成主流。那如何划分微服务呢？一个非常有效的方式是以业务职责为依据。对应到本章的概念，就是限界上下文。</p>\n<p>当然，并不是僵化地说一个限界上下文只能对应一个微服务，只是限界上下文确实可以很好地指导微服务的划分。图 8.10 是一个在微服务环境下划分服务的示例，从中我们能够看到子域、限界上下文和微服务之间的关系。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00374.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 8.10</strong>　子域、限界上下文和微服务</p>\n<p>显式的边界，特别是通过代码库进行代码隔离、通过微服务进行部署隔离，有许多方面的优点，不过也并非没有风险。人们对于子域划分的认知往往是渐进的，如果在边界还不是那么确定的时候，就贸然划分出边界，那么可能会给后续的系统间交互以及重构造成较大的困扰。因此，如何平衡边界的价值和不利影响，是划分边界时要做的一种重要取舍。一个较为稳妥的策略是考虑认知的渐进特征，不要过早隔离。在已经确定的边界上进行划分，延缓划分那些尚具模糊性的边界，在这些边界逐渐变得清晰时再分离它们。</p>\n<h2 id=\"nav_point_193\">8.6　上下文映射</h2>\n<p>限界上下文约定了基于领域模型的架构层次的设计分解，而分解必然意味着集成和协作。上下文映射就是对限界上下文之间的协作关系的模式总结。熟悉这些模式，有助于在不同场景下选择恰当的依赖关系。</p>\n<h3 id=\"nav_point_194\">8.6.1　在边界上完成概念映射</h3>\n<p>不同的限界上下文使用不同的领域模型。这些限界上下文相互协作，就相当于使用不同语种的人在打交道，因此需要在边界上进行概念的映射和转换。</p>\n<p>下面看一个例子。为了提升食堂餐品的质量，计划在订餐系统中加入一个新功能：订餐人可以对餐品提交评价。图 8.11 是为该业务功能建立的领域模型。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00375.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 8.11</strong>　餐品的评价功能涉及多个限界上下文</p>\n<p>注意，处在不同限界上下文中的不同概念可能指向的是同一个事物。例如，评论上下文中的可评论资源在这个业务场景中对应的是餐品。假如在应用界面上，除了显示评论内容外，还会显示被评论的餐品图片，那么在应用层组装时就需要知道：要把可评论资源的 ID 作为餐品 ID 去餐品服务中查询信息。</p>\n<p>以上描述的是第一类概念转换，第二类概念转换出现在限界上下文之间存在依赖的场景中。假如在一个外卖送餐场景中涉及送餐路径的规划问题，会用到一个通用的数学算法，那这里不应该存在取餐点、送餐点、距离这些概念，更合适的概念应该是节点、边以及边的权重。这时候就可能需要把订单上下文中的取餐点、送餐点转义为图上的节点，把规划获得的路径转换为图上的边。为了不污染路径规划算法中的概念，保持这个算法的通用性，这部分概念转换肯定不应该实现在路径规划算法中，常见做法如图 8.12 所示，就是在两个上下文之间增加一个适配器，完成上述转换。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00376.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 8.12</strong>　在两个上下文之间增加适配器完成转换</p>\n<p>在边界上完成概念映射是一种基本模式。通过在应用层组装或者使用适配器完成概念映射，可以保持领域概念的清晰，避免领域模型遭到不必要的污染。</p>\n<h3 id=\"nav_point_195\">8.6.2　上下文映射的模式</h3>\n<p>在限界上下文的边界上使用适配器是一种常见的架构策略。从服务提供方（被依赖方）的角度讲，因为它提供的是标准服务，所以服务具有非常好的通用性，可在多个场景下复用。从服务请求方（依赖方）的角度讲，因为它总是通过适配器和服务提供方相连接，和服务提供方实现了解耦，两者的关系从强依赖变成了弱依赖。</p>\n<p>在《领域驱动设计》中，Eric Evans 提出了若干种上下文映射的模式，其中部分模式已经在图 8.3 中列出，本书合并了具有一定时代特征的开放主机服务模式和公开发布语言模式，并使用标准开放服务模式作为代替。</p>\n<p>事实上，图 8.12 是一个典型的上下文映射的模式，用术语表达出来就是图 8.13。其中，标准开放服务等价于图计算上下文对外定义的标准术语和服务，如节点、边的概念以及获取最短路径的能力等；防腐层则基本和前述的适配器相对应。如果对比图 8.13 和图 8.12，就会发现这两张图只存在表示法的差异，本质是一致的。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00377.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 8.13</strong>　使用上下文映射模式表达的依赖关系</p>\n<p>当然，之所以会提出图 8.3 中的那么多模式，是因为在不同的场景下，对依赖关系的管理和限界上下文之间的协作模式是不同的。下面我们介绍两个上下文映射的主要模式，它们的适用场景以及对协作方式的指导。</p>\n<p><strong>防腐层模式</strong></p>\n<p>要不依赖其他服务实现一个功能，一般情况下是不太可能做到的。而依赖其他服务又会面临如下一些情况。</p>\n<ul>\n<li>服务提供方提供的服务、接口质量或者数据质量不好。</li>\n<li>不想让服务请求方和服务提供方紧密绑定在一起，未来可能会替换服务提供方。</li>\n<li>不想受服务提供方未来变化（如升级、接口变更）的影响。</li>\n</ul>\n<p>在两个上下文之间引入防腐层可以解决上述问题。图 8.12 中的配送路径计算接口和配送路径计算适配器就扮演了防腐层的角色。从订单上下文的角度看，它总是依赖配送路径计算接口。这个接口本质上就是一个服务请求方接口，是稳定的。无论服务提供方的质量是高还是低、在未来是否要替换，或者接口是否有变更，都只会影响到配送路径计算适配器，而订单上下文的内容可以保持稳定。</p>\n<p><strong>标准开放服务模式</strong></p>\n<p>在本书中，我使用标准开放服务这个术语来指代 Eric Evans 在参考书籍 [23][41] 中定义的开放主机服务（openhost service）和公开发布语言（published language）。标准开放服务更加强调“标准”和“开放”这两个词的内涵，不考虑具体的服务提供形式。</p>\n<p>假如你正在工作的领域或者模块有许多不同的客户，那么为每个客户都提供一个专门的服务定义显然不可能。更为有效的办法其实是声明一组接口（或者服务、数据规范等），并把它们以标准的形式发布出来。开放的标准化服务可以大幅降低维护成本和支持成本。现在有不少服务是以标准化、公开发布的形式提供的，如地图服务、短信服务。即便是在团队内部，当客户很多或者服务已经相当成熟时，采取标准开放服务的方式也是非常合适的。</p>\n<p><strong>客户 - 供应商模式</strong></p>\n<p>标准化服务往往需要时间的沉淀。在许多场景下，一个子域还不够成熟，由于对这个领域的认知还不够，所以服务的定义很难稳定；或者只有有限的客户，由于这个阶段客户不多，所以服务提供方只是服务于服务请求方，服务提供方的价值也只有通过服务请求方的使用才能体现。这时候定义标准化的服务，再增加防腐层模式，可能只是引入了额外成本，并没有带来什么实际收益，因此这么做可能并不合适。</p>\n<p>在这种情况下，彼此协作的双方可以建立更密切的关系，服务请求方作为客户，服务提供方作为供应商，二者之间的关系也转换为直接依赖。一旦客户产生了新需求，那么只要确实对应供应商的职责，就可以及时更新。</p>\n<p>为了更好地让客户和供应商协作，还可以把二者间的契约显式化。例如，让客户通过测试描述契约，并把契约加入供应商的测试列表中。这样供应商就可以持续地通过测试来验证所提供的服务是否满足客户的需求。</p>\n<p>客户 - 供应商模式下的供应商，也可以进一步发展为标准开放服务。随着供应商对一个领域的认知逐步加深，能力越来越丰富，可能会有更多的客户依赖于它所提供的服务。此时，就可以考虑提取客户需求的共性，把它们加以抽象并标准化为开放服务，然后通过防腐层和原来的客户对接。</p>\n<p><strong>追随者模式</strong></p>\n<p>服务请求方有时候感到和服务提供方的关系不符合防腐层模式的关键特征。例如，服务提供方的数据质量或者服务标准定义很好，没有在未来会被替换的诉求，自己的变化也不是那么频繁。这时候引入额外的防腐层可能就不太合算，服务请求方可以把自己定义为追随者，即完全服从服务提供方定义的服务标准。</p>\n<p>追随者模式有一定的好处。除了成本较低之外，还适用于服务请求方对一个领域的认知还不够成熟，而服务提供方的认知已经很成熟的情况。这时候服务请求方作为追随者，还可以从服务提供方的定义中学习关键概念，避免走不必要的弯路。</p>\n<p>当然，一旦发现服务请求方和服务提供方的关系已经呈现出防腐层模式期望的特征，就应该及时把追随者模式切换成防腐层模式。</p>\n<h2 id=\"nav_point_196\">8.7　领域模型的持续演进</h2>\n<p>领域模型并非一成不变。随着业务发展，现有的领域模型可能无法满足新的需求，就需要及时演进。纯粹从概念上讲，领域模型的演进是问题域的关注点，4.4 节已经讨论过这个话题。为什么在讨论代码实现的章节，我们还要再次提及领域模型的演进呢？原因如下。</p>\n<blockquote>\n<p>如果在编码阶段缺乏分解和抽象意识，就很容易漏掉领域模型演进的机会，导致领域模型腐化。</p>\n</blockquote>\n<p>这是从大量实践中总结得出的经验。如果在编码阶段忽略了领域模型的演进，那么领域模型基本上会名存实亡，原有的模型无法从新的业务场景中吸收信息，势必走向过时和失效。只有做到模型和代码的同步变化，才是真正的“统一语言”。</p>\n<p>代码清单 8.14 是一段来自真实项目的反例。</p>\n<pre class=\"code-rows\"><code>class Review {\n    String id;\n    String comment;\n    Date creationDate;\n    CreatorId creatorId;\n\n    Integer point;\n    // 其他代码略\n}\n\nclass ReviewService {\n    ReviewRepository repo;\n\n    MemberService memberService;\n    // 其他代码略\n}</code></pre>\n<p><strong>代码清单 8.14</strong>　缺乏演进意识导致领域模型腐化</p>\n<p>这段代码就是由于缺乏演进意识，导致了领域模型的腐化。请注意其中的第 7 行和第 14 行。<code>Review</code> 代表评论子域的领域实体，<code>ReviewService</code> 是评论微服务的一个应用层服务，<code>id</code>、<code>comment</code> 这些概念看起来也都很正常，但是为什么会出现 <code>point</code> 和 <code>memberService</code> 呢？它们是什么呢？</p>\n<p>产生上述问题的原因是业务演进。为了鼓励用户提交评论，产品设计人员决定增加一个功能：用户提交评论后，可以获得积分奖励。当然，如果用户删除了评论，评论对应的积分也会删除。积分会被计入会员账户中，这就是 <code>point</code>、<code>memberService</code> 的由来，它们分别对应评论被奖励了多少积分，以及通知会员服务记录或扣除该积分。</p>\n<h3 id=\"nav_point_197\">8.7.1　及时分离领域概念</h3>\n<p>我们现在基于限界上下文的概念，来重新考虑代码清单 8.14 的合理性。在 <code>Review</code> 中引入 <code>point</code>，其实是对边界的侵蚀，这样做降低了评论这个业务概念的内聚性，是不可取的。更合理的做法是：在会员上下文中新建一个积分计算服务，让它监听评论创建事件和评论删除事件，并基于这些事件增减会员的积分。其结构如图 8.14 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00378.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 8.14</strong>　正确解耦，保持业务概念内聚</p>\n<h3 id=\"nav_point_198\">8.7.2　及时抽象领域概念</h3>\n<p>我们已经在 8.6 节中讨论过概念抽象，如把餐品或者订单抽象为可评论资源。不过有时候未必需要抽象，也未必能发现一切抽象的机会。</p>\n<p>在图 4.18 中和代码清单 8.9 中就存在这样一个抽象的机会。请注意，在订单项这个概念中，有一个“餐品”属性，如果抽象来看，订单真的只能描述餐品吗？并不是，它也可以用在其他场景下，如描述一本书、一架钢琴或者一个上门美甲服务。</p>\n<p>过早抽象并不一定是好事。如果订单这个聚合就是在餐品预订的业务中发展起来的，暂时也没有购买其他类型的商品或者服务的需要，那么即使其中掺杂了一点未经抽象的概念，也并不会伤害可扩展性。抽象是有解释成本的，特别是在想象的业务场景还没发生时，进行抽象反而会伤害可理解性。</p>\n<p>反之，在该抽象的时候，一定要及时演进领域模型和对应的实现。一旦新的业务场景发生了，如订单子系统在另外一个系统中得到了复用，这个系统对应购买图书的服务，那么切记不要复制一份订单子系统，并仅把其中的 <code>FoodData</code> 改成 <code>BookData</code>，而是要及时把 <code>FoodData</code> 抽象为 <code>SaledItemData</code>。这意味着要同时调整业务表述中的概念、代码中的概念和日常交流中的术语。</p>\n<blockquote>\n<p>不必过早抽象领域概念。但是，在需要抽象时，一定要及时抽象，并始终保持所有制品中的概念模型的同步。</p>\n</blockquote>\n<h2 id=\"nav_point_199\">8.8　小结</h2>\n<p>高质量的代码应该反映核心的业务概念，并和问题域中的表示尽量一致。本章介绍了源自领域驱动设计的战术模式，以及领域驱动设计的战略模式，以体现领域模型在架构层面对接口设计和依赖关系的指导。图 8.15 给出了本章的内容概要。</p>\n<p>注意，仅仅依赖领域模型，并不足以做出卓越的设计。领域模型只是构建领域层的基础，它还需要配合将在第 9 章讲到的由外而内的设计，才能高效实现产品需求。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00379.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 8.15</strong>　用领域模型指导实现</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 8 章 用领域模型指导实现(1)","id":740977},"right":{"article_title":"第 9 章 由外而内的设计(1)","id":740979}},"comments":[]}