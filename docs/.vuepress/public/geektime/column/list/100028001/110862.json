{"id":110862,"title":"29 | 如何使用设计模式优化并发编程？","content":"<p>你好，我是刘超。</p><p>在我们使用多线程编程时，很多时候需要根据业务场景设计一套业务功能。其实，在多线程编程中，本身就存在很多成熟的功能设计模式，学好它们，用好它们，那就是如虎添翼了。今天我就带你了解几种并发编程中常用的设计模式。</p><h2>线程上下文设计模式</h2><p>线程上下文是指贯穿线程整个生命周期的对象中的一些全局信息。例如，我们比较熟悉的Spring中的ApplicationContext就是一个关于上下文的类，它在整个系统的生命周期中保存了配置信息、用户信息以及注册的bean等上下文信息。</p><p>这样的解释可能有点抽象，我们不妨通过一个具体的案例，来看看到底在什么的场景下才需要上下文呢？</p><p>在执行一个比较长的请求任务时，这个请求可能会经历很多层的方法调用，假设我们需要将最开始的方法的中间结果传递到末尾的方法中进行计算，一个简单的实现方式就是在每个函数中新增这个中间结果的参数，依次传递下去。代码如下：</p><pre><code>public class ContextTest {\n\n\t// 上下文类\n\tpublic class Context {\n\t\tprivate String name;\n\t\tprivate long id\n\n\t\tpublic long getId() {\n\t\t\treturn id;\n\t\t}\n\n\t\tpublic void setId(long id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn this.name;\n\t\t}\n\n\t\tpublic void setName(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\t}\n\n\t// 设置上下文名字\n\tpublic class QueryNameAction {\n\t\tpublic void execute(Context context) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000L);\n\t\t\t\tString name = Thread.currentThread().getName();\n\t\t\t\tcontext.setName(name);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\t// 设置上下文ID\n\tpublic class QueryIdAction {\n\t\tpublic void execute(Context context) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000L);\n\t\t\t\tlong id = Thread.currentThread().getId();\n\t\t\t\tcontext.setId(id);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\t// 执行方法\n\tpublic class ExecutionTask implements Runnable {\n\n\t\tprivate QueryNameAction queryNameAction = new QueryNameAction();\n\t\tprivate QueryIdAction queryIdAction = new QueryIdAction();\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tfinal Context context = new Context();\n\t\t\tqueryNameAction.execute(context);\n\t\t\tSystem.out.println(&quot;The name query successful&quot;);\n\t\t\tqueryIdAction.execute(context);\n\t\t\tSystem.out.println(&quot;The id query successful&quot;);\n\n\t\t\tSystem.out.println(&quot;The Name is &quot; + context.getName() + &quot; and id &quot; + context.getId());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tIntStream.range(1, 5).forEach(i -&gt; new Thread(new ContextTest().new ExecutionTask()).start());\n\t}\n}\n</code></pre><p>执行结果：</p><pre><code>The name query successful\nThe name query successful\nThe name query successful\nThe name query successful\nThe id query successful\nThe id query successful\nThe id query successful\nThe id query successful\nThe Name is Thread-1 and id 11\nThe Name is Thread-2 and id 12\nThe Name is Thread-3 and id 13\nThe Name is Thread-0 and id 10\n</code></pre><p>然而这种方式太笨拙了，每次调用方法时，都需要传入Context作为参数，而且影响一些中间公共方法的封装。</p><p>那能不能设置一个全局变量呢？如果是在多线程情况下，需要考虑线程安全，这样的话就又涉及到了锁竞争。</p><!-- [[[read_end]]] --><p>除了以上这些方法，其实我们还可以使用ThreadLocal实现上下文。ThreadLocal是线程本地变量，可以实现多线程的数据隔离。<span class=\"orange\">ThreadLocal为每一个使用该变量的线程都提供一份独立的副本，线程间的数据是隔离的，每一个线程只能访问各自内部的副本变量。</span></p><p>ThreadLocal中有三个常用的方法：set、get、initialValue，我们可以通过以下一个简单的例子来看看ThreadLocal的使用：</p><pre><code>private void testThreadLocal() {\n    Thread t = new Thread() {\n        ThreadLocal&lt;String&gt; mStringThreadLocal = new ThreadLocal&lt;String&gt;();\n\n        @Override\n        public void run() {\n            super.run();\n            mStringThreadLocal.set(&quot;test&quot;);\n            mStringThreadLocal.get();\n        }\n    };\n\n    t.start();\n}\n</code></pre><p>接下来，我们使用ThreadLocal来重新实现最开始的上下文设计。你会发现，我们在两个方法中并没有通过变量来传递上下文，只是通过ThreadLocal获取了当前线程的上下文信息：</p><pre><code>public class ContextTest {\n\t// 上下文类\n\tpublic static class Context {\n\t\tprivate String name;\n\t\tprivate long id;\n\n\t\tpublic long getId() {\n\t\t\treturn id;\n\t\t}\n\n\t\tpublic void setId(long id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn this.name;\n\t\t}\n\n\t\tpublic void setName(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\t}\n\n\t// 复制上下文到ThreadLocal中\n\tpublic final static class ActionContext {\n\n\t\tprivate static final ThreadLocal&lt;Context&gt; threadLocal = new ThreadLocal&lt;Context&gt;() {\n\t\t\t@Override\n\t\t\tprotected Context initialValue() {\n\t\t\t\treturn new Context();\n\t\t\t}\n\t\t};\n\n\t\tpublic static ActionContext getActionContext() {\n\t\t\treturn ContextHolder.actionContext;\n\t\t}\n\n\t\tpublic Context getContext() {\n\t\t\treturn threadLocal.get();\n\t\t}\n\n\t\t// 获取ActionContext单例\n\t\tpublic static class ContextHolder {\n\t\t\tprivate final static ActionContext actionContext = new ActionContext();\n\t\t}\n\t}\n\n\t// 设置上下文名字\n\tpublic class QueryNameAction {\n\t\tpublic void execute() {\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000L);\n\t\t\t\tString name = Thread.currentThread().getName();\n\t\t\t\tActionContext.getActionContext().getContext().setName(name);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\t// 设置上下文ID\n\tpublic class QueryIdAction {\n\t\tpublic void execute() {\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000L);\n\t\t\t\tlong id = Thread.currentThread().getId();\n\t\t\t\tActionContext.getActionContext().getContext().setId(id);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\t// 执行方法\n\tpublic class ExecutionTask implements Runnable {\n\t\tprivate QueryNameAction queryNameAction = new QueryNameAction();\n\t\tprivate QueryIdAction queryIdAction = new QueryIdAction();\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tqueryNameAction.execute();//设置线程名\n\t\t\tSystem.out.println(&quot;The name query successful&quot;);\n\t\t\tqueryIdAction.execute();//设置线程ID\n\t\t\tSystem.out.println(&quot;The id query successful&quot;);\n\n\t\t\tSystem.out.println(&quot;The Name is &quot; + ActionContext.getActionContext().getContext().getName() + &quot; and id &quot; + ActionContext.getActionContext().getContext().getId())\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tIntStream.range(1, 5).forEach(i -&gt; new Thread(new ContextTest().new ExecutionTask()).start());\n\t}\n}\n</code></pre><p>运行结果：</p><pre><code>The name query successful\nThe name query successful\nThe name query successful\nThe name query successful\nThe id query successful\nThe id query successful\nThe id query successful\nThe id query successful\nThe Name is Thread-2 and id 12\nThe Name is Thread-0 and id 10\nThe Name is Thread-1 and id 11\nThe Name is Thread-3 and id 13\n</code></pre><h2>Thread-Per-Message设计模式</h2><p>Thread-Per-Message设计模式翻译过来的意思就是每个消息一个线程的意思。例如，我们在处理Socket通信的时候，通常是一个线程处理事件监听以及I/O读写，如果I/O读写操作非常耗时，这个时候便会影响到事件监听处理事件。</p><p>这个时候Thread-Per-Message模式就可以很好地解决这个问题，一个线程监听I/O事件，每当监听到一个I/O事件，则交给另一个处理线程执行I/O操作。下面，我们还是通过一个例子来学习下该设计模式的实现。</p><pre><code>//IO处理\npublic class ServerHandler implements Runnable{\n\tprivate Socket socket;\n\t \n    public ServerHandler(Socket socket) {\n        this.socket = socket;\n    }\n    \n    public void run() {\n        BufferedReader in = null;\n        PrintWriter out = null;\n        String msg = null;\n        try {\n            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            out = new PrintWriter(socket.getOutputStream(),true);\n            while ((msg = in.readLine()) != null &amp;&amp; msg.length()!=0) {//当连接成功后在此等待接收消息（挂起，进入阻塞状态）\n                System.out.println(&quot;server received : &quot; + msg);\n                out.print(&quot;received~\\n&quot;);\n                out.flush();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n        \ttry {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            try {\n                out.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre><pre><code>//Socket启动服务\npublic class Server {\n\t\n\tprivate static int DEFAULT_PORT = 12345;\n\tprivate static ServerSocket server;\n\n\tpublic static void start() throws IOException {\n\t\tstart(DEFAULT_PORT);\n\t}\n\n\tpublic static void start(int port) throws IOException {\n\t\tif (server != null) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\ttry {\n\t\t\t//启动服务\n\t\t\tserver = new ServerSocket(port);\n\t\t\t// 通过无线循环监听客户端连接\n\t\t\twhile (true) {\n\t\t\t\t\n\t\t\t\tSocket socket = server.accept();\n\t\t\t\t// 当有新的客户端接入时，会执行下面的代码\n\t\t\t\tlong start = System.currentTimeMillis();\n\t\t\t\tnew Thread(new ServerHandler(socket)).start();\n\t\t\t\t\n\t\t\t\tlong end = System.currentTimeMillis();\n\n\t\t\t\tSystem.out.println(&quot;Spend time is &quot; + (end - start));\n\t\t\t}\n\t\t} finally {\n\t\t\tif (server != null) {\n\t\t\t\tSystem.out.println(&quot;服务器已关闭。&quot;);\n\t\t\t\tserver.close();\n\t\t\t}\n\n\t\t}\n\n\t}\n\t\n\tpublic static void main(String[] args) throws InterruptedException{\n\n\t\t// 运行服务端\n\t\tnew Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tServer.start();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}).start();\n\n\t}\n}\n</code></pre><p>以上，我们是完成了一个使用Thread-Per-Message设计模式实现的Socket服务端的代码。但这里是有一个问题的，你发现了吗？</p><p>使用这种设计模式，如果遇到大的高并发，就会出现严重的性能问题。如果针对每个I/O请求都创建一个线程来处理，在有大量请求同时进来时，就会创建大量线程，而此时JVM有可能会因为无法处理这么多线程，而出现内存溢出的问题。</p><p>退一步讲，即使是不会有大量线程的场景，每次请求过来也都需要创建和销毁线程，这对系统来说，也是一笔不小的性能开销。</p><p>面对这种情况，<span class=\"orange\">我们可以使用线程池来代替线程的创建和销毁，</span>这样就可以避免创建大量线程而带来的性能问题，是一种很好的调优方法。</p><h2>Worker-Thread设计模式</h2><p>这里的Worker是工人的意思，代表在Worker Thread设计模式中，会有一些工人（线程）不断轮流处理过来的工作，当没有工作时，工人则会处于等待状态，直到有新的工作进来。除了工人角色，Worker Thread设计模式中还包括了流水线和产品。</p><p>这种设计模式相比Thread-Per-Message设计模式，可以减少频繁创建、销毁线程所带来的性能开销，还有无限制地创建线程所带来的内存溢出风险。</p><p>我们可以假设一个场景来看下该模式的实现，通过Worker Thread设计模式来完成一个物流分拣的作业。</p><p>假设一个物流仓库的物流分拣流水线上有8个机器人，它们不断从流水线上获取包裹并对其进行包装，送其上车。当仓库中的商品被打包好后，会投放到物流分拣流水线上，而不是直接交给机器人，机器人会再从流水线中随机分拣包裹。代码如下：</p><pre><code>//包裹类\npublic class Package {\n\tprivate String name;\n\tprivate String address;\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getAddress() {\n\t\treturn address;\n\t}\n\n\tpublic void setAddress(String address) {\n\t\tthis.address = address;\n\t}\n\n\tpublic void execute() {\n\t\tSystem.out.println(Thread.currentThread().getName()+&quot; executed &quot;+this);\n\t}\n}\n</code></pre><pre><code>//流水线\npublic class PackageChannel {\n\tprivate final static int MAX_PACKAGE_NUM = 100;\n\n\tprivate final Package[] packageQueue;\n\tprivate final Worker[] workerPool;\n\tprivate int head;\n\tprivate int tail;\n\tprivate int count;\n\n\tpublic PackageChannel(int workers) {\n\t\tthis.packageQueue = new Package[MAX_PACKAGE_NUM];\n\t\tthis.head = 0;\n\t\tthis.tail = 0;\n\t\tthis.count = 0;\n\t\tthis.workerPool = new Worker[workers];\n\t\tthis.init();\n\t}\n\n\tprivate void init() {\n\t\tfor (int i = 0; i &lt; workerPool.length; i++) {\n\t\t\tworkerPool[i] = new Worker(&quot;Worker-&quot; + i, this);\n\t\t}\n\t}\n\n\t/**\n\t * push switch to start all of worker to work\n\t */\n\tpublic void startWorker() {\n\t\tArrays.asList(workerPool).forEach(Worker::start);\n\t}\n\n\tpublic synchronized void put(Package packagereq) {\n\t\twhile (count &gt;= packageQueue.length) {\n\t\t\ttry {\n\t\t\t\tthis.wait();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\tthis.packageQueue[tail] = packagereq;\n\t\tthis.tail = (tail + 1) % packageQueue.length;\n\t\tthis.count++;\n\t\tthis.notifyAll();\n\t}\n\n\tpublic synchronized Package take() {\n\t\twhile (count &lt;= 0) {\n\t\t\ttry {\n\t\t\t\tthis.wait();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\tPackage request = this.packageQueue[head];\n\t\tthis.head = (this.head + 1) % this.packageQueue.length;\n\t\tthis.count--;\n\t\tthis.notifyAll();\n\t\treturn request;\n\t}\n\n}\n</code></pre><pre><code>//机器人\npublic class Worker extends Thread{\n\t private static final Random random = new Random(System.currentTimeMillis());\n\t private final PackageChannel channel;\n\n\t    public Worker(String name, PackageChannel channel) {\n\t        super(name);\n\t        this.channel = channel;\n\t    }\n\n\t    @Override\n\t    public void run() {\n\t        while (true) {\n\t            channel.take().execute();\n\n\t            try {\n\t                Thread.sleep(random.nextInt(1000));\n\t            } catch (InterruptedException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t    }\n\n}\n</code></pre><pre><code>public class Test {\n\t   public static void main(String[] args) {\n            //新建8个工人\n\t        final PackageChannel channel = new PackageChannel(8);\n            //开始工作\n\t        channel.startWorker();\n            //为流水线添加包裹\n\t        for(int i=0; i&lt;100; i++) {\n\t        \t Package packagereq = new Package();\n\t \t        packagereq.setAddress(&quot;test&quot;);\n\t \t        packagereq.setName(&quot;test&quot;);\n\t \t        channel.put(packagereq);\n\t        }\n\t    }\n}\n</code></pre><p>我们可以看到，这里有8个工人在不断地分拣仓库中已经包装好的商品。</p><h2>总结</h2><p>平时，如果需要传递或隔离一些线程变量时，我们可以考虑使用上下文设计模式。在数据库读写分离的业务场景中，则经常会用到ThreadLocal实现动态切换数据源操作。但在使用ThreadLocal时，我们需要注意内存泄漏问题，在之前的<a href=\"https://time.geekbang.org/column/article/109201\">第25讲</a>中，我们已经讨论过这个问题了。</p><p>当主线程处理每次请求都非常耗时时，就可能出现阻塞问题，这时候我们可以考虑将主线程业务分工到新的业务线程中，从而提高系统的并行处理能力。而 Thread-Per-Message  设计模式以及  Worker-Thread  设计模式则都是通过多线程分工来提高系统并行处理能力的设计模式。</p><h2>思考题</h2><p>除了以上这些多线程的设计模式，平时你还使用过其它的设计模式来优化多线程业务吗？</p><p>期待在留言区看到你的答案。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。</p><p></p>","neighbors":{"left":{"article_title":"28 | 原型模式与享元模式：提升系统性能的利器","id":109980},"right":{"article_title":"30 | 生产者消费者模式：电商库存设计优化","id":111288}},"comments":[{"had_liked":false,"id":117897,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1564185930,"is_pvip":true,"replies":[{"id":"43175","content":"是的，有些设计模式更多的是优化代码逻辑结构，但还是有很多设计模式也起到了优化性能效果。例如，文中的Worker-Thread 设计模式其实就是一种线程池的优化方式，在并发量大时，一般的代码逻辑要么是串行执行，要么使用创建线程并发执行，在大量并发时两者都可能会出现性能瓶颈，而这种Worker-Thread 这样的设计方式则即可以并发执行，又避免创建过多的线程导致性能瓶颈。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564192889,"ip_address":"","comment_id":117897,"utype":1}],"discussion_count":2,"race_medal":0,"score":"74578629962","product_id":100028001,"comment_content":" 讲真，我是觉得设计模式是优化代码组织结构的，性能提升只是因为你的实现途径导致了你适合用某种设计模式，so感觉这样标题怪怪的。<br><br>如果要这么说的话，mapreduce或者说javase引入的forkjoin，流水线模式，cow就都是了。","like_count":18,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460166,"discussion_content":"是的，有些设计模式更多的是优化代码逻辑结构，但还是有很多设计模式也起到了优化性能效果。例如，文中的Worker-Thread 设计模式其实就是一种线程池的优化方式，在并发量大时，一般的代码逻辑要么是串行执行，要么使用创建线程并发执行，在大量并发时两者都可能会出现性能瓶颈，而这种Worker-Thread 这样的设计方式则即可以并发执行，又避免创建过多的线程导致性能瓶颈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564192889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304053,"discussion_content":"把线程当做比较重的对象，创建这样的对象如何优化，当然是设计模式的范围","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599460140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118444,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1564366043,"is_pvip":false,"replies":[{"id":"43742","content":"很赞","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564542269,"ip_address":"","comment_id":118444,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48809006299","product_id":100028001,"comment_content":"1.最常用的多线程设计模式应该是生产者消费者模式，在分布式系统，该模式现在一般也由Mq来承接。（以rocketMq为例）好处有：消峰，解耦，消息堆积，多broker并行消费，单broker串行（顺序）消费，发布订阅，分组消费，失败重试，死信管理等等。<br>2.其他的业务不常用，比如lmmutability（不变模式，Long类的内部静态类对象池），还有个实时赋值COW，指得一提的应该还有个Actor，但java不支持，要玩又得引第三方包，所以java生产也不会用。<br>3.forkjoin并行处理也是使用的多线程执行子任务，但这个应该算不上多线程设计模式，感觉说是多线程应用更好，其中的任务窃取挺有意思。","like_count":12,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460412,"discussion_content":"很赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564542269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118944,"user_name":"张德","can_delete":false,"product_type":"c1","uid":1101929,"ip_address":"","ucode":"31FE63E8725EFC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","comment_is_top":false,"comment_ctime":1564473027,"is_pvip":false,"replies":[{"id":"51660","content":"我们在之前也讲过reactor模式，reactor模式是基于事件驱动，并且有专门有一个监听线程池监听事件，一旦有事件进来，将会再通过handler线程池来处理具体的业务，实现更为复杂，性能要比thread-per-message更佳","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568897262,"ip_address":"","comment_id":118944,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23039309507","product_id":100028001,"comment_content":"老师好  我还用过reactor模式   这个多线程的thread-per-message感觉和reactor模式有点像  又有一些区别   但我就是总结不出之间的区别   老师能不能点化一下 多谢","like_count":5,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460679,"discussion_content":"我们在之前也讲过reactor模式，reactor模式是基于事件驱动，并且有专门有一个监听线程池监听事件，一旦有事件进来，将会再通过handler线程池来处理具体的业务，实现更为复杂，性能要比thread-per-message更佳","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568897262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101929,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","nickname":"张德","note":"","ucode":"31FE63E8725EFC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3548,"discussion_content":"谢谢老师了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564567374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118005,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1564210730,"is_pvip":false,"replies":[{"id":"43411","content":"对的，分析的很到位。下一讲中我们会详细聊到生产者消费者模式。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564368297,"ip_address":"","comment_id":118005,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14449112618","product_id":100028001,"comment_content":"比起Worker-Thread 设计模式类似工厂车间工人的工作模式，还有用的比较多的是生产者和消费者模式，与之前的不同的是，生产者和消费者模式核心是一个任务队列，生产者生产任务到任务队列中，消费者从队列消费任务，优点是解耦和平衡两者之前的速度差异。","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460220,"discussion_content":"对的，分析的很到位。下一讲中我们会详细聊到生产者消费者模式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564368297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117904,"user_name":"undifined","can_delete":false,"product_type":"c1","uid":1068920,"ip_address":"","ucode":"449CB4CD2DC089","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/78/c3d8ecb0.jpg","comment_is_top":false,"comment_ctime":1564187096,"is_pvip":false,"replies":[{"id":"43174","content":"可以通过Future模式拿到返回结果，虽然是异步执行，如果要等待返回结果，则主线程还是在阻塞等待。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564191609,"ip_address":"","comment_id":117904,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14449088984","product_id":100028001,"comment_content":"老师，有一个问题没想明白，就是异步的请求处理中，每一个线程接收将请求交给处理的线程后，怎么拿到返回结果并返回给用户呢","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460171,"discussion_content":"可以通过Future模式拿到返回结果，虽然是异步执行，如果要等待返回结果，则主线程还是在阻塞等待。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564191609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133262,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1568470075,"is_pvip":false,"replies":[{"id":"51097","content":"是的，多余了","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568531650,"ip_address":"","comment_id":133262,"utype":1}],"discussion_count":1,"race_medal":1,"score":"10158404667","product_id":100028001,"comment_content":"&#47;&#47;InputStreamReader读取原始的字节流,FileReader继承自InputStreamReader<br>                br = new BufferedReader(new InputStreamReader(socket.getInputStream()));<br>                out = new PrintWriter(socket.getOutputStream(), true);<br>                while ((msg = br.readLine()) != null &amp;&amp; msg.length() != 0) {<br>                    System.out.println(&quot;server received:&quot; + msg);<br>                    out.write(&quot;received~\\n&quot;);<br>                    out.flush();<br>                }<br>老师，您在新建PrintWriter实例的时候，已经设置了自动刷新。为什么还要out.flush呢?这一句是多余的吧?<br>","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467322,"discussion_content":"是的，多余了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568531650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118253,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1564302615,"is_pvip":false,"replies":[{"id":"43414","content":"我记得大学时候读过一本《大话设计模式》的书籍不错，讲解的通俗易懂。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564369121,"ip_address":"","comment_id":118253,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10154237207","product_id":100028001,"comment_content":"老师啊！有没有好的书推荐，我觉得设计模式很好，源码应该是学习设计模式最好的老师，可是我的能力看源码感觉太早了。我就之前看过header first。感觉理解完全不够。好的设计模式和算法都能在系统性能有瓶颈的时候提升系统。我认识到它的重要了可是不得门，入不了难受啊。","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460323,"discussion_content":"我记得大学时候读过一本《大话设计模式》的书籍不错，讲解的通俗易懂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564369121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3519,"discussion_content":"昨晚翻了两页感觉还可以，就是觉得自己起步晚了。书上说适合新手，我都工作好几年了惭愧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564550290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","nickname":"行则将至","note":"","ucode":"DB972F2DF059C4","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":11931,"discussion_content":"我大学的时候，有同学说过这本书，可惜我没当回事。一晃都好几年过去了，买吧，赶紧补，还来得及。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568449806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117922,"user_name":"陆离","can_delete":false,"product_type":"c1","uid":1483932,"ip_address":"","ucode":"2C8C206CE36A81","user_header":"https://static001.geekbang.org/account/avatar/00/16/a4/9c/b32ed9e9.jpg","comment_is_top":false,"comment_ctime":1564192185,"is_pvip":false,"replies":[{"id":"51441","content":"1、替换之后，“是否偏向锁”标志位设置为 1；<br>2、如果获取锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁；<br>3、是的；<br>4、标志位为00；<br>5、如果是锁释放轻量级锁，直接将指向轻量级锁的指针置为null就可以了；<br>6、这个是轻量级升级为重量级就会带过来的，暂时没有观察到具体的作用","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568771365,"ip_address":"","comment_id":117922,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10154126777","product_id":100028001,"comment_content":"老师，讲到并发这里，我想问一个前面讲过的synchronized锁升级的几个问题。<br>1.当锁由无锁状态升级到偏向锁时，除了将Mark Work中的线程ID替换是否还有其他操作？替换完线程ID就代表获取到了锁吗？<br>2.当锁状态为偏向锁状态时, 其他线程竞争锁只是CAS替换线程ID吗？如果之前的线程还没有执行完呢？<br>3.针对第2个问题，假设线程T1获取到了偏向锁，将线程ID设为T1。线程T2尝试获取偏向锁时，先检测锁的Mark Word线程ID是否为T2,如果不是，会CAS替换，这个时候的期望值为null,更新值为T2，失败后进入偏向锁撤销。stop-the-world后检测T1是否存活，如果否清空Mark work线程ID，锁恢复为无锁状态，唤醒T2,接着尝试获取锁。流程是这样的吗？<br>4.当锁升级为轻量级锁时，获取锁的标志是锁指针指向线程的锁记录，当有其他线程尝试CAS获取锁时，期望值是无锁时，Mark word中为hash age 01这样的内容吗？<br>5.当线程释放轻量锁时，需要将锁记录替换回Mark Word中，这种情况下锁还未释放为什么会有失败？<br>6.当锁升级为重量锁后，开始使用monitor对象，为什么Mark Word中还会把内容替换为指向线程锁记录的指针？这个时候还需要使用Mark word吗？<br>期待老师及同学的解答","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460181,"discussion_content":"1、替换之后，“是否偏向锁”标志位设置为 1；\n2、如果获取锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁；\n3、是的；\n4、标志位为00；\n5、如果是锁释放轻量级锁，直接将指向轻量级锁的指针置为null就可以了；\n6、这个是轻量级升级为重量级就会带过来的，暂时没有观察到具体的作用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568771365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3203,"discussion_content":"第五个问题原文是这么描述的:如果替换失败，说明有其他线程尝试过获取该锁，那就在释放锁的同时，唤醒被挂起的线程。我的理解是，锁偏斜的线程在运行是，发生了一次锁升级，升级成了轻量级锁，然后偏向线程释放锁的时候发现升级了(不在什么专有)，知道有别的线程在等待锁。他就会唤醒那个等待的线程。个人理解可能有错，最好自己看书确认下，要是理解错了欢迎指正谢谢。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564302324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3202,"discussion_content":"你好!可以看下深入理解Java虚拟机的最后两页。有讲这个。\n偏向锁大概就是比较Mark Word。的线程id和当前线程id是否一样一样直接运行了。不一样锁升级，升级成轻量级锁。偏斜锁就是这个锁只有一个人能用，转属于的，每次就校验下id对不对。万一不对了就升级了。升级的时候会分两种情况，一种就是这个锁偏向的线程正好持有锁，另一种情况就是，偏斜的线程没有持有锁，具体怎么做的给忘了。轻量级锁是通过CAS实现(乐观锁)，不会设计到用户态和内核态的切换所以开销比较小。如果发生竞争了就会升级成重量锁(悲观锁)了。竞争激烈的时候需要用悲观锁，乐观锁在低竞争的事后好可以剩下，用户态和内核态切换的开销。可是竞争大的时候，乐观锁一般通过重试来保证原子性，重试也会有开销。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564301922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117918,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1564191608,"is_pvip":false,"replies":[{"id":"43413","content":"赞，现学现用","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564368892,"ip_address":"","comment_id":117918,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10154126200","product_id":100028001,"comment_content":"一个注册逻辑，下面有注册实现数组，注册实现里面有队列，并且本身实现runable ，注册门面依次从注册实现数组获取一个注册实现 并把请求放到注册实现的队列中，请求由一个注册实现来完成，请求由唯一的注册实现来完成，不会有并发问题  而且如果 注册实现有复杂业务 还可以加上  work thread模式来优化","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460179,"discussion_content":"赞，现学现用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564368892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139773,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1570721119,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5865688415","product_id":100028001,"comment_content":"除了文中第一个设计模式，其他设计模式在《图解Java多线程设计模式》中都有更详细的介绍。感谢老师的分享，如果能在专栏的第一篇文章中推荐一些相关的书籍就更好了。","like_count":1},{"had_liked":false,"id":133273,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1568472889,"is_pvip":false,"replies":[{"id":"51096","content":"这个性能我猜是说的相对的，只是说System.currentTimeMillis() 性能损耗更大","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568531421,"ip_address":"","comment_id":133273,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5863440185","product_id":100028001,"comment_content":"老师，前几天看了一篇帖子，上面说System.currentMills在高并下下也会有性能问题。我看您直接用的，并没有做优化。您在实际工作中，有没有碰见过System.currentMills影响性能的例子呢？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467330,"discussion_content":"这个性能我猜是说的相对的，只是说System.currentTimeMillis() 性能损耗更大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568531421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118415,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1564362414,"is_pvip":false,"replies":[{"id":"43695","content":"对的，例如读写分离，ThreadLocal存放了读从库数据源和写主库数据源，如果是查询操作，则切换为读数据源，如果是新增修改删除操作，则切换为写数据源。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564536183,"ip_address":"","comment_id":118415,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5859329710","product_id":100028001,"comment_content":"老师好，文中提到，通过threadlocal动态切换数据源是什么意思？指的是用一个threadlocal的map管理多数据源的连接，每次都从map去拿不同datasource的连接吗？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460399,"discussion_content":"对的，例如读写分离，ThreadLocal存放了读从库数据源和写主库数据源，如果是查询操作，则切换为读数据源，如果是新增修改删除操作，则切换为写数据源。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564536183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1138821,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg","nickname":"与路同飞","note":"","ucode":"2985F1440A1962","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308125,"discussion_content":"读写分离","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600850809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1138821,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg","nickname":"与路同飞","note":"","ucode":"2985F1440A1962","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308124,"discussion_content":"这种读写分类一般是数据库代理就做了，这样这么防止写后读的数据主从延迟呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600850794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118180,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1564283452,"is_pvip":false,"replies":[{"id":"43386","content":"我们对put take方法已经加锁了，所以是线程安全的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564364976,"ip_address":"","comment_id":118180,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5859250748","product_id":100028001,"comment_content":"请问老师packageChannel中的成员变量count不会存在线程安全问题吗","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460289,"discussion_content":"我们对put take方法已经加锁了，所以是线程安全的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302424,"user_name":"Sherk","can_delete":false,"product_type":"c1","uid":2156245,"ip_address":"","ucode":"AFE3E7F158258D","user_header":"https://static001.geekbang.org/account/avatar/00/20/e6/d5/4f1fc074.jpg","comment_is_top":false,"comment_ctime":1626223128,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626223128","product_id":100028001,"comment_content":"老师我有一个疑惑，ThreadLocal不是线程独享的么，线程是拿不到其他线程设置的applicationContext。所以这边applicationContext还是一个共享的上下文信息吗","like_count":0},{"had_liked":false,"id":301893,"user_name":"平民人之助","can_delete":false,"product_type":"c1","uid":2658705,"ip_address":"","ucode":"5CCEC0BAC08AEC","user_header":"https://static001.geekbang.org/account/avatar/00/28/91/91/428a27a3.jpg","comment_is_top":false,"comment_ctime":1625963932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625963932","product_id":100028001,"comment_content":"搞设计模式也要比较容易调试和排查问题","like_count":0},{"had_liked":false,"id":268746,"user_name":"姜大大","can_delete":false,"product_type":"c1","uid":1480811,"ip_address":"","ucode":"C2C7FAD30D89BF","user_header":"https://static001.geekbang.org/account/avatar/00/16/98/6b/5b9f6a3c.jpg","comment_is_top":false,"comment_ctime":1608339032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608339032","product_id":100028001,"comment_content":"老师，关于ThreadLocal我有个问题，在entry数组中， ThreadLocal作为key是弱引用，那垃圾回收随时就会把它回收了，那这样没有key就获取不到value,是不是说使用 ThreadLocal不能一定保证能获取到数据啊。帮忙解答一下","like_count":0},{"had_liked":false,"id":268080,"user_name":"不工","can_delete":false,"product_type":"c1","uid":1462843,"ip_address":"","ucode":"A8725E6D0E1765","user_header":"https://static001.geekbang.org/account/avatar/00/16/52/3b/f1501d79.jpg","comment_is_top":false,"comment_ctime":1608045686,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608045686","product_id":100028001,"comment_content":"&#47;&#47; 获取ActionContext单例 <br>public static class ContextHolder {<br> private final static ActionContext actionContext = new ActionContext(); <br>}<br>为什么不在ActionContext的get方法里直接获取，要兜一圈从静态类中获取？","like_count":0},{"had_liked":false,"id":237354,"user_name":"Gavin","can_delete":false,"product_type":"c1","uid":1616970,"ip_address":"","ucode":"A5735665E303FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2UXuSevhia94o9Eky4OfMuSictaldxcqpjGuvRCOcvjIIoVBAENLEZbv2lgwmwC8icK1ZrUcneNtiaeFBV8MT3uzNg/132","comment_is_top":false,"comment_ctime":1595806839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595806839","product_id":100028001,"comment_content":"老师，请问下使用ThreadLocal是不是有这样一个问题，线程开始是设置一个变量，key是弱引用，中间由于GC回收了key，会导致最后获取不到一开始设置的值。","like_count":0},{"had_liked":false,"id":175082,"user_name":"停三秒","can_delete":false,"product_type":"c1","uid":1442497,"ip_address":"","ucode":"C9D8F39F24672E","user_header":"https://static001.geekbang.org/account/avatar/00/16/02/c1/80e68043.jpg","comment_is_top":false,"comment_ctime":1580549146,"is_pvip":false,"replies":[{"id":"69015","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1581506983,"ip_address":"","comment_id":175082,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1580549146","product_id":100028001,"comment_content":"老师，其实我觉得worker-thread设计模式就是生产者消费者模式。执行流水线的take的Worker就是消费者，执行put的一方就是生产者。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482619,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581506983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161543,"user_name":"Mr wind","can_delete":false,"product_type":"c1","uid":1217874,"ip_address":"","ucode":"484F02D1962239","user_header":"https://static001.geekbang.org/account/avatar/00/12/95/52/ad190682.jpg","comment_is_top":false,"comment_ctime":1576226772,"is_pvip":false,"replies":[{"id":"61974","content":"是的，原理都是生产者消费者模式。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1576669105,"ip_address":"","comment_id":161543,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576226772","product_id":100028001,"comment_content":"还是不明白Worker-Thread 设计模式相比普通线程池的优点是什么呢，两者都可以创建固定的线程，都会在满载时等待。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477754,"discussion_content":"是的，原理都是生产者消费者模式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576669105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132923,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568275450,"is_pvip":false,"replies":[{"id":"50990","content":"异步是有场景条件的，例如，异步调用用户不需要感知结果，或者用户的客户端与服务端是一个tcp长连接，处理之后由服务端推送处理结果给用户。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568424041,"ip_address":"","comment_id":132923,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1568275450","product_id":100028001,"comment_content":"我们的项目中有用上下文模式，为了记录业务中间的关键操作步骤，不过比较挫是传输参数的方式，下次可以改版为使用ThreadLocal形式的。<br>看到有同学问异步的问题，我也有这样的疑问，我想异步调用为了更好的性能，但是我也想要调用后的结果。<br>问题如下：<br>1：这种异步是真异步嘛？<br>2：这种异步最终还是必须阻塞等待获取响应结果的，性能提升有多大空间呢？看主线程继续处理某些事情的速度快，还是异步任务线程的执行速度快？如果异步执行的响应速度更快，那他需要等待主线程执行完再给他结果？还是会中断主线程将结果给他？<br>3：最关键是异步的结果怎么拿到，这是什么原理？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467179,"discussion_content":"异步是有场景条件的，例如，异步调用用户不需要感知结果，或者用户的客户端与服务端是一个tcp长连接，处理之后由服务端推送处理结果给用户。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568424041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304064,"discussion_content":"主线程不阻塞是为了高效响应新的连接，主线程直接处理，如果阻塞的话服务就变得不可用；而且，worker线程已经拿到socket了，不必再回到主线程，可以直接响应客服端","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599461327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121961,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1565258052,"is_pvip":false,"replies":[{"id":"44862","content":"实现的基本原理是一样的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565313389,"ip_address":"","comment_id":121961,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565258052","product_id":100028001,"comment_content":"请问老师，worker thread模式和线程池是不是一样的","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462028,"discussion_content":"实现的基本原理是一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565313389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118248,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1564301342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564301342","product_id":100028001,"comment_content":"老师好!Thread-Per-Message 设计模式就是分离阻塞和非阻塞的呗。阻塞的部分通过多路复用。非阻塞的的那部分就丢线程池并发处理。","like_count":0}]}