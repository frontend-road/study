{"id":509508,"title":"实战一｜嵌入式开发：如何使用C语言开发智能电灯？","content":"<p>你好，我是郭朝斌。</p><p>作为RISC-V开发板动手实践的第一讲，我们从智能灯的嵌入式开发开始吧。</p><p>智能灯硬件最重要的功能是控制LED灯的颜色和开关，这就涉及到PWM信号的生成和继电器的控制。之前我们是使用Python语言在NodeMCU开发板上实现的。那么，这些功能如何在RISC-V芯片上，使用C语言实现呢？</p><p>别着急，我来一步一步地讲解一下。</p><h2>开发板介绍</h2><p><a href=\"https://time.geekbang.org/column/article/506337\">上一讲</a>已经提到，我们使用的开发板是平头哥（T-Head）公司设计开发的RVB2601 开发板。主控芯片代号是CH2601，它基于平头哥开源的玄铁E906处理器内核IP设计开发，具体的指令集架构是RV32IMACX。</p><p>根据上节学到的RISC-V指令集知识，你可以知道这代表它采用 RISC-V 32bit 基本整数指令子集，并且包含整数乘法与除法指令子集，不可中断指令（也称作存储器原子操作指令）子集，压缩指令子集，这些标准扩展指令集。</p><p>其中，压缩指令子集对于嵌入式芯片非常重要，它可用于提高代码密度，节省存储成本。最后的代号\"X\"表示玄铁E906自定义的一些扩展指令集，这也是RISC-V指令集架构可扩展性的体现。</p><p>说了这么多，我们来看一下RVB2601开发板的实物图。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/d2/54/d29e903c981408b36f8785da9a3acf54.jpg?wh=1144x605\" alt=\"\"></p><p>作为一款嵌入式系统开发板，RVB2601在用户交互体验上下了一番功夫，提供了一块OLED屏幕，两个MIC输入，一个扬声器，一个三色LED灯，还有两个实体按键。基于这些器件，你可以直接动手实验很多有趣的应用。</p><p>更重要的是，这些外围器件都是通过跳线帽与主控芯片CH2601的I/O接口相连的，这就是说我们可以把跳线帽去掉，将我们自己的传感器、继电器等器件与芯片的I/O接口连接，开发我们的特定的应用。</p><p>当然，在这之前，我们需要先了解一下 RVB2601 开发板的I/O接口分布及功能。我绘制了一张I/O接口功能图，供你参考。<a href=\"https://occ.t-head.cn/vendor/detail/index?id=3886757103532519424&key=download&module=4&vendorId=3706716635429273600\">官方文档</a>中也有相关的描述，你也可以参考，但是介绍比较分散，你可能经常需要查看文档的多个位置来确认一个接口的功能。</p><p><img src=\"https://static001.geekbang.org/resource/image/78/d8/788e31d927eea0a781d496c0d760ccd8.png?wh=1080x1440\" alt=\"\"></p><h2>开发环境初体验</h2><p>了解完硬件的基本情况，我们来看一下软件的开发工具和流程。</p><h3>第一步 安装集成开发环境</h3><p>平头哥提供了一个集成开发环境，名称是剑池CDK。在这个软件开发环境里，图形化的操作界面更利于我们使用。</p><p>不过，CDK只支持 Windows操作系统，如果你使用Mac电脑的话，可以像我一样使用 <a href=\"https://www.virtualbox.org/wiki/Downloads\">VirtualBox</a> 虚拟机软件，在Mac电脑上运行一个Windows虚拟机。VirtualBox是完全免费的，当然其他商用的虚拟机软件也可以使用。</p><h3>第二步 程序开发</h3><p>安装好IDE（集成开发环境）后，我们来创建一个工程项目。为了简便、快速地帮你理解，我们直接基于 IDE 提供的模版工程创建一个示例程序。</p><p>在IDE的欢迎页面中，点击右上角的“新建工程”<br>\n<img src=\"https://static001.geekbang.org/resource/image/4d/fd/4d83e3a12d9604750b8a582c69e003fd.png?wh=2458x110\" alt=\"\"></p><p>接着，你可以在新页面中找到顶部的搜索框，然后输入\"ch2601\"。</p><p>如果IDE没有显示欢迎页面，你可以点击工具栏右侧的平头哥Logo图标，重新打开欢迎页面。</p><p><img src=\"https://static001.geekbang.org/resource/image/08/0f/08yy844c38f63afed903289305cff40f.png?wh=376x83\" alt=\"\"></p><p>点击搜索，你可以看到所有关于芯片CH2601的工程项目。</p><p><img src=\"https://static001.geekbang.org/resource/image/81/df/81b4629c289e6c785d98d207f685a5df.png?wh=2478x1122\" alt=\"\"></p><p>我们选择与智能灯最接近的跑马灯项目作为模板。点击“ch2601_marquee_demo”条目右侧的“创建工程”。在弹出的“新建工程”窗口中，输入一个工程名称，比如“Led”，然后点击“确认”。</p><p><img src=\"https://static001.geekbang.org/resource/image/30/06/30bdbc036c5ef4bc05f871c330d1be06.png?wh=444x324\" alt=\"\"></p><p>在IDE左侧，我们可以看到新建工程“Led”的工程结构：</p><ul>\n<li>“app”目录中的文件是工程的应用代码。</li>\n<li>“.gdbinit”文件是GDB调试程序的初始化参数。</li>\n<li>“SConstruct”文件是<a href=\"https://scons.org\">Scons</a>软件构建工具的配置文件。</li>\n<li>“sdk_chip_ch2601”节点中是YOC平台相关的基础库。</li>\n</ul><h3>第三步 编译</h3><p>现在我们新建的Led工程中是跑马灯应用的完整代码。我们先不做任何修改，直接编译、运行一下。你可以点击工具栏中的编译图标，启动工程编译。</p><p><img src=\"https://static001.geekbang.org/resource/image/93/76/93b5284be8646c42b6c93419fac6a376.png?wh=235x85\" alt=\"\"></p><p>或者从“Project”菜单中选择“Build Active Project”。</p><p><img src=\"https://static001.geekbang.org/resource/image/ae/e8/aeda012d7f0c46d5ac66444e2f66f7e8.png?wh=486x486\" alt=\"\"></p><p>从这里我们也可以看出C语言和Python语言的不同，<strong>C语言开发的代码在运行之前必须先进行编译，生成机器指令，而在这个过程中，编译器可以提前发现语法错误等。</strong></p><h3>第四步 烧录</h3><p>接着，我们需要将编译生成的固件文件烧录到开发板中。RVB开发板是通过JTAG接口来完成固件烧录的。你需要使用USB连接线把电脑与开发板的JTAG接口相连，然后点击工具栏中的烧录图标。</p><p><img src=\"https://static001.geekbang.org/resource/image/99/55/9989201a40eb9db047bea7803080e155.png?wh=372x136\" alt=\"\"></p><h3>第五步 运行</h3><p>烧录完成后，你需要按一下开发板上的RST按键，重置RVB2601开发板。这时就可以看到开发板上的LED灯开始三种颜色交替点亮、熄灭。</p><p>这里提醒一下，如果LED灯的闪烁不正确，你需要查看一下开发板上PA7、PA25和PA4的跳线帽安装位置是否正确。我收到的开发板上，PA7一开始没有安装跳线帽，就导致了LED灯的红色状态不工作。</p><h2>智能灯的开发</h2><p>接下来，我们开始智能灯的开发。</p><p>LED模块和继电器仍然使用我们之前实验中使用的器件。如果你是第一次接触这个实验，或者之前的器件已经不知道跑到哪里去了，也可以参考<a href=\"https://shimo.im/sheets/D3VVPdwcYRhhQRXh/MODOC\">这份文档</a>自行采购相关硬件。</p><p>至于电路连接图，你可以参考下图。</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/1f/4d9d6cb1004d2b262efae194901ae11f.png?wh=1920x1080\" alt=\"\"></p><p>这里需要注意的是，最初，开发板上的J1扩展接口的15和16位、J3扩展接口的3和4位、J3扩展接口的5和6位、J3扩展接口的7和8位，还有J4扩展接口的15和16位是安装着跳线帽的，你在接线时需要把这些跳线帽去掉。</p><h3>PWM信号生成</h3><p>在本实验中，LED模块的发光原理依然是PWM，忘记的同学可以回去<a href=\"https://time.geekbang.org/column/article/322528\">第17节</a>复习一下。LED灯的代码如下，供你参考。</p><pre><code class=\"language-c++\">\n/*********************\n&nbsp;*&nbsp; &nbsp; &nbsp; INCLUDES\n&nbsp;*********************/\n#define _DEFAULT_SOURCE /* needed for usleep() */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;time.h&gt;\n#include &lt;aos/aos.h&gt;\n#include \"app_config.h\"\n#include \"app_init.h\"\n#include \"csi_config.h\"\n#include \"hw_config.h\"\n\n#include \"board_config.h\"\n#include \"drv/gpio_pin.h\"\n#include &lt;drv/pin.h&gt;\n#include &lt;drv/pwm.h&gt;\n\n#ifdef CONFIG_PWM_MODE\n\nstatic uint32_t g_ctr = 0;\nstatic csi_pwm_t&nbsp; r;\n\nvoid led_pinmux_init()\n{\n&nbsp; &nbsp; &nbsp; &nbsp; //7\n&nbsp; &nbsp; csi_error_t ret;\n&nbsp; &nbsp; csi_pin_set_mux(PA7, PA7_PWM_CH7);\n&nbsp; &nbsp; csi_pin_set_mux(PA25, PA25_PWM_CH2);\n&nbsp; &nbsp; csi_pin_set_mux(PA4, PA4_PWM_CH4);\n\n&nbsp; &nbsp; ret = csi_pwm_init(&amp;r, 0);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n}\n\nvoid rgb_light(uint32_t red, uint32_t green, uint32_t blue)\n{\n\tcsi_error_t ret;\n\tret = csi_pwm_out_config(&amp;r, 7 / 2, 300, red*300/255, PWM_POLARITY_HIGH);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; ret = csi_pwm_out_start(&amp;r, 7 / 2);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; //25\n&nbsp; &nbsp; ret = csi_pwm_out_config(&amp;r, 2 / 2, 300, green*300/255, PWM_POLARITY_HIGH);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; ret = csi_pwm_out_start(&amp;r, 2 / 2);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; //4\n&nbsp; &nbsp; ret = csi_pwm_out_config(&amp;r, 4 / 2, 300, blue*300/255, PWM_POLARITY_HIGH);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; ret = csi_pwm_out_start(&amp;r, 4 / 2);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n}\n#endif&nbsp;\n\n#ifdef CONFIG_GPIO_MODE\nstatic uint32_t g_ctr = 0;\nstatic csi_gpio_pin_t r;\nstatic csi_gpio_pin_t g;\nstatic csi_gpio_pin_t b;\nvoid led_pinmux_init()\n{\n&nbsp; &nbsp; csi_pin_set_mux(PA7, PIN_FUNC_GPIO);\n&nbsp; &nbsp; csi_pin_set_mux(PA25, PIN_FUNC_GPIO);\n&nbsp; &nbsp; csi_pin_set_mux(PA4, PIN_FUNC_GPIO);\n&nbsp; &nbsp; csi_gpio_pin_init(&amp;r, PA7);\n&nbsp; &nbsp; csi_gpio_pin_dir(&amp;r, GPIO_DIRECTION_OUTPUT);\n\tcsi_gpio_pin_mode(&amp;r, GPIO_MODE_PUSH_PULL);\n&nbsp; &nbsp; csi_gpio_pin_init(&amp;g, PA25);\n&nbsp; &nbsp; csi_gpio_pin_dir(&amp;g, GPIO_DIRECTION_OUTPUT);\n\tcsi_gpio_pin_mode(&amp;g, GPIO_MODE_PUSH_PULL);\n&nbsp; &nbsp; csi_gpio_pin_init(&amp;b, PA4);\n&nbsp; &nbsp; csi_gpio_pin_dir(&amp;b, GPIO_DIRECTION_OUTPUT);\n\tcsi_gpio_pin_mode(&amp;b, GPIO_MODE_PUSH_PULL);\n&nbsp; &nbsp; g_ctr = 0;\n}\n\n//fake rgb, because of only high or low state of gpio\nvoid rgb_light(uint32_t red, uint32_t green, uint32_t blue)\n{\n\t(red &lt; 50)?csi_gpio_pin_write(&amp;r, GPIO_PIN_LOW):csi_gpio_pin_write(&amp;r, GPIO_PIN_HIGH);\n\t(green &lt; 50)?csi_gpio_pin_write(&amp;r, GPIO_PIN_LOW):csi_gpio_pin_write(&amp;g, GPIO_PIN_HIGH);\n\t(blue &lt; 50)?csi_gpio_pin_write(&amp;r, GPIO_PIN_LOW):csi_gpio_pin_write(&amp;b, GPIO_PIN_HIGH);\n}\n#endif\n</code></pre><p>在代码中，我们主要使用了 CSI 接口规范中的相关接口函数，你可以参考<a href=\"https://yoc.docs.t-head.cn/yocbook/Chapter3-AliOS/CSI%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%8E%A5%E5%8F%A3/CSI2/PWM.html\">接口规范文档</a>进一步了解具体细节。</p><p>比对规范文档，你可能会有一个疑问：接口PA7、PA25和PA4对应的PWM输出接口编号分别是CH7、CH2和CH4，为什么接口函数csi_pwm_out_config和csi_pwm_out_start的channel（通道号）入参中填写的是编号除以2的得数取整，而不是编号本身呢？</p><p>这涉及到CH2601芯片对于PWM的内部具体设计。</p><p>CH2601芯片内部有6个PWM发生器，对应着编号0～5的通道。每个PWM发生器对应2个输出接口，这两个接口的PWM信号波形是完全一致的。通道编号与输出接口的具体关系如下表。</p><p><img src=\"https://static001.geekbang.org/resource/image/f8/de/f87bfc6865170163f964c9740937c2de.jpg?wh=1280x534\" alt=\"\"></p><p>从表格中，你可以直观地看到PWM输出接口编号数字需要除以2，并取整，才可以得到PWM的通道编号。这就是上面代码处理方式的来源。</p><p>另外，在上面表格中，我还列出了PWM通道对应的GPIO接口。这是为了方便你在以后的应用中选择合适的PWM接口。比如，在本实验的智能灯应用中，我们需要三个独立的PWM通道来控制LED模块的R、G、B接口，那么我们就不能选择表格里面同一格的多个GPIO接口。显然，我们选择的PA7、PA25和PA4是满足这个原则的。</p><p>同时，我也使用GPIO的高低电平模式实现了LED模块的控制逻辑，便于你对比两种方式的异同。</p><h3>继电器的控制</h3><p>接下来我们看继电器控制的部分是怎么实现的。继电器的驱动同样是通过GPIO口，通过输出高低电平，实现它的通断控制。代码如下。</p><pre><code class=\"language-c++\">/*********************\n&nbsp;*&nbsp; &nbsp; &nbsp; INCLUDES\n&nbsp;*********************/\n#define _DEFAULT_SOURCE /* needed for usleep() */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;time.h&gt;\n#include &lt;aos/aos.h&gt;\n#include \"app_config.h\"\n#include \"app_init.h\"\n#include \"csi_config.h\"\n#include \"hw_config.h\"\n\n#include \"board_config.h\"\n#include \"drv/gpio_pin.h\"\n#include &lt;drv/pin.h&gt;\n\nstatic csi_gpio_pin_t relay;\n\nvoid relay_pinmux_init()&nbsp;\n{\n\tcsi_error_t ret;\n\tcsi_pin_set_mux(PA26, PIN_FUNC_GPIO);\n\tcsi_gpio_pin_init(&amp;relay, PA26);\n&nbsp; &nbsp; csi_gpio_pin_dir(&amp;relay, GPIO_DIRECTION_OUTPUT);\n}\n\nvoid relay_toggle(bool on)\n{\n\tif(on)\n\t{\n\t\tcsi_gpio_pin_write(&amp;relay, GPIO_PIN_HIGH);\n\t}&nbsp;\n\telse&nbsp;\n\t{\n\t\tcsi_gpio_pin_write(&amp;relay, GPIO_PIN_LOW);\n\t}\n}\n</code></pre><h3>主逻辑编写</h3><p>最后是程序的主逻辑。我们需要先初始化LED模块和继电器使用的I/O接口，然后调用LED代码的接口，点亮LED灯。在主循环中，我们周期性地打开、关闭继电器，实现LED灯闪烁的效果。</p><p><span class=\"reference\">注：其中lv和oled开头的函数，是显示屏相关的代码。你暂时不需要关心它们，我会在后面的实验中详细讲解。</span></p><pre><code class=\"language-c++\">\n/*********************\n&nbsp;*&nbsp; &nbsp; &nbsp; INCLUDES\n&nbsp;*********************/\n#define _DEFAULT_SOURCE /* needed for usleep() */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;time.h&gt;\n#include &lt;aos/aos.h&gt;\n#include \"aos/cli.h\"\n\n#include \"app_config.h\"\n#include \"app_init.h\"\n#include \"csi_config.h\"\n#include \"hw_config.h\"\n#include \"lvgl.h\"\n#include \"lv_label.h\"\n#include \"oled.h\"\n\n#include \"board_config.h\"\n#include \"drv/gpio_pin.h\"\n#include &lt;drv/pin.h&gt;\n#include &lt;drv/pwm.h&gt;\n\n/*********************\n&nbsp;*&nbsp; &nbsp; &nbsp; DEFINES\n&nbsp;*********************/\n#define TAG \"app\"\n\n/**********************\n&nbsp;*&nbsp; &nbsp; &nbsp; TYPEDEFS\n&nbsp;**********************/\n\n/**********************\n&nbsp;*&nbsp; STATIC PROTOTYPES\n&nbsp;**********************/\nstatic void led_task(void *arg);\n\n/**********************\n&nbsp;*&nbsp; STATIC VARIABLES\n&nbsp;**********************/\n\n/**********************\n&nbsp;*&nbsp; &nbsp; &nbsp; MACROS\n&nbsp;**********************/\n\n/**********************\n&nbsp;*&nbsp; &nbsp;GLOBAL FUNCTIONS\n&nbsp;**********************/\n\nvolatile uint32_t g_debug = 0;\nvolatile uint32_t g_debug_v = 0;\n\n#include \"csi_core.h\"\n/**\n&nbsp;* main\n&nbsp;*/\nint main(void)\n{\n&nbsp; &nbsp; board_yoc_init();\n\n&nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; aos_task_new(\"demo\", led_task, NULL, 10 * 1024);\n&nbsp; &nbsp; return 0;\n}\n\nstatic void lable_test(void)\n{\n&nbsp; &nbsp; lv_obj_t *p = lv_label_create(lv_scr_act(), NULL);\n&nbsp; &nbsp; lv_label_set_long_mode(p, LV_LABEL_LONG_BREAK);\n&nbsp; &nbsp; lv_label_set_align(p, LV_LABEL_ALIGN_CENTER);\n&nbsp; &nbsp; lv_obj_set_pos(p, 0, 4);\n&nbsp; &nbsp; lv_obj_set_size(p, 128, 60);\n&nbsp; &nbsp; lv_label_set_text(p, \"THEAD\\nMARQUEE\\nDEMO\");\n}\n\nstatic void led_task(void *arg)\n{\n&nbsp; &nbsp; lv_init();\n&nbsp; &nbsp; oled_init();\n&nbsp; &nbsp; lable_test();\n&nbsp; &nbsp; led_pinmux_init();\n\trelay_pinmux_init();\n\trgb_light(255,255,0);\n\n&nbsp; &nbsp; while (1)\n&nbsp; &nbsp; {\n\t\trelay_toggle(true);\n&nbsp; &nbsp; &nbsp; &nbsp; lv_task_handler();\n&nbsp; &nbsp; &nbsp; &nbsp; udelay(1000 * 1000);\n&nbsp; &nbsp; &nbsp; &nbsp; lv_tick_inc(1);\n&nbsp; &nbsp; &nbsp; &nbsp; relay_toggle(false);\n\t\tudelay(1000 * 1000);\n&nbsp; &nbsp; }\n}\n\n</code></pre><h2>云上实验室</h2><p>如果你暂时没有RVB2601开发板，是不是就只能干看了呢？我发现有一个备选方案可以让你体验一下RVB2601开发板，甚至其他型号的RISC-V芯片的开发板：你可以访问平头哥开发者社区提供的<a href=\"https://occ.t-head.cn/community/cloudlab/home\">“云上实验室”</a>服务。</p><p>具体怎么做呢？</p><p>首先，在云上实验室页面的筛选条件区域中，直接选择“开发板型号”为 RVB2601，如图所示，你可以看到可供申请的所有开发板。然后点击“申请评估”，可以看到这个开发板可供选择的空闲日期。你可以根据自己的需求，选择一个合适的时间区间进行申请。</p><p><img src=\"https://static001.geekbang.org/resource/image/95/33/9575a76093f380d38620b290dd878233.png?wh=2448x1246\" alt=\"\"></p><p>当申请通过后，你会收到一条短信提醒。这时，打开云上实验室页面中“我的设备”标签，就可以看到可以使用的开发板了。</p><p><img src=\"https://static001.geekbang.org/resource/image/f0/fb/f0199d684b8a89e371472df0c2a9f6fb.png?wh=834x636\" alt=\"\"></p><p>点击“进入云评估”，你会进入评估控制台，页面中有详细的使用介绍。</p><p>除了体验平台提供的几个demo程序，我们也可以尝试修改一下代码来运行。比如在ch2601_gui_demo 的程序，尝试修改一下屏幕显示的文字。命令可参考图片。</p><p><img src=\"https://static001.geekbang.org/resource/image/41/a2/41f6294796420f35aee97455f4f354a2.png?wh=1614x96\" alt=\"\"></p><p>我改为了下图的内容：</p><p><img src=\"https://static001.geekbang.org/resource/image/ea/96/ea1523b3e3319d6f64d3b4224b0b3f96.png?wh=1376x1084\" alt=\"\"></p><p>然后，在 Host Terminal 命令行输入 make all 编译固件。</p><p><img src=\"https://static001.geekbang.org/resource/image/6f/d3/6fd2c9188f1842yy5b1d1637d76dbcd3.png?wh=1620x56\" alt=\"\"></p><p>接着，输入 make flashall 烧录固件文件到开发板中。</p><p><img src=\"https://static001.geekbang.org/resource/image/c7/a2/c7ed4ea4e8e470d1ac8d84016e70b6a2.png?wh=1690x54\" alt=\"\"></p><p>最终的运行情况，我们可以通过摄像头来查看。</p><p><img src=\"https://static001.geekbang.org/resource/image/c3/c5/c34a27b31d1277fbbbc0d2b55f2e38c5.png?wh=1006x792\" alt=\"\"></p><h2>小结</h2><p>到这里，我们已经熟悉了RVB2601开发板的开发环境，并且完成了智能灯的硬件搭建和嵌入式软件开发。</p><p>你可以看到，当面对一个新的芯片和新的开发板时，我们需要根据GPIO接口的功能来选择合适的接口，比如选择具备PWM功能的接口连接LED模块的R、G、B通道。</p><p>针对RVB2601开发板，PWM输出接口的选择还需要注意一个点——通道（Channel）的选择。CH0/CH1、CH2/CH3、CH4/CH5、CH6/CH7、CH8/CH9和CH10/CH11分别对应编号0～5的6个PWM通道。</p><p>另外，因为现在的实验使用C语言，嵌入式系统应用的开发步骤与之前使用Python语言是不同的，包括下图所示的步骤。</p><p><img src=\"https://static001.geekbang.org/resource/image/50/01/50a9822f97e0ec7a92078bd27yy5f501.png?wh=2046x286\" alt=\"\"></p><p>如果你暂时没有开发板，可以申请体验一下云上实验室。除了可以像我上面提到的那样修改代码来运行，我还推荐你来动手实践一下Linux环境下的开发工具<a href=\"https://yoc.docs.t-head.cn/yocbook/Chapter2-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%BC%95/YocTools.html\">YocTools</a>的使用方法。</p><h2>思考题</h2><p>最后，我想提出一个挑战，当你完成本节的实验后，是否可以为开发板上自带的用户按键开发代码，实现按键控制继电器通断的功能呢？</p><p>欢迎你在评论区分享自己的挑战成果。基于你完成的智能灯，下一节中，我将介绍一下连接物联网平台，并实现联网控制的方法。同时，也欢迎你把今天的内容分享给你的朋友，一起来“极客”一把。</p>","neighbors":{"left":{"article_title":"引子｜RISC-V：物联网领域值得关注的芯片趋势是什么？","id":506337},"right":{"article_title":"实战二｜MQTT开发：如何实现联网控制？","id":511795}},"comments":[]}