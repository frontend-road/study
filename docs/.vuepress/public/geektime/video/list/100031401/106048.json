{"id":106048,"title":"08 | 数据和接口模型设计：账户服务","content":"","comments":[{"had_liked":false,"id":172327,"user_name":"ella","can_delete":false,"product_type":"c3","uid":1449133,"ip_address":"","ucode":"D7DD3CCA5FECDB","user_header":"https://static001.geekbang.org/account/avatar/00/16/1c/ad/27c7dae0.jpg","comment_is_top":false,"comment_ctime":1579155385,"is_pvip":false,"replies":[{"id":66856,"content":"数据库能不拆尽量不要拆，除非万不得已。拆开以后就会面临分布式事务的问题。\n\n但是业务和团队发展到一定阶段，解耦拆分在所难免。数据库拆分是个很大的主题，也是一个体力活，没有一招鲜的办法，就是一个制定拆分计划，按部就班不断执行拆分的过程。一般的思路是先做好服务化(所有应用都不能直接调用数据库，必须通过服务访问)，服务化搞定，有了一层间接抽象以后，才可以考虑数据库拆分。数据库先做好读写分离：数据库端只有写入，然后变更数据同步到其它存储(其它DB&#47;ES&#47;HBase&#47;...)再构建各种读视图。实现读写分离以后，DB只有一个写入端，这时候就可以考虑拆分甚至替换(从双写+比对开始)。拆分之后一定会引入不同数据源之间数据一致性和数据同步的问题，这个时候一定会需要引入可靠消息系统。\n\n所以，根据个人经验，数据库拆分的几个关键是：1). 服务化，2)读写分离，3)可靠消息系统。\n\n关于分布式事务，这个东西其实是具体业务相关，也没有简单一招鲜的框架。思路很多，简单常用的做法是先落地(类似WAL~Write Ahead Log)+子系统执行事务+协调器协调。推荐看ebay架构师写的关于微服务数据一致性的文章，讲得比较全面：\nhttps:&#47;&#47;dzone.com&#47;articles&#47;data-consistency-in-microservices-architecture\n\n","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1579170971,"ip_address":"","comment_id":172327,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"对于老的项目转到微服务，数据库的拆分很难，有什么best practice可以遵循，可以不拆分数据库么？如果拆分开，原来的事务操作应该怎么处理呢","like_count":6,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481702,"discussion_content":"数据库能不拆尽量不要拆，除非万不得已。拆开以后就会面临分布式事务的问题。\n\n但是业务和团队发展到一定阶段，解耦拆分在所难免。数据库拆分是个很大的主题，也是一个体力活，没有一招鲜的办法，就是一个制定拆分计划，按部就班不断执行拆分的过程。一般的思路是先做好服务化(所有应用都不能直接调用数据库，必须通过服务访问)，服务化搞定，有了一层间接抽象以后，才可以考虑数据库拆分。数据库先做好读写分离：数据库端只有写入，然后变更数据同步到其它存储(其它DB/ES/HBase/...)再构建各种读视图。实现读写分离以后，DB只有一个写入端，这时候就可以考虑拆分甚至替换(从双写+比对开始)。拆分之后一定会引入不同数据源之间数据一致性和数据同步的问题，这个时候一定会需要引入可靠消息系统。\n\n所以，根据个人经验，数据库拆分的几个关键是：1). 服务化，2)读写分离，3)可靠消息系统。\n\n关于分布式事务，这个东西其实是具体业务相关，也没有简单一招鲜的框架。思路很多，简单常用的做法是先落地(类似WAL~Write Ahead Log)+子系统执行事务+协调器协调。推荐看ebay架构师写的关于微服务数据一致性的文章，讲得比较全面：\nhttps://dzone.com/articles/data-consistency-in-microservices-architecture\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579170971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195413,"user_name":"Walking Man","can_delete":false,"product_type":"c3","uid":1309962,"ip_address":"","ucode":"3465FACAA42A20","user_header":"https://static001.geekbang.org/account/avatar/00/13/fd/0a/edfb9ad9.jpg","comment_is_top":false,"comment_ctime":1585186574,"is_pvip":false,"replies":[{"id":74366,"content":"服务之间调用(或者网关调后台服务)要做好限流容错，可以采用组件hystrix&#47;resillience4j或者阿里开源的限流容错平台sentinel。\n\n数据一致性，如果短事务要求强一致性，可以考虑阿里开源seata，它是一种2pc的变体实现。也可以考虑基于可靠消息的最终一致性。长事务一般考虑saga模式(类似一种基于可靠消息的协调机制)。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1585234328,"ip_address":"","comment_id":195413,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"波波大佬，服务之间或者网关调用服务的可靠性怎么考虑呢，数据一致性用一些xa方案好吗","like_count":2,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489055,"discussion_content":"服务之间调用(或者网关调后台服务)要做好限流容错，可以采用组件hystrix/resillience4j或者阿里开源的限流容错平台sentinel。\n\n数据一致性，如果短事务要求强一致性，可以考虑阿里开源seata，它是一种2pc的变体实现。也可以考虑基于可靠消息的最终一致性。长事务一般考虑saga模式(类似一种基于可靠消息的协调机制)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585234328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143069,"user_name":"grey927","can_delete":false,"product_type":"c3","uid":1202782,"ip_address":"","ucode":"833E02ED835B4A","user_header":"https://static001.geekbang.org/account/avatar/00/12/5a/5e/a897cb0d.jpg","comment_is_top":false,"comment_ctime":1571625609,"is_pvip":false,"replies":[{"id":55457,"content":"你好，staffjoy里头持久层model的主键id都是用的system-uuid，这个应该是jpa&#47;hibernate生成的uuid，类似java的UUID.randomUUID。\n\n我的理解一般java的UUID.randomUUID就足够了(碰撞只是理论上，实际真碰撞了数据库会报错，也没有大问题)，而且这个是无状态的，根据wikipedia的说法：\n\nOnly after generating 1 billion UUIDs every second for the next 100 years, the probability of creating just one duplicate would be about 50%. Or, to put it another way, the probability of one duplicate would be about 50% if every person on earth owned 600 million UUIDs.\n\n参考：\nhttps:&#47;&#47;stackoverflow.com&#47;questions&#47;24876188&#47;how-big-is-the-chance-to-get-a-java-uuid-randomuuid-collision\n\nhttps:&#47;&#47;stackoverflow.com&#47;questions&#47;2513573&#47;how-good-is-javas-uuid-randomuuid\n\n当然如果你还是不放心，可以研究考虑分布式unique id生成系统，可以参考twitter snowflake：\nhttps:&#47;&#47;github.com&#47;twitter-archive&#47;snowflake&#47;tree&#47;snowflake-2010\n\nhttps:&#47;&#47;github.com&#47;sony&#47;sonyflake\n\n","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1571752345,"ip_address":"","comment_id":143069,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"杨老师，你好，staffjoy里面，会有一种场景是生成分布式唯一id的需求么？生成分布式唯一id有没有一些推荐的解决方案","like_count":2,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471372,"discussion_content":"你好，staffjoy里头持久层model的主键id都是用的system-uuid，这个应该是jpa/hibernate生成的uuid，类似java的UUID.randomUUID。\n\n我的理解一般java的UUID.randomUUID就足够了(碰撞只是理论上，实际真碰撞了数据库会报错，也没有大问题)，而且这个是无状态的，根据wikipedia的说法：\n\nOnly after generating 1 billion UUIDs every second for the next 100 years, the probability of creating just one duplicate would be about 50%. Or, to put it another way, the probability of one duplicate would be about 50% if every person on earth owned 600 million UUIDs.\n\n参考：\nhttps://stackoverflow.com/questions/24876188/how-big-is-the-chance-to-get-a-java-uuid-randomuuid-collision\n\nhttps://stackoverflow.com/questions/2513573/how-good-is-javas-uuid-randomuuid\n\n当然如果你还是不放心，可以研究考虑分布式unique id生成系统，可以参考twitter snowflake：\nhttps://github.com/twitter-archive/snowflake/tree/snowflake-2010\n\nhttps://github.com/sony/sonyflake\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571752345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112293,"user_name":"黑夜骑士","can_delete":false,"product_type":"c3","uid":1084527,"ip_address":"","ucode":"202B76FBF97F5D","user_header":"","comment_is_top":false,"comment_ctime":1562717098,"is_pvip":false,"replies":[{"id":41026,"content":"我演示用的是mac系统，不过会介绍windows环境下搭建docker&#47;k8s的一些注意点。课程会采用docker desktop演示，它内置支持k8s，windows安装docker desktop的话，要求win10&#47;64位环境(参考:https:&#47;&#47;docs.docker.com&#47;docker-for-windows&#47;install&#47;)。如果不是win10的话，要装minikube，或者用vagrant镜像之类会比较麻烦。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1562849610,"ip_address":"","comment_id":112293,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"波波老师，一直追随你的脚步，想问下这门课程会讲解Windows环境下如何部署doker kubernetes容器云部署么，我用的是windows系统","like_count":2,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457662,"discussion_content":"我演示用的是mac系统，不过会介绍windows环境下搭建docker/k8s的一些注意点。课程会采用docker desktop演示，它内置支持k8s，windows安装docker desktop的话，要求win10/64位环境(参考:https://docs.docker.com/docker-for-windows/install/)。如果不是win10的话，要装minikube，或者用vagrant镜像之类会比较麻烦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562849610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207819,"user_name":"A","can_delete":false,"product_type":"c3","uid":1580869,"ip_address":"","ucode":"DDF0B08188F628","user_header":"https://static001.geekbang.org/account/avatar/00/18/1f/45/92343cb6.jpg","comment_is_top":false,"comment_ctime":1587187147,"is_pvip":false,"replies":[{"id":77938,"content":"这个每家企业做法不同，没有统一标准做法，有些整合在一个表中，通过字段区分，也有的放在不同表中，通过前面的微服务提供统一接口，屏蔽存储细节。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1587393586,"ip_address":"","comment_id":207819,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"对于一个系统中存在微信用户、系统用户、会员用户该如何处理","like_count":1,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492252,"discussion_content":"这个每家企业做法不同，没有统一标准做法，有些整合在一个表中，通过字段区分，也有的放在不同表中，通过前面的微服务提供统一接口，屏蔽存储细节。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587393586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159593,"user_name":"lester","can_delete":false,"product_type":"c3","uid":1025747,"ip_address":"","ucode":"79BD59B50C97BA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/d3/856316dd.jpg","comment_is_top":false,"comment_ctime":1575699183,"is_pvip":false,"replies":[{"id":61113,"content":"我认为这些HTTP方法和安全没有直接关系。\n\n作为RESTful API，POST&#47;GET&#47;PUT有一些惯例语义，POST常表示创建新业务记录， PUT表示更新业务记录，GET则是获取业务记录。但这个只是一种惯例，不是统一标准。\n\n","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1575890029,"ip_address":"","comment_id":159593,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"波波老师，您好，从业务或安全的角度来看，哪些场景适合使用POST，哪些适合GET，哪些使用PUT,这个有统一的标准么？","like_count":0,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477111,"discussion_content":"我认为这些HTTP方法和安全没有直接关系。\n\n作为RESTful API，POST/GET/PUT有一些惯例语义，POST常表示创建新业务记录， PUT表示更新业务记录，GET则是获取业务记录。但这个只是一种惯例，不是统一标准。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575890029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195169,"user_name":"春哥","can_delete":false,"product_type":"c3","uid":1103105,"ip_address":"","ucode":"C20FED6AE27B76","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/01/befc9f3e.jpg","comment_is_top":false,"comment_ctime":1585143519,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"希望能学会kubernetes","like_count":0}]}