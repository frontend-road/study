{"id":431400,"title":"02｜聊聊x86体系架构中的实模式和保护模式","content":"<p>你好，我是海纳。</p><p>上一节课我们讲了虚拟内存的概念，分析了线性地址（虚拟地址）是如何映射到物理地址上的。</p><p>不过，在x86架构诞生之初，其实是没有虚拟内存的概念的。1978年发行的8086芯片是x86架构的首款芯片，它在内存管理上使用的是直接访问物理内存的方式，这种工作方式，有一个专门的名称，那就是<strong>实模式</strong>（Real Mode）。上节课我们也曾简单提到过，直接访问物理内存的工作方式让程序员必须要关心自己使用的内存会不会与其他进程产生冲突，为程序员带来极大的心智负担。</p><p>后来，CPU上就出现虚拟内存的概念，它可以将每个进程的地址空间都隔离开，极大地减轻了程序员的负担，同时由于页表项中有多种权限保护标志，极大地提高了应用程序的数据安全。所以人们把CPU的这种工作模式称为<strong>保护模式</strong>（Protection Mode）。</p><p>从实模式演进到保护模式，x86体系架构的内存管理发生了重大的变化，最大的不同就体现在段式管理和中断的管理上。所以今天这节课，我们会围绕这两个重点，让你彻底理解x86体系架构下的内存管理演进。你也能通过这节课的学习，学会阅读Linux内核源码的段管理和中断管理的相关部分，还可以增加调试coredump文件的能力。</p><!-- [[[read_end]]] --><p>这里我们就按照时间顺序，从8086芯片中的实模式开始讲起。</p><h3>8086中的实模式</h3><p>8086芯片是Intel公司在1978年推出的CPU芯片，它定义的指令集对计算机的发展历程影响十分巨大，之后的286、386、486、奔腾处理器等等都是在8086的基础上演变而来。这一套指令集也被称为x86指令集。直到今天，很多大学里的微机原理课和汇编语言课还是使用8086进行讲解。</p><p>8086的寄存器只有16位，我们也习惯于称8086的工作模式是16位模式。而且，后面的CPU为了保持兼容，在芯片上电了以后，还必须运行在16位模式之下，这种模式有个正式的名字，叫做<strong>实模式</strong>（Real Mode）。<strong>在实模式下，程序员是不能通过内存管理单元（Memory Management Unit, MMU）访问地址的，程序必须直接访问物理内存。</strong></p><p>那实模式下，我们是怎么访问存储的物理地址的呢？</p><p>8086的寄存器位宽是16位，但地址总线却有20位，地址的编码可以从20位0到20位1，这意味着8086的寻址空间是2^20 = 1M。但是在写程序的时候，我们没有办法把一个地址完整地放到一个寄存器里，因为它的寄存器相比地址少了4位。</p><p>为了解决这个问题，8086就引入了<strong>段寄存器</strong>，例如cs、ds、es、gs、ss等。段寄存器中记录了一个段基地址，通过计算可以得到我们存储的真实地址，也就是物理地址。物理地址可以使用“段寄存器:段内偏移”这样的格式来表示，计算的公式是：</p><p><strong>物理地址 =段寄存器 &lt;&lt; 4 + 段内偏移</strong></p><p>不过，在我们写汇编代码的时候（如果你对汇编不熟悉，可以先去看看我前面讲的<a href=\"https://time.geekbang.org/column/article/430173\">导学（一）</a>和<a href=\"https://time.geekbang.org/column/article/430184\">导学（二）</a>），也不一定就要使用段寄存器来表示段基址，也可以使用“段基址:段内偏移”这样的立即数的写法，比如你可以看下这个节选自Linux的bootsect中的代码：</p><pre><code>BOOTSEG   = 0x7c0\n\n_start:\n  jmpl $BOOTSEG, $start2\n\nstart2:\n  movw $BOOTSEG, %ax\n  movw %ax, %ds\n  ...\n</code></pre><p>这块代码里，它跳转的目标地址就是0x7c0 &lt;&lt; 4 + OFFSET(start2)。跳转成功以后，cs段寄存器中的值就是段基址0x7c0，start2的偏移值是8，所以记录当前执行指令地址的ip寄存器中的值就是实际地址0x7c08。</p><p>而且，这块代码里也包含了段基址和段内偏移值这种地址形式，这显然有别于我们所讲的虚拟地址。这种包含了段基址和段内偏移值的地址形式有一个专门的名字，叫做<strong>逻辑地址</strong>。你可以看到，虚拟地址是一个整数，而逻辑地址是一对整数。所以说，在8086芯片中，逻辑地址要经过一步计算才可以得到物理地址。</p><p>在8086中，cs被用来做为代码段基址寄存器，比如上面示例代码中的jmp指令，跳转成功就会把段基址自动存入cs寄存器。ds被用来做为数据段基址寄存器，你可以看看下面这个代码：</p><pre><code>INITSEG = 0x9000\n    ....\n    movw $INITSEG, %ax\n    movw %ax, %ds\n    movb $0x03, %ah\n    xor  %bh,  %bh\n    int  $0x10\n    movw %dx, (0)\n    movb $0x88, %ah\n    int  $0x15\n    movw %ax, (2)\n</code></pre><p>上述代码的第7行执行0x10号BIOS中断，它的结果存放在dx寄存器中，然后第8行，将结果存入内存0x90000，9至11行再把0x15号BIOS中断的结果存到0x90002处。</p><p>在寻址时，我们并没有明确地声明数据段基址存储在段寄存器ds中，但是CPU在执行时会默认使用ds做为数据段寄存器。类似的还有ss，它是做为栈基址寄存器，当我们在使用push指令的时候，要保存的数据会放在ss:(sp)的位置。</p><p>CPU没有强制规定代码段和数据段分离，也就意味着，你使用ds段寄存器去访问指令，CPU也是允许的。但在实际编程时，我们还是会把数据和代码分到不同的段里，并且将数据段的起始地址放到ds寄存器，把代码段的地址放到cs寄存器。这种按功能分段的管理内存方式就是段式管理。关于段式管理和页式管理的对比，我们稍后会加以介绍。</p><p>到这里8086的实模式，我们已经基本讲完了。8086是最古老的x86芯片，在实模式下，它只能直接操作物理内存，非常不便于编程，这一点，我们在<a href=\"https://time.geekbang.org/column/article/430073\">第1节课</a>也提到了。接下来，我们把目光转向x86体系架构中的保护模式，它是实模式的进一步发展。</p><h3>i386中的保护模式</h3><p>经过十年的发展，x86 CPU迎来了历史上使用最广泛、影响力最大的32位CPU，这就是i386芯片。i386与8086的一个很大的不同，就是它采用了全新的保护模式。这个体现在，i386中的段式管理机制，相比8086发生了重大变化；同时，i386芯片在段式管理的基础上，还引入了页式管理。</p><p>i386在完成各种初始化动作以后，就会开启页表，从此程序员就不必再直接操作物理内存的地址空间了，代替它的是线性地址空间。而且由于段和页都能提供对内存的保护，安全性也得到了提升，所以这种工作模式被称为保护模式（Protection Mode）。i386的保护模式是一种段式管理和页式管理混合使用的模式。</p><p>至于页式管理，我们<a href=\"https://time.geekbang.org/column/article/430073\">第1节课</a>已经讲过了，所以这里我们就来看一下相比8086，段式管理在i386上有了哪些变化。</p><p><strong>变化一：段选择子和全局描述符表</strong></p><p>在i386上，地址总线是32位的，通用寄存器也变成32位的，这就意味着因为寄存器位数不够而产生的段基址寄存器已经失去了作用。</p><p>但是i386没有直接放弃掉段寄存器，而是将它进化成了新的段式内存管理。段寄存器仍然是16位寄存器，但是其中存的不再是段基址，而是被称为段选择子的东西。</p><p>相比8086芯片，i386中多了一个叫全局描述符表（Global Descriptor Table, GDT）的结构。它本质上是一个数组，其中的每一项都是一个全局描述符，32位的段基址就存储在这个描述符里。段选择子本质上就是这个数组的下标。具体你可以看看下面这张图：</p><p><img src=\"https://static001.geekbang.org/resource/image/e4/46/e4abd9ca17763b5094990fb9ef108846.jpg?wh=3480x1918\" alt=\"\"></p><p>GDT的地址也要保存在寄存器里，这个寄存器就是GDTR，这个做法和<a href=\"https://time.geekbang.org/column/article/430073\">第1节课</a>我们讲到的CR3寄存器的做法十分相似。</p><p>在上面这张图中，CPU在处理一个逻辑地址“cs:offset”的时候，就会将GDTR中的基址加上cs中的下标值来得到一个段描述符，再从这个段描述符中取出段基址，最后将段基址与偏移值相加，这样就可以得到线性地址了。这个线性地址就是我们<a href=\"https://time.geekbang.org/column/article/430073\">第1节课</a>中所讲的虚拟地址。</p><p>得到线性地址以后，剩下的工作我们就非常熟悉了：<strong>由CPU的MMU将线性地址映射为物理地址，然后就可以交给地址总线去进行读写了。</strong></p><p><strong>变化二：段寄存器对段的保护能力增强</strong></p><p>在8086中，段寄存器只起到了段基址的作用，对于段的各种属性并没有加以定义。例如，在实模式下，任何指令都可以对代码段进行随意地更改。</p><p>但在i386中，对段的保护能力加强了，我们先来看一下i386中段描述符（也就是GDT中的每一项）的结构。</p><p><img src=\"https://static001.geekbang.org/resource/image/16/38/16b2787068bb721ae5366ee286414138.jpg?wh=1932x845\" alt=\"\"></p><p>你会看到，描述符中除了记录了段基址之外，还记录了段的长度，以及定义了一些与段相关的属性，其中比较重要的属性有P位、DPL、S位、G位和Type。我们接下来一个个来分析。</p><p>P位是一个比特，指示了段在内存中是否存在，1表示段在内存中存在，0则表示不存在。</p><p>DPL，占据了两个比特，指的是描述符特权级，英文是Descriptor Privilege Level。Intel规定了CPU工作的4个特权级，分别是0、1、2、3，数字越小，权限越高。</p><p>以Linux为例，Linux只使用了0和3两个特权级，并且规定0是内核态，3是用户态。特权级的切换是比较复杂的一种机制，但Linux只使用了中断这一种，后面我们会再讲到中断。</p><p>接下来我们再看S位，S为1代表该描述符是数据段/代码段描述符，为0则代表系统段/门描述符。门是i386提供的用于切换特权级的机制，有调用门、陷阱门、中断门、任务门等。在Linux系统中，只使用了中断门描述符。</p><p>然后是G位，它指的是定义段颗粒度（Granularity），它的值为0时，段界限的单位是字节，为1时段界限以4KB为单位，也就是一页。</p><p>我们也可以从图中看出定义段长度的“段界限”字段并不是连续的，它一共有20位，分散在两个地方。当G=1时，段界限的最大值是2^20 * 4K = 4G，这是i386一个段的最大长度。</p><p>最后是Type属性，它定义了描述符类型，我把比较重要的类型用表列在了下面，你可以看看。</p><p><img src=\"https://static001.geekbang.org/resource/image/b8/f5/b80ddc894798e31d077394df613d5bf5.jpg?wh=1980x804\" alt=\"\"></p><p>到这里，我们已经解释清楚了，i386中保护模式相比8086实模式在段式管理上的升级。那么在现代的CPU和操作系统中，段式管理和页式管理又是怎样的关系呢？要讲清楚这一点就要先对比这两种内存管理方式的优缺点。</p><h3>段式管理对比页式管理</h3><p>段式管理会按功能把内存空间分割成不同段，有代码段、数据段、只读数据段、堆栈段，等等，为不同的段赋予了不同的读写权限和特权级。通过段式管理，操作系统可以进一步区分内核数据段、内核代码段、用户态数据段、用户态代码段等，为系统提供了更好的安全性。</p><p>但是段的长度往往是不能固定的，例如不同的应用程序中，代码段的长度各不相同。如果以段为单位进行内存的分配和回收的话，数据结构非常难于设计，而且难免会造成各种内存空间的浪费。页式管理则不按照功能区分，而是按照固定大小将内存分割成很多大小相同的页面，不管是存放数据，还是存放代码，都要先分配一个页，再将内容存进页里。</p><p>所以，你可以看到，相比页式管理，段式管理的优点是提供更好的安全性，按照内存的用途进行划分更符合人的直观思维。它的缺点就是由于不定长，难于进行分配、回收调度。</p><p>而页式管理的优点是大小固定，分配回收都比较容易。而且段式管理所能提供的安全性，在现代CPU上也可以被页表项中的属性替代，所以现在段式管理已经变得越来越不重要了。像64位Linux系统，它把所有段的基地址都设成了从0开始，段长度设置为最大。这样段式管理的重要性就大大下降了。</p><p>但是，如果我们以x86的历史演进来看，你会发现段式管理其实是最早出现的（8086芯片），然后才出现了页式管理（i386芯片）。而且，我们现代的x86架构的CPU，也同时兼容段式管理和页式管理，我们可以认为是一种混合的段页式管理（当然，并不是所有人都认可这种命名方式）。</p><p>总的来说，现代的操作系统都是采用段式管理来做基本的权限管理，而对于内存的分配、回收、调度都是依赖页式管理。</p><p>到这里，我们就讲清楚了8086实模式到i386保护模式下段式管理的演进，并且进一步分析了段式管理和页式管理的对比和现状。</p><p>保护模式相比实模式，发生重大变化的不止是内存管理，同时还有中断管理。因为管理中断的结构与段式管理的全局描述符表的结构非常相似，所以我们在讲保护模式时也一起讲一下。你可以将中断机制与段管理机制比较着一起学习。</p><h3>中断描述符表</h3><p>中断描述符表（Interruption Description Table, IDT），是i386中一个非常重要的描述符表，它也是保护模式对比实模式的另一大不同。你在后面学习fork、execve的实现时，涉及到的写保护中断，缺页中断等机制都要依赖它。</p><p>CPU与外设之间的协同工作是以中断机制来进行的。例如，我们敲击键盘的时候，键盘的控制器就会向CPU发起一个中断请求。CPU在接到请求以后，就会停下正在做的工作，把当前的寄存器状态全部保存好，然后去调用中断服务程序。当然，这个过程中有一些是CPU的工作，有一些是操作系统的工作，但因为我们关注的重点是内存，所以就没必要计较这里面细微的差别了。</p><p>中断根据中断来源的不同，又可以细分为Fault、Trap、Abort以及普通中断。我们这门课对它们也不加区分，例如执行除法的时候除数为0的情况、访问数据时权限不足引发的保护错误、由用户使用int指令产生的中断等，虽然中断源不同，它们的类型也不相同，但我们统一称它们为中断。</p><p>硬件负责产生中断，CPU会响应中断，但是中断来了以后要做什么事情是由操作系统定义的。操作系统要通过设置某个中断号的中断描述符，来指定中断到达以后要调用的函数。<strong>中断描述符表（IDT）的作用就体现在这了，它的本质就是中断描述符的数组</strong>。</p><p>IDT的基地址存储在idtr寄存器中，这和GDTR的设计如出一辙。每个中断都有一个编号与其对应，我们称之为<strong>中断向量号</strong>。中断向量号是CPU提前分配好的，我也把比较重要的中断向量号放在了下表里，你可以看看。</p><p><img src=\"https://static001.geekbang.org/resource/image/c3/3d/c361fe908d647f4227d4b4e2f447993d.jpg?wh=1980x1080\" alt=\"\"></p><p>在这个表里，我们没有看到前边所提到的键盘中断，这是因为键盘中断都是由一个名为8259A的芯片在管理。</p><p>两片级联的8259A芯片可以管理16个中断，其中包括了时钟中断、键盘中断，还有软盘、硬盘、鼠标的中断等等。这些中断的中断向量号是可以通过对8259A编程进行设置的。虽然8259A的编程比较繁琐，但好在只需要操作系统开机引导时设置一次。</p><p>你也可以看到，Linux系统把中断向量表的32号中断（用户自定义中断的第一位）设置成8259A的0号中断，也就是说IDT的32号至47号都分配给了8259A所管理的中断。键盘、软盘、硬盘、鼠标的中断服务程序就设置在这里。</p><p>关于中断，我们掌握这么多就已经足够了，更多的知识我们会在后面的课程按需讲解。</p><p>现在，我们可以通过一个例子，体验一下中断的使用。在Linux系统上，我们把下面这个代码保存到文件hello.c中，并且使用\"gcc -o hello hello.c\"编译，得到可执行程序hello。再运行它，你就可以看到屏幕上打印出一行\"hello\"。</p><pre><code>// compile command : gcc -o hello hello.c\nvoid sayHello() {\n    const char* s = &quot;hello\\n&quot;;\n    __asm__(&quot;int $0x80\\n\\r&quot;\n            ::&quot;a&quot;(4), &quot;b&quot;(1), &quot;c&quot;(s), &quot;d&quot;(6):);\n}\n\nint main() {\n    sayHello();\n    return 0\n}\n</code></pre><p>相比于使用printf进行打印，需要引入头文件\"stdio.h\"，我们这段代码里没有使用任何头文件，但一样可以在控制台上进行打印。</p><p>这是因为，我们使用了0x80号中断进行了Linux系统调用。系统调用号在eax中，也就是4，代表write这个调用。第一个参数在ebx中，其值为1，代表控制台的标准输出；第二个参数是字符串\"hello\"的地址，在rcx中；第三个参数是字符串的长度，也就是6，存储在edx中。</p><p>这样，我们就通过中断，就不必再使用C语言的printf进行输出，这就绕过了C语言的基础库，完成了向控制台打印的功能。</p><h3>总结</h3><p>今天我们拆解了x86体系架构下的实模式和保护模式，也认识了两个x86演进史上非常重要的CPU。</p><p>8086是16位的CPU，我们称8086的工作模式为实模式，它的特点是直接操作物理内存，内存管理容易出错，要十分小心，代码编写和调试都很困难。</p><p>之后出现的i386，则采用了和实模式不同的保护模式。相比实模式，i386中的保护模式，采用了页式管理，但它没有彻底放弃8086的段式管理，而是将段寄存器中的值由段基址变成了段选择子。段选择子本质是GDT表的下标值，段基址都转移到GDT中去了。</p><p>段式管理负责将逻辑地址转换为线性地址，或者称为虚拟地址，页式管理负责将线性地址映射到物理地址。i386的保护模式采用了段页式混合管理的模式，兼具了段式管理和页式管理的优点。</p><p>除了段页式内存管理这个不同之外，保护模式和实模式的区别还体现在中断描述符表（IDT）上。IDT是保护模式的一个重要组成部分，它保存着i386中断服务程序的入口地址。</p><p>8086和i386对x86架构的CPU影响巨大。直到今天，x86架构的CPU在上电以后，为了与8086保持兼容，还是运行在16位实模式下，也就是说所有访存指令访问的都是物理内存地址。在启动操作系统后，才会切换到保护模式下进行工作。</p><h3>思考题</h3><p>我们今天这节课只讲了16位CPU和32位CPU，并没有讲64位CPU的段式管理是怎么做的。实际上64位CPU的段式管理和32位的结构非常相似，惟一的区别是段描述符的段基址和段长度字段都被废弃了，也就是说不管你将段基址设置成什么，都会被CPU自动识别为0。</p><p>那么请你思考，CPU为什么要这么设计呢？一方面，它还保留了段寄存器，另一方面，它又不再起到逻辑地址转换线性地址的作用，这不是很奇怪吗？请你站在CPU架构师的角度思考一下原因。欢迎你在留言区分享你的想法和收获，我在留言区等你。</p><p><img src=\"https://static001.geekbang.org/resource/image/17/8d/175d317a156b977c0c013909dcc3f68d.jpg?wh=2284x1361\" alt=\"\"></p><p>好啦，这节课到这就结束啦。欢迎你把这节课分享给更多对计算机内存感兴趣的朋友。我是海纳，我们下节课再见！</p>","comments":[{"had_liked":false,"id":318535,"user_name":"慢动作","can_delete":false,"product_type":"c1","uid":1133945,"ip_address":"","ucode":"62C944F4A4D8AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","comment_is_top":false,"comment_ctime":1635325989,"is_pvip":true,"replies":[{"id":"115507","content":"1. 第一个问题，linux内核引入了vm_area_struct结构，通过软件的办法做了很多权限管理的事情，这个可以代替段的权限管理的部分工作；另外，每个页也有读写权限管理，所以硬件本身的页管理机制也代替了一些段的权限管理机制。<br>2. IDT是全局的，你已经理解了。GDT也是全局的。linux会使用GDT来区分内核代码段和内核数据段。每个进程单独的确实也有这种结构，叫做局部（local）表述符表，LDT才是和单个进程相关的表，其中的描述符的结构与全局描述符是完全一样的。由于它的结构和GDT非常像，我故意略去了。<br>3. 段选择子我没有展开讲它的结构，实际上，段选择子的第三位为0就表示要在GDT中找描述符，为1就在LDT中查找。所以你只要理解GDT就足够了。但既然你考虑到这里了，我就单独回答一下这个问题。<br>你思考得很深入，点赞！","user_name":"作者回复","comment_id":318535,"uid":"1360512","ip_address":"","utype":1,"ctime":1635351378,"user_name_real":"氦钠锶"}],"discussion_count":3,"race_medal":0,"score":"61764868133","product_id":100094901,"comment_content":"没有段以后，代码权限是以什么为单位管理的？GDT是每个进程单独一份，IDT是系统独一份？","like_count":15,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529288,"discussion_content":"1. 第一个问题，linux内核引入了vm_area_struct结构，通过软件的办法做了很多权限管理的事情，这个可以代替段的权限管理的部分工作；另外，每个页也有读写权限管理，所以硬件本身的页管理机制也代替了一些段的权限管理机制。\n2. IDT是全局的，你已经理解了。GDT也是全局的。linux会使用GDT来区分内核代码段和内核数据段。每个进程单独的确实也有这种结构，叫做局部（local）表述符表，LDT才是和单个进程相关的表，其中的描述符的结构与全局描述符是完全一样的。由于它的结构和GDT非常像，我故意略去了。\n3. 段选择子我没有展开讲它的结构，实际上，段选择子的第三位为0就表示要在GDT中找描述符，为1就在LDT中查找。所以你只要理解GDT就足够了。但既然你考虑到这里了，我就单独回答一下这个问题。\n你思考得很深入，点赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635351378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1432830,"avatar":"https://static001.geekbang.org/account/avatar/00/15/dc/fe/f11f25dd.jpg","nickname":"左星辰","note":"","ucode":"A67D772F6AA584","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545731,"discussion_content":"按我的理解，每个进程有一个LDT，跟GDTR对应的也有一个LDTR寄存器，保存着当前执行进程的LDT基地址，LDT与GDT结构是完全一致的，根据段选择子的第14位（老师说的第三位应该是方向跟我相反）来选择从GDTR还是LDTR中选择段描述符表的基地址，0表示从GDTR，1表示冲LDTR","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642046021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1711838,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/1e/de/cdee1780.jpg","nickname":"我是内存","note":"","ucode":"3D763D4F434D50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411189,"discussion_content":"这么说GDT是给内核用的，LDT是给进程用的?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635862783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318459,"user_name":"郑童文","can_delete":false,"product_type":"c1","uid":1030733,"ip_address":"","ucode":"3D193715CB8549","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/4d/7ba09ff0.jpg","comment_is_top":false,"comment_ctime":1635302134,"is_pvip":false,"replies":[{"id":"115480","content":"好问题。gdt和idt都是由操作系统设置的。所以我们可以理解成是在内核空间里。但这仍然不准确。最准确的说法是由于gdtr和idtr里存的是物理地址，相当于操作系统从物理地址里扣了一块给gdt和idt。这块物理地址以后就不参与分配了。","user_name":"作者回复","comment_id":318459,"uid":"1360512","ip_address":"","utype":1,"ctime":1635308073,"user_name_real":"氦钠锶"}],"discussion_count":5,"race_medal":0,"score":"27405105910","product_id":100094901,"comment_content":"请问老师，IDT是储存在操作系统的内核内存空间的吗？GDT是存在进程的用户内存空间还是内核内存空间呢？ 谢谢！","like_count":6,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529251,"discussion_content":"好问题。gdt和idt都是由操作系统设置的。所以我们可以理解成是在内核空间里。但这仍然不准确。最准确的说法是由于gdtr和idtr里存的是物理地址，相当于操作系统从物理地址里扣了一块给gdt和idt。这块物理地址以后就不参与分配了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635308073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":3,"child_discussions":[{"author":{"id":1106566,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e2/86/90041355.jpg","nickname":"一塌糊涂","note":"","ucode":"B55DAEFB98D83C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":539394,"discussion_content":"gdtr和idtr里存的是物理地址  ，记忆中应该是 线性地址吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639706992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":529251,"ip_address":""},"score":539394,"extra":""},{"author":{"id":2523660,"avatar":"https://static001.geekbang.org/account/avatar/00/26/82/0c/cc106ab1.jpg","nickname":"Samaritan.","note":"","ucode":"A3730B90313C26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":578390,"discussion_content":"老师， 感觉gdtr中存放的线性地址呀，为什么是物理地址呢？没想明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656693721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":529251,"ip_address":""},"score":578390,"extra":""},{"author":{"id":1513432,"avatar":"","nickname":"西门长风","note":"","ucode":"DDA510AEAE3F16","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2523660,"avatar":"https://static001.geekbang.org/account/avatar/00/26/82/0c/cc106ab1.jpg","nickname":"Samaritan.","note":"","ucode":"A3730B90313C26","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582316,"discussion_content":"gdt是个表，gdtr寄存器存的是这个表的物理位置，这个表的内容是各种线性地址。\ngdt存在的意义，是为了给更上层传来的逻辑地址转化为线性地址。\n按老师的意思，gdt是常驻内存的，不会修改，所以gdtr直接存物理地址可以方便使用gdt。如果gdtr存的是gdt的线性地址，每次给别人查找线性地址前，自己要额外做一次gdt的线性地址到物理地址的查找。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659362980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":578390,"ip_address":"安徽"},"score":582316,"extra":""}]},{"author":{"id":2837328,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/4b/50/fae00aff.jpg","nickname":"HollyWong","note":"","ucode":"03A66A2BCC0A58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413672,"discussion_content":"内核的常驻部分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636538763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318388,"user_name":"送过快递的码农","can_delete":false,"product_type":"c1","uid":1587666,"ip_address":"","ucode":"66EA81B3BADC73","user_header":"https://static001.geekbang.org/account/avatar/00/18/39/d2/845c0e39.jpg","comment_is_top":false,"comment_ctime":1635265665,"is_pvip":false,"replies":[{"id":"115486","content":"Good，这是很重要的一方面。是x86的设计哲学，但也给x86架构带来了巨大的包袱。","user_name":"作者回复","comment_id":318388,"uid":"1360512","ip_address":"","utype":1,"ctime":1635308967,"user_name_real":"氦钠锶"}],"discussion_count":1,"race_medal":0,"score":"18815134849","product_id":100094901,"comment_content":"保留段寄存器是不是为了向下兼容实模式啊？因为64位地址总线够大了，不需要段了。但是为了保证向下兼容性，段不做删除？纯属瞎猜","like_count":4,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529219,"discussion_content":"Good，这是很重要的一方面。是x86的设计哲学，但也给x86架构带来了巨大的包袱。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635308967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334235,"user_name":"Yun","can_delete":false,"product_type":"c1","uid":2611211,"ip_address":"","ucode":"BB5DD469788955","user_header":"https://static001.geekbang.org/account/avatar/00/27/d8/0b/a4593892.jpg","comment_is_top":false,"comment_ctime":1644824530,"is_pvip":true,"replies":[{"id":"122934","content":"32位linux先动的手，intel一看，你们写os的不按套路出牌啊，所以就干脆在设计64位cpu的时候把这块电路给扣了。","user_name":"作者回复","comment_id":334235,"uid":"1360512","ip_address":"","utype":1,"ctime":1646124134,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"14529726418","product_id":100094901,"comment_content":"“实际上 64 位 CPU 的段式管理和 32 位的结构非常相似，惟一的区别是段描述符的段基址和段长度字段都被废弃了，也就是说不管你将段基址设置成什么，都会被 CPU 自动识别为 0”。<br>这句话里的“CPU自动识别为0”？记得是Linux内核将段基地址都设置为0，然后是的Linux本质上抛弃了段式管理，所以想请教一下，这里是CPU将段基址设置为0还是Linux内核来设置？或者说32位和64位还不一样？，谢谢","like_count":3,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553874,"discussion_content":"32位linux先动的手，intel一看，你们写os的不按套路出牌啊，所以就干脆在设计64位cpu的时候把这块电路给扣了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646124134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324944,"user_name":"『SIGNIFICANT』","can_delete":false,"product_type":"c1","uid":1697419,"ip_address":"","ucode":"1F661466FE5F97","user_header":"https://static001.geekbang.org/account/avatar/00/19/e6/8b/27d0d277.jpg","comment_is_top":false,"comment_ctime":1638752324,"is_pvip":false,"replies":[{"id":"117931","content":"不需要。java程序员的成长建议先学java类库，把算法和数据结构吃透是收益最大的。","user_name":"作者回复","comment_id":324944,"uid":"1360512","ip_address":"","utype":1,"ctime":1638786632,"user_name_real":"编辑"}],"discussion_count":4,"race_medal":0,"score":"10228686916","product_id":100094901,"comment_content":"java程序员一般不会接触到coredump这样的文件分析，一般也就是JVM调优，内存信息dump下来用工具查看，还有必要深入了解这些么","like_count":2,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536454,"discussion_content":"不需要。java程序员的成长建议先学java类库，把算法和数据结构吃透是收益最大的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638786632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2667912,"avatar":"https://static001.geekbang.org/account/avatar/00/28/b5/88/9b65e31c.jpg","nickname":"Y          X","note":"","ucode":"C9926CA7510F3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":544672,"discussion_content":"请问作者，我目前是大四科班应届生以后也是打算从事java 方向，买了这门课 目的也是打算了解一些底层相关的知识，那我应该优先看哪些部分呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641632921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536454,"ip_address":""},"score":544672,"extra":""}]},{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"小李讲源码","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558491,"discussion_content":"不需要深入了解，有个大致的概念就行。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1648347049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1959822,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e7/8e/318cfde0.jpg","nickname":"Spoon","note":"","ucode":"2FF9193AD482C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589302,"discussion_content":"最近遇到了JVM内存占用率高的问题，还是得从底层开始看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664678200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321627,"user_name":".","can_delete":false,"product_type":"c1","uid":1335848,"ip_address":"","ucode":"C0541289C44AF8","user_header":"https://static001.geekbang.org/account/avatar/00/14/62/28/0356880b.jpg","comment_is_top":false,"comment_ctime":1636969133,"is_pvip":false,"replies":[{"id":"117071","content":"OK，请继续关注，我们一定能讲清楚内存屏障是干嘛的。","user_name":"作者回复","comment_id":321627,"uid":"1360512","ip_address":"","utype":1,"ctime":1637375204,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"10226903725","product_id":100094901,"comment_content":"两顿饭钱买到很多知识，期待后面内存模型那块。以前看文章说理解x86内存模式是强类型，所以有部分标准内存屏障是不存在，我一脸懵了好多年。","like_count":2,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531651,"discussion_content":"OK，请继续关注，我们一定能讲清楚内存屏障是干嘛的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637375204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320881,"user_name":"HollyWong","can_delete":false,"product_type":"c1","uid":2837328,"ip_address":"","ucode":"03A66A2BCC0A58","user_header":"https://static001.geekbang.org/account/avatar/00/2b/4b/50/fae00aff.jpg","comment_is_top":false,"comment_ctime":1636538024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10226472616","product_id":100094901,"comment_content":"64位保留段寄存器主要应该是兼容考虑，IA64不兼容32位x86已经得到教训了。","like_count":2},{"had_liked":false,"id":320880,"user_name":"HollyWong","can_delete":false,"product_type":"c1","uid":2837328,"ip_address":"","ucode":"03A66A2BCC0A58","user_header":"https://static001.geekbang.org/account/avatar/00/2b/4b/50/fae00aff.jpg","comment_is_top":false,"comment_ctime":1636537789,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10226472381","product_id":100094901,"comment_content":"碎片问题就是外碎片和内碎片的问题","like_count":2},{"had_liked":false,"id":330122,"user_name":"=","can_delete":false,"product_type":"c1","uid":2600127,"ip_address":"","ucode":"104232A8292220","user_header":"https://static001.geekbang.org/account/avatar/00/27/ac/bf/f549183e.jpg","comment_is_top":false,"comment_ctime":1641805038,"is_pvip":false,"replies":[{"id":"120892","content":"good。带着思考去阅读收获才能更大","user_name":"作者回复","comment_id":330122,"uid":"1360512","ip_address":"","utype":1,"ctime":1642385600,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5936772334","product_id":100094901,"comment_content":"内存碎片以前理解时，只考虑到了段式内存管理会有段间的内存碎片，一直没有考虑到页式内存管理的页内部的内存碎片问题。<br>海老师的这篇文章，从“16位CPU演化到32位CPU后内存管理的变化”的角度讲起，帮助我更好地理解了全局段描述符的问题，之前看x86CPU的GDT等知识，不知其所以然，但是今天从内存管理的角度来看，很清晰！","like_count":1,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546662,"discussion_content":"good。带着思考去阅读收获才能更大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642385600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329718,"user_name":"乘风","can_delete":false,"product_type":"c1","uid":2112229,"ip_address":"","ucode":"D25976CDD1D39B","user_header":"https://static001.geekbang.org/account/avatar/00/20/3a/e5/1a1b08ad.jpg","comment_is_top":false,"comment_ctime":1641500629,"is_pvip":true,"replies":[{"id":"120110","content":"不是。它们都是内存管理的一种思路，既可以用于物理内存也可以用于虚拟内存。你可以这样理解虚拟内存：它和物理内存一样，也是一段地址空间，只是它还需要通过页表进行一次映射而已。对内存的管理，本质上就是对一段地址区间进行管理。再想想？","user_name":"作者回复","comment_id":329718,"uid":"1360512","ip_address":"","utype":1,"ctime":1641535891,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5936467925","product_id":100094901,"comment_content":"段式管理和页式管理都是针对的物理内存是吧，很虚拟内存没关系","like_count":1,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544470,"discussion_content":"不是。它们都是内存管理的一种思路，既可以用于物理内存也可以用于虚拟内存。你可以这样理解虚拟内存：它和物理内存一样，也是一段地址空间，只是它还需要通过页表进行一次映射而已。对内存的管理，本质上就是对一段地址区间进行管理。再想想？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641535892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324413,"user_name":"Geek_d797a2","can_delete":false,"product_type":"c1","uid":2821112,"ip_address":"","ucode":"80027DA49D41BA","user_header":"","comment_is_top":false,"comment_ctime":1638422222,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5933389518","product_id":100094901,"comment_content":"老师好，我从远程终端连接到一台 ubuntu 的机器，内联汇编的例子却没成功。我用 gcc -S 汇编，发现内联的汇编代码都有的，为什么没在终端上打印呢？<br>还有啊，我发现汇编出来的代码，会先把那个ebx需要的参数 1 放在 esi 里，然后再 movl %esi, %ebx  ，这又是什么原因呢？","like_count":1,"discussions":[{"author":{"id":2821112,"avatar":"","nickname":"Geek_d797a2","note":"","ucode":"80027DA49D41BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535872,"discussion_content":"原来是因为 int 只能用在32位中，建议 64 位还是老老实实用 systemcall","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638587071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319666,"user_name":"keepgoing","can_delete":false,"product_type":"c1","uid":1471387,"ip_address":"","ucode":"A2FE0687FB17E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/73/9b/67a38926.jpg","comment_is_top":false,"comment_ctime":1635905614,"is_pvip":false,"replies":[{"id":"115853","content":"你的理解是对的。cpu的设计者是希望大家还继续使用段机制的，但是linux不按套路出牌，弱化了段的作用。linux主要使用页管理，所以，是的，后来的程序员不再使用逻辑地址了。","user_name":"作者回复","comment_id":319666,"uid":"1360512","ip_address":"","utype":1,"ctime":1635920857,"user_name_real":"海纳"}],"discussion_count":4,"race_medal":0,"score":"5930872910","product_id":100094901,"comment_content":"老师，能理解为之后的i386中主要用段式管理（也就是GDT）来管理段类型的区分，比如代码段&#47;数据段，用页式管理（所以GDT中的描述子G值一般都为1）来管理真正的物理内存和虚拟内存的映射吗？<br>如果这样来说的话，我理解段式管理主要来作类型的区分，在i386中程序员自己会去用逻辑地址寻址的场景是否会比较少，主要是什么场景会用到逻辑寻址呢。<br><br>初学小白，听了老师的课比较好奇，如有冒犯或理解不对的地方请老师多多包涵","like_count":1,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529714,"discussion_content":"你的理解是对的。cpu的设计者是希望大家还继续使用段机制的，但是linux不按套路出牌，弱化了段的作用。linux主要使用页管理，所以，是的，后来的程序员不再使用逻辑地址了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635920857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2837328,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/4b/50/fae00aff.jpg","nickname":"HollyWong","note":"","ucode":"03A66A2BCC0A58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413674,"discussion_content":"还是习惯把程序从逻辑上分正代码段和数据段了，这样逻辑上更清晰，可以做到按需分配，代码共享更容易操作 ，这些都是段机制的优点，Linux这样弱化段机制的好处是什么？感觉这时候段表就没什么意义了 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636539021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"小李讲源码","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2837328,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/4b/50/fae00aff.jpg","nickname":"HollyWong","note":"","ucode":"03A66A2BCC0A58","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558493,"discussion_content":"感觉就是想减少逻辑地址，从而都转为虚拟地址，才弱化段的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648348325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":413674,"ip_address":""},"score":558493,"extra":""}]},{"author":{"id":1471387,"avatar":"https://static001.geekbang.org/account/avatar/00/16/73/9b/67a38926.jpg","nickname":"keepgoing","note":"","ucode":"A2FE0687FB17E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411514,"discussion_content":"感谢老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635944072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318609,"user_name":"coder","can_delete":false,"product_type":"c1","uid":2824732,"ip_address":"","ucode":"F85CD7A71EBA0C","user_header":"https://static001.geekbang.org/account/avatar/00/2b/1a/1c/d160d44b.jpg","comment_is_top":false,"comment_ctime":1635347679,"is_pvip":false,"replies":[{"id":"115525","content":"你说得非常对！看了我们的前导课就会明白，x86和arm的寄存器都不一样，所以这个内嵌汇编只能在x86上运行。汇编是不能跨平台的。不过你倒是可以尝试修改一下哦，这就是跨架构移植了：）","user_name":"作者回复","comment_id":318609,"uid":"1360512","ip_address":"","utype":1,"ctime":1635386247,"user_name_real":"氦钠锶"}],"discussion_count":1,"race_medal":0,"score":"5930314975","product_id":100094901,"comment_content":"老师给的例子在x86上可以跑通，arm上不行","like_count":1,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529313,"discussion_content":"你说得非常对！看了我们的前导课就会明白，x86和arm的寄存器都不一样，所以这个内嵌汇编只能在x86上运行。汇编是不能跨平台的。不过你倒是可以尝试修改一下哦，这就是跨架构移植了：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635386247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358745,"user_name":"Spoon","can_delete":false,"product_type":"c1","uid":1959822,"ip_address":"浙江","ucode":"2FF9193AD482C2","user_header":"https://static001.geekbang.org/account/avatar/00/1d/e7/8e/318cfde0.jpg","comment_is_top":false,"comment_ctime":1664678148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664678148","product_id":100094901,"comment_content":"GDT的具体事例可以放一个，光说概念有点空洞；IDT在操作系统里面应该就是一个数组","like_count":0},{"had_liked":false,"id":336930,"user_name":"会爆炸的小米Note","can_delete":false,"product_type":"c1","uid":2150023,"ip_address":"","ucode":"1DA0B740A7C7B7","user_header":"https://static001.geekbang.org/account/avatar/00/20/ce/87/41c44923.jpg","comment_is_top":false,"comment_ctime":1646475620,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646475620","product_id":100094901,"comment_content":"老师好 如果页式管理在虚拟内存层面考虑是不是就既有内部碎片也有外部碎片了呢","like_count":0},{"had_liked":false,"id":336728,"user_name":"Y          X","can_delete":false,"product_type":"c1","uid":2667912,"ip_address":"","ucode":"C9926CA7510F3C","user_header":"https://static001.geekbang.org/account/avatar/00/28/b5/88/9b65e31c.jpg","comment_is_top":false,"comment_ctime":1646318660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646318660","product_id":100094901,"comment_content":"请问作者，我目前是大四科班应届生以后也是打算从事java 方向，买了这门课 目的也是打算了解一些底层相关的知识，那我应该优先看哪些部分呢。","like_count":0},{"had_liked":false,"id":333288,"user_name":"Horizon","can_delete":false,"product_type":"c1","uid":2860223,"ip_address":"","ucode":"A64861EA9697CA","user_header":"https://static001.geekbang.org/account/avatar/00/2b/a4/bf/4ac1f3d0.jpg","comment_is_top":false,"comment_ctime":1644246991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644246991","product_id":100094901,"comment_content":"老师请问一下示例编译报这个错误是什么原因啊<br>hello.c:13:1: 错误：expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ at end of input<br> }I<br> ^","like_count":0},{"had_liked":false,"id":329169,"user_name":"牙齿天天晒太阳","can_delete":false,"product_type":"c1","uid":2817633,"ip_address":"","ucode":"319289611BE05B","user_header":"https://static001.geekbang.org/account/avatar/00/2a/fe/61/2ee87c68.jpg","comment_is_top":false,"comment_ctime":1641194079,"is_pvip":false,"replies":[{"id":"120114","content":"CPU设计的时候就是这样的，这个我也不知道了。40年前，也许是硬件规格限制了，也许是制造工艺限制了，我们也很难考证了。","user_name":"作者回复","comment_id":329169,"uid":"1360512","ip_address":"","utype":1,"ctime":1641536083,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1641194079","product_id":100094901,"comment_content":"8086 的寄存器位宽是 16 位，但地址总线却有 20 位<br>-------------------------------<br>为什么不让寄存器位宽和地址总线相等呢？","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544475,"discussion_content":"CPU设计的时候就是这样的，这个我也不知道了。40年前，也许是硬件规格限制了，也许是制造工艺限制了，我们也很难考证了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641536084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326768,"user_name":"稽山的柚子","can_delete":false,"product_type":"c1","uid":1546579,"ip_address":"","ucode":"E19BCF4604CBB9","user_header":"","comment_is_top":false,"comment_ctime":1639665626,"is_pvip":false,"replies":[{"id":"118968","content":"因为jmp指令的目标地址写的就是段基址，段内偏移这样的格式呀。你加微信群了吗？我在微信群里发过一个视频，讲实模式怎么实验的。你可以加一下，微信上问下。","user_name":"作者回复","comment_id":326768,"uid":"1360512","ip_address":"","utype":1,"ctime":1639928521,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"1639665626","product_id":100094901,"comment_content":"跳转成功以后，cs 段寄存器中的值就是段基址 0x7c0，start2 的偏移值是 8，所以记录当前执行指令地址的 ip 寄存器中的值就是实际地址 0x7c08。<br><br>请问老师 跳转成功以后cs段寄存器的值为什么是0x07c0呢？没有道理呀","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540058,"discussion_content":"因为jmp指令的目标地址写的就是段基址，段内偏移这样的格式呀。你加微信群了吗？我在微信群里发过一个视频，讲实模式怎么实验的。你可以加一下，微信上问下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639928521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1670664,"avatar":"https://static001.geekbang.org/account/avatar/00/19/7e/08/a50945c3.jpg","nickname":"muzigef","note":"","ucode":"BB65A61733D1D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589514,"discussion_content":"求微信群号","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665056686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324806,"user_name":"满分💯","can_delete":false,"product_type":"c1","uid":2758349,"ip_address":"","ucode":"E074D9761DBC23","user_header":"https://static001.geekbang.org/account/avatar/00/2a/16/cd/226cd9f1.jpg","comment_is_top":false,"comment_ctime":1638633565,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638633565","product_id":100094901,"comment_content":"【8086 的寄存器位宽是 16 位，但地址总线却有 20 位】<br>这个设计是由于当时的技术限制，导致寄存器和地址总线位数不相同吗，有没有什么有趣的历史？","like_count":0},{"had_liked":false,"id":321689,"user_name":".","can_delete":false,"product_type":"c1","uid":1335848,"ip_address":"","ucode":"C0541289C44AF8","user_header":"https://static001.geekbang.org/account/avatar/00/14/62/28/0356880b.jpg","comment_is_top":false,"comment_ctime":1636993833,"is_pvip":false,"replies":[{"id":"117069","content":"GDT是一个表，这个表里是有很多项的，也有就是有很多全局描述符。表只有一个哈。我们先来对齐一下这个概念。然后Linux为每个进程都准备了各种段描述符，有的是全局的，有的是局部的。它们都被映射到了0~4G这个区域，但是权限不同。仅此而已。所以你看，这已经是一个不重要的概念了。你可以搞任意多个去描述内核数据段，内核代码段，内核堆栈段，这不是一个固定的机制。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1637375117,"ip_address":"","comment_id":321689,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636993833","product_id":100094901,"comment_content":"老师我不知道我理解的对不对。段页式管理就是将GDT设置为1并且设置GDT为最大的长度为4G.然后再页内通过操作系统手动再去细化内存的为段管理方式？<br><br>假设我电脑8G 使用段页式管理。linux操作系统会有两个GDT？<br>假设我电脑只有4G使用段页式管理那么GDT只有一个？如果只有一个GDT如何区分内核内存区域和用户态内存区域？因为我看文章GDT是可以标志出这块内存是否为内核内存","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531649,"discussion_content":"GDT是一个表，这个表里是有很多项的，也有就是有很多全局描述符。表只有一个哈。我们先来对齐一下这个概念。然后Linux为每个进程都准备了各种段描述符，有的是全局的，有的是局部的。它们都被映射到了0~4G这个区域，但是权限不同。仅此而已。所以你看，这已经是一个不重要的概念了。你可以搞任意多个去描述内核数据段，内核代码段，内核堆栈段，这不是一个固定的机制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637375117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320189,"user_name":"小时候可鲜啦","can_delete":false,"product_type":"c1","uid":1050777,"ip_address":"","ucode":"C88B3EDF758230","user_header":"https://static001.geekbang.org/account/avatar/00/10/08/99/6ab45a2f.jpg","comment_is_top":false,"comment_ctime":1636113131,"is_pvip":false,"replies":[{"id":"116145","content":"下电状态是指关机。上电可以理解为开机。这句话的意思是，CPU在开机以后先工作在实模式下，需要操作系统来负责进入保护模式。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1636279034,"ip_address":"","comment_id":320189,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636113131","product_id":100094901,"comment_content":"“X86 架构的 CPU 在上电以后，为了与 8086 保持兼容，还是运行在 16 位实模式下”，这句话的意思是用户模式下的cpu处于下电状态？下电不是不工作了吗","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529912,"discussion_content":"下电状态是指关机。上电可以理解为开机。这句话的意思是，CPU在开机以后先工作在实模式下，需要操作系统来负责进入保护模式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636279034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}