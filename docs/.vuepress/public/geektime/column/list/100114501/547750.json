{"id":547750,"title":"26｜StatefulSet：怎么管理有状态的应用？","content":"<p>你好，我是Chrono。</p><p>在中级篇里，我们学习了Deployment和DaemonSet两种API对象，它们是在Kubernetes集群里部署应用的重要工具，不过它们也有一个缺点，只能管理“无状态应用”（Stateless Application），不能管理“有状态应用”（Stateful Application）。</p><p>“有状态应用”的处理比较复杂，要考虑的事情很多，但是这些问题我们其实可以通过组合之前学过的Deployment、Service、PersistentVolume等对象来解决。</p><p>今天我们就来研究一下什么是“有状态应用”，然后看看Kubernetes为什么会设计一个新对象——StatefulSet来专门管理“有状态应用”。</p><h2>什么是有状态的应用</h2><p>我们先从PersistentVolume谈起，它为Kubernetes带来了持久化存储的功能，能够让应用把数据存放在本地或者远程的磁盘上。</p><p>那么你有没有想过，持久化存储，对应用来说，究竟意味着什么呢？</p><p>有了持久化存储，应用就可以把一些运行时的关键数据落盘，相当于有了一份“保险”，如果Pod发生意外崩溃，也只不过像是按下了暂停键，等重启后挂载Volume，再加载原数据就能够满血复活，恢复之前的“状态”继续运行。</p><!-- [[[read_end]]] --><p>注意到了吗？这里有一个关键词——“<strong>状态</strong>”，应用保存的数据，实际上就是它某个时刻的“运行状态”。</p><p>所以从这个角度来说，理论上任何应用都是有状态的。</p><p>只是有的应用的状态信息不是很重要，即使不恢复状态也能够正常运行，这就是我们常说的“<strong>无状态应用</strong>”。“无状态应用”典型的例子就是Nginx这样的Web服务器，它只是处理HTTP请求，本身不生产数据（日志除外），不需要特意保存状态，无论以什么状态重启都能很好地对外提供服务。</p><p>还有一些应用，运行状态信息就很重要了，如果因为重启而丢失了状态是绝对无法接受的，这样的应用就是“<strong>有状态应用</strong>”。</p><p>“有状态应用”的例子也有很多，比如Redis、MySQL这样的数据库，它们的“状态”就是在内存或者磁盘上产生的数据，是应用的核心价值所在，如果不能够把这些数据及时保存再恢复，那绝对会是灾难性的后果。</p><p>理解了这一点，我们结合目前学到的知识思考一下：<strong>Deployment加上PersistentVolume，在Kubernetes里是不是可以轻松管理有状态的应用了呢？</strong></p><p>的确，用Deployment来保证高可用，用PersistentVolume来存储数据，确实可以部分达到管理“有状态应用”的目的（你可以自己试着编写这样的YAML）。</p><p>但是Kubernetes的眼光则更加全面和长远，它认为“状态”不仅仅是数据持久化，在集群化、分布式的场景里，还有多实例的依赖关系、启动顺序和网络标识等问题需要解决，而这些问题恰恰是Deployment力所不及的。</p><p>因为只使用Deployment，多个实例之间是无关的，启动的顺序不固定，Pod的名字、IP地址、域名也都是完全随机的，这正是“无状态应用”的特点。</p><p>但对于“有状态应用”，多个实例之间可能存在依赖关系，比如master/slave、active/passive，需要依次启动才能保证应用正常运行，外界的客户端也可能要使用固定的网络标识来访问实例，而且这些信息还必须要保证在Pod重启后不变。</p><p>所以，Kubernetes就在Deployment的基础之上定义了一个新的API对象，名字也很好理解，就叫StatefulSet，专门用来管理有状态的应用。</p><h2>如何使用YAML描述StatefulSet</h2><p>首先我们还是用命令 <code>kubectl api-resources</code> 来查看StatefulSet的基本信息，可以知道它的简称是 <code>sts</code>，YAML文件头信息是：</p><pre><code class=\"language-yaml\">apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n&nbsp; name: xxx-sts\n</code></pre><p>和DaemonSet类似，StatefulSet也可以看做是Deployment的一个特例，它也不能直接用 <code>kubectl create</code> 创建样板文件，但它的对象描述和Deployment差不多，你同样可以把Deployment适当修改一下，就变成了StatefulSet对象。</p><p>这里我给出了一个使用Redis的StatefulSet，你来看看它与Deployment有什么差异：</p><pre><code class=\"language-yaml\">apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n&nbsp; name: redis-sts\n\nspec:\n&nbsp; serviceName: redis-svc\n&nbsp; replicas: 2\n&nbsp; selector:\n&nbsp; &nbsp; matchLabels:\n&nbsp; &nbsp; &nbsp; app: redis-sts\n\n&nbsp; template:\n&nbsp; &nbsp; metadata:\n&nbsp; &nbsp; &nbsp; labels:\n&nbsp; &nbsp; &nbsp; &nbsp; app: redis-sts\n&nbsp; &nbsp; spec:\n&nbsp; &nbsp; &nbsp; containers:\n&nbsp; &nbsp; &nbsp; - image: redis:5-alpine\n&nbsp; &nbsp; &nbsp; &nbsp; name: redis\n&nbsp; &nbsp; &nbsp; &nbsp; ports:\n&nbsp; &nbsp; &nbsp; &nbsp; - containerPort: 6379\n</code></pre><p>我们会发现，YAML文件里除了 <code>kind</code> 必须是“<strong>StatefulSet</strong>”，在 <code>spec</code> 里还多出了一个“<strong>serviceName</strong>”字段，其余的部分和Deployment是一模一样的，比如 <code>replicas</code>、<code>selector</code>、<code>template</code> 等等。</p><p>这两个不同之处其实就是StatefulSet与Deployment的关键区别。想要真正理解这一点，我们得结合StatefulSet在Kubernetes里的使用方法来分析。</p><h2>如何在Kubernetes里使用StatefulSet</h2><p>让我们用 <code>kubectl apply</code> 创建StatefulSet对象，用 <code>kubectl get</code> 先看看它是什么样的：</p><pre><code class=\"language-plain\">kubectl apply -f redis-sts.yml\nkubectl get sts\nkubectl get pod\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/71/88/71b485401dca6946fe4788fa97e3fd88.png?wh=1268x414\" alt=\"图片\"></p><p>从截图里，你应该能够看到，StatefulSet所管理的Pod不再是随机的名字了，而是有了顺序编号，从0开始分别被命名为 <code>redis-sts-0</code>、<code>redis-sts-1</code>，Kubernetes也会按照这个顺序依次创建（0号比1号的AGE要长一点），这就解决了<strong>“有状态应用”的第一个问题：启动顺序</strong>。</p><p>有了启动的先后顺序，应用该怎么知道自己的身份，进而确定互相之间的依赖关系呢？</p><p>Kubernetes给出的方法是<strong>使用hostname</strong>，也就是每个Pod里的主机名，让我们再用 <code>kubectl exec</code> 登录Pod内部看看：</p><pre><code class=\"language-plain\">kubectl exec -it redis-sts-0 -- sh\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/be/39/be44f94eaf07f3591c7a2a8b9cdd1739.png?wh=1308x468\" alt=\"图片\"></p><p>在Pod里查看环境变量 <code>$HOSTNAME</code> 或者是执行命令 <code>hostname</code>，都可以得到这个Pod的名字 <code>redis-sts-0</code>。</p><p>有了这个唯一的名字，应用就可以自行决定依赖关系了，比如在这个Redis例子里，就可以让先启动的0号Pod是主实例，后启动的1号Pod是从实例。</p><p>解决了启动顺序和依赖关系，还剩下<strong>第三个问题：网络标识，这就需要用到Service对象</strong>。</p><p>不过这里又有一点奇怪的地方，我们不能用命令 <code>kubectl expose</code> 直接为StatefulSet生成Service，只能手动编写YAML。但是这肯定难不倒你，经过了这么多练习，现在你应该能很轻松地写出一个Service对象。</p><p>因为不能自动生成，你在写Service对象的时候要小心一些，<code>metadata.name</code> 必须和StatefulSet里的 <code>serviceName</code> 相同，<code>selector</code> 里的标签也必须和StatefulSet里的一致：</p><pre><code class=\"language-yaml\">apiVersion: v1\nkind: Service\nmetadata:\n&nbsp; name: redis-svc\n\nspec:\n&nbsp; selector:\n&nbsp; &nbsp; app: redis-sts\n\n&nbsp; ports:\n&nbsp; - port: 6379\n&nbsp; &nbsp; protocol: TCP\n&nbsp; &nbsp; targetPort: 6379\n</code></pre><p>写好Service之后，还是用 <code>kubectl apply</code> 创建这个对象：</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/c8/5f8e4dbedaa563801bb6bbe09c441dc8.png?wh=1584x1056\" alt=\"图片\"></p><p>可以看到这个Service并没有什么特殊的地方，也是用标签选择器找到StatefulSet管理的两个Pod，然后找到它们的IP地址。</p><p>不过，StatefulSet的奥秘就在它的域名上。</p><p>还记得在<a href=\"https://time.geekbang.org/column/article/536829\">第20讲</a>里我们说过的Service的域名用法吗？Service自己会有一个域名，格式是“<strong>对象名.名字空间</strong>”，每个Pod也会有一个域名，形式是“<strong>IP地址.名字空间</strong>”。但因为IP地址不稳定，所以Pod的域名并不实用，一般我们会使用稳定的Service域名。</p><p>当我们把Service对象应用于StatefulSet的时候，情况就不一样了。</p><p>Service发现这些Pod不是一般的应用，而是有状态应用，需要有稳定的网络标识，所以就会为Pod再多创建出一个新的域名，格式是“<strong>Pod名.服务名.名字空间.svc.cluster.local</strong>”。当然，这个域名也可以简写成“<strong>Pod名.服务名</strong>”。</p><p>我们还是用 <code>kubectl exec</code> 进入Pod内部，用ping命令来验证一下：</p><pre><code class=\"language-plain\">kubectl exec -it redis-sts-0 -- sh\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/f1/39/f1b058b5fb3e5218c638ca0534b92439.png?wh=1524x1338\" alt=\"图片\"></p><p>显然，在StatefulSet里的这两个Pod都有了各自的域名，也就是稳定的网络标识。那么接下来，外部的客户端只要知道了StatefulSet对象，就可以用固定的编号去访问某个具体的实例了，虽然Pod的IP地址可能会变，但这个有编号的域名由Service对象维护，是稳定不变的。</p><p>到这里，通过StatefulSet和Service的联合使用，Kubernetes就解决了“有状态应用”的依赖关系、启动顺序和网络标识这三个问题，剩下的多实例之间内部沟通协调等事情就需要应用自己去想办法处理了。</p><p>关于Service，有一点值得再多提一下。</p><p>Service原本的目的是负载均衡，应该由它在Pod前面来转发流量，但是对StatefulSet来说，这项功能反而是不必要的，因为Pod已经有了稳定的域名，外界访问服务就不应该再通过Service这一层了。所以，从安全和节约系统资源的角度考虑，<strong>我们可以在Service里添加一个字段 <code>clusterIP: None</code> ，告诉Kubernetes不必再为这个对象分配IP地址</strong>。</p><p>我画了一张图展示StatefulSet与Service对象的关系，你可以参考一下它们字段之间的互相引用：</p><p><img src=\"https://static001.geekbang.org/resource/image/49/22/490d814cf0f25db56537a20f3af57e22.jpg?wh=1920x1094\" alt=\"图片\"></p><h2>如何实现StatefulSet的数据持久化</h2><p>现在StatefulSet已经有了固定的名字、启动顺序和网络标识，只要再给它加上数据持久化功能，我们就可以实现对“有状态应用”的管理了。</p><p>这里就能用到上一节课里学的PersistentVolume和NFS的知识，我们可以很容易地定义StorageClass，然后编写PVC，再给Pod挂载Volume。</p><p>不过，为了强调持久化存储与StatefulSet的一对一绑定关系，Kubernetes为StatefulSet专门定义了一个字段“<strong>volumeClaimTemplates</strong>”，直接把PVC定义嵌入StatefulSet的YAML文件里。这样能保证创建StatefulSet的同时，就会为每个Pod自动创建PVC，让StatefulSet的可用性更高。</p><p>“<strong>volumeClaimTemplates</strong>”这个字段好像有点难以理解，你可以把它和Pod的 <code>template</code>、Job的 <code>jobTemplate</code> 对比起来学习，它其实也是一个“套娃”的对象组合结构，里面就是应用了StorageClass的普通PVC而已。</p><p>让我们把刚才的Redis StatefulSet对象稍微改造一下，加上持久化存储功能：</p><pre><code class=\"language-yaml\">apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n&nbsp; name: redis-pv-sts\n\nspec:\n&nbsp; serviceName: redis-pv-svc\n\n&nbsp; volumeClaimTemplates:\n&nbsp; - metadata:\n&nbsp; &nbsp; &nbsp; name: redis-100m-pvc\n&nbsp; &nbsp; spec:\n&nbsp; &nbsp; &nbsp; storageClassName: nfs-client\n&nbsp; &nbsp; &nbsp; accessModes:\n&nbsp; &nbsp; &nbsp; &nbsp; - ReadWriteMany\n&nbsp; &nbsp; &nbsp; resources:\n&nbsp; &nbsp; &nbsp; &nbsp; requests:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; storage: 100Mi\n\n&nbsp; replicas: 2\n&nbsp; selector:\n&nbsp; &nbsp; matchLabels:\n&nbsp; &nbsp; &nbsp; app: redis-pv-sts\n\n&nbsp; template:\n&nbsp; &nbsp; metadata:\n&nbsp; &nbsp; &nbsp; labels:\n&nbsp; &nbsp; &nbsp; &nbsp; app: redis-pv-sts\n&nbsp; &nbsp; spec:\n&nbsp; &nbsp; &nbsp; containers:\n&nbsp; &nbsp; &nbsp; - image: redis:5-alpine\n&nbsp; &nbsp; &nbsp; &nbsp; name: redis\n&nbsp; &nbsp; &nbsp; &nbsp; ports:\n&nbsp; &nbsp; &nbsp; &nbsp; - containerPort: 6379\n\n&nbsp; &nbsp; &nbsp; &nbsp; volumeMounts:\n&nbsp; &nbsp; &nbsp; &nbsp; - name: redis-100m-pvc\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mountPath: /data\n</code></pre><p>这个YAML文件比较长，内容比较多，不过你只要有点耐心，分功能模块逐个去看也能很快看明白。</p><p>首先StatefulSet对象的名字是 <code>redis-pv-sts</code>，表示它使用了PV存储。然后“volumeClaimTemplates”里定义了一个PVC，名字是 <code>redis-100m-pvc</code>，申请了100MB的NFS存储。在Pod模板里用 <code>volumeMounts</code> 引用了这个PVC，把网盘挂载到了 <code>/data</code> 目录，也就是Redis的数据目录。</p><p>下面的这张图就是这个StatefulSet对象完整的关系图：<br>\n<img src=\"https://static001.geekbang.org/resource/image/1a/0f/1a06987c87f3db948b591883a81bac0f.jpg?wh=4000x2946\" alt=\"\"></p><p>最后使用 <code>kubectl apply</code> 创建这些对象，一个带持久化功能的“有状态应用”就算是运行起来了：</p><pre><code class=\"language-plain\">kubectl apply -f redis-pv-sts.yml\n</code></pre><p>你可以使用命令 <code>kubectl get pvc</code> 来查看StatefulSet关联的存储卷状态：</p><p><img src=\"https://static001.geekbang.org/resource/image/33/f5/33eee3c5a5033e4bf73f5003669c4ff5.png?wh=1920x189\" alt=\"图片\"></p><p>看这两个PVC的命名，不是随机的，是有规律的，用的是PVC名字加上StatefulSet的名字组合而成，所以即使Pod被销毁，因为它的名字不变，还能够找到这个PVC，再次绑定使用之前存储的数据。</p><p>那我们就来实地验证一下吧，用 <code>kubectl exec</code> 运行Redis的客户端，在里面添加一些KV数据：</p><pre><code class=\"language-plain\">kubectl exec -it redis-pv-sts-0 -- redis-cli\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/94/b7/94a96b1b8a000dcd852d2ea11yy8ddb7.png?wh=1562x530\" alt=\"图片\"></p><p>这里我设置了两个值，分别是 <code>a=111</code> 和 <code>b=222</code>。</p><p>现在我们模拟意外事故，删除这个Pod：</p><pre><code class=\"language-plain\">kubectl delete pod redis-pv-sts-0\n</code></pre><p>由于StatefulSet和Deployment一样会监控Pod的实例，发现Pod数量少了就会很快创建出新的Pod，并且名字、网络标识也都会和之前的Pod一模一样：</p><p><img src=\"https://static001.geekbang.org/resource/image/52/23/52e2f02a1d80d8bba2a42c8258cda923.png?wh=1300x236\" alt=\"图片\"></p><p>那Redis里存储的数据怎么样了呢？是不是真的用到了持久化存储，也完全恢复了呢？</p><p>你可以再用Redis客户端登录去检查一下：</p><pre><code class=\"language-plain\">kubectl exec -it redis-pv-sts-0 -- redis-cli\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/c7/08/c78ca845ee20459dd2d8bayy3db71808.png?wh=1544x530\" alt=\"图片\"></p><p>因为我们把NFS网络存储挂载到了Pod的 <code>/data</code> 目录，Redis就会定期把数据落盘保存，所以新创建的Pod再次挂载目录的时候会从备份文件里恢复数据，内存里的数据就恢复原状了。</p><h2>小结</h2><p>好了，今天我们学习了专门部署“有状态应用”的API对象StatefulSet，它与Deployment非常相似，区别是由它管理的Pod会有固定的名字、启动顺序和网络标识，这些特性对于在集群里实施有主从、主备等关系的应用非常重要。</p><p>我再简单小结一下今天的内容：</p><ol>\n<li>StatefulSet的YAML描述和Deployment几乎完全相同，只是多了一个关键字段 <code>serviceName</code>。</li>\n<li>要为StatefulSet里的Pod生成稳定的域名，需要定义Service对象，它的名字必须和StatefulSet里的 <code>serviceName</code> 一致。</li>\n<li>访问StatefulSet应该使用每个Pod的单独域名，形式是“Pod名.服务名”，不应该使用Service的负载均衡功能。</li>\n<li>在StatefulSet里可以用字段“volumeClaimTemplates”直接定义PVC，让Pod实现数据持久化存储。</li>\n</ol><h2>课下作业</h2><p>最后是课下作业时间，给你留两个思考题：</p><ol>\n<li>有了StatefulSet提供的固定名字和启动顺序，应用还需要怎么做才能实现主从等依赖关系呢？</li>\n<li>是否可以不使用“volumeClaimTemplates”内嵌定义PVC呢？会有什么样的后果呢？</li>\n</ol><p>欢迎在留言区参与讨论，分享你的想法。我们下节课再见。</p><p><img src=\"https://static001.geekbang.org/resource/image/88/e5/884a5c91b82cb515c856ce2ece6a91e5.jpg?wh=1920x1544\" alt=\"图片\"></p>","comments":[{"had_liked":false,"id":367389,"user_name":"Lorry","can_delete":false,"product_type":"c1","uid":1066409,"ip_address":"北京","ucode":"BD4754D0F1D786","user_header":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","comment_is_top":false,"comment_ctime":1675181212,"is_pvip":false,"replies":[{"id":133837,"content":"great.","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1675240175,"ip_address":"上海","comment_id":367389,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"Pod负责服务，Job负责调度，\nDaemon&#47;Deployment负责无状态部署，StatefulSet负责状态部署，\nService负责四层访问（负载均衡、IP分配、域名访问），Ingress负责应用层（7层）访问（路由规则），\nPVC&#47;PV负责可靠性存储。\n\nK8s提供的解决方案基本就是代表了微服务部署的最佳实践了。","like_count":10,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601491,"discussion_content":"great.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675240175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3252934,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIuj7Wx21ecNlPHCfBsQIchmFxVSlPepwUiaKh0RMGgDB0aibTM50ibQN06dDmbqjuQZUIdH4qiaRJkgQ/132","nickname":"Geek_adb513","note":"","ucode":"02432C80700001","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630689,"discussion_content":"这个service无法提供域名访问，4层的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698798224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355205,"user_name":"YueShi","can_delete":false,"product_type":"c1","uid":1625530,"ip_address":"北京","ucode":"8F7AFAE4641A7D","user_header":"https://static001.geekbang.org/account/avatar/00/18/cd/ba/3a348f2d.jpg","comment_is_top":false,"comment_ctime":1661170032,"is_pvip":true,"replies":[{"id":129246,"content":"Redis的主从部署直接用StatefulSet来实现还是很麻烦的，这个可能用operator来做会比较简单。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1661217344,"ip_address":"北京","comment_id":355205,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"好奇redis的主从，哨兵，cluster都是怎么在sts上实现的，打算抽个时间深入的学习一下。\n\nbtw，越学习越能理解到 老师讲的“云原生”的概念了","like_count":10,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584907,"discussion_content":"Redis的主从部署直接用StatefulSet来实现还是很麻烦的，这个可能用operator来做会比较简单。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661217344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356206,"user_name":"摊牌","can_delete":false,"product_type":"c1","uid":1453182,"ip_address":"上海","ucode":"F142596BFE4594","user_header":"https://static001.geekbang.org/account/avatar/00/16/2c/7e/f1efd18b.jpg","comment_is_top":false,"comment_ctime":1662041189,"is_pvip":false,"replies":[{"id":129666,"content":"不行，域名必须通过Service对象才能实现，可以自己试试没有Service对象会怎么样。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1662086637,"ip_address":"上海","comment_id":356206,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"老师，既然statefulSet对象管理的pod可以直接通过域名指定来访问，那可不可以 不给statefulSet对象创建service","like_count":7,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586271,"discussion_content":"不行，域名必须通过Service对象才能实现，可以自己试试没有Service对象会怎么样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662086637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1087243,"avatar":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","nickname":"zhou","note":"","ucode":"E1CE8575B3F106","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":592353,"discussion_content":"直接通过pod域名访问，如何做的到高可用，负载均衡","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1667348183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":586271,"ip_address":"浙江","group_id":0},"score":592353,"extra":""}]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612653,"discussion_content":"一般不直接用pod的域名访问，但kubernetes不限制这么做。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680833113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":362709,"user_name":"Bachue Zhou","can_delete":false,"product_type":"c1","uid":1494491,"ip_address":"北京","ucode":"3175754775CA32","user_header":"https://static001.geekbang.org/account/avatar/00/16/cd/db/7467ad23.jpg","comment_is_top":false,"comment_ctime":1668771289,"is_pvip":false,"replies":[{"id":131929,"content":"StatefulSet的功能还是比较弱的，直接用还不是很方便，所以后来才出了operator等等，但StatefulSet无疑是基础。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1668908243,"ip_address":"北京","comment_id":362709,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"我感觉 statefulset 起到的作用相比于普通的 systemd 差不多，特别是对于数据库这种真正有状态的服务而言，实例运行的节点通常是固定的，因为对硬件的要求要比普通的节点高很多，且在生产环境不可能用任何基于网络的文件系统来存储数据库文件。由于节点固定，所以 ip 也就固定，没必要非用域名来访问，而且现在有些服务本来也实现了服务发现，客户端连接集群的任意实例都可以获取完整集群节点的 ip 就可以直连，改用域名反而不太直接，statefulset 也不能让主从配置或是sharding配置变得更方便。","like_count":5,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594226,"discussion_content":"StatefulSet的功能还是比较弱的，直接用还不是很方便，所以后来才出了operator等等，但StatefulSet无疑是基础。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1668908243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356208,"user_name":"摊牌","can_delete":false,"product_type":"c1","uid":1453182,"ip_address":"上海","ucode":"F142596BFE4594","user_header":"https://static001.geekbang.org/account/avatar/00/16/2c/7e/f1efd18b.jpg","comment_is_top":false,"comment_ctime":1662042330,"is_pvip":false,"replies":[{"id":129667,"content":"good","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1662086655,"ip_address":"上海","comment_id":356208,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"有了 StatefulSet 提供的固定名字和启动顺序，应用还需要怎么做才能实现主从等依赖关系呢？\n\n答：我理解是采用StatefulSet对象管理多个（2n+1）有状态pod的情形下，应该在有状态应用中基于pod的固定名字进行实例通信交互，比如redis集群中节点之间通过Gossip协议进行广播自身的状态信息，从而完成实例之间依赖关系，保证集群的可用性","like_count":5,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586272,"discussion_content":"good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662086655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364432,"user_name":"陈斯佳","can_delete":false,"product_type":"c1","uid":1259323,"ip_address":"上海","ucode":"C236F874FC767A","user_header":"https://static001.geekbang.org/account/avatar/00/13/37/3b/495e2ce6.jpg","comment_is_top":false,"comment_ctime":1670981077,"is_pvip":false,"replies":[{"id":132475,"content":"operator比较复杂，可能在我们这个课里不会细讲了。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1670989620,"ip_address":"上海","comment_id":364432,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"老师 能讲解一下什么是operator吗？","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":596439,"discussion_content":"operator比较复杂，可能在我们这个课里不会细讲了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670989621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357518,"user_name":"dao","can_delete":false,"product_type":"c1","uid":1087879,"ip_address":"北京","ucode":"4181FB270462CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/87/5066026c.jpg","comment_is_top":false,"comment_ctime":1663325266,"is_pvip":false,"replies":[{"id":130114,"content":"\n1. 用StatefulSet实现主从还是比较麻烦的，可以根据hostname，在镜像里编写脚本来启动不同的逻辑。\n\n2.正确。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1663332897,"ip_address":"北京","comment_id":357518,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"作业：\n1. 这个应该具体应用具体设置吧。比如 Redis ，需要给 主、从 实例加载不同的 conf 。以我目前的 kube 知识我不知道如何给不同的副本使用不同的配置文件。我只能使用临时命令实现主从 kubectl exec -it redis-pv-sts-1 -- redis-cli replicaof redis-pv-sts-0.redis-svc 6379 。\n2. 若不使用“volumeClaimTemplates”内嵌定义 PVC，那么可能的后果就是，多个副本挂载同一个网络存储设备，这可能会导致数据丢失。","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587877,"discussion_content":"\n1. 用StatefulSet实现主从还是比较麻烦的，可以根据hostname，在镜像里编写脚本来启动不同的逻辑。\n\n2.正确。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663332897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364133,"user_name":"泽","can_delete":false,"product_type":"c1","uid":2858725,"ip_address":"上海","ucode":"44A1D076F59D60","user_header":"https://static001.geekbang.org/account/avatar/00/2b/9e/e5/9e732ec1.jpg","comment_is_top":false,"comment_ctime":1670568783,"is_pvip":false,"replies":[{"id":132370,"content":"我对helm了解不是太深，简单讲讲倒是可以，但可能只是大概的介绍，有时间会写一篇。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1670571218,"ip_address":"上海","comment_id":364133,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"老师 求您个事 ，讲讲helm吧，迫切想学","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":596036,"discussion_content":"我对helm了解不是太深，简单讲讲倒是可以，但可能只是大概的介绍，有时间会写一篇。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670571218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2150926,"avatar":"https://static001.geekbang.org/account/avatar/00/20/d2/0e/579fc19b.jpg","nickname":"conorzhong","note":"","ucode":"A2AAE8B6B41031","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":597753,"discussion_content":"同求","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672209110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":596036,"ip_address":"浙江","group_id":0},"score":597753,"extra":""},{"author":{"id":3602392,"avatar":"https://static001.geekbang.org/account/avatar/00/36/f7/d8/dc437147.jpg","nickname":"So what?","note":"","ucode":"A15C7E39BF16A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":622285,"discussion_content":"同求","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688057541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":596036,"ip_address":"陕西","group_id":0},"score":622285,"extra":""}]},{"author":{"id":1810497,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/pHPfugzib71LOuAUcwtb64tiaPxCjAIkFu35oznsQjup0e8J2L0uMJloMQk4kJ5xh6NujzMFBI3FD5skdlU3TgYA/132","nickname":"一路向北","note":"","ucode":"337ADE78A1316B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599917,"discussion_content":"小伙子求知若渴啊，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673864048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360569,"user_name":"rubys_","can_delete":false,"product_type":"c1","uid":1394115,"ip_address":"上海","ucode":"931AD02864126A","user_header":"https://static001.geekbang.org/account/avatar/00/15/45/c3/775fe460.jpg","comment_is_top":false,"comment_ctime":1666666651,"is_pvip":false,"replies":[{"id":131179,"content":"有的时候coredns会有错误，可以删除重启，或者用rollout restart。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1666668942,"ip_address":"上海","comment_id":360569,"utype":1}],"discussion_count":1,"race_medal":2,"score":2,"product_id":100114501,"comment_content":"在我的虚拟机上 ping redis-sts-1.redis-svc 失败，一种解决方案是，kubectl get pod -o wide -n kube-system 找到 coredns 的 pod，然后删除那两个 pod，比如 kubectl delete pod coredns-65c54cc984-qlkt9 -n kube-system。等待 k8s 重新创建 coredns 的 pod 就可以 ping 了","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591578,"discussion_content":"有的时候coredns会有错误，可以删除重启，或者用rollout restart。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1666668943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355291,"user_name":"小宝","can_delete":false,"product_type":"c1","uid":1402330,"ip_address":"北京","ucode":"A7223A477C60C9","user_header":"https://static001.geekbang.org/account/avatar/00/15/65/da/29fe3dde.jpg","comment_is_top":false,"comment_ctime":1661250650,"is_pvip":false,"replies":[{"id":129274,"content":"good","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1661295866,"ip_address":"北京","comment_id":355291,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"“访问 StatefulSet 应该使用每个 Pod 的单独域名，形式是“Pod 名. 服务名”，不应该使用 Service 的负载均衡功能。”\n请教老师，通常会在StatefulSet上创建一个Headless Service吧，作为pod的负载均衡。","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585021,"discussion_content":"good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661295866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393816,"user_name":"起司猫","can_delete":false,"product_type":"c1","uid":1018670,"ip_address":"广西","ucode":"D86EF6FBA10EAC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/2e/df74d56a.jpg","comment_is_top":false,"comment_ctime":1724984230,"is_pvip":false,"replies":[{"id":142989,"content":"great！","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1724993047,"ip_address":"北京","comment_id":393816,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100114501,"comment_content":"说说自己的总结和理解（都 2024 了，还有人在学这个课程吗哈哈哈）：\n1. StatefulSet 是被设计来用于管理有状态的应用的，而有状态的应用需要处理“启动顺序”、“依赖关系”、“网络标识”三个问题。\n2. StatefulSet 通过 把 pod 的名称、pod 所在的主机名、 pod 域名进行了有规律的命名，通过 “[sts名]-[顺序号]”的方式对上述几个名称进行命名，使得用户能够通过 名称 和 顺序号 确认副本的身份和进行特定的处理。\n3. StatefulSet 的场景下，不能通过 service 的域名去访问 pod，因为在有状态的一组应用中，访问的顺序、访问哪一个应用，应该是跟具体业务场景相关的，service 并不能帮你去做选择。\n4. StatefulSet 的 pod 不需要分配 clusterIP，正如第 3 点中说的，用户要根据自己的业务场景去判断要访问哪个pod副本， 而 IP 不具备身份特征，并且原来 service 那样给 pod 分配 [对象名&#47;IP-local] 这种域名，同样不具备身份特征。这时候 headless-service 必须重新给 pod 分配具有身份特征的域名。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650442,"discussion_content":"great！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1724993048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393790,"user_name":"sgcls","can_delete":false,"product_type":"c1","uid":1255198,"ip_address":"广东","ucode":"F359E943BF6D14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erRCf8vWbWibajdSaMtCM1OzPQ6uPhblgL4zXJvKoaQYVmialqFqr0NIdD6Dlm1F5icOBxiaXvUcQs4BA/132","comment_is_top":false,"comment_ctime":1724902818,"is_pvip":false,"replies":[{"id":142984,"content":"good","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1724923978,"ip_address":"上海","comment_id":393790,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100114501,"comment_content":"1.容器启动脚本对环境变量（如 hostname）的不同取值，设定不同的启动参数，如 if hostname=redis-sts-0 时，添加 --master\n2.使用独立定义的 PVC(kind: PersistentVolumeClaim)，生成的 pvc 名称就不是固定的了，Pod 重建后使用的 pvc 可能不是之前的 pvc，就出现了状态不一致（PV）","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650409,"discussion_content":"good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1724923978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":392899,"user_name":"王旧业","can_delete":false,"product_type":"c1","uid":1013076,"ip_address":"美国","ucode":"A8DEC38430D007","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/54/73cc7f73.jpg","comment_is_top":false,"comment_ctime":1722093413,"is_pvip":false,"replies":[{"id":142731,"content":"有一些历史原因……","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1722296708,"ip_address":"北京","comment_id":392899,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100114501,"comment_content":"有时候很难理解， 怎么这些API对象针对是否能够通过kubectl create创建yaml样本方面没有拉齐，做到一致多好哈","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":648839,"discussion_content":"有一些历史原因……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1722296708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377829,"user_name":"ray","can_delete":false,"product_type":"c1","uid":1717235,"ip_address":"中国台湾","ucode":"10962C711CBC11","user_header":"","comment_is_top":false,"comment_ctime":1689308904,"is_pvip":false,"replies":[{"id":137731,"content":"一般不建议，kubernetes虽然有stateful set，但要用来维护有复杂状态的应用还是有点弱，也许以后会有改善。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1689555462,"ip_address":"北京","comment_id":377829,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100114501,"comment_content":"老师您好，\n请问老师会建议把rdbms, redis, queue这类需要维护状态的服务放入k8s一起管理吗？\n这类服务通常都需要放在特定规格的机器上，不像一般的pod比较能随意游移到不同节点。\n虽说k8s可以匹配stateful set到特定节点，但我们仍需考虑cluster、备援、故障恢复等情境，加入这些考量后，就不太清楚是否该将上述服务放入k8s。\n再麻烦老师解答～\n\n谢谢老师＾＾","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623480,"discussion_content":"一般不建议，kubernetes虽然有stateful set，但要用来维护有复杂状态的应用还是有点弱，也许以后会有改善。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1689555462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374297,"user_name":"泰一","can_delete":false,"product_type":"c1","uid":1757959,"ip_address":"北京","ucode":"D85C764BA108CE","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d3/07/5fc3c694.jpg","comment_is_top":false,"comment_ctime":1683863981,"is_pvip":false,"replies":[{"id":136710,"content":"用是当然可以用，只是域名不稳定而已。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1684123959,"ip_address":"上海","comment_id":374297,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100114501,"comment_content":"老师，deployment 的 pod 没有稳定的域名，是不是就不能用用 headless svc了？（但是我看我们服务deployment也使用了 headles svc）","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618132,"discussion_content":"用是当然可以用，只是域名不稳定而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684123959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374295,"user_name":"泰一","can_delete":false,"product_type":"c1","uid":1757959,"ip_address":"北京","ucode":"D85C764BA108CE","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d3/07/5fc3c694.jpg","comment_is_top":false,"comment_ctime":1683863294,"is_pvip":false,"replies":[{"id":136705,"content":"coredns提供的是域名解析服务，不是负载均衡，流量的管理还是用的kube-proxy。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1684123583,"ip_address":"北京","comment_id":374295,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100114501,"comment_content":"老师，想问下\n是不是访问 headless svc，负载均衡到某个pod是通过k8s 的coreDNS 完成\n而访问普通clusterIP 的svc，负载均衡是通过kube-proxy完成","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618127,"discussion_content":"coredns提供的是域名解析服务，不是负载均衡，流量的管理还是用的kube-proxy。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684123583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374293,"user_name":"泰一","can_delete":false,"product_type":"c1","uid":1757959,"ip_address":"北京","ucode":"D85C764BA108CE","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d3/07/5fc3c694.jpg","comment_is_top":false,"comment_ctime":1683862474,"is_pvip":false,"replies":[{"id":136709,"content":"Pod已经有了域名，就直接coredns解析拿到IP地址。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1684123921,"ip_address":"上海","comment_id":374293,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100114501,"comment_content":"“Service 原本的目的是负载均衡，应该由它在 Pod 前面来转发流量，但是对 StatefulSet 来说，这项功能反而是不必要的，因为 Pod 已经有了稳定的域名，外界访问服务就不应该再通过 Service 这一层了。所以，从安全和节约系统资源的角度考虑，我们可以在 Service 里添加一个字段 clusterIP: None ，告诉 Kubernetes 不必再为这个对象分配 IP 地址。”\n\n\n老师，我想问下，如果应用A 通过  headless-service 访问应用B，不通过 service这一层做负载均衡了，那么应用 A 是怎么定位应用B的某个Pod的，这个过程能讲下么？\n\n然后，我看k8s的文档，说访问headless服务，会返回一组pod地址列表，客户端自己做负载均衡了。\n但是我们实际的服务，访问headless，直接就转发到某个pod了，和文档说的不一样，很迷惑。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618131,"discussion_content":"Pod已经有了域名，就直接coredns解析拿到IP地址。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684123921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372071,"user_name":"Leon","can_delete":false,"product_type":"c1","uid":1305641,"ip_address":"广东","ucode":"FADE93F80CCDCC","user_header":"https://static001.geekbang.org/account/avatar/00/13/ec/29/895dbe3f.jpg","comment_is_top":false,"comment_ctime":1680681459,"is_pvip":false,"replies":[{"id":135799,"content":"是的，模板会创建各自独立的pv，因为存储是和Pod绑定的。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1680743096,"ip_address":"上海","comment_id":372071,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100114501,"comment_content":"老师，我发现StatefulSet里面的volumeClaimTemplates配置的PVC在用于多个POD时，容器中挂载的NFS文件系统是分别两个不同的pvc，这样两个redis中的数据还是分别隔离的，这样是正常的吗","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612492,"discussion_content":"是的，模板会创建各自独立的pv，因为存储是和Pod绑定的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680743096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371020,"user_name":"庄颖","can_delete":false,"product_type":"c1","uid":2974369,"ip_address":"广东","ucode":"784890C940EC81","user_header":"","comment_is_top":false,"comment_ctime":1679465990,"is_pvip":false,"replies":[{"id":135442,"content":"kubernetes里存储和应用是分离的，所以这两者没有必然的关系，只是StatefulSet在创建PVC时有特别的规则。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1679705721,"ip_address":"湖南","comment_id":371020,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100114501,"comment_content":"老师，请问下文章最后的pvc挂载，直接使用deployment添加pvc挂载，删除对应的pod，或者删除deployment重建，只要对应的pvc名称不变，数据也不会变化啊。\n这是不是意味着deployment和statefulset在使用pvc持久化数据时，是没什么去别的？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610714,"discussion_content":"kubernetes里存储和应用是分离的，所以这两者没有必然的关系，只是StatefulSet在创建PVC时有特别的规则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679705721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1604355,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7b/03/03583011.jpg","nickname":"天天有吃的","note":"","ucode":"6267FE8E68DEE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612523,"discussion_content":"请问下这里的特别的规则，是需要包含statefulset和对应pod的序号吗？那如果一个statefulset只绑定一个pvc，一个deployment也只绑定一个pvc。能不能这么说：这种情况下，deployment和statefulset对应存储的高可用那些是没差的？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680768040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368787,"user_name":"lpqoang","can_delete":false,"product_type":"c1","uid":1190090,"ip_address":"广东","ucode":"EB1E09117503A3","user_header":"https://static001.geekbang.org/account/avatar/00/12/28/ca/47333d8b.jpg","comment_is_top":false,"comment_ctime":1676707799,"is_pvip":false,"replies":[{"id":134331,"content":"这个是当然的，不过确实容易忽视。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1676787575,"ip_address":"上海","comment_id":368787,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100114501,"comment_content":"经过测试创建svc时候有个小坑，service的name必须和sts的serviceName一致，不然域名解析不到","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":605605,"discussion_content":"这个是当然的，不过确实容易忽视。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676787576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368707,"user_name":"极客酱酱","can_delete":false,"product_type":"c1","uid":2934665,"ip_address":"四川","ucode":"18CDC1DB754D58","user_header":"https://static001.geekbang.org/account/avatar/00/2c/c7/89/16437396.jpg","comment_is_top":false,"comment_ctime":1676604706,"is_pvip":false,"replies":[{"id":134288,"content":"good","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1676623343,"ip_address":"上海","comment_id":368707,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100114501,"comment_content":"将svc转换为headless service时，修改redis-svc.yml，添加clusterIP: None后，\n执行kubectl apply -f redis-svc.yml更新svc时会报spec.clusterIPs[0]: Invalid value，\n需要先将svc删除后重新apply才行，直接更新不起来。\n","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":605313,"discussion_content":"good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676623343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365011,"user_name":"mkcaptain","can_delete":false,"product_type":"c1","uid":2341231,"ip_address":"上海","ucode":"0BF1BAE12B0C11","user_header":"https://static001.geekbang.org/account/avatar/00/23/b9/6f/b40d1acf.jpg","comment_is_top":false,"comment_ctime":1671933429,"is_pvip":false,"replies":[{"id":132923,"content":"Kubernetes只是提供了域名解析，如何利用每个pod的域名是业务层面的事情了，需要我们自己根据业务去考虑，课程里只是示例，比较简单。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1672048390,"ip_address":"上海","comment_id":365011,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100114501,"comment_content":"老师，有个疑问，今天讲解的中，如果固定域名绑定了pod，那结尾数字1的那个有什么作用呢？感觉一直都只会用0结尾的那个？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597585,"discussion_content":"Kubernetes只是提供了域名解析，如何利用每个pod的域名是业务层面的事情了，需要我们自己根据业务去考虑，课程里只是示例，比较简单。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672048390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":361410,"user_name":"悟远","can_delete":false,"product_type":"c1","uid":1912923,"ip_address":"上海","ucode":"3BD9C748698888","user_header":"https://static001.geekbang.org/account/avatar/00/1d/30/5b/4f4b0a40.jpg","comment_is_top":false,"comment_ctime":1667473759,"is_pvip":false,"replies":[{"id":131446,"content":"是不是用Job就行了，应该不用StatefulSet吧。看看Kubernetes里的这些对象哪个最符合你的实际需求，看人下菜。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1667474862,"ip_address":"上海","comment_id":361410,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100114501,"comment_content":"老师好，我有个需求，想部署分布式爬虫环境，有什么方案可以让集群中所有副本同时启动执行任务吗？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592552,"discussion_content":"是不是用Job就行了，应该不用StatefulSet吧。看看Kubernetes里的这些对象哪个最符合你的实际需求，看人下菜。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667474862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357646,"user_name":"朱雯","can_delete":false,"product_type":"c1","uid":1035744,"ip_address":"北京","ucode":"064C45FBF6B51F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","comment_is_top":false,"comment_ctime":1663514730,"is_pvip":false,"replies":[{"id":130175,"content":"这些问题可以参考其他同学的回答，重要的是思考的过程。\n\n有状态服务不好维护不方便扩容缩容，无状态服务管理简单。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1663557463,"ip_address":"北京","comment_id":357646,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100114501,"comment_content":"问题1： 想办法给这两个配置上配置文件，但感觉比较麻烦。 问题2： 不知道，我看答案说的是可能会多个挂载一个nfs，但如果是statefulset里面设置就不会发生这样的事情吗？\n\n下面是一些总结和思考：\n1. 有状态的状态，指的是启动顺序，机器标识和网络标识，网络标识是通过svc实现的。通过sts和svc的绑定，可以让pod拥有自己的域名，可以被直接访问到。\n2. 有状态的状态对比起无状态服务，本质上来说，就是有更多的确定性，当一个deployment启动的时候，pod名称很多时候是随机的，但sts设置好以后，名称是固定的，hostname也是固定的，网络域名也是固定的，这些状态被固定住。\n3. 有一个问题是，在docker-compose中，其实着一些东西也是固定的，无状态的设计是新加的，而有状态的服务是后面来的，依赖关系也在docker-compose中设计好，那么问题来了，为什么会有无状态服务，为什么不把所有服务都设计为有状态服务，我想的是不管有没有必要，都规范不就好了。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588110,"discussion_content":"这些问题可以参考其他同学的回答，重要的是思考的过程。\n\n有状态服务不好维护不方便扩容缩容，无状态服务管理简单。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663557463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356292,"user_name":"龙之大者","can_delete":false,"product_type":"c1","uid":1057665,"ip_address":"北京","ucode":"1BB8B26EEDFE34","user_header":"https://static001.geekbang.org/account/avatar/00/10/23/81/3865297c.jpg","comment_is_top":false,"comment_ctime":1662111359,"is_pvip":false,"replies":[{"id":129692,"content":"看看nfs是否工作正常，然后再看看Provisioner的状态。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1662170038,"ip_address":"北京","comment_id":356292,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100114501,"comment_content":"执行了redis-pv-sts.yml，生产pvc一直是pending，然后报错如下\n\npersistentvolume-controller  waiting for a volume to be created, either by external provisioner &quot;k8s-sigs.io&#47;nfs-subdir-external-provisioner&quot; or manually created by system administrator","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586373,"discussion_content":"看看nfs是否工作正常，然后再看看Provisioner的状态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662170038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1057665,"avatar":"https://static001.geekbang.org/account/avatar/00/10/23/81/3865297c.jpg","nickname":"龙之大者","note":"","ucode":"1BB8B26EEDFE34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586579,"discussion_content":"问题已解决：（1）nfs目录要调整到/data；（2）rbac.yaml里面namespace较多，都要替换完，不能遗漏了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662349150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355263,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"上海","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1661237897,"is_pvip":false,"replies":[{"id":129257,"content":"\n1. 这个还真不知道，也许只能加强运维管理了吧。\n\n2.应用不能控制，需要自己编写脚本，判断hostname得知自己是第几个启动的。\n\n3. kubectl get all -A\n\n4.用showmount检查，还有service等系统管理命令。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1661243898,"ip_address":"上海","comment_id":355263,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100114501,"comment_content":"请教老师几个问题：\nQ1：怎么查询一个POD是通过什么创建的？\n用“delete -f . ”来删除，发现只有最近的通过YAML创建的被删除，比如今天上午通过YAML创建了两个POD，用“delete -f . ”只删除了刚创建的这个sts，但以前通过deploy YAML创建的POD无法删除。为了删除其它POD,需要知道这个POD是通过什么创建的，请问：用哪个命令可以查看一个POD是通过什么创建的？\nQ2：应用怎么控制启动顺序？\n执行“kubectl apply -f redis-sts.yml”以后，两个POD被K8S启动了，已经启动了，应用还能控制启动顺序吗？\nQ3：什么命令可以列出所有创建的对象？\n目的是想查看以前创建的对象，各种类型的对象。是否有一个命令可以列出所有创建过得对象？\nQ4：怎么判断console上安装的NFS server是否在运行，或者说怎么判断其状态？ Nfs version吗？同样，在client上，开机后怎么判断nfs client状态？（也许开机后自动运行？）","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584946,"discussion_content":"\n1. 这个还真不知道，也许只能加强运维管理了吧。\n\n2.应用不能控制，需要自己编写脚本，判断hostname得知自己是第几个启动的。\n\n3. kubectl get all -A\n\n4.用showmount检查，还有service等系统管理命令。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661243898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1087879,"avatar":"https://static001.geekbang.org/account/avatar/00/10/99/87/5066026c.jpg","nickname":"dao","note":"","ucode":"4181FB270462CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587865,"discussion_content":"关于 Q1 估计可以试试 kubectl get events","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663325991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355260,"user_name":"事已至此开始撤退","can_delete":false,"product_type":"c1","uid":2901316,"ip_address":"上海","ucode":"1076FDF53DA81D","user_header":"https://static001.geekbang.org/account/avatar/00/2c/45/44/8df79d3c.jpg","comment_is_top":false,"comment_ctime":1661235791,"is_pvip":false,"replies":[{"id":129254,"content":"good","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1661243735,"ip_address":"上海","comment_id":355260,"utype":1}],"discussion_count":4,"race_medal":0,"score":4,"product_id":100114501,"comment_content":"实践看这个，底层原理看张坤","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584943,"discussion_content":"good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661243735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008312,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/b8/0e1b655e.jpg","nickname":"fireshort","note":"","ucode":"10550CA9C6C730","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589099,"discussion_content":"应该说的是张磊。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1664419158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1214303,"avatar":"https://static001.geekbang.org/account/avatar/00/12/87/5f/6bf8b74a.jpg","nickname":"Kepler","note":"","ucode":"0C9CA3DB8B3CF0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585502,"discussion_content":"张磊？张坤我只知道易方达…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661609985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344431,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","nickname":"马以","note":"","ucode":"3FEA06CA14DE28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584968,"discussion_content":"哪个张坤？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661249782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355143,"user_name":"K_Library争四狂魔","can_delete":false,"product_type":"c1","uid":1072668,"ip_address":"北京","ucode":"EA85CDF0052AC0","user_header":"https://static001.geekbang.org/account/avatar/00/10/5e/1c/6b4e6aa5.jpg","comment_is_top":false,"comment_ctime":1661134766,"is_pvip":false,"replies":[{"id":129228,"content":"我不是很了解WordPress，如果是如你所说，那么它应该部署成StatefulSet。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1661144394,"ip_address":"北京","comment_id":355143,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100114501,"comment_content":"老师您好。我理解的话WordPress实际上也是有状态的服务，它需要安装插件之后产生.php文件存放在PV里面。如果同一个WordPress实例两个节点，其中一个节点安装了WP插件，另一个节点也要同时变化（装上插件），这样的控制太复杂，所以我觉得WordPress是不适合用Service来启动多个实例的。\n我觉得应该把WordPress应该跟背后的MySQL定义为同一组StatefulSet，一旦一个节点挂了，另一个节点可以读取MySQL和WordPress的文件启动之后恢复之前的状态。\n您觉得有没有更好的WordPress部署方式？谢谢。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584811,"discussion_content":"我不是很了解WordPress，如果是如你所说，那么它应该部署成StatefulSet。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661144394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018670,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/2e/df74d56a.jpg","nickname":"起司猫","note":"","ucode":"D86EF6FBA10EAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650430,"discussion_content":"查了下，说是 WP 的插件是安装在/wp-content/plugins/下的，如果在这个路径上挂载一个 volume ，那么用 depoyment + service + pv 就能够解决问题了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1724981808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广西","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}