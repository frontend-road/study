{"id":381423,"title":"06｜自定义Hooks ：四个典型的使用场景","content":"<p>你好，我是王沛。</p><p>我在开篇词就说过，要用好 React Hooks，很重要的一点，就是要能够从 Hooks 的角度去思考问题。要做到这一点其实也不难，就是在遇到一个功能开发的需求时，首先问自己一个问题：<strong>这个功能中的哪些逻辑可以抽出来成为独立的 Hooks？</strong></p><p>这么问的目的，是为了让我们尽可能地把业务逻辑拆成独立的 Hooks ，这样有助于实现代码的模块化和解耦，同时也方便后面的维护。如果你基础篇的知识掌握得牢固的话，就会发现，这是因为 Hooks 有两个非常核心的优点：</p><ul>\n<li>一是方便进行逻辑复用；</li>\n<li>二是帮助关注分离。</li>\n</ul><p>接下来我就通过一个案例，来带你认识什么是自定义Hooks，以及如何创建。然后，我们再通过其它3个典型案例，来看看自定义Hooks 具体有什么用，从而帮你掌握从 Hooks 角度去解决问题的思考方式。</p><h1>如何创建自定义 Hooks？</h1><p>自定义 Hooks 在形式上其实非常简单，就是<strong>声明一个名字以 use 开头的函数</strong>，比如 useCounter。这个函数在形式上和普通的 JavaScript 函数没有任何区别，你可以传递任意参数给这个 Hook，也可以返回任何值。</p><p>但是要注意，Hooks 和普通函数在语义上是有区别的，就在于<strong>函数中有没有用到其它 Hooks。</strong></p><!-- [[[read_end]]] --><p>什么意思呢？就是说如果你创建了一个 useXXX 的函数，但是内部并没有用任何其它 Hooks，那么这个函数就不是一个 Hook，而只是一个普通的函数。但是如果用了其它 Hooks ，那么它就是一个 Hook。</p><p>举一个简单的例子，在第3讲中我们看到过一个简单计数器的实现，当时把业务逻辑都写在了函数组件内部，但其实是可以把业务逻辑提取出来成为一个 Hook。比如下面的代码：</p><pre><code>import { useState, useCallback }from 'react';\n \nfunction useCounter() {\n  // 定义 count 这个 state 用于保存当前数值\n  const [count, setCount] = useState(0);\n  // 实现加 1 的操作\n  const increment = useCallback(() =&gt; setCount(count + 1), [count]);\n  // 实现减 1 的操作\n  const decrement = useCallback(() =&gt; setCount(count - 1), [count]);\n  // 重置计数器\n  const reset = useCallback(() =&gt; setCount(0), []);\n  \n  // 将业务逻辑的操作 export 出去供调用者使用\n  return { count, increment, decrement, reset };\n}\n</code></pre><p>有了这个 Hook，我们就可以在组件中使用它，比如下面的代码：</p><pre><code>import React from 'react';\n\nfunction Counter() {\n  // 调用自定义 Hook\n  const { count, increment, decrement, reset } = useCounter();\n\n  // 渲染 UI\n  return (\n    &lt;div&gt;\n      &lt;button onClick={decrement}&gt; - &lt;/button&gt;\n      &lt;p&gt;{count}&lt;/p&gt;\n      &lt;button onClick={increment}&gt; + &lt;/button&gt;\n      &lt;button onClick={reset}&gt; reset &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre><p>在这段代码中，我们把原来在函数组件中实现的逻辑提取了出来，成为一个单独的 Hook，<strong>一方面能让这个逻辑得到重用，另外一方面也能让代码更加语义化</strong>，<strong>并且易于理解和维护。</strong></p><p>从这个例子，我们可以看到自定义 Hooks 的两个特点：</p><ol>\n<li>名字一定是以 use 开头的函数，这样 React 才能够知道这个函数是一个 Hook；</li>\n<li>函数内部一定调用了其它的 Hooks，可以是内置的 Hooks，也可以是其它自定义 Hooks。这样才能够让组件刷新，或者去产生副作用。</li>\n</ol><p>当然，这只是一个非常简单的例子，实现了计数器业务逻辑的拆分和重用。不过通过这个例子，你也看到了创建自定义 Hook 是如此之简单，和过去的高阶组件设计模式相比，简直是天上地下的区别。也正因如此，Hooks 出现后就得到了迅速的普及。</p><p>那么，在日常开发的时候，除了解耦业务相关的逻辑，还有哪些场景需要去创建自定义 Hooks 呢？下面我就再给你介绍三个典型的业务场景。</p><h1>封装通用逻辑：useAsync</h1><p>在组件的开发过程中，有一些常用的通用逻辑。过去可能会因为逻辑重用比较繁琐，而经常在每个组件中去自己实现，造成维护的困难。但现在有了 Hooks，就可以将更多的通用逻辑通过 Hooks 的形式进行封装，方便被不同的组件重用。</p><p>比如说，在日常 UI 的开发中，有一个最常见的需求：<strong>发起异步请求获取数据并显示在界面上</strong>。在这个过程中，我们不仅要关心请求正确返回时，UI 会如何展现数据；还需要处理请求出错，以及关注 Loading 状态在 UI 上如何显示。</p><p>我们可以重新看下在第1讲中看到的异步请求的例子，从 Server 端获取用户列表，并显示在界面上：</p><pre><code>import React from &quot;react&quot;;\n\nexport default function UserList() {\n  // 使用三个 state 分别保存用户列表，loading 状态和错误状态\n  const [users, setUsers] = React.useState([]);\n  const [loading, setLoading] = React.useState(false);\n  const [error, setError] = React.useState(null);\n\n  // 定义获取用户的回调函数\n  const fetchUsers = async () =&gt; {\n    setLoading(true);\n    try {\n      const res = await fetch(&quot;https://reqres.in/api/users/&quot;);\n      const json = await res.json();\n      // 请求成功后将用户数据放入 state\n      setUsers(json.data);\n    } catch (err) {\n      // 请求失败将错误状态放入 state\n      setError(err);\n    }\n    setLoading(false);\n  };\n\n  return (\n    &lt;div className=&quot;user-list&quot;&gt;\n      &lt;button onClick={fetchUsers} disabled={loading}&gt;\n        {loading ? &quot;Loading...&quot; : &quot;Show Users&quot;}\n      &lt;/button&gt;\n      {error &amp;&amp; \n        &lt;div style={{ color: &quot;red&quot; }}&gt;Failed: {String(error)}&lt;/div&gt;\n      }\n      &lt;br /&gt;\n      &lt;ul&gt;\n        {users &amp;&amp; users.length &gt; 0 &amp;&amp;\n          users.map((user) =&gt; {\n            return &lt;li key={user.id}&gt;{user.first_name}&lt;/li&gt;;\n          })}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre><p>在这里，我们定义了 users、loading 和 error 三个状态。如果我们在异步请求的不同阶段去设置不同的状态，这样 UI 最终能够根据这些状态展现出来。在每个需要异步请求的组件中，其实都需要重复相同的逻辑。</p><p>事实上，在处理这类请求的时候，模式都是类似的，通常都会遵循下面步骤：</p><ol>\n<li>创建 data，loading，error 这3个 state；</li>\n<li>请求发出后，设置 loading state 为 true；</li>\n<li>请求成功后，将返回的数据放到某个 state 中，并将 loading state 设为 false；</li>\n<li>请求失败后，设置 error state 为 true，并将 loading state 设为 false。</li>\n</ol><p>最后，基于 data、loading、error 这3个 state 的数据，UI 就可以正确地显示数据，或者 loading、error 这些反馈给用户了。</p><p>所以，通过创建一个自定义 Hook，可以很好地将这样的逻辑提取出来，成为一个可重用的模块。比如代码可以这样实现：</p><pre><code>import { useState } from 'react';\n\nconst useAsync = (asyncFunction) =&gt; {\n  // 设置三个异步逻辑相关的 state\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  // 定义一个 callback 用于执行异步逻辑\n  const execute = useCallback(() =&gt; {\n    // 请求开始时，设置 loading 为 true，清除已有数据和 error 状态\n    setLoading(true);\n    setData(null);\n    setError(null);\n    return asyncFunction()\n      .then((response) =&gt; {\n        // 请求成功时，将数据写进 state，设置 loading 为 false\n        setData(response);\n        setLoading(false);\n      })\n      .catch((error) =&gt; {\n        // 请求失败时，设置 loading 为 false，并设置错误状态\n        setError(error);\n        setLoading(false);\n      });\n  }, [asyncFunction]);\n\n  return { execute, loading, data, error };\n};\n</code></pre><p>那么有了这个 Hook，我们在组件中就只需要关心与业务逻辑相关的部分。比如代码可以简化成这样的形式：</p><pre><code>import React from &quot;react&quot;;\nimport useAsync from './useAsync';\n\nexport default function UserList() {\n  // 通过 useAsync 这个函数，只需要提供异步逻辑的实现\n  const {\n    execute: fetchUsers,\n    data: users,\n    loading,\n    error,\n  } = useAsync(async () =&gt; {\n    const res = await fetch(&quot;https://reqres.in/api/users/&quot;);\n    const json = await res.json();\n    return json.data;\n  });\n  \n  return (\n    // 根据状态渲染 UI...\n  );\n}\n</code></pre><p>通过这个例子可以看到，我们<strong>利用了 Hooks 能够管理 React 组件状态的能力，将一个组件中的某一部分状态独立出来，从而实现了通用逻辑的重用</strong>。</p><p>不过在这里你可能会有一个疑问：这种类型的封装我写一个工具类不就可以了？为什么一定要通过 Hooks 进行封装呢？</p><p>答案很容易就能想到。因为在 Hooks 中，你可以管理当前组件的 state，从而将更多的逻辑写在可重用的 Hooks 中。但是要知道，在普通的工具类中是无法直接修改组件 state 的，那么也就无法在数据改变的时候触发组件的重新渲染。</p><h1>监听浏览器状态：useScroll</h1><p>虽然 React 组件基本上不需要关心太多的浏览器 API，但是有时候却是必须的：</p><ul>\n<li>界面需要根据在窗口大小变化重新布局；</li>\n<li>在页面滚动时，需要根据滚动条位置，来决定是否显示一个“返回顶部”的按钮。</li>\n</ul><p>这都需要用到浏览器的 API 来监听这些状态的变化。那么我们就以滚动条位置的场景为例，来看看应该如何用 Hooks 优雅地监听浏览器状态。</p><p>正如 Hooks 的字面意思是“钩子”，它带来的一大好处就是：<strong>可以让 React 的组件绑定在任何可能的数据源上。这样当数据源发生变化时，组件能够自动刷新</strong>。把这个好处对应到滚动条位置这个场景就是：组件需要绑定到当前滚动条的位置数据上。</p><p>虽然这个逻辑在函数组件中可以直接实现，但是把这个逻辑实现为一个独立的Hooks，既可以达到逻辑重用，在语义上也更加清晰。这个和上面的 useAsync 的作用是非常类似的。</p><p>我们可以直接来看这个 Hooks 应该如何实现：</p><pre><code>import { useState, useEffect } from 'react';\n\n// 获取横向，纵向滚动条位置\nconst getPosition = () =&gt; {\n  return {\n    x: document.body.scrollLeft,\n    y: document.body.scrollTop,\n  };\n};\nconst useScroll = () =&gt; {\n  // 定一个 position 这个 state 保存滚动条位置\n  const [position, setPosition] = useState(getPosition());\n  useEffect(() =&gt; {\n    const handler = () =&gt; {\n      setPosition(getPosition(document));\n    };\n    // 监听 scroll 事件，更新滚动条位置\n    document.addEventListener(&quot;scroll&quot;, handler);\n    return () =&gt; {\n      // 组件销毁时，取消事件监听\n      document.removeEventListener(&quot;scroll&quot;, handler);\n    };\n  }, []);\n  return position;\n};\n\n</code></pre><p>有了这个 Hook，你就可以非常方便地监听当前浏览器窗口的滚动条位置了。比如下面的代码就展示了“返回顶部”这样一个功能的实现：</p><pre><code>import React, { useCallback } from 'react';\nimport useScroll from './useScroll';\n\nfunction ScrollTop() {\n  const { y } = useScroll();\n\n  const goTop = useCallback(() =&gt; {\n    document.body.scrollTop = 0;\n  }, []);\n\n  const style = {\n    position: &quot;fixed&quot;,\n    right: &quot;10px&quot;,\n    bottom: &quot;10px&quot;,\n  };\n  // 当滚动条位置纵向超过 300 时，显示返回顶部按钮\n  if (y &gt; 300) {\n    return (\n      &lt;button onClick={goTop} style={style}&gt;\n        Back to Top\n      &lt;/button&gt;\n    );\n  }\n  // 否则不 render 任何 UI\n  return null;\n}\n\n</code></pre><p>通过这个例子，我们看到了如何将浏览器状态变成可被 React 组件绑定的数据源，从而在使用上更加便捷和直观。当然，除了窗口大小、滚动条位置这些状态，还有其它一些数据也可以这样操作，比如 cookies，localStorage, URL，等等。你都可以通过这样的方法来实现。</p><h1>拆分复杂组件</h1><p>函数组件虽然很容易上手，但是当某个组件功能越来越复杂的时候，我发现很多同学会出现一个问题，就是组件代码很容易变得特别长，比如超过500行，甚至1000行。这就变得非常难维护了。</p><p>设想当你接手某个项目，发现一个函数动辄就超过了500行，那会是什么感受？所以<strong>“保持每个函数的短小”</strong>这样通用的最佳实践，同样适用于函数组件。只有这样，才能让代码始终易于理解和维护。</p><p>那么现在的关键问题就是，怎么才能让函数组件不会太过冗长呢？做法很简单，就是<strong>尽量将相关的逻辑做成独立的 Hooks，然后在函数组中使用这些 Hooks，通过参数传递和返回值让 Hooks 之间完成交互</strong>。</p><p>这里可以注意一点，拆分逻辑的目的不一定是为了重用，而可以是仅仅为了业务逻辑的隔离。所以在这个场景下，我们不一定要把 Hooks 放到独立的文件中，而是可以和函数组件写在一个文件中。这么做的原因就在于，这些 Hooks 是和当前函数组件紧密相关的，所以写到一起，反而更容易阅读和理解。</p><p>为了让你对这一点有更直观的感受，我们来看一个例子。设想现在有这样一个需求：我们需要展示一个博客文章的列表，并且有一列要显示文章的分类。同时，我们还需要提供表格过滤功能，以便能够只显示某个分类的文章。</p><p>为了支持过滤功能，后端提供了两个 API：一个用于获取文章的列表，另一个用于获取所有的分类。这就需要我们在前端将文章列表返回的数据分类 ID 映射到分类的名字，以便显示在列表里。</p><p>这时候，如果按照直观的思路去实现，通常都会把逻辑都写在一个组件里，比如类似下面的代码：</p><pre><code>function BlogList() {\n  // 获取文章列表...\n  // 获取分类列表...\n  // 组合文章数据和分类数据...\n  // 根据选择的分类过滤文章...\n  \n  // 渲染 UI ...\n}\n</code></pre><p>你可以想一下，如果你是在写一个其它的普通函数，会不会将其中一些逻辑写成单独的函数呢？相信答案是肯定的，因为这样做可以隔离业务逻辑，让代码更加清楚。</p><p>但我却发现很多同学在写函数组件时没有意识到 Hooks 就是普通的函数，所以通常不会这么去做隔离，而是习惯于一路写下来，这就会造成某个函数组件特别长。还是老生常谈的那句话，<strong>改变这个状况的关键仍然在于开发思路的转变</strong>。我们要真正<strong>把 Hooks 就看成普通的函数，能隔离的尽量去做隔离</strong>，从而让代码更加模块化，更易于理解和维护。</p><p>那么针对这样一个功能，我们甚至可以将其拆分成4个 Hooks，每一个 Hook 都尽量小，代码如下：</p><pre><code>import React, { useEffect, useCallback, useMemo, useState } from &quot;react&quot;;\nimport { Select, Table } from &quot;antd&quot;;\nimport _ from &quot;lodash&quot;;\nimport useAsync from &quot;./useAsync&quot;;\n\nconst endpoint = &quot;https://myserver.com/api/&quot;;\nconst useArticles = () =&gt; {\n  // 使用上面创建的 useAsync 获取文章列表\n  const { execute, data, loading, error } = useAsync(\n    useCallback(async () =&gt; {\n      const res = await fetch(`${endpoint}/posts`);\n      return await res.json();\n    }, []),\n  );\n  // 执行异步调用\n  useEffect(() =&gt; execute(), [execute]);\n  // 返回语义化的数据结构\n  return {\n    articles: data,\n    articlesLoading: loading,\n    articlesError: error,\n  };\n};\nconst useCategories = () =&gt; {\n  // 使用上面创建的 useAsync 获取分类列表\n  const { execute, data, loading, error } = useAsync(\n    useCallback(async () =&gt; {\n      const res = await fetch(`${endpoint}/categories`);\n      return await res.json();\n    }, []),\n  );\n  // 执行异步调用\n  useEffect(() =&gt; execute(), [execute]);\n\n  // 返回语义化的数据结构\n  return {\n    categories: data,\n    categoriesLoading: loading,\n    categoriesError: error,\n  };\n};\nconst useCombinedArticles = (articles, categories) =&gt; {\n  // 将文章数据和分类数据组合到一起\n  return useMemo(() =&gt; {\n    // 如果没有文章或者分类数据则返回 null\n    if (!articles || !categories) return null;\n    return articles.map((article) =&gt; {\n      return {\n        ...article,\n        category: categories.find(\n          (c) =&gt; String(c.id) === String(article.categoryId),\n        ),\n      };\n    });\n  }, [articles, categories]);\n};\nconst useFilteredArticles = (articles, selectedCategory) =&gt; {\n  // 实现按照分类过滤\n  return useMemo(() =&gt; {\n    if (!articles) return null;\n    if (!selectedCategory) return articles;\n    return articles.filter((article) =&gt; {\n      console.log(&quot;filter: &quot;, article.categoryId, selectedCategory);\n      return String(article?.category?.name) === String(selectedCategory);\n    });\n  }, [articles, selectedCategory]);\n};\n\nconst columns = [\n  { dataIndex: &quot;title&quot;, title: &quot;Title&quot; },\n  { dataIndex: [&quot;category&quot;, &quot;name&quot;], title: &quot;Category&quot; },\n];\n\nexport default function BlogList() {\n  const [selectedCategory, setSelectedCategory] = useState(null);\n  // 获取文章列表\n  const { articles, articlesError } = useArticles();\n  // 获取分类列表\n  const { categories, categoriesError } = useCategories();\n  // 组合数据\n  const combined = useCombinedArticles(articles, categories);\n  // 实现过滤\n  const result = useFilteredArticles(combined, selectedCategory);\n\n  // 分类下拉框选项用于过滤\n  const options = useMemo(() =&gt; {\n    const arr = _.uniqBy(categories, (c) =&gt; c.name).map((c) =&gt; ({\n      value: c.name,\n      label: c.name,\n    }));\n    arr.unshift({ value: null, label: &quot;All&quot; });\n    return arr;\n  }, [categories]);\n\n  // 如果出错，简单返回 Failed\n  if (articlesError || categoriesError) return &quot;Failed&quot;;\n\n  // 如果没有结果，说明正在加载\n  if (!result) return &quot;Loading...&quot;;\n\n  return (\n    &lt;div&gt;\n      &lt;Select\n        value={selectedCategory}\n        onChange={(value) =&gt; setSelectedCategory(value)}\n        options={options}\n        style={{ width: &quot;200px&quot; }}\n        placeholder=&quot;Select a category&quot;\n      /&gt;\n      &lt;Table dataSource={result} columns={columns} /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre><p>通过这样的方式，我们就把一个较为复杂的逻辑拆分成一个个独立的 Hook 了，不仅隔离了业务逻辑，也让代码在语义上更加明确。比如说有 useArticles、useCategories 这样与业务相关的名字，就非常易于理解。</p><p>虽然这个例子中抽取出来的 Hooks 都非常简单，甚至看上去没有必要。但是实际的开发场景一定是比这个复杂的，比如对于 API 返回的数据需要做一些数据的转换，进行数据的缓存，等等。那么这时就要避免把这些逻辑都放到一起，而是就要拆分到独立的 Hooks，以免产生过于复杂的组件。到时候你也就更能更体会到 Hooks 带给你的惊喜了。</p><h1>小结</h1><p>好了，这一讲我主要给你介绍了自定义 Hooks 的概念，以及典型的四个使用场景：</p><ol>\n<li>抽取业务逻辑；</li>\n<li>封装通用逻辑；</li>\n<li>监听浏览器状态；</li>\n<li>拆分复杂组件。</li>\n</ol><p>其中，我通过四个案例来帮助你真正理解 Hooks ，并熟练掌握自定义 Hooks 的用法。应始终记得，要用Hooks 的思路去解决问题，发挥 Hooks 的最大价值，就是要经常去思考哪些逻辑应该封装到一个独立的 Hook，保证每个 Hook 的短小精悍，从而让代码更加清晰，易于理解和维护。</p><h1>思考题</h1><p>在 useCounter 这个例子中，我们是固定让数字每次加一。假如要做一个改进，允许灵活配置点击加号时应该加几，比如说每次加10，那么应该如何实现？</p><p>欢迎在留言区分享你的思考和想法，我会和你交流讨论。我们下节课再见！</p>","neighbors":{"left":{"article_title":"05｜进一步认识 Hooks ：如何正确理解函数组件的生命周期？","id":380891},"right":{"article_title":"07｜全局状态管理：如何在函数组件中使用 Redux？","id":382459}},"comments":[{"had_liked":false,"id":296480,"user_name":"Bug般的存在","can_delete":false,"product_type":"c1","uid":1573766,"ip_address":"","ucode":"7A61F7AA3B49A3","user_header":"https://static001.geekbang.org/account/avatar/00/18/03/86/c9051c6a.jpg","comment_is_top":false,"comment_ctime":1622994208,"is_pvip":false,"replies":[{"id":"107751","content":"👍🏻","user_name":"作者回复","comment_id":296480,"uid":"1018676","ip_address":"","utype":1,"ctime":1623082221,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":0,"score":"104702209312","product_id":100079901,"comment_content":"《拆分复杂组件》 这个例子，有种醍醐灌顶的感觉，豁然开朗，感谢-","like_count":24},{"had_liked":false,"id":296250,"user_name":"凡凡","can_delete":false,"product_type":"c1","uid":1374266,"ip_address":"","ucode":"CAEA596A037D9A","user_header":"https://static001.geekbang.org/account/avatar/00/14/f8/3a/dbf7bdee.jpg","comment_is_top":false,"comment_ctime":1622862936,"is_pvip":true,"replies":[{"id":"107744","content":"赞！Hooks 作为普通函数，是可以传递任何参数的。","user_name":"作者回复","comment_id":296250,"uid":"1018676","ip_address":"","utype":1,"ctime":1623081577,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":0,"score":"57457437784","product_id":100079901,"comment_content":"import { useState, useCallback } from &#39;react&#39;;<br><br>const useCounter = (step) =&gt; {<br>  const [counter, setCounter] = useState(0);<br>  const increment = useCallback(() =&gt; setCounter(counter + step), [counter, step]);<br>  const decrement = useCallback(() =&gt; setCounter(counter - step), [counter, step]);<br>  const reset = useCallback(() =&gt; setCounter(0), []);<br>  <br>  return {counter, increment, decrement, reset};<br>}<br><br>export default useCounter;","like_count":13},{"had_liked":false,"id":299709,"user_name":"余熙","can_delete":false,"product_type":"c1","uid":1240802,"ip_address":"","ucode":"7F98DCFB899CB7","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/e2/23e44221.jpg","comment_is_top":false,"comment_ctime":1624809561,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"31689580633","product_id":100079901,"comment_content":"这一节总结得非常好，官方文档和网上文章没写出来的干货👍","like_count":7},{"had_liked":false,"id":296873,"user_name":"山城旧客","can_delete":false,"product_type":"c1","uid":2642370,"ip_address":"","ucode":"A3CC05224DCA98","user_header":"https://static001.geekbang.org/account/avatar/00/28/51/c2/90a959d2.jpg","comment_is_top":false,"comment_ctime":1623208086,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"14508109974","product_id":100079901,"comment_content":"<br>import React from &quot;react&quot;;<br>import useAsync from &#39;.&#47;useAsync&#39;;<br><br>export default function UserList() {<br>  &#47;&#47; 通过 useAsync 这个函数，只需要提供异步逻辑的实现<br>  const {<br>    execute: fetchUsers,<br>    data: users,<br>    loading,<br>    error,<br>  } = useAsync(async () =&gt; {<br>    const res = await fetch(&quot;https:&#47;&#47;reqres.in&#47;api&#47;users&#47;&quot;);<br>    const json = await res.json();<br>    return json.data;<br>  });<br>  <br>  return (<br>    &#47;&#47; 根据状态渲染 UI...<br>  );<br>}<br><br>我验证了这个案例必须执行副作用useEffect(() =&gt; fetchUsers(), []);才能发起异步数据请求，如果在依赖项数组中再传入useEffect(() =&gt; fetchUsers(), [fetchUsers]);会陷入异步数据请求死循环。","like_count":3,"discussions":[{"author":{"id":1200447,"avatar":"https://static001.geekbang.org/account/avatar/00/12/51/3f/41c68054.jpg","nickname":"我要的飞翔","note":"","ucode":"41C51DBC8372BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381427,"discussion_content":"是因为你useAsync传的async函数没经过useCallback处理啦～\n因为asyncFunction变化导致fetchUsers每次都是一个新的function","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1625048198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1555361,"avatar":"https://static001.geekbang.org/account/avatar/00/17/bb/a1/08ae0611.jpg","nickname":"逆风飞扬","note":"","ucode":"FA4C58D3D3FDA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571975,"discussion_content":"我的理解是useAsync只是封装了接口返回数据的处理逻辑，至于什么时候调用接口，就需要使用这个hook的组件自行决定。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652518706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1672018,"avatar":"https://static001.geekbang.org/account/avatar/00/19/83/52/47dc4d5c.jpg","nickname":"Claus Wong","note":"","ucode":"E07685C4E7B07F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380407,"discussion_content":"传不传与否，要结合合适业务场景，不能学技术而学技术。老师在封装里面将asyncFunction作为依赖就挺突兀费解的，应该传空的嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624493492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1200447,"avatar":"https://static001.geekbang.org/account/avatar/00/12/51/3f/41c68054.jpg","nickname":"我要的飞翔","note":"","ucode":"41C51DBC8372BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1672018,"avatar":"https://static001.geekbang.org/account/avatar/00/19/83/52/47dc4d5c.jpg","nickname":"Claus Wong","note":"","ucode":"E07685C4E7B07F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381428,"discussion_content":"maybe是考虑到asyncFunction可能是动态的，对同一个组件里的同一个hook发请求有时候是asyncA，有时候是asyncB","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625048369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":380407,"ip_address":""},"score":381428,"extra":""}]}]},{"had_liked":false,"id":324545,"user_name":"傻子来了快跑丶","can_delete":false,"product_type":"c1","uid":1282777,"ip_address":"","ucode":"662624121A1DFA","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/d9/84c1de45.jpg","comment_is_top":false,"comment_ctime":1638497050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10228431642","product_id":100079901,"comment_content":"老师，后面的课程能不能出门更深入的，比如fibier，hooks的底层实现啊，这种，以及fiber的各种调度，啥的","like_count":2},{"had_liked":false,"id":312091,"user_name":"李克勤","can_delete":false,"product_type":"c1","uid":2660079,"ip_address":"","ucode":"78917017E984FB","user_header":"","comment_is_top":false,"comment_ctime":1631619681,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10221554273","product_id":100079901,"comment_content":"function useCounter() {<br><br>    const [count,setCount] = useState(0);<br>    const [step ,setStep] =useState(1)  <br><br>    const changeStep = useCallback((value) =&gt; {<br>        setStep(value);<br>    },[]);<br>    const increment = useCallback(() =&gt; {<br>        setCount(count+step);<br>    },[count,step]);<br>    const decrement = useCallback(() =&gt; {<br>        setCount(count-step);<br>    },[count,step]);<br>    <br>    const reset = useCallback(() =&gt; {<br>        setCount(0);<br>    },[])<br><br>    return {count,increment,decrement,reset,changeStep};<br><br>}<br>export default function Counter () {<br><br>   <br>   const {count,increment,decrement,reset,changeStep} = useCounter();<br><br>   return(<br>       &lt;div&gt;<br>           &lt;button onClick={decrement}&gt;-&lt;&#47;button&gt;<br>           &lt;p&gt;count:{count}&lt;&#47;p&gt;<br>           &lt;button onClick={increment}&gt;+&lt;&#47;button&gt;<br>           &lt;button onClick={reset}&gt;Reset&lt;&#47;button&gt;<br>           &lt;div&gt;<br>               &lt;InputNumber defaultValue={1} onChange={(v) =&gt; changeStep(v)}&#47;&gt;<br>           &lt;&#47;div&gt;<br>       &lt;&#47;div&gt;<br>   )<br>}","like_count":2},{"had_liked":false,"id":301709,"user_name":"别拦我让我学","can_delete":false,"product_type":"c1","uid":2613324,"ip_address":"","ucode":"7FBDEB867A68AE","user_header":"https://static001.geekbang.org/account/avatar/00/27/e0/4c/e6042c6c.jpg","comment_is_top":false,"comment_ctime":1625819619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10215754211","product_id":100079901,"comment_content":"useScroll中getPosition中应该将document.body.scrollTop改为document.documentElement.scrollTop。","like_count":2},{"had_liked":false,"id":296739,"user_name":"寇云","can_delete":false,"product_type":"c1","uid":1001332,"ip_address":"","ucode":"87181F16F83543","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/74/5e292ded.jpg","comment_is_top":false,"comment_ctime":1623140264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10213074856","product_id":100079901,"comment_content":"感谢老师，之前对于hooks 只停留在如何使用的层面。 慢慢的会把单文件中引入很多的useState，通过这节课，知道了应该如何创建自己的 hooks 来优化代码。","like_count":2},{"had_liked":false,"id":296412,"user_name":"Geek1560","can_delete":false,"product_type":"c1","uid":2028949,"ip_address":"","ucode":"5F27A28B8002E6","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/95/a362f01b.jpg","comment_is_top":false,"comment_ctime":1622965424,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10212900016","product_id":100079901,"comment_content":"老师您好，uesAsync 这个例子中，execute 使用了 useCallback，但实际传入的函数每次都是重新创建的，浅比较结果是不相同，缓存依然会更新，如果要使用uesCallback，是否是应该在外层缓存传入的asyncFunction","like_count":2},{"had_liked":false,"id":313111,"user_name":"泷沁心","can_delete":false,"product_type":"c1","uid":1293186,"ip_address":"","ucode":"E811D9F1A17689","user_header":"https://static001.geekbang.org/account/avatar/00/13/bb/82/5a32de87.jpg","comment_is_top":false,"comment_ctime":1632281828,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5927249124","product_id":100079901,"comment_content":"写了这么久Hooks，一直以逻辑+UI作为基本区分，看到这里老师的几个例子，更加对Hooks另眼相看了，感谢老师，大赞！！！","like_count":1},{"had_liked":false,"id":307685,"user_name":"江谢木","can_delete":false,"product_type":"c1","uid":1563403,"ip_address":"","ucode":"E1B1B0F0F03D41","user_header":"https://static001.geekbang.org/account/avatar/00/17/db/0b/f0ded153.jpg","comment_is_top":false,"comment_ctime":1629200716,"is_pvip":false,"replies":[{"id":"111731","content":"只是引用比较。只要引用没变，对象内部结构怎么变化都不会被认为依赖项变化了。所以 react 中都是用 immutable 的数据结构。","user_name":"作者回复","comment_id":307685,"uid":"1018676","ip_address":"","utype":1,"ctime":1629726322,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":0,"score":"5924168012","product_id":100079901,"comment_content":"老师，useMemo、useCallback对数据进行缓存时，依赖项是进行浅比较？ 如果存在依赖项是深层对象的数据发生变化会影响缓存计算结果？","like_count":1},{"had_liked":false,"id":304590,"user_name":"Tristan","can_delete":false,"product_type":"c1","uid":1359476,"ip_address":"","ucode":"DC454E16AAA66A","user_header":"https://static001.geekbang.org/account/avatar/00/14/be/74/0d900ed9.jpg","comment_is_top":false,"comment_ctime":1627489758,"is_pvip":false,"replies":[{"id":"110259","content":"祖传秘方，不可外传~","user_name":"作者回复","comment_id":304590,"uid":"1018676","ip_address":"","utype":1,"ctime":1627634425,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":0,"score":"5922457054","product_id":100079901,"comment_content":"醍醐灌顶啊，敢问如何保养头发？","like_count":1},{"had_liked":false,"id":356034,"user_name":"elune3344","can_delete":false,"product_type":"c1","uid":2908775,"ip_address":"上海","ucode":"90183038A77E6A","user_header":"https://static001.geekbang.org/account/avatar/00/2c/62/67/cd17dabe.jpg","comment_is_top":false,"comment_ctime":1661930025,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1661930025","product_id":100079901,"comment_content":"useEffect(() =&gt; execute(), [execute]);<br>为啥不把这个执行的逻辑封在useAsync里面呢","like_count":0},{"had_liked":false,"id":356033,"user_name":"elune3344","can_delete":false,"product_type":"c1","uid":2908775,"ip_address":"上海","ucode":"90183038A77E6A","user_header":"https://static001.geekbang.org/account/avatar/00/2c/62/67/cd17dabe.jpg","comment_is_top":false,"comment_ctime":1661929982,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1661929982","product_id":100079901,"comment_content":"useEffect(() =&gt; execute(), [execute]);<br>这一句为什么不在useAsync 直接执行呢","like_count":0},{"had_liked":false,"id":348311,"user_name":"林芊芊","can_delete":false,"product_type":"c1","uid":3023492,"ip_address":"","ucode":"08B487A9F44A7A","user_header":"","comment_is_top":false,"comment_ctime":1654951826,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654951826","product_id":100079901,"comment_content":"react根本不关心 名字是否是usexxx 。 ","like_count":0},{"had_liked":false,"id":339862,"user_name":"siegfried","can_delete":false,"product_type":"c1","uid":1007931,"ip_address":"","ucode":"31673819DD2605","user_header":"https://static001.geekbang.org/account/avatar/00/0f/61/3b/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1648438933,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648438933","product_id":100079901,"comment_content":"思考题。在useCounter的function内添加参数。","like_count":0},{"had_liked":false,"id":337277,"user_name":"Geek_983da8","can_delete":false,"product_type":"c1","uid":2937788,"ip_address":"","ucode":"D276FDB24F29A9","user_header":"https://static001.geekbang.org/account/avatar/00/2c/d3/bc/51c1029f.jpg","comment_is_top":false,"comment_ctime":1646730832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646730832","product_id":100079901,"comment_content":"原来这就是花钱的才能感受到的魅力","like_count":0},{"had_liked":false,"id":334423,"user_name":"陈冠南","can_delete":false,"product_type":"c1","uid":2735318,"ip_address":"","ucode":"89AB86B1BFA242","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqdH1VzVC9fJySwZib0vGSTS6EQib1JMtXb0TeHmWhdibASnnx5RqEGoreVT6005LnY4iaXOprwHtMp6A/132","comment_is_top":false,"comment_ctime":1644928596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644928596","product_id":100079901,"comment_content":"醍醐灌顶，这就把之前在公司写的很难维护的代码用自定义hooks拆分一下～ 谢谢老师！","like_count":0},{"had_liked":false,"id":331897,"user_name":"uinging","can_delete":false,"product_type":"c1","uid":1025345,"ip_address":"","ucode":"5D0FDB5EADB756","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a5/41/9ae89188.jpg","comment_is_top":false,"comment_ctime":1642858578,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642858578","product_id":100079901,"comment_content":"清晰又简洁，老师多出几门课吧。","like_count":0},{"had_liked":false,"id":331257,"user_name":"馍馍汉宝","can_delete":false,"product_type":"c1","uid":2727971,"ip_address":"","ucode":"D46DC76AF6674C","user_header":"https://static001.geekbang.org/account/avatar/00/29/a0/23/4668496b.jpg","comment_is_top":false,"comment_ctime":1642508070,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642508070","product_id":100079901,"comment_content":"太棒了这节，学到很多","like_count":0},{"had_liked":false,"id":328062,"user_name":"Light 胖虎","can_delete":false,"product_type":"c1","uid":2876591,"ip_address":"","ucode":"D5FCFE14172D31","user_header":"https://static001.geekbang.org/account/avatar/00/2b/e4/af/f8cf4bc2.jpg","comment_is_top":false,"comment_ctime":1640510288,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640510288","product_id":100079901,"comment_content":"老师，在阅读过拆分方法的这里发现了一个问题，是不是普遍的如果该自定义hooks有参数里面hooks的依赖项必须有参数，如果该自定义hooks不需要参数则一般依赖项为空数组就可以","like_count":0},{"had_liked":false,"id":322189,"user_name":"曹昌魁","can_delete":false,"product_type":"c1","uid":1127384,"ip_address":"","ucode":"426CF942C5DD38","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/d8/28858704.jpg","comment_is_top":false,"comment_ctime":1637226684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637226684","product_id":100079901,"comment_content":"老师好，请问useAsync中的execute如何传参数？","like_count":0},{"had_liked":false,"id":314363,"user_name":"阿阳","can_delete":false,"product_type":"c1","uid":1165817,"ip_address":"","ucode":"20A35FB86B1C5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/c9/f9/39492855.jpg","comment_is_top":false,"comment_ctime":1632986452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632986452","product_id":100079901,"comment_content":"这节课的典型例子，真的需要不断学习，不断实践，不断体会，真的是突破已有的认知，提升水平。","like_count":0},{"had_liked":false,"id":306374,"user_name":"rookie","can_delete":false,"product_type":"c1","uid":1686457,"ip_address":"","ucode":"F6CCC3EEE2A96E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoeOax1CZKbFicWib6Eicl7WHVpFG269qQCes0wbiawJsqPs45B8sAgF7eGyjhJJkibXTjtApNicnmicPh1g/132","comment_is_top":false,"comment_ctime":1628518980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628518980","product_id":100079901,"comment_content":"import { useState, useCallback } from &quot;react&quot;;<br>import { InputNumber } from &quot;antd&quot;;<br><br>function useCounter() {<br>  &#47;&#47; 定义 count 这个 state 用于保存当前数值<br>  const [count, setCount] = useState(0);<br><br>  const [step, setStep] = useState(1);<br>  &#47;&#47; 实现加 1 的操作<br>  const increment = useCallback(() =&gt; setCount(count + step), [count]);<br>  &#47;&#47; 实现减 1 的操作<br>  const decrement = useCallback(() =&gt; {<br>    setCount(count - step);<br>  }, [count]);<br>  &#47;&#47; 重置计数器<br>  const reset = useCallback(() =&gt; setCount(0), []);<br><br>  const change = useCallback((value) =&gt; {<br>    setStep(value);<br>  }, []);<br><br>  &#47;&#47; 将业务逻辑的操作 export 出去供调用者使用<br>  return { count, increment, decrement, reset, change, step };<br>}<br><br>export default function Counter() {<br>  &#47;&#47; 调用自定义 Hook<br>  const { count, increment, decrement, reset, change, step } = useCounter();<br><br>  &#47;&#47; 渲染 UI<br>  return (<br>    &lt;div&gt;<br>      &lt;h1&gt;Use Counter&lt;&#47;h1&gt;<br>      &lt;button onClick={decrement}&gt; - &lt;&#47;button&gt;<br>      &lt;span<br>        style={{ display: &quot;inline-block&quot;, width: &quot;40px&quot;, textAlign: &quot;center&quot; }}<br>      &gt;<br>        {count}<br>      &lt;&#47;span&gt;<br>      &lt;button onClick={increment}&gt; + &lt;&#47;button&gt;<br>      &lt;button onClick={reset}&gt; reset &lt;&#47;button&gt;<br>      &lt;InputNumber defaultValue={step} onChange={change} &#47;&gt;<br>    &lt;&#47;div&gt;<br>  );<br>}<br>","like_count":0},{"had_liked":false,"id":301493,"user_name":"Roy Liang","can_delete":false,"product_type":"c1","uid":1098898,"ip_address":"","ucode":"1DF5FC831A35DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/92/338b5609.jpg","comment_is_top":false,"comment_ctime":1625714766,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1625714766","product_id":100079901,"comment_content":"老师，如果fetchUsers方法带参数，该怎么写？","like_count":0},{"had_liked":false,"id":298869,"user_name":"发芽的紫菜","can_delete":false,"product_type":"c1","uid":1055836,"ip_address":"","ucode":"49450F3287DF28","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/5c/f5f24221.jpg","comment_is_top":false,"comment_ctime":1624352245,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"1624352245","product_id":100079901,"comment_content":"还是不太理解自定义hooks，自定义hooks useCounter用到了useState，那么我在使用自定义hooks useCounter的时候，可以理解为跟使用useState差不多吗？<br><br>但是这个状态count是在useCounter的函数里，什么使用自定义hooks的外层函数组件Counter也会更新呢？这个底层原理是什么？是React做了什么处理吗？","like_count":0,"discussions":[{"author":{"id":1200447,"avatar":"https://static001.geekbang.org/account/avatar/00/12/51/3f/41c68054.jpg","nickname":"我要的飞翔","note":"","ucode":"41C51DBC8372BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381431,"discussion_content":"我觉得就是老师一直强调的  hook就是函数  hook的执行就是函数的执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625048596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1385324,"avatar":"https://static001.geekbang.org/account/avatar/00/15/23/6c/e5a88f14.jpg","nickname":"胡哥有话说","note":"","ucode":"5046D968D448E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380605,"discussion_content":"react对以use开头的函数，识别为用户自定义Hooks，处理上与useState会保持一致。\n也可以简单的认为，react在识别是否是Hooks函数时，的判断标准是use开头\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624602663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1200447,"avatar":"https://static001.geekbang.org/account/avatar/00/12/51/3f/41c68054.jpg","nickname":"我要的飞翔","note":"","ucode":"41C51DBC8372BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1385324,"avatar":"https://static001.geekbang.org/account/avatar/00/15/23/6c/e5a88f14.jpg","nickname":"胡哥有话说","note":"","ucode":"5046D968D448E5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381432,"discussion_content":"其实react不会判断是不是use开头，严格来讲不是use开头的函数依然可以作为hook使用，里面可以useState/useEffect，只要这个函数是在函数组件或者其他自定义hook中使用\n但是！这更像是一种规范，以及在eslint检查中会对此进行检查","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625048794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":380605,"ip_address":""},"score":381432,"extra":""}]},{"author":{"id":1672018,"avatar":"https://static001.geekbang.org/account/avatar/00/19/83/52/47dc4d5c.jpg","nickname":"Claus Wong","note":"","ucode":"E07685C4E7B07F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380335,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624444464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298794,"user_name":"Geek_5104b1","can_delete":false,"product_type":"c1","uid":2649750,"ip_address":"","ucode":"97B26557EC7823","user_header":"","comment_is_top":false,"comment_ctime":1624327392,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1624327392","product_id":100079901,"comment_content":"还有一个问题，就是在useAsync内部，return asyncFunction()这个地方的return有什么意义嘛？useCallback不是将整个的回调函数做缓存嘛？不是很理解，差了相关资料也没有解决，望老师给解答一下","like_count":0,"discussions":[{"author":{"id":1672018,"avatar":"https://static001.geekbang.org/account/avatar/00/19/83/52/47dc4d5c.jpg","nickname":"Claus Wong","note":"","ucode":"E07685C4E7B07F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380417,"discussion_content":"内层(封装)return与否取决于外层(调用)的细腻度，如果调用用到promise fetchUsers().then().catch()，那可以return；但此处即使return，fetchUsers().then().catch()因为内层（封装）只是setData/setLoading/setError，并没有再次return数据，因此无用，要结合具体业务场景。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1624497101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2649750,"avatar":"","nickname":"Geek_5104b1","note":"","ucode":"97B26557EC7823","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1672018,"avatar":"https://static001.geekbang.org/account/avatar/00/19/83/52/47dc4d5c.jpg","nickname":"Claus Wong","note":"","ucode":"E07685C4E7B07F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380574,"discussion_content":"理解了，感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624589070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":380417,"ip_address":""},"score":380574,"extra":""}]}]},{"had_liked":false,"id":298337,"user_name":"重生","can_delete":false,"product_type":"c1","uid":1173049,"ip_address":"","ucode":"8ABFEAD785184A","user_header":"https://static001.geekbang.org/account/avatar/00/11/e6/39/16208644.jpg","comment_is_top":false,"comment_ctime":1624022670,"is_pvip":false,"replies":[{"id":"108269","content":"一般我会单独用一个 hooks 文件夹放自定义的 hooks。关于文件夹结构可以参考第10课哦！","user_name":"作者回复","comment_id":298337,"uid":"1018676","ip_address":"","utype":1,"ctime":1624086723,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":0,"score":"1624022670","product_id":100079901,"comment_content":"自定义hooks一般放在哪个文件夹下","like_count":0},{"had_liked":false,"id":297531,"user_name":"Neil 陈荣","can_delete":false,"product_type":"c1","uid":1018719,"ip_address":"","ucode":"CE66700BE7E225","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/5f/ecf0e687.jpg","comment_is_top":false,"comment_ctime":1623601450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623601450","product_id":100079901,"comment_content":"useAsync 命名成 useFetch 是否贴切些","like_count":0},{"had_liked":false,"id":296882,"user_name":"Isaac","can_delete":false,"product_type":"c1","uid":1110607,"ip_address":"","ucode":"038C349AB508AB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","comment_is_top":false,"comment_ctime":1623209714,"is_pvip":false,"replies":[{"id":"107976","content":"是的。","user_name":"作者回复","comment_id":296882,"uid":"1018676","ip_address":"","utype":1,"ctime":1623470379,"user_name_real":"Nate"}],"discussion_count":2,"race_medal":0,"score":"1623209714","product_id":100079901,"comment_content":"老师，自定义 hooks 必须要以 usexxx开头吗？","like_count":0,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521626,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623470379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2876591,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/e4/af/f8cf4bc2.jpg","nickname":"Light 胖虎","note":"","ucode":"D5FCFE14172D31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541667,"discussion_content":"再细问一下必须是use开头的驼峰写法吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640510394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296782,"user_name":"小个子外星人：）","can_delete":false,"product_type":"c1","uid":2642842,"ip_address":"","ucode":"AC8925E536DD58","user_header":"https://static001.geekbang.org/account/avatar/00/28/53/9a/2eddfce2.jpg","comment_is_top":false,"comment_ctime":1623158286,"is_pvip":false,"replies":[{"id":"107954","content":"谢谢~","user_name":"作者回复","comment_id":296782,"uid":"1018676","ip_address":"","utype":1,"ctime":1623388996,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":0,"score":"1623158286","product_id":100079901,"comment_content":"这节课超级棒！谢谢老师。努力在实践中，使用这节课的内容","like_count":0},{"had_liked":false,"id":296478,"user_name":"Bug般的存在","can_delete":false,"product_type":"c1","uid":1573766,"ip_address":"","ucode":"7A61F7AA3B49A3","user_header":"https://static001.geekbang.org/account/avatar/00/18/03/86/c9051c6a.jpg","comment_is_top":false,"comment_ctime":1622993719,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622993719","product_id":100079901,"comment_content":" const increment = useCallback((step = 1) =&gt; setCounter(counter + step), [counter]);","like_count":0},{"had_liked":false,"id":296402,"user_name":"满月","can_delete":false,"product_type":"c1","uid":1380258,"ip_address":"","ucode":"5D4F8B769E79F6","user_header":"https://static001.geekbang.org/account/avatar/00/15/0f/a2/2bb7df25.jpg","comment_is_top":false,"comment_ctime":1622956965,"is_pvip":false,"replies":[{"id":"107946","content":"赞~ 也可以在 useCounter 的时候传参数。","user_name":"作者回复","comment_id":296402,"uid":"1018676","ip_address":"","utype":1,"ctime":1623388132,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":0,"score":"1622956965","product_id":100079901,"comment_content":"import React, { useState, useCallback } from &#39;react&#39;;<br><br>function useCounter() {<br>  const [count, setCount] = useState(0);<br>  const increment = useCallback(<br>    (delta = 1) =&gt; setCount(count + delta),<br>    [count],<br>  );<br>  const decrement = useCallback(<br>    (delta = 1) =&gt; setCount(count - delta),<br>    [count],<br>  );<br>  const reset = useCallback(() =&gt; setCount(0), []);<br>  return {<br>    count,<br>    increment,<br>    decrement,<br>    reset,<br>  };<br>}<br><br>export default function Counter() {<br>  &#47;&#47; 调用自定义 Hook<br>  const { count, increment, decrement, reset } = useCounter();<br><br>  &#47;&#47; 渲染 UI<br>  return (<br>    &lt;div&gt;<br>      &lt;button onClick={() =&gt; decrement()}&gt; - &lt;&#47;button&gt;<br>      &lt;p&gt;{count}&lt;&#47;p&gt;<br>      &lt;button onClick={() =&gt; increment(2)}&gt; + &lt;&#47;button&gt;<br>      &lt;button onClick={reset}&gt; reset &lt;&#47;button&gt;<br>    &lt;&#47;div&gt;<br>  );<br>}","like_count":0},{"had_liked":false,"id":296399,"user_name":"Geek_71adef","can_delete":false,"product_type":"c1","uid":2643315,"ip_address":"","ucode":"E3CC6F6FBB1468","user_header":"","comment_is_top":false,"comment_ctime":1622954387,"is_pvip":false,"replies":[{"id":"107945","content":"自定义的 useHooks 不一定返回一个方法，可能只是本身需要一些参数，场景是不一样的。","user_name":"作者回复","comment_id":296399,"uid":"1018676","ip_address":"","utype":1,"ctime":1623388080,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":0,"score":"1622954387","product_id":100079901,"comment_content":"请问如何区别 自定义hook是在usehook传参，还是在usehook里面的方法传参？","like_count":0},{"had_liked":false,"id":296335,"user_name":"xgqfrms","can_delete":false,"product_type":"c1","uid":1436879,"ip_address":"","ucode":"7858A74FEEBE7D","user_header":"https://static001.geekbang.org/account/avatar/00/15/ec/cf/8c1f8d38.jpg","comment_is_top":false,"comment_ctime":1622903133,"is_pvip":false,"replies":[{"id":"107748","content":"res.json() 返回的是一个 promise，所以要 await 哦。","user_name":"作者回复","comment_id":296335,"uid":"1018676","ip_address":"","utype":1,"ctime":1623082131,"user_name_real":"Nate"}],"discussion_count":7,"race_medal":0,"score":"1622903133","product_id":100079901,"comment_content":"完全没有必要使用 await 处理 res 呀<br><br>```js<br>&#47;&#47; return await res.json();<br><br> return res.json();<br><br>```","like_count":0,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521401,"discussion_content":"res.json() 返回的是一个 promise，所以要 await 哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623082131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123263,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/bf/071dbb60.jpg","nickname":"Nodreame","note":"","ucode":"E2CF7D8B1341E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377908,"discussion_content":"Body.json()返回的是promise","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622958828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2995803,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/icDTEyU8lQ5bQJYnp7SAJicR3Nf3P8k18JcNkxib4xeuOCxEAx5OV4Eq5IFIytOHTkbSCaicPTDcZFQUKAcpFeyqIA/132","nickname":"Geek_f3ceca","note":"","ucode":"6EBAF9DBCF3923","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574163,"discussion_content":"我还是赞成xgqfrms，不需要await。async 返回默认会转promise的，直接return个promise一样的效果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653880124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1672018,"avatar":"https://static001.geekbang.org/account/avatar/00/19/83/52/47dc4d5c.jpg","nickname":"Claus Wong","note":"","ucode":"E07685C4E7B07F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380420,"discussion_content":"https://developer.mozilla.org/zh-CN/docs/Web/API/Body/json","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624498159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1436879,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ec/cf/8c1f8d38.jpg","nickname":"xgqfrms","note":"","ucode":"7858A74FEEBE7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378530,"discussion_content":"```js\n\nasync () => { \n  const res = await fetch(`${endpoint}/posts`); \n  return await res.json(); \n}\n\nasync () => { \n  const res = await fetch(`${endpoint}/posts`); \n  // res 已经 await 成功了，不需要再次 await\n  return res.json(); \n}\n\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623260423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1436879,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ec/cf/8c1f8d38.jpg","nickname":"xgqfrms","note":"","ucode":"7858A74FEEBE7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378529,"discussion_content":"res 已经 await 了呀，所以 res.json() 不需要 再次 await 还是没看明白吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623260309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1195144,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3c/88/6bef27d6.jpg","nickname":"大神博士","note":"","ucode":"8C4318095949F0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1436879,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ec/cf/8c1f8d38.jpg","nickname":"xgqfrms","note":"","ucode":"7858A74FEEBE7D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379967,"discussion_content":"Body.json()返回的是promise，所以 res.json 需要 再次 await 还是没看明白吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624264473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378529,"ip_address":""},"score":379967,"extra":""}]}]},{"had_liked":false,"id":296282,"user_name":"Free fall","can_delete":false,"product_type":"c1","uid":2637054,"ip_address":"","ucode":"8DBF73CD0F423F","user_header":"","comment_is_top":false,"comment_ctime":1622880543,"is_pvip":false,"replies":[{"id":"107747","content":"不错，这样可以在调用方法的时候指定具体加几~","user_name":"作者回复","comment_id":296282,"uid":"1018676","ip_address":"","utype":1,"ctime":1623081944,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":0,"score":"1622880543","product_id":100079901,"comment_content":"const useCounter = (initCount = 0) =&gt; {<br>  const [count, setCount] = useState(initCount)<br><br>  const increase = useCallback((body) =&gt; {<br>    setCount((count) =&gt; (count += body))<br>  }, [])<br><br>  return [count, increase]<br>}","like_count":0}]}