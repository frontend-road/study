{"id":71187,"title":"32 | 字符串匹配基础（上）：如何借助哈希算法实现高效字符串匹配？","content":"<p>从今天开始，我们来学习字符串匹配算法。字符串匹配这样一个功能，我想对于任何一个开发工程师来说，应该都不会陌生。我们用的最多的就是编程语言提供的字符串查找函数，比如Java中的indexOf()，Python中的find()函数等，它们底层就是依赖接下来要讲的字符串匹配算法。</p><p>字符串匹配算法很多，我会分四节来讲解。今天我会讲两种比较简单的、好理解的，它们分别是：BF算法和RK算法。下一节，我会讲两种比较难理解、但更加高效的，它们是：BM算法和KMP算法。</p><p>这两节讲的都是单模式串匹配的算法，也就是一个串跟一个串进行匹配。第三节、第四节，我会讲两种多模式串匹配算法，也就是在一个串中同时查找多个串，它们分别是Trie树和AC自动机。</p><p>今天讲的两个算法中，RK算法是BF算法的改进，它巧妙借助了我们前面讲过的哈希算法，让匹配的效率有了很大的提升。那<strong><span class=\"orange\">RK算法是如何借助哈希算法来实现高效字符串匹配的呢</span></strong>？你可以带着这个问题，来学习今天的内容。</p><h2>BF算法</h2><p>BF算法中的BF是Brute Force的缩写，中文叫作暴力匹配算法，也叫朴素匹配算法。从名字可以看出，这种算法的字符串匹配方式很“暴力”，当然也就会比较简单、好懂，但相应的性能也不高。</p><!-- [[[read_end]]] --><p>在开始讲解这个算法之前，我先定义两个概念，方便我后面讲解。它们分别是<strong>主串</strong>和<strong>模式串</strong>。这俩概念很好理解，我举个例子你就懂了。</p><p>比方说，我们在字符串A中查找字符串B，那字符串A就是主串，字符串B就是模式串。我们把主串的长度记作n，模式串的长度记作m。因为我们是在主串中查找模式串，所以n&gt;m。</p><p>作为最简单、最暴力的字符串匹配算法，BF算法的思想可以用一句话来概括，那就是，<strong>我们在主串中，检查起始位置分别是0、1、2....n-m且长度为m的n-m+1个子串，看有没有跟模式串匹配的</strong>。我举一个例子给你看看，你应该可以理解得更清楚。</p><p><img src=\"https://static001.geekbang.org/resource/image/f3/a2/f36fed972a5bdc75331d59c36eb15aa2.jpg?wh=1142*856\" alt=\"\"></p><p>从上面的算法思想和例子，我们可以看出，在极端情况下，比如主串是“aaaaa....aaaaaa”（省略号表示有很多重复的字符a），模式串是“aaaaab”。我们每次都比对m个字符，要比对n-m+1次，所以，这种算法的最坏情况时间复杂度是O(n*m)。</p><p>尽管理论上，BF算法的时间复杂度很高，是O(n*m)，但在实际的开发中，它却是一个比较常用的字符串匹配算法。为什么这么说呢？原因有两点。</p><p>第一，实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把m个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是O(n*m)，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。</p><p>第二，朴素字符串匹配算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有bug也容易暴露和修复。在工程中，在满足性能要求的前提下，简单是首选。这也是我们常说的<a href=\"https://zh.wikipedia.org/wiki/KISS%E5%8E%9F%E5%88%99\">KISS（Keep it Simple and Stupid）设计原则</a>。</p><p>所以，在实际的软件开发中，绝大部分情况下，朴素的字符串匹配算法就够用了。</p><h2>RK算法</h2><p>RK算法的全称叫Rabin-Karp算法，是由它的两位发明者Rabin和Karp的名字来命名的。这个算法理解起来也不是很难。我个人觉得，它其实就是刚刚讲的BF算法的升级版。</p><p>我在讲BF算法的时候讲过，如果模式串长度为m，主串长度为n，那在主串中，就会有n-m+1个长度为m的子串，我们只需要暴力地对比这n-m+1个子串与模式串，就可以找出主串与模式串匹配的子串。</p><p>但是，每次检查主串与子串是否匹配，需要依次比对每个字符，所以BF算法的时间复杂度就比较高，是O(n*m)。我们对朴素的字符串匹配算法稍加改造，引入哈希算法，时间复杂度立刻就会降低。</p><p>RK算法的思路是这样的：我们通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（这里先不考虑哈希冲突的问题，后面我们会讲到）。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。</p><p><img src=\"https://static001.geekbang.org/resource/image/01/ee/015c85a9c2a4adc11236f9a40c6d57ee.jpg?wh=1142*523\" alt=\"\"></p><p>不过，通过哈希算法计算子串的哈希值的时候，我们需要遍历子串中的每个字符。尽管模式串与子串比较的效率提高了，但是，算法整体的效率并没有提高。有没有方法可以提高哈希算法计算子串哈希值的效率呢？</p><p>这就需要哈希算法设计的非常有技巧了。我们假设要匹配的字符串的字符集中只包含K个字符，我们可以用一个K进制数来表示一个子串，这个K进制数转化成十进制数，作为子串的哈希值。表述起来有点抽象，我举了一个例子，看完你应该就能懂了。</p><p>比如要处理的字符串只包含a～z这26个小写字母，那我们就用二十六进制来表示一个字符串。我们把a～z这26个字符映射到0～25这26个数字，a就表示0，b就表示1，以此类推，z表示25。</p><p>在十进制的表示法中，一个数字的值是通过下面的方式计算出来的。对应到二十六进制，一个包含a到z这26个字符的字符串，计算哈希的时候，我们只需要把进位从10改成26就可以。</p><p><img src=\"https://static001.geekbang.org/resource/image/d5/04/d5c1cb11d9fc97d0b28513ba7495ab04.jpg?wh=1142*581\" alt=\"\"></p><p>这个哈希算法你应该看懂了吧？现在，为了方便解释，在下面的讲解中，我假设字符串中只包含a～z这26个小写字符，我们用二十六进制来表示一个字符串，对应的哈希值就是二十六进制数转化成十进制的结果。</p><p>这种哈希算法有一个特点，在主串中，相邻两个子串的哈希值的计算公式有一定关系。我这有个例子，你先找一下规律，再来看我后面的讲解。</p><p><img src=\"https://static001.geekbang.org/resource/image/f9/f5/f99c16f2f899d19935567102c59661f5.jpg?wh=1142*488\" alt=\"\"></p><p>从这里例子中，我们很容易就能得出这样的规律：相邻两个子串s[i-1]和s[i]（i表示子串在主串中的起始位置，子串的长度都为m），对应的哈希值计算公式有交集，也就是说，我们可以使用s[i-1]的哈希值很快的计算出s[i]的哈希值。如果用公式表示的话，就是下面这个样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/c4/9c/c47b092408ebfddfa96268037d53aa9c.jpg?wh=2048*1147\" alt=\"\"></p><p>不过，这里有一个小细节需要注意，那就是26^(m-1)这部分的计算，我们可以通过查表的方法来提高效率。我们事先计算好26^0、26^1、26^2……26^(m-1)，并且存储在一个长度为m的数组中，公式中的“次方”就对应数组的下标。当我们需要计算26的x次方的时候，就可以从数组的下标为x的位置取值，直接使用，省去了计算的时间。</p><p><img src=\"https://static001.geekbang.org/resource/image/22/2f/224b899c6e82ec54594e2683acc4552f.jpg?wh=1142*268\" alt=\"\"></p><p>我们开头的时候提过，RK算法的效率要比BF算法高，现在，我们就来分析一下，RK算法的时间复杂度到底是多少呢？</p><p>整个RK算法包含两部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较。第一部分，我们前面也分析了，可以通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是O(n)。</p><p>模式串哈希值与每个子串哈希值之间的比较的时间复杂度是O(1)，总共需要比较n-m+1个子串的哈希值，所以，这部分的时间复杂度也是O(n)。所以，RK算法整体的时间复杂度就是O(n)。</p><p>这里还有一个问题就是，模式串很长，相应的主串中的子串也会很长，通过上面的哈希算法计算得到的哈希值就可能很大，如果超过了计算机中整型数据可以表示的范围，那该如何解决呢？</p><p>刚刚我们设计的哈希算法是没有散列冲突的，也就是说，一个字符串与一个二十六进制数一一对应，不同的字符串的哈希值肯定不一样。因为我们是基于进制来表示一个字符串的，你可以类比成十进制、十六进制来思考一下。实际上，我们为了能将哈希值落在整型数据范围内，可以牺牲一下，允许哈希冲突。这个时候哈希算法该如何设计呢？</p><p>哈希算法的设计方法有很多，我举一个例子说明一下。假设字符串中只包含a～z这26个英文字母，那我们每个字母对应一个数字，比如a对应1，b对应2，以此类推，z对应26。我们可以把字符串中每个字母对应的数字相加，最后得到的和作为哈希值。这种哈希算法产生的哈希值的数据范围就相对要小很多了。</p><p>不过，你也应该发现，这种哈希算法的哈希冲突概率也是挺高的。当然，我只是举了一个最简单的设计方法，还有很多更加优化的方法，比如将每一个字母从小到大对应一个素数，而不是1，2，3……这样的自然数，这样冲突的概率就会降低一些。</p><p>那现在新的问题来了。之前我们只需要比较一下模式串和子串的哈希值，如果两个值相等，那这个子串就一定可以匹配模式串。但是，当存在哈希冲突的时候，有可能存在这样的情况，子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配。</p><p>实际上，解决方法很简单。当我们发现一个子串的哈希值跟模式串的哈希值相等的时候，我们只需要再对比一下子串和模式串本身就好了。当然，如果子串的哈希值与模式串的哈希值不相等，那对应的子串和模式串肯定也是不匹配的，就不需要比对子串和模式串本身了。</p><p>所以，哈希算法的冲突概率要相对控制得低一些，如果存在大量冲突，就会导致RK算法的时间复杂度退化，效率下降。极端情况下，如果存在大量的冲突，每次都要再对比子串和模式串本身，那时间复杂度就会退化成O(n*m)。但也不要太悲观，一般情况下，冲突不会很多，RK算法的效率还是比BF算法高的。</p><h2>解答开篇&amp;内容小结</h2><p>今天我们讲了两种字符串匹配算法，BF算法和RK算法。</p><p>BF算法是最简单、粗暴的字符串匹配算法，它的实现思路是，拿模式串与主串中是所有子串匹配，看是否有能匹配的子串。所以，时间复杂度也比较高，是O(n*m)，n、m表示主串和模式串的长度。不过，在实际的软件开发中，因为这种算法实现简单，对于处理小规模的字符串匹配很好用。</p><p>RK算法是借助哈希算法对BF算法进行改造，即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间。所以，理想情况下，RK算法的时间复杂度是O(n)，跟BF算法相比，效率提高了很多。不过这样的效率取决于哈希算法的设计方法，如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化为O(n*m)。</p><h2>课后思考</h2><p>我们今天讲的都是一维字符串的匹配方法，实际上，这两种算法都可以类比到二维空间。假设有下面这样一个二维字符串矩阵（图中的主串），借助今天讲的处理思路，如何在其中查找另一个二维字符串矩阵（图中的模式串）呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/00/c9/00c353326466a8ce4e790e36924704c9.jpg?wh=1142*505\" alt=\"\"></p><p>欢迎留言和我分享，也欢迎点击“<span class=\"orange\">请朋友读</span>”，把今天的内容分享给你的好友，和他一起讨论、学习。</p>","neighbors":{"left":{"article_title":"31 | 深度和广度优先搜索：如何找出社交网络中的三度好友关系？","id":70891},"right":{"article_title":"33 | 字符串匹配基础（中）：如何实现文本编辑器中的查找功能？","id":71525}},"comments":[{"had_liked":false,"id":46833,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1543988155,"is_pvip":false,"discussion_count":12,"race_medal":0,"score":"1178365027259","product_id":100017301,"comment_content":"觉得今天的hash算法真是巧妙","like_count":275,"discussions":[{"author":{"id":1329835,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4a/ab/5d8a478f.jpg","nickname":"su","note":"","ucode":"66028FA847F9A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37877,"discussion_content":"如果对比的是中文，这种哈希方式就不能用了","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1571673779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2413294,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqfEZles2ojt0PC6Spic4zRRjWvS90KKqjmMib9kNOd6uOPicD6sbQudgs3DSkWQ2lKSickCvUSAsibHpg/132","nickname":"Geek_9ae5e2","note":"","ucode":"AA3FB86E372F6D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1329835,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4a/ab/5d8a478f.jpg","nickname":"su","note":"","ucode":"66028FA847F9A3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344981,"discussion_content":"每一个中文也对应一个ASCII编码","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1611633222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":37877,"ip_address":""},"score":344981,"extra":""}]},{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377495,"discussion_content":"被点名的幸运儿随便一句话都能上热榜😂","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1622685350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2204462,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/IY4fLqdVwCPlW7xJicz3nZm4OePT0o20tDZj1Hiauk2b0iaHMQcSOGpamLt9b72hYVG72sgRWic1BHY3uCvibWcfickw/132","nickname":"Grocker","note":"","ucode":"DF2E19A65DEAD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324262,"discussion_content":"遇到hash值相等的，再比较一下两者本身来确认是否相等以避免hash冲突","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1605081694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1068361,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","nickname":"明翼","note":"","ucode":"E77F86BEB3D5C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9673,"discussion_content":"但是字符串很长就失效了，这点麻烦\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1568203047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1068361,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","nickname":"明翼","note":"","ucode":"E77F86BEB3D5C1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9894,"discussion_content":"为什么，字符串长了，hash算法就失效了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568239412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":9673,"ip_address":""},"score":9894,"extra":""},{"author":{"id":1068361,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","nickname":"明翼","note":"","ucode":"E77F86BEB3D5C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10595,"discussion_content":"按照26进制计算这种方式就容易溢出了","likes_number":16,"is_delete":false,"is_hidden":false,"ctime":1568297394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":9894,"ip_address":""},"score":10595,"extra":""},{"author":{"id":1814542,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6MFOTicBvia6hWE5EVpicAWzibxNpaM6iaRLQugcf6ib9TUianqX0PpoTTmgiccKXUYxicnpo21rhN4V7YCJ1sAV9gyI0OQ/132","nickname":"Geek_367e88","note":"","ucode":"BB92172A420AB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1068361,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","nickname":"明翼","note":"","ucode":"E77F86BEB3D5C1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178629,"discussion_content":"不失效啊，文中不是写了么。取模就不会溢出了，由此带来hash冲突，hash匹配时再次对比原文即可","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1582183051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":9673,"ip_address":""},"score":178629,"extra":""}]},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360877,"discussion_content":"中文不是assic码，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616552420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":47318,"user_name":"ZX","can_delete":false,"product_type":"c1","uid":1235583,"ip_address":"","ucode":"0D2622FE6D1774","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/7f/8069035d.jpg","comment_is_top":false,"comment_ctime":1544105852,"is_pvip":false,"replies":[{"id":"16928","content":"你说的很对 代码实现就是这样处理的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544148737,"ip_address":"","comment_id":47318,"utype":1}],"discussion_count":17,"race_medal":0,"score":"847652663164","product_id":100017301,"comment_content":"RK算法，在对主串构建的时候，就对比是不是一样的，一样就不继续计算后面的hash，这样会不会更快一点","like_count":197,"discussions":[{"author":{"id":2057513,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/65/29/8c0fe011.jpg","nickname":"Fire","note":"","ucode":"8D3E102E690443","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310678,"discussion_content":"       这位同学的意思应该是说，查看一个主串是否包含一个模式串的时候，在RK算法中，每计算完主串中一个子串hash后，就拿该hash和模式串对比。hash相同并且字符串也相同的话，就不用计算其他子串的hash了。此时已经有答案了，可以直接返回了。\n       这样理解，没问题吧？","likes_number":49,"is_delete":false,"is_hidden":false,"ctime":1601991920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":2027249,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/ee/f1/10bd611c.jpg","nickname":"鸡哥","note":"","ucode":"4B6D01101264AD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2057513,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/65/29/8c0fe011.jpg","nickname":"Fire","note":"","ucode":"8D3E102E690443","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":410543,"discussion_content":"谢谢老哥的详细解释～","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635728194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310678,"ip_address":""},"score":410543,"extra":""},{"author":{"id":2694205,"avatar":"https://static001.geekbang.org/account/avatar/00/29/1c/3d/76465ee4.jpg","nickname":"摘星","note":"","ucode":"55D8CAFC938F91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2057513,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/65/29/8c0fe011.jpg","nickname":"Fire","note":"","ucode":"8D3E102E690443","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":413993,"discussion_content":"考虑到有哈希冲突 哈希值相同时也是需要进行字符逐一对比。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636632430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310678,"ip_address":""},"score":413993,"extra":""},{"author":{"id":2706487,"avatar":"https://static001.geekbang.org/account/avatar/00/29/4c/37/b6626a2d.jpg","nickname":"w","note":"","ucode":"CE4230DB2C4398","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2057513,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/65/29/8c0fe011.jpg","nickname":"Fire","note":"","ucode":"8D3E102E690443","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":577236,"discussion_content":"所以说，学好语文还是很重要的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655978938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310678,"ip_address":""},"score":577236,"extra":""}]},{"author":{"id":1275203,"avatar":"https://static001.geekbang.org/account/avatar/00/13/75/43/c6058200.jpg","nickname":"www","note":"","ucode":"951B364F2CB211","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391685,"discussion_content":"剪枝，尽早退出","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1630574359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431735,"discussion_content":"你说的很对 代码实现就是这样处理的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1544148737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1363822,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/uktgj5R0p78c67oLib8EuRMRCgP8yjxnZ1ibVOuibhRZvjJpKSJNaTl0UlEfGyiaaiaGyPmqpGYpibTt0QopX1qtWfQQ/132","nickname":"杨大小最嗨皮","note":"","ucode":"7DFACF1414AE16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353253,"discussion_content":"剪枝的思想","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615097653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1246157,"avatar":"https://static001.geekbang.org/account/avatar/00/13/03/cd/264f6a1c.jpg","nickname":"渔夫","note":"","ucode":"43C267E01220F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294263,"discussion_content":"实际的文本匹配，有时候需要匹配模式串出现的所有位置，并且他们都高亮","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595842784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1593085,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4e/fd/c2c330d5.jpg","nickname":"为此","note":"","ucode":"2E0331524A7CFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362997,"discussion_content":"对比是包括hash值和字符串两个的比较吗？\n如果不是的话，那么出现冲突不就乱套了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617088504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328748,"discussion_content":"赞，这想法不错。思考好深入。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606222380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250922,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIzGGthScz54sECZJKX3lgyjCATkgrvSt5N3eOsYB34jibCr3SkAX88QaZ5IVmME9Ec7VdkQGwRSPw/132","nickname":"哈哈哈","note":"","ucode":"8AC20A1C9C7DF8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304094,"discussion_content":"計算完當前子串就比較一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599467749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1305257,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ea/a9/0a917f2c.jpg","nickname":"Sunny","note":"","ucode":"BB7B274CE0672E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276930,"discussion_content":"啥意思 ? 没懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590972490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1543162,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/fa/103e6900.jpg","nickname":"山鬼谣","note":"","ucode":"E25F498B85A01B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1305257,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ea/a9/0a917f2c.jpg","nickname":"Sunny","note":"","ucode":"BB7B274CE0672E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280663,"discussion_content":"RK算法要先计算哈希值，在计算哈希值之前就拿原串和模式串进行比较是不是一样；构建应该是指 计算主串中所有子串的哈希值的过程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591588718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":276930,"ip_address":""},"score":280663,"extra":""},{"author":{"id":2056710,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/62/06/0d3b77f0.jpg","nickname":"今天我有猫了吗","note":"","ucode":"CFFEE98F292EB4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1543162,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/fa/103e6900.jpg","nickname":"山鬼谣","note":"","ucode":"E25F498B85A01B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304557,"discussion_content":"你应该理解错了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599614363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":280663,"ip_address":""},"score":304557,"extra":""},{"author":{"id":1909732,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLY0FFoux40Negib6LrE7EwT3T2BUbpYzOzUeiaiaXBmNGDGVgIZr5NeWBTEeCuALOg3ODtWa21bHMgg/132","nickname":"Geek_99ae14","note":"","ucode":"268852986A6B69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1543162,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/fa/103e6900.jpg","nickname":"山鬼谣","note":"","ucode":"E25F498B85A01B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305272,"discussion_content":"应该是计算哈希值之后拿原串和模式串的哈希值进行比较是不是一样","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1599836976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":280663,"ip_address":""},"score":305272,"extra":""}]},{"author":{"id":1257347,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/83/516e62ac.jpg","nickname":"木同","note":"","ucode":"81A7C9E8D27A52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212817,"discussion_content":"可以的，这想法着实不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585020226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014550,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/16/ca250e8c.jpg","nickname":"王木公","note":"","ucode":"F049AEBFA0338D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":106471,"discussion_content":"厉害了，有想法，赞一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577537659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":47025,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1544020616,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"242062189192","product_id":100017301,"comment_content":"思考题：<br><br>以模式串矩阵的大小，去匹配主串矩阵，每个小矩阵可以构建成字符串，就能用 RK 算法做字符串匹配了。<br><br>如果主串的大小是 M * N，模式串大小为 m * n，则时间复杂度为 (M - m  + 1) * (N - n + 1)。","like_count":56,"discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77186,"discussion_content":"em \nRK算法 这里应该是 O(M*N)，BF 是 O(MN*mn)","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1575894476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46898,"user_name":"朱月俊","can_delete":false,"product_type":"c1","uid":1017707,"ip_address":"","ucode":"4DA0728B862FBD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/6b/0b6cd39a.jpg","comment_is_top":false,"comment_ctime":1543998896,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"216292363696","product_id":100017301,"comment_content":"以前刷题的时候，遇到过rk算法，当时是没太考虑hash冲突，一个字母对应一个数字，子串的hash值就是子串中的字母对应的数字想加。<br>今天大佬将之抽象提炼出来，还专门提到冲突解决方法，不可谓不妙！","like_count":50,"discussions":[{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306885,"discussion_content":"额  其实这种冲突是很正常的一个玩法，如果对rocketmq的一些知识有了解【文件索引查找类似】，server按照key查询消息的时候，其实是key映射为hash，然后按照hash查找文件，文件里边查找到了，在client端在实际对比真正的key是否是key。。。不要太拘泥于单纯的刷题学习，多看一些开源项目的源码原理也是脑洞大开。。。kiss原则的实战","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1600411518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2962599,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/34/a7/52c4ea60.jpg","nickname":"年少挽滑稽世无双","note":"","ucode":"793DCBDE25A07B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574698,"discussion_content":"666，向大佬学习！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654262600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":306885,"ip_address":""},"score":574698,"extra":""}]},{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261022,"discussion_content":"没想到以这种方式遇见师兄，哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588930829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46681,"user_name":"P@tricK","can_delete":false,"product_type":"c1","uid":1233716,"ip_address":"","ucode":"293B2B3261A793","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/34/5dee4f70.jpg","comment_is_top":false,"comment_ctime":1543971116,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"181932597548","product_id":100017301,"comment_content":"思考题：<br>假设二维主串和模式串的维度分别是 m*n 和 i*j，横向在[0, m-i]，纵向在[0, n-j]取起始点，然后取同样的子串窗口对比，共有(m-i+1)*(n-j+1)个子串。<br><br>ps：<br>文中计算子串哈希值h[i]的公式中，第二个h[i-1]和后面的h[i+m-1]，应该是主串中的第i-1个和第i+m-1个字符的哈希值…","like_count":43,"discussions":[{"author":{"id":1185590,"avatar":"https://static001.geekbang.org/account/avatar/00/12/17/36/ece951b4.jpg","nickname":"恋雪","note":"","ucode":"B0D8870130A314","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221267,"discussion_content":"文中的公式你理解错了，文中不是h[i+m-1]，而是s[i+m-1]指的是主串下标为i+m-1的字符。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1585996875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63878,"user_name":"Flash","can_delete":false,"product_type":"c1","uid":1236163,"ip_address":"","ucode":"E285075C9E0B02","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/c3/e4ba51d5.jpg","comment_is_top":false,"comment_ctime":1548573929,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"121807658217","product_id":100017301,"comment_content":"看了很多评论后，发现思考题其实就是举一反三，我们可以在比较时，将二维串矩阵看作是字符串来处理，至于怎么转换成一维字符串，应该有很多方法，比如子串矩阵和模式串矩阵都用同样的规则来组成一个字符串，从左到右，再从上到下遍历取矩阵的元素a[i][j]。转换为一维字符后，就可以用BF或者RK算法了 。<br>复杂度分析，假设二维主串矩阵和模式串矩阵的维度分别是 m*n 和 i*j，按一个个矩阵来看子串的话，共有(m-i+1) * (n-j+1)个子串矩阵。<br>用RK算法的话，复杂度就是O((m-i+1) * (n-j+1))。","like_count":28,"discussions":[{"author":{"id":1121677,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/8d/9717e593.jpg","nickname":"一枝梅","note":"","ucode":"7DCE43B638EA6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102132,"discussion_content":"在匹配矩阵同一行时，将矩阵转化为一维字符是没什么问题，但是这样会导致一个问题就是由于丢失二维信息造成的跨行匹配，还是需要解决一下这个问题。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577326004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1121677,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/8d/9717e593.jpg","nickname":"一枝梅","note":"","ucode":"7DCE43B638EA6A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377497,"discussion_content":"对啊，跨行怎么玩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622685930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":102132,"ip_address":""},"score":377497,"extra":""}]},{"author":{"id":1019812,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8f/a4/abb7bfe3.jpg","nickname":"silence","note":"","ucode":"6765E6B1942541","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":182614,"discussion_content":"转换为一维字符串很难匹配，因为这种二维操作让行和列信息都消息了，除非用特殊的表示法，否则这条路行不通","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582441505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179759,"avatar":"https://static001.geekbang.org/account/avatar/00/12/00/6f/f0c0841d.jpg","nickname":"小吴同学","note":"","ucode":"29F8C0575E32AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6593,"discussion_content":"兄die，请教一下，有没有实现一下如何把二维数组转成一维字符串的。思考了一下，写不出来啊😢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566985975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71620,"user_name":"晓龙","can_delete":false,"product_type":"c1","uid":1004576,"ip_address":"","ucode":"78CDCEBD183D3A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/20/93c79f7c.jpg","comment_is_top":false,"comment_ctime":1551402174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"117515519166","product_id":100017301,"comment_content":"RK算法有两个可以改进的点，一个可以避免hash冲突，另一个可以减少hash计算次数。<br><br>改进一：先计算模式串的hash值，记录下来，然后计算每一个子串的hash，计算一次，就对比一次，如果hash值匹配，在全量对比字符串。这样做可以不用关心hash冲突问题。<br><br>改进二：计算子串hash值的时候只要计算到n-（n-m）处即可，剩下的子串长度小于模式串，不用计算。<br>","like_count":27},{"had_liked":false,"id":47446,"user_name":"hunterlodge","can_delete":false,"product_type":"c1","uid":1069755,"ip_address":"","ucode":"5B83A79E784161","user_header":"https://static001.geekbang.org/account/avatar/00/10/52/bb/225e70a6.jpg","comment_is_top":false,"comment_ctime":1544144626,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"113213294322","product_id":100017301,"comment_content":"RK算法和布隆过滤器的思想是一致的","like_count":26,"discussions":[{"author":{"id":1244845,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fe/ad/7fa85a7d.jpg","nickname":"放飞心情","note":"","ucode":"75A2192D91D86C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382382,"discussion_content":"稍微有一丢丢区别，布隆用了多个hash公式","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1625552396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":47336,"user_name":"✨拓星✨","can_delete":false,"product_type":"c1","uid":1234598,"ip_address":"","ucode":"CEB1206F5F7BC3","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/a6/0e4f73d9.jpg","comment_is_top":false,"comment_ctime":1544109384,"is_pvip":false,"replies":[{"id":"16926","content":"应该是比较刁钻的场景 我也没遇到过 平时都是直接用编程语言提供的函数。不过不耽误我们学习他的思想 技巧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544148589,"ip_address":"","comment_id":47336,"utype":1}],"discussion_count":2,"race_medal":0,"score":"104623324488","product_id":100017301,"comment_content":"基于BF的匹配算法平时的用的比较多，看完之后想了一会觉得没有什么情况会用到第二种RK算法的情况，因为平时业务关系可能没有做到相关的项目，所以想问老师一般什么场景会使用RK这种匹配算法呢？","like_count":24,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431742,"discussion_content":"应该是比较刁钻的场景 我也没遇到过 平时都是直接用编程语言提供的函数。不过不耽误我们学习他的思想 技巧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1544148589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2173090,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIstR9CfEytdeJyicODHOe6cYGt4icg8cNVam9mE0s7picUsInZvwvia1hEtKsyHETfic0jrAddjt0wXdA/132","nickname":"Geek_d68bf9","note":"","ucode":"D88E117B6A18B3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581843,"discussion_content":"RK算法竟然没有实际场景...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659020497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"陕西"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58294,"user_name":"痛改前非","can_delete":false,"product_type":"c1","uid":1005412,"ip_address":"","ucode":"4509CB0BB892EE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/64/064dc124.jpg","comment_is_top":false,"comment_ctime":1547028184,"is_pvip":false,"replies":[{"id":"21062","content":"我补一下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547085915,"ip_address":"","comment_id":58294,"utype":1}],"discussion_count":1,"race_medal":0,"score":"87446374104","product_id":100017301,"comment_content":"老师您应该把公式的推理过程简单地说一下，这公式对您来说非常简单，但是对于我这种基础差的人，完全是懵逼的状态。看着大家讨论，却无法深入下去。&#47;(ㄒoㄒ)&#47;~~","like_count":20,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435992,"discussion_content":"我补一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547085915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46922,"user_name":"coulson","can_delete":false,"product_type":"c1","uid":1125035,"ip_address":"","ucode":"ADBC6AEED866FC","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/ab/6b2475e9.jpg","comment_is_top":false,"comment_ctime":1544002303,"is_pvip":false,"replies":[{"id":"16819","content":"在高级篇那部分会涉及一点","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544062375,"ip_address":"","comment_id":46922,"utype":1}],"discussion_count":2,"race_medal":0,"score":"74558446335","product_id":100017301,"comment_content":"老师，前天面试被问到一个问题，关于地图算法的，比如线路推荐。请问地图算法会讲到么","like_count":17,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431602,"discussion_content":"在高级篇那部分会涉及一点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544062375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79843,"discussion_content":"反应面试的👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576116457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46750,"user_name":"Alan","can_delete":false,"product_type":"c1","uid":1243563,"ip_address":"","ucode":"EF3B6A90054B34","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/ab/374fe105.jpg","comment_is_top":false,"comment_ctime":1543977230,"is_pvip":false,"replies":[{"id":"16711","content":"写错了 感谢指正 已经改了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543987701,"ip_address":"","comment_id":46750,"utype":1}],"discussion_count":2,"race_medal":0,"score":"70263453966","product_id":100017301,"comment_content":"h[i] = 26*(h[i-1]-26^(m-1)*h[i-1]) + h[i+m-1];<br><br>其中, h[i]、h[i-1] 分别对应 s[i] 和 s[i-1] 两个子串的哈希值<br>------------------<br>文中这个公式，26*(h[i-1]-26^(m-1)*h[i-1])可以化简为26*h[i-1]*(1-26^(m-1))，所以这里是不是应该改为26*(h[i-1]-26^(m-1)*s[i-1])，用s[i-1]代表当前位置的字符串的值，例如图中d的值是3，同样的公式后面加 h[i+m-1]是不是也是s[i+m-1]呢","like_count":16,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431528,"discussion_content":"写错了 感谢指正 已经改了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543987701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039735,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/dd/77/1a26fa4d.jpg","nickname":"网虫子","note":"","ucode":"641B3FB7372E90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":17249,"discussion_content":"改后的h[i]公式少一个小括号","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568959728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49184,"user_name":"星君","can_delete":false,"product_type":"c1","uid":1132467,"ip_address":"","ucode":"4DECEC14EF8226","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/b3/4a76fccf.jpg","comment_is_top":false,"comment_ctime":1544618639,"is_pvip":false,"replies":[{"id":"17727","content":"不着急 慢慢来 没必要一直紧跟着","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544666025,"ip_address":"","comment_id":49184,"utype":1}],"discussion_count":2,"race_medal":0,"score":"48789258895","product_id":100017301,"comment_content":"好几期没看了，感觉跟不上了","like_count":11,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432519,"discussion_content":"不着急 慢慢来 没必要一直紧跟着","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544666025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261023,"discussion_content":"感觉数据结构与算法，就像是锻炼似的，要时不时拿出来练练，不然就忘了，锻炼身体断了一段时间，肥肉就长出来了，再去继续坚持续上就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588930960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46692,"user_name":"蒋礼锐","can_delete":false,"product_type":"c1","uid":1248897,"ip_address":"","ucode":"25E042066A1427","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/gM1ibHKPkrs5DSIp4aIuQ9jnYtNicc2tdG244PbaSvKw5jO9DWrhWghcVM1Y5Iq2QSpzLBUeWZQLhARst51z35mA/132","comment_is_top":false,"comment_ctime":1543971774,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"48788612030","product_id":100017301,"comment_content":"思考题:<br>可以先查找第一行的字符串，假设长度为m，用bf或者rk都可以，假设是n*n的数组，<br>bf的复杂度是(n-m)*n<br>rk的复杂度为n<br><br>如果有匹配，则依次匹配第2到m行字符串。每次的复杂度与第一次的相同<br><br>最坏时间复杂度为<br>bf:(m-n)^2*n^2<br>rk:n^2<br><br>但是如果第一行不匹配的话是不会进行第二行的匹配的，平均复杂度会小很多。","like_count":11,"discussions":[{"author":{"id":1344997,"avatar":"https://static001.geekbang.org/account/avatar/00/14/85/e5/eedb0528.jpg","nickname":"Zed","note":"","ucode":"0B1BF15DFB050C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178449,"discussion_content":"和你想法一样","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582165206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179443,"user_name":"兰柯","can_delete":false,"product_type":"c1","uid":1850499,"ip_address":"","ucode":"6D7230B3CE8722","user_header":"https://static001.geekbang.org/account/avatar/00/1c/3c/83/93e7af9e.jpg","comment_is_top":false,"comment_ctime":1582006285,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40236711949","product_id":100017301,"comment_content":"思考题可以用cnn里面的池化的思想来考虑，改一下池化的函数当作哈希函数。","like_count":9},{"had_liked":false,"id":46733,"user_name":"yaya","can_delete":false,"product_type":"c1","uid":1233856,"ip_address":"","ucode":"8C7FAC8F828BA4","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/c0/d38daa2d.jpg","comment_is_top":false,"comment_ctime":1543975628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35903713996","product_id":100017301,"comment_content":"二维矩阵只要如果以i&#39;j为左上角，即可定义一个i.j  i+1.j  i. j+1  i+1.j+1的子串，其本质是和字符串相同的，即可以由rf又可以由bf解","like_count":8},{"had_liked":false,"id":51139,"user_name":"漫漫越","can_delete":false,"product_type":"c1","uid":1249222,"ip_address":"","ucode":"F9F1E3AC4CF692","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/c6/cf344f74.jpg","comment_is_top":false,"comment_ctime":1545119820,"is_pvip":false,"replies":[{"id":"18558","content":"停一停 歇歇挺好的 也没必要跟的很紧 搞的自己很窘迫","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545185106,"ip_address":"","comment_id":51139,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31609890892","product_id":100017301,"comment_content":"停看了好多天，最后还是决定继续跟随老师的脚步，为自己加油~","like_count":7,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433304,"discussion_content":"停一停 歇歇挺好的 也没必要跟的很紧 搞的自己很窘迫","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545185106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169675,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1578403225,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"27348207001","product_id":100017301,"comment_content":"字符存储匹配算法是各种编程语言都会提供的字符匹配函数的底层依赖，它可以分为单模式匹配和多模式匹配算法。<br><br>单模式匹配：BF算法和RK算法，RK算法是BF算法的改进，它巧妙借助了哈希算法，提升了匹配的效率。<br>一：BF算法<br>\t1，BF算法是Brute Force的缩写，中文译作暴力匹配算法，也叫朴素匹配算法。<br>\t2，两个概念：主串和模式串<br>\t\t如在字符串A中查找字符串B，则字符串A就是主串，字符串B就是模式串<br>\t\t将主串长度记为n，模式串的长度记作m。因为是在主串中查找模式串，所以n&gt;m<br>\t3，BF算法的思想可概括为：我们在主串中，检查起始位置分别是0,1,2……n-m且长度为m的n-m+1个子串，看有没有更模式串匹配的。<br>\t4，极端情况下，如主串是“aaaaa…aaaaa”，模式串是“aaaab”。每次都比对m个字符，要比对n-m+1次，所以最坏的时间复杂度是O(m*n)。<br>\t5，虽然BF算法时间复杂度很高，但在实际开发中使用的非常常见。<br>\t\t原因1：实际软件开发中，大部分情况下，模式串和主串的长度都不会太长。每次模式串与主串中的子串匹配时，当中途不能遇到匹配的字符的时候，就可以停止，不需要全部对比一次。所以理论上最坏情况时间复杂度是O(m*n)，但这更多的是统计意义上的，大部分情况中，这个算法执行的很高效。<br>\t\t原因2：朴素字符串匹配算法思想简单，代码实现也非常简单，简单就意味着不容易出错。工程中，在满足性能要求的前提下，简单是首选，也是常说的KISS（keep it Simple and Stupid）设计原则。<br><br>二：RK算法：<br>\t1，RK算法的全称是Rabin-Karp算法，是两位发明人的名字拼接。是BF算法的升级版<br>\t2，BF算法的问题在于每次检查主串与子串是否匹配，需要依次对比每个字符，所以BF算法的时间复杂就比较高。但引入哈希算法，时间复杂度立即就会降低。<br>\t3，RK算法的思路：<br>\t\t通过哈希算法对主串中的n-m+1个子串分别求哈希值，<br>\t\t然后逐个于模式串的哈希值比较大小，如果相等就说明有对应的模式串。<br>\t4，通过哈希算法计算字符的哈希值时，需要遍历子串中的每个字符，这只提供了模式串与子串比较的效率，但整体的效率并没有提高。<br>\t5，为了提高哈希算法计算子串哈希值的效率，可以通过哈希算法的设计来解决。<br>\t\t假设要匹配的字符串的字符集中只包含k个字符，这就可以用一个k进制数来表示一个子串，这个k进制数转化成十进制，作为子串的哈希值。<br>\t6， <br>\t7，这种哈希算法有个特点，在主串中，相邻两个子串的哈希值的计算公式有一定关系。<br>\t8，相邻额哈希值计算公式有交集：<br> <br>\t9，RK算法的时间复杂度：<br>\t\t①：整个RK算法包含两个部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较。<br>\t\t②：第一部分，只需要扫描一遍主串就能计算出所有子串的哈希值了，复杂度是O(n)。<br>\t\t③：模式串哈希值与每个子串哈希值之间的比较时间复杂度是O(1)，总共需要比较n-m+1个子串的哈希值，所有，这部分的时间复杂度也是O(n)。<br>\t\t所以RK算法整体时间复杂度就是O(n)。<br>\t10，如果模式串很长，相应的主串中子串也会很长，通过上面的哈希算法计算得到的哈希值就可能很大，如果超过了计算机中整形数据可以表示范围，该如何解决？<br>\t答：我们可以把字符串中每个字母的数字相加，最后得到的和作为哈希值。这种哈希算法产生的哈希值的数据范围就相对要小很多。<br>11，若出现哈希冲突如何解决？<br>\t答：如果两值相等，比较子串中每个字符。<br>\t<br>\t所以，哈希算法中的冲突概率要相对控制得低一些，如果存在大量冲突，就会导致RK算法的时间复杂度退化，效率下降。极端情况下，如果存在大量的冲突，每次都要对比子串和模式串本身，时间复杂度就会退化成O(n*m)。<br>\t<br>","like_count":6},{"had_liked":false,"id":111439,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1562558086,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27332361862","product_id":100017301,"comment_content":"字符串匹配算法分类：单模式串匹配算法&amp;多模式串匹配算法<br>BF算法时间复杂度：o(m * n)<br>BF算法空间复杂度：o(1)<br>BF算法在jdk中的实践：String的indexof<br>BF算法优点：大部分实践情况下模式串和主串都不太长，且经常遇到能剪枝的情况，实际算法执行效率要比o(m * n)要好；符合KISS原则<br>RK算法时间复杂度：o(n)<br>RK算法空间复杂度：o(m)<br>RK算法中获得的启发：<br><br>1. 算法调优的核心就是减少无用功<br>2. 哈希表经常作为用空间换时间的典型数据结构<br>3. 当前算法的进行要考量是否能复用之前的结果，即考量步骤的前后关联性（可能有点动态规划的意思）","like_count":6,"discussions":[{"author":{"id":1027507,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epS4BWsMOb1Bq28XGZkwmrKiczb5QgRor6kjXRUaDqF10pqomriazaheFCZjaXe8aOPibItU4EeTep9g/132","nickname":"小欢子","note":"","ucode":"387DEBAAAF414A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317848,"discussion_content":"RK算法的空间复杂度也是O(1)吧？额外占用的空间，并没有随主串长度n或者模式串长度m变化呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603607448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50155,"user_name":"gesanri","can_delete":false,"product_type":"c1","uid":1121174,"ip_address":"","ucode":"AE3B97DC3ED668","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELtOO0HKrj5SI5JSlmwiaCvaF6GLiaTmf5NX88OZaO3HymTAGTeIoicBUjqzmMF6sF5raPFjuqLFibrrw/132","comment_is_top":false,"comment_ctime":1544880665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27314684441","product_id":100017301,"comment_content":"关于rk算法有一个疑问，举的例子是只包含26个字母的字符串，那如果字符串内容是不限制的，比如汉字，我不知道有多少个汉字，那应该怎么计算哈希值呢？总不能比如说有十万个汉字就用十万进制去计算哈希值吧","like_count":6},{"had_liked":false,"id":58302,"user_name":"痛改前非","can_delete":false,"product_type":"c1","uid":1005412,"ip_address":"","ucode":"4509CB0BB892EE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/64/064dc124.jpg","comment_is_top":false,"comment_ctime":1547029875,"is_pvip":false,"replies":[{"id":"21061","content":"抱歉 没写清楚","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547085799,"ip_address":"","comment_id":58302,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23021866355","product_id":100017301,"comment_content":"h[i] = 26*(h[i-1]-26^(m-1)*(s[i-1]-&#39;a&#39;)) + (s[i+m-1]-&#39;a&#39;);<br>其中, h[i]、h[i-1] 分别对应 s[i] 和 s[i-1] 两个子串的哈希值<br>  好吧，这一段代码我对照上下文看了10遍，看懂了。我承认我很蠢","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435997,"discussion_content":"抱歉 没写清楚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547085799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46883,"user_name":"煦暖","can_delete":false,"product_type":"c1","uid":1245418,"ip_address":"","ucode":"96D0B236C4148A","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/ea/6ad346c1.jpg","comment_is_top":false,"comment_ctime":1543996693,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23018833173","product_id":100017301,"comment_content":"“h[i] = 26*(h[i-1]-26^(m-1)*h[i-1]) + h[i+m-1];其中, h[i]、h[i-1] 分别对应 s[i] 和 s[i-1] 两个子串的哈希值。”老师你好，26^(m-1)*h[i-1]中的h[i-1]和h[i+m-1]应该是一个字符的哈希值而不应该是子串的哈希值吧？？PS：用您的例子套用公式：h0 = 3*26*26+1*26+2 = 2056；h1=26*(h0-26*26*h0)+(4*26*26+3*26+4) = -36080014 和期望的哈希值1*26*26+2*26+4=732不符。<br><br>","like_count":5,"discussions":[{"author":{"id":1055334,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","nickname":"苦行僧","note":"","ucode":"726024A9A9CF44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1246,"discussion_content":"应该是发生了溢出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562465960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107825,"user_name":"Geek_cf29f0","can_delete":false,"product_type":"c1","uid":1337800,"ip_address":"","ucode":"F635968AE2656C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bWpFdAQwTzBg70ib6QTQomfQV3Ak1CFQPXun20w2Kz3PCLtsV75nNrqBuDEvehtlCoTkyT3icNWnvO7nPMc1RFfg/132","comment_is_top":false,"comment_ctime":1561617635,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18741486819","product_id":100017301,"comment_content":"关键是构建n-1个子串，构建子串，在构建子串过程中实现字符串对比，最坏复杂度是o(n方)，我这里实现字符串对比，简写了，直接用了字符串的equals方法，可以使用bf或者rk算法实现，但是这个应用中，没必要利用以上方案实现两个字符串对比，当然可以再代码实现下，加深bf\\rk的算法思想的理解<br>private static boolean twoDimensionalMach(int n, String[][] array, String objectString){<br>        &#47;&#47;1.取前n-1阶矩阵作为起始元素构建2维矩阵---》获取字符串--》对比<br>        for (int i=0; i&lt;n-1; i++){<br>            for (int j=0; j&lt;n-1; j++){<br>                String item = array[i][j] + array[i][j+1] + array[i+1][j] + array[i+1][j+1];<br>                if (item.equals(objectString)){<br>                    return true;<br>                }<br>            }<br>        }<br>        return false;<br>    }","like_count":4,"discussions":[{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377499,"discussion_content":"冲突没写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622686657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55703,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1546265216,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18726134400","product_id":100017301,"comment_content":"RK 算法，计算相邻两个子串哈希值的规律，比如，相邻两个子串分别为 &quot;dbc&quot; 和 &quot;bce&quot;，那么 s[i-1] = &#39;d&#39;，s[i]=&#39;b&#39; ，与 &#39;a&#39; 相减意思是，它们的 ASCII 码值的差值正好表示字母的数值；<br>评论中有同学不明白老师给的哈希值 h[i] 和 h[i-1] 之间的关系，我想应该是 s[i] 和 s[i-1] 代表什么这点没明白。","like_count":4},{"had_liked":false,"id":47133,"user_name":"他在她城断了弦","can_delete":false,"product_type":"c1","uid":1242521,"ip_address":"","ucode":"3D91CA87B64C8B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/99/454b17c1.jpg","comment_is_top":false,"comment_ctime":1544061499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14428963387","product_id":100017301,"comment_content":"后面更新的课程老师能不能顺便帮贴几道有关的题，让大家检验自查一下","like_count":3},{"had_liked":false,"id":46773,"user_name":"王婵","can_delete":false,"product_type":"c1","uid":1252171,"ip_address":"","ucode":"2125BEDE4DB773","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/4b/5c04e06c.jpg","comment_is_top":false,"comment_ctime":1543979534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14428881422","product_id":100017301,"comment_content":"思考题二维数组用RK算法计算哈希值要复杂一些，i-1 j-1不越界的情况下，如果模式串的行数大于列数可以通过h[i-1,j]计算h[i,j]，如果列数大于行数可以通过h[i,j-1]计算h[i,j] 还有更好的方法计算哈希值吗？<br>另外正文里的计算哈希值的公式貌似写错了，应该是<br>h[i] = 26*(h[i-1]-26^(m-1)*(s[i-1]-‘a’)) + (s[i+m-1]-‘a’); ","like_count":3},{"had_liked":false,"id":222544,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1590831546,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10180766138","product_id":100017301,"comment_content":"RF 算法很巧妙啊，抓住了 BF 中最耗时的模式串与子串进行比较这个耗时最大的环节，通过计算子串的哈希值，变成两个值的比较。<br>两张人像图片进行比较，先提取特征值，然后计算两个特征值的距离，得到两张图片的相似度。感觉和 RF 有异曲同工之妙。","like_count":2,"discussions":[{"author":{"id":2876025,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/e2/79/d5d021cb.jpg","nickname":"Ins-think","note":"","ucode":"07E73D4C963E52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546715,"discussion_content":"是的，和图片搜索有点像。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642401038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194227,"user_name":"light","can_delete":false,"product_type":"c1","uid":1687572,"ip_address":"","ucode":"FC6FE8335D29E0","user_header":"https://static001.geekbang.org/account/avatar/00/19/c0/14/a1cce0fb.jpg","comment_is_top":false,"comment_ctime":1585039571,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10174974163","product_id":100017301,"comment_content":"思考题：<br>我搞图像的，如果实际遇到思考题这种问题，我肯定会首先考虑类似卷积的方式来处理。<br>1.将主串、模式串用数字表示；<br>2.将4*4的主串矩阵转化成9*4的矩阵；2*2的模式串转化成4*1的矩阵；<br>3.两个矩阵相乘，得到结果是9*1的矩阵； <br>4.将第3步矩阵的每行与模试串矩阵的平方和比较，得到所有结果相同的行；<br>5.最后在上一步得到的行里比较，得到结果。<br><br>这个的主要差别就在第三步，没有求hash而是直接算乘法了。","like_count":2,"discussions":[{"author":{"id":2876025,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/e2/79/d5d021cb.jpg","nickname":"Ins-think","note":"","ucode":"07E73D4C963E52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546716,"discussion_content":"大佬，我想问一下第二步的转换根据是什么？为什么把4*4的主串转成9*4；2*2的转成4*1？以及具体是如何转换的？挺感兴趣的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642401221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183254,"user_name":"云之崖","can_delete":false,"product_type":"c1","uid":1003366,"ip_address":"","ucode":"724C0614F40EC1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4f/66/1f8fccfb.jpg","comment_is_top":false,"comment_ctime":1582982846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10172917438","product_id":100017301,"comment_content":"自己电脑测试了一下，发现2个现象：<br>1. 如果主串、模式串都不长，同样情况 2 种算法都运行十万次，明显 BF 算法快；<br>2. 如果主串、模式串都比较长，同样情况 2 种算法都运行十万次，RK 算法会比 BF 算法快；<br><br>RK 我用的是很简单的 hash 算法，a-z分别代表0-1，然后逐个字符相加这种，不确定我这样验证是否验证有误？<br>如果没问题的话，是不是少量级的轮询比较操作，其实是非常快的，反而数字运算操作会比这个更加耗时，所以在大数量级上 RK 算法才会比 BF 算法更高效。","like_count":2},{"had_liked":false,"id":130464,"user_name":"一念逍遥、","can_delete":false,"product_type":"c1","uid":1136890,"ip_address":"","ucode":"827A4447D70798","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/fa/6f221fbc.jpg","comment_is_top":false,"comment_ctime":1567470632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10157405224","product_id":100017301,"comment_content":"h[i]的计算公式少了个右括号","like_count":2},{"had_liked":false,"id":51850,"user_name":"大刚","can_delete":false,"product_type":"c1","uid":1248488,"ip_address":"","ucode":"85630159EE53F6","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/e8/b0cb5616.jpg","comment_is_top":false,"comment_ctime":1545270271,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10135204863","product_id":100017301,"comment_content":"老师，下面的不懂，能不能在详细讲解下<br>h[i] = 26*(h[i-1]-26^(m-1)*(s[i-1]-&#39;a&#39;)) + (s[i+m-1]-&#39;a&#39;);","like_count":2,"discussions":[{"author":{"id":1329116,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/BJjGmy4ooNjeURBDhVeJ7EslNbyVd6jNricALVsx1QriczD2EXddKLkXxLQK02nExosCJdyfvicVcZwfpDk64iazmQ/132","nickname":"style_月月","note":"","ucode":"59489E1BDB0090","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91397,"discussion_content":"其实就是将B替换为A*26，而A = h[i-1] - 26^(m-1)26^(m-1)*(s[i-1]-&#39;a&#39;)，其中s[i-1]-&#39;a&#39;代表的就是这个字母对应的数字，使用文中的a～z用0～25表示，例如s[i-1]如果为b，s[i-1]-&#39;a&#39; = 2-1 = 1","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576831900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":47558,"user_name":"leo","can_delete":false,"product_type":"c1","uid":1107385,"ip_address":"","ucode":"0A3D3508398328","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLhicDSmL4vicPF4mF9g5icORERwDSqZv5Guk0TyhiacuBsiaVxCdktI6oCrKzcycwFlpyL6Q1nDbvJZzA/132","comment_is_top":false,"comment_ctime":1544154783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10134089375","product_id":100017301,"comment_content":"10进制1353对应的26进制应该是cab","like_count":2},{"had_liked":false,"id":47483,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1544147067,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10134081659","product_id":100017301,"comment_content":"用 K 进制表示字符串应该不会出现哈希冲突吧，比如 “0” 到 “F” 的字符，用 16 进制表示， 有且仅有 &quot;FFFF&quot; 的结果是 0xFFFF 的值呀。","like_count":2,"discussions":[{"author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8562,"discussion_content":"用 K 进制表示字符串是不可能会出现哈希冲突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568017709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46691,"user_name":"青铜5 周群力","can_delete":false,"product_type":"c1","uid":1111965,"ip_address":"","ucode":"EA80B442EC8A68","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/9d/c7295d17.jpg","comment_is_top":false,"comment_ctime":1543971754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10133906346","product_id":100017301,"comment_content":"二维字符串匹配能用rk算法解决，那么能用kmp解决么?","like_count":2},{"had_liked":false,"id":243265,"user_name":"着迷","can_delete":false,"product_type":"c1","uid":1716801,"ip_address":"","ucode":"429F1D4015A195","user_header":"https://static001.geekbang.org/account/avatar/00/1a/32/41/c1a7840b.jpg","comment_is_top":false,"comment_ctime":1598006010,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5892973306","product_id":100017301,"comment_content":"利用字符的ASCII来计算hash值怎么样","like_count":1},{"had_liked":false,"id":227990,"user_name":"Geek_dd8b2b","can_delete":false,"product_type":"c1","uid":1988075,"ip_address":"","ucode":"CBEF7C39075A96","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJX4ZU53F8hBHicctluqK6Ef3U0ib40bq1vFyAvqV0wu3GaPuWbj967OdMT7k0gl3OMxsfopvbk9veQ/132","comment_is_top":false,"comment_ctime":1592533335,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5887500631","product_id":100017301,"comment_content":"bf滑动窗口依次匹配模式串，rk则是改进bf里每次匹配模式串方式，通过遍历主串中所有字串，共n-m+1个并分别计算他们所有的hash值，然后与模式串的hash码比较。假如模式串比较长，就避免了n*m次的计算了。前提是hash计算的复杂度不要太高。","like_count":1},{"had_liked":false,"id":214765,"user_name":"宁悦","can_delete":false,"product_type":"c1","uid":1901403,"ip_address":"","ucode":"68844C314FEEF8","user_header":"https://static001.geekbang.org/account/avatar/00/1d/03/5b/3cdbc9fa.jpg","comment_is_top":false,"comment_ctime":1588815905,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883783201","product_id":100017301,"comment_content":"如果只是二维矩阵的话，可以先将模式串中对应的字符转化为数字，计算这个矩阵的行列式的值，然后计算主串中的对应矩阵的行列式的值，如果有冲突就要在匹配一下。","like_count":1},{"had_liked":false,"id":196601,"user_name":"新人欢","can_delete":false,"product_type":"c1","uid":1714847,"ip_address":"","ucode":"5767C15518A93D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJScAic7Td8olloIENiaUdEAVl5TjDZYtNhpGJMJL9SXonGYKBYc6UD7oJnPIBEQBYGV3VhEAdo44wA/132","comment_is_top":false,"comment_ctime":1585296694,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5880263990","product_id":100017301,"comment_content":"&#47;**<br> *<br> *  a b c d e<br> *  f g h i j<br> *  k l m n o<br> *  p q r s t<br> *  u v w x y<br> *<br> *  h i<br> *  m n<br> *<br> *&#47;<br>public static void find(char[][] mainChars,char[][] modeChars) {<br>        int modeWidth = modeChars.length;<br>        int modeHeight = modeChars[0].length;<br><br>        String modeString = getMode(modeChars,modeWidth,modeHeight,0,0);<br><br>        StringBuilder mainString = new StringBuilder();<br>        for (int i = 0; i &lt;=mainChars.length - modeWidth; i++) {<br>            for (int j = 0; j &lt;= mainChars.length - modeHeight; j++) {<br>                String mode = getMode(mainChars, modeWidth, modeHeight, i, j);<br>                if(modeString.equals(mode)){<br>                    System.out.println(&quot;x:&quot;+i+&quot;-&gt;&quot;+(i+modeWidth-1));<br>                    System.out.println(&quot;y:&quot;+j+&quot;-&gt;&quot;+(j+modeHeight-1));<br>                }<br>            }<br>        }<br><br>    }<br><br>    public static String getMode(char[][] chars,int width,int height,int x, int y){<br>        StringBuilder str = new StringBuilder();<br>        for (int k = 0; k &lt; width; k++) {<br>            for (int l = 0; l &lt; height; l++) {<br>                str.append(chars[x+k][y+l]);<br>            }<br>        }<br>        return str.toString();<br>    }","like_count":1,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300993,"discussion_content":"为啥我觉得二维数组的宽才是modeChars[0].length，当然如果是正方形就无所谓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598359283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93041,"user_name":"这个Tale要转运","can_delete":false,"product_type":"c1","uid":1024666,"ip_address":"","ucode":"F5855DD3B41EF1","user_header":"","comment_is_top":false,"comment_ctime":1557382888,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5852350184","product_id":100017301,"comment_content":"前段时间迷迷糊糊像是看懂了，今天回看有点忘了，也有点蒙圈了。<br>s[i-1] 和 s[i]是两个相邻子串，那s[i-1] - &#39;a&#39; 表示啥呢？一串字符减去一个字符？<br>对比例子努力回想，&#39;a&#39; 应该是选取的N进制中的最小值，s[i-1] - &#39;a&#39; 是计算第 i 个字符转换为N进制对应的值？","like_count":1,"discussions":[{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87005,"discussion_content":"s[i-1] 与s[i]不是子串，而是单个元素","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576637198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84704,"user_name":"菜鸡程序员","can_delete":false,"product_type":"c1","uid":1308074,"ip_address":"","ucode":"F1DFEC2343FE25","user_header":"https://static001.geekbang.org/account/avatar/00/13/f5/aa/5d520017.jpg","comment_is_top":false,"comment_ctime":1554896253,"is_pvip":false,"replies":[{"id":"30470","content":"可以的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554939105,"ip_address":"","comment_id":84704,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5849863549","product_id":100017301,"comment_content":"可不可以先不遍历所有的hash值，而是移动一位算一位hash值，然后再对比，这样能否提高效率","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446425,"discussion_content":"可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554939105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055334,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","nickname":"苦行僧","note":"","ucode":"726024A9A9CF44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1247,"discussion_content":"我找到一个rk的实现，就是这样一个思路，实时运算hash值，有可能在前几次比较就找到匹配项了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562466685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84693,"user_name":"菜鸡程序员","can_delete":false,"product_type":"c1","uid":1308074,"ip_address":"","ucode":"F1DFEC2343FE25","user_header":"https://static001.geekbang.org/account/avatar/00/13/f5/aa/5d520017.jpg","comment_is_top":false,"comment_ctime":1554895703,"is_pvip":false,"replies":[{"id":"30471","content":"浪费空间呢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554939126,"ip_address":"","comment_id":84693,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849862999","product_id":100017301,"comment_content":"为何不再生成子串的hash值时，把hash值存到一个hashmap中，这样就不用遍历数组了，可以根据目标的hash值，直接在map的链表中查找","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446422,"discussion_content":"浪费空间呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554939126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69067,"user_name":"卡洛梅特","can_delete":false,"product_type":"c1","uid":1234998,"ip_address":"","ucode":"A9997083BF684A","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/36/badf4003.jpg","comment_is_top":false,"comment_ctime":1550655176,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5845622472","product_id":100017301,"comment_content":"用广搜也可以，时间O（m*n）,或者分成两条子串，上下两行匹配，用BF或者RK算法","like_count":1},{"had_liked":false,"id":57397,"user_name":"caidy","can_delete":false,"product_type":"c1","uid":1188783,"ip_address":"","ucode":"AEFB529C32C7EE","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/af/84f4714e.jpg","comment_is_top":false,"comment_ctime":1546780031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5841747327","product_id":100017301,"comment_content":"n&gt;m\r<br>主串是n*n的二维矩阵\r<br>模式串是m*m的二维矩阵\r<br>在主串找到(n-m+1)*(n-m+1)组m*m的子串\r<br>然后通过哈希算法用哈希值来表示子串\r<br>计算模式串的哈希值\r<br>通过对比子串个模式串的哈希值，如果相等就把子串跟模式串的原始值在对比一下，相等就表示找到了。","like_count":1},{"had_liked":false,"id":56466,"user_name":"Mr.M","can_delete":false,"product_type":"c1","uid":1243730,"ip_address":"","ucode":"C32AE0A9CD6EEF","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/52/4781da3f.jpg","comment_is_top":false,"comment_ctime":1546469088,"is_pvip":false,"replies":[{"id":"21086","content":"你看错了吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547107682,"ip_address":"","comment_id":56466,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5841436384","product_id":100017301,"comment_content":"h[i] = 26*(h[i-1]-26^(m-1)*h[i-1]) + h[i+m-1];<br>这里h[i-1]-26^(m-1)*h[i-1]，是常数比指数大吗？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435051,"discussion_content":"你看错了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547107682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51092,"user_name":"Douglas","can_delete":false,"product_type":"c1","uid":1073027,"ip_address":"","ucode":"CFDE3D76B9DAE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","comment_is_top":false,"comment_ctime":1545112981,"is_pvip":false,"replies":[{"id":"18566","content":"你描述的有点不清楚 没有特别明白你想问什么 哈希冲突是指 换了一种哈希算法  就有可能产生哈希冲突 我文章中有说 ","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545185568,"ip_address":"","comment_id":51092,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5840080277","product_id":100017301,"comment_content":"老师 这里出现哈希冲突还是不太明白，k进制数字 和 字符串一一对应， 不同的字符串一定是不同的k进制数字，这里比较容易出现 超出整数表示范围，但是 哈希冲突发现的场景，还是不明白，能解释一些不，感谢","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433276,"discussion_content":"你描述的有点不清楚 没有特别明白你想问什么 哈希冲突是指 换了一种哈希算法  就有可能产生哈希冲突 我文章中有说 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545185568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178283,"avatar":"","nickname":"钟狼","note":"","ucode":"EBDED251153164","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":145704,"discussion_content":"abc cab不同的字符串，如果没有进制，只是单纯的123，那两者总各都是6，如果匹配的字符串是cba, 就会发生错误匹配","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579576109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46684,"user_name":"許敲敲","can_delete":false,"product_type":"c1","uid":1046681,"ip_address":"","ucode":"6486466820E7BF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/99/8e760987.jpg","comment_is_top":false,"comment_ctime":1543971363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838938659","product_id":100017301,"comment_content":"主串m*n把主串分割成m-1*n-1个子串 每个子串计算哈希值，再与模式串的哈希值比较","like_count":1},{"had_liked":false,"id":46675,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1543970696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838937992","product_id":100017301,"comment_content":"BF：遍历主串，以矩阵左上角元素作为矩阵起始位，从（0，0）到 （rowN - rowM, colN - colM), 取行列长度与模式相等的子矩阵串进行比较<br><br>hash算法同理","like_count":1},{"had_liked":false,"id":46660,"user_name":"hughieyu","can_delete":false,"product_type":"c1","uid":1206690,"ip_address":"","ucode":"FC1A64B2BAB784","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/a2/c30ac459.jpg","comment_is_top":false,"comment_ctime":1543969834,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838937130","product_id":100017301,"comment_content":"把矩阵中的每个块按照相同的规律转化成子串<br>比如 a,b a+1,b a,b+1 a+1,b+1 判断不越界之后就可以进行比较，计算hash的话就可以这样计算，如果采用暴力算法，就直接按照顺序比就行了，不用转成串，不合格直接continue","like_count":1},{"had_liked":false,"id":46649,"user_name":"深蓝...","can_delete":false,"product_type":"c1","uid":1067358,"ip_address":"","ucode":"4FCF94BC87CB49","user_header":"https://static001.geekbang.org/account/avatar/00/10/49/5e/855768b0.jpg","comment_is_top":false,"comment_ctime":1543969182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838936478","product_id":100017301,"comment_content":"老师早啊","like_count":1},{"had_liked":false,"id":46646,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1543968753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838936049","product_id":100017301,"comment_content":"二维字符串矩阵，在计算中可以使用二维数组存储，然后顺其自然地可以应用今天所学的两种字符串查找思路可以进行求解。","like_count":1},{"had_liked":false,"id":46631,"user_name":"五岳寻仙","can_delete":false,"product_type":"c1","uid":1247467,"ip_address":"","ucode":"88A46A4E1832CE","user_header":"https://static001.geekbang.org/account/avatar/00/13/08/eb/594e9e6c.jpg","comment_is_top":false,"comment_ctime":1543966801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838934097","product_id":100017301,"comment_content":"对于二维数组，方法应该是类似的。只是搜索的方向和匹配的方向都变成了行列两个方向。假设主串为n1×n2矩阵，模式串为m1×m2矩阵。对于BF算法，复杂度为O(n1×n2×m1×m2)，对于RK算法，复杂度为O(n1×n2)","like_count":1},{"had_liked":false,"id":359124,"user_name":"111","can_delete":false,"product_type":"c1","uid":3109487,"ip_address":"北京","ucode":"D6E8E83A118A3E","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/6f/44c10658.jpg","comment_is_top":false,"comment_ctime":1665279773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665279773","product_id":100017301,"comment_content":"总结：<br>1. BF 暴力匹配<br>2. RK 使用hash算法<br><br>二维的从左到右，从上到下匹配","like_count":0},{"had_liked":false,"id":358905,"user_name":"Geek_b89018","can_delete":false,"product_type":"c1","uid":3189568,"ip_address":"广东","ucode":"2DAF0B0A22C8F1","user_header":"","comment_is_top":false,"comment_ctime":1665016978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665016978","product_id":100017301,"comment_content":"哈希函数设计的有点问题，aaa的哈希值为0,a的哈希值也为0，不就有哈希冲突了吗","like_count":0},{"had_liked":false,"id":358831,"user_name":"packy","can_delete":false,"product_type":"c1","uid":1235915,"ip_address":"北京","ucode":"52BBB56DCFD86A","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/cb/e8680a25.jpg","comment_is_top":false,"comment_ctime":1664869026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664869026","product_id":100017301,"comment_content":"h(i )和h(i -1)的关系的公式中缺一个左小括号，这个公式是某一张图片中最后一行。","like_count":0},{"had_liked":false,"id":357476,"user_name":"~patience","can_delete":false,"product_type":"c1","uid":1614285,"ip_address":"四川","ucode":"8D9BC78A241CEA","user_header":"https://static001.geekbang.org/account/avatar/00/18/a1/cd/bc74741c.jpg","comment_is_top":false,"comment_ctime":1663297501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663297501","product_id":100017301,"comment_content":"课后习题,java代码写出来了:<br>&#47;&#47; 主串<br>        String[][] mainStr = new String[][]{<br>                {&quot;y&quot;, &quot;x&quot;, &quot;d&quot;, &quot;f&quot;, &quot;h&quot;,&quot;b&quot;},<br>                {&quot;g&quot;, &quot;w&quot;, &quot;q&quot;, &quot;z&quot;, &quot;g&quot;,&quot;f&quot;},<br>                {&quot;q&quot;, &quot;j&quot;, &quot;v&quot;, &quot;e&quot;, &quot;x&quot;,&quot;j&quot;},<br>                {&quot;z&quot;, &quot;l&quot;, &quot;n&quot;, &quot;w&quot;, &quot;c&quot;,&quot;l&quot;},<br>                {&quot;q&quot;, &quot;v&quot;, &quot;j&quot;, &quot;u&quot;, &quot;m&quot;,&quot;q&quot;},<br>        };<br>        &#47;&#47; 模式串<br>        String[][] modeStr = new String[][]{<br>                {&quot;l&quot;, &quot;n&quot;},<br>                {&quot;v&quot;, &quot;j&quot;},<br>        };<br>        Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();<br>        StringBuilder subStrBuilder = new StringBuilder();<br><br>        for (String[] strings : modeStr) {<br>            for (String str : strings) {<br>                subStrBuilder.append(str);<br>            }<br>        }<br>        System.out.println(&quot;子串:&quot; + subStrBuilder);<br>        &#47;&#47; 将子串从左至右拼接字符串放入hashmap<br>        hashMap.put(subStrBuilder.toString(), subStrBuilder.toString());<br>        &#47;&#47; 模式串(矩阵)的长宽<br>        int outLength = modeStr.length;<br>        int inLength = modeStr[0].length;<br><br>        int targetY = 0;<br>        int targetX = 0;<br>        &#47;&#47; 从左到右遍历 主串矩阵<br>        for (int y = 0; y &lt;= mainStr.length - outLength; y++) {<br>            for (int x = 0; x &lt;= mainStr[0].length - inLength; x++) {<br>                StringBuilder builder = new StringBuilder();<br>                for (int i = 0; i &lt;outLength ; i++) {<br>                    for (int j = 0; j &lt; inLength; j++) {<br>                        targetY = y + i;<br>                        targetX = x + j;<br>                        builder.append(mainStr[y + i][x + j]);<br>                    }<br>                }<br>                System.out.println(builder);<br>                if (hashMap.get(builder.toString()) != null) {<br>                    &#47;&#47; 矩阵左上角和右下角下标可以确定唯一一个矩阵<br>                    System.out.println(&quot;主串左上角坐标:&quot; + y + &quot;,&quot; + x);<br>                    System.out.println(&quot;主串右下角坐标:&quot; + targetY + &quot;,&quot; + targetX);<br>                    break;<br>                }<br>            }<br>        }<br><br>","like_count":0},{"had_liked":false,"id":352506,"user_name":"至尊傲剑","can_delete":false,"product_type":"c1","uid":3002881,"ip_address":"","ucode":"C3CED1F1F013DF","user_header":"https://static001.geekbang.org/account/avatar/00/2d/d2/01/f6076dea.jpg","comment_is_top":false,"comment_ctime":1658737093,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1658737093","product_id":100017301,"comment_content":"妙啊<br>太妙了","like_count":0},{"had_liked":false,"id":348940,"user_name":"Geek_c2a2be","can_delete":false,"product_type":"c1","uid":2914259,"ip_address":"","ucode":"ECAE3C732915CC","user_header":"","comment_is_top":false,"comment_ctime":1655603113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655603113","product_id":100017301,"comment_content":"2 * 26 * 26 + 1 * 26 + 0 * 1= 1378?","like_count":0},{"had_liked":false,"id":348091,"user_name":"知行","can_delete":false,"product_type":"c1","uid":1802022,"ip_address":"","ucode":"5AC8CBCC0AD48B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7f/26/c5127e9a.jpg","comment_is_top":false,"comment_ctime":1654736038,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654736038","product_id":100017301,"comment_content":"hash算法设计和优化，妙","like_count":0},{"had_liked":false,"id":347955,"user_name":"Geek_56537c","can_delete":false,"product_type":"c1","uid":3021545,"ip_address":"","ucode":"67DFDB99FE7BB9","user_header":"","comment_is_top":false,"comment_ctime":1654606479,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654606479","product_id":100017301,"comment_content":"绝对不冲突的hash算法，需要增加计算、存储的成本；如果适当减低hash冲突的要求，可以通过简单的运算，就能快速判断是否匹配；但这种场景需要再按照基础方法&#39;核查&#39;一遍。核查的频率和hash冲突是相互制约的，如何平衡两者的矛盾，来获取最佳性能，才是算法的精妙之处","like_count":0},{"had_liked":false,"id":347953,"user_name":"Geek_56537c","can_delete":false,"product_type":"c1","uid":3021545,"ip_address":"","ucode":"67DFDB99FE7BB9","user_header":"","comment_is_top":false,"comment_ctime":1654605750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654605750","product_id":100017301,"comment_content":"RK算法的思想，是将文本的逐直接比对，转化成摘要比对。<br>子串越大、hash冲突的概率越小，该算法的效率越高","like_count":0},{"had_liked":false,"id":346986,"user_name":"陈波","can_delete":false,"product_type":"c1","uid":1276472,"ip_address":"","ucode":"E0C3B4B79C8709","user_header":"https://static001.geekbang.org/account/avatar/00/13/7a/38/5ced9666.jpg","comment_is_top":false,"comment_ctime":1653580838,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653580838","product_id":100017301,"comment_content":"思考题：<br>先找一行或者一列匹配，在找下一行或者下一列匹配","like_count":0},{"had_liked":false,"id":342586,"user_name":"卖藥郎","can_delete":false,"product_type":"c1","uid":1231829,"ip_address":"","ucode":"0539EF1D335918","user_header":"https://static001.geekbang.org/account/avatar/00/12/cb/d5/fab32cf7.jpg","comment_is_top":false,"comment_ctime":1650355714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650355714","product_id":100017301,"comment_content":"BF算法是暴力查找算法 两个循环嵌套 小循环是为了逐个比较 字串中的字符是否和模式串儿相等，时间复杂度是 O(m*n)<br>RK算法中设计精妙的hash函数，其实就是为了解决暴力查找中的 小循环 使时间复杂度尽量降低到 O(n)<br>","like_count":0},{"had_liked":false,"id":339160,"user_name":"Hunter_Dark","can_delete":false,"product_type":"c1","uid":1342279,"ip_address":"","ucode":"3A07CCBC250B69","user_header":"https://static001.geekbang.org/account/avatar/00/14/7b/47/96dad3ff.jpg","comment_is_top":false,"comment_ctime":1647950994,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647950994","product_id":100017301,"comment_content":"BF算法类似滑动窗口；凡事能用RK算法的，一定能用BF算法，RK算法少了子串对比的for循环","like_count":0},{"had_liked":false,"id":337939,"user_name":"Today","can_delete":false,"product_type":"c1","uid":1235000,"ip_address":"","ucode":"4FA397F0BD8C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/38/41027bda.jpg","comment_is_top":false,"comment_ctime":1647167408,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647167408","product_id":100017301,"comment_content":"思考题：<br>先找第一位匹配的， 在第一位的基础上同方向找第二位，依次类推。时间复杂度 O(n * C);<br><br>感觉像是 BF 算法， 没有利用到 哈希","like_count":0},{"had_liked":false,"id":328187,"user_name":"TigerLee","can_delete":false,"product_type":"c1","uid":1334855,"ip_address":"","ucode":"45E3F608AF7A85","user_header":"https://static001.geekbang.org/account/avatar/00/14/5e/47/b8d03d92.jpg","comment_is_top":false,"comment_ctime":1640595061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640595061","product_id":100017301,"comment_content":"<br>RK算法 计算子串hash的逻辑。个人的理解：手动计算出首串的hash值后，往后的子串hash值 = 上一个串的hash值 （减） 上一个串中的最高位值 （加） 当前子串的最低位的值","like_count":0},{"had_liked":false,"id":324536,"user_name":"Andy","can_delete":false,"product_type":"c1","uid":1635018,"ip_address":"","ucode":"E2EF514B62DD35","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eYRDia7JQukURiaDyoMKbsYsTZrOps1IdYl2ibPIfgNokn4kCjfY62kTtevhPU42jC1wNpE0lvEheuER1X4doFyHg/132","comment_is_top":false,"comment_ctime":1638494592,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638494592","product_id":100017301,"comment_content":"“我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小”<br>每次都需要计算子串哈希吗？比如是同一个主串，不同的模式串且长度不同","like_count":0},{"had_liked":false,"id":318160,"user_name":"Shinran.","can_delete":false,"product_type":"c1","uid":1240937,"ip_address":"","ucode":"E28AF157D1A93E","user_header":"https://static001.geekbang.org/account/avatar/00/12/ef/69/25ea2d67.jpg","comment_is_top":false,"comment_ctime":1635167604,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1635167604","product_id":100017301,"comment_content":"有点难，看不明白","like_count":0},{"had_liked":false,"id":313471,"user_name":"camel","can_delete":false,"product_type":"c1","uid":1117530,"ip_address":"","ucode":"D0D698CD74388F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0d/5a/e60f4125.jpg","comment_is_top":false,"comment_ctime":1632454363,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632454363","product_id":100017301,"comment_content":"人肉眼找子串有点像RK算法。对比一般的找子串案例，人肉眼能很快找出答案，而不需要繁琐地一个个去比对。原因是人眼扫一眼主串的时候能很快过滤掉哪些明显跟子串不同的情况。这种明显不匹配的快速反应基于人脑的对两个子串的不同“印象”，这个“印象”就是人脑的一种hash算法。当子串相似即“印象”相似时人需要仔细去比对每一个字符确认是否相同，这个过程就是RK算法里hash冲突时的解决方法。","like_count":0},{"had_liked":false,"id":308598,"user_name":"张斌辉","can_delete":false,"product_type":"c1","uid":1985779,"ip_address":"","ucode":"D8D2E278F86F15","user_header":"https://static001.geekbang.org/account/avatar/00/1e/4c/f3/6d6def2a.jpg","comment_is_top":false,"comment_ctime":1629695507,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629695507","product_id":100017301,"comment_content":"一路看过来，hash算法出现的频率好高，散列表，负载均衡通过hash跟服务器数量取余，这里的字符串匹配算法，了解hash的含义，在很多地方可以使用","like_count":0},{"had_liked":false,"id":305054,"user_name":"聂旋","can_delete":false,"product_type":"c1","uid":1193784,"ip_address":"","ucode":"40061E5AFDA99C","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/38/5a3b72d4.jpg","comment_is_top":false,"comment_ctime":1627791911,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627791911","product_id":100017301,"comment_content":"思考题，在Bf的基础上，为了提高匹配效率，可以用矩阵乘法。将二维矩阵的匹配，转换为二维矩阵乘积的匹配。 将 模式矩阵*模式矩阵 的乘积作为目标， 如果模式矩阵与选取矩阵的乘积，与目标相等，再比较模式矩阵与选取矩阵的数据。","like_count":0},{"had_liked":false,"id":302740,"user_name":"Aaron","can_delete":false,"product_type":"c1","uid":2527977,"ip_address":"","ucode":"5B31F3923707C5","user_header":"https://static001.geekbang.org/account/avatar/00/26/92/e9/cfb01b05.jpg","comment_is_top":false,"comment_ctime":1626351027,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626351027","product_id":100017301,"comment_content":"“cba” = “c” * 26 *26 + &quot;b&quot; * 26 + &quot;a&quot; * 1  这个计算，计算结果是 1353 吗， 我怎么算的是 1378， 难道说什么玄机？还是老师算错了？  “cba” = “c” * 26 *26 + &quot;b&quot; * 26 + &quot;a&quot; * 1  等价于 “cba” = “c” * 26 *26 + &quot;b&quot; * 26 + &quot;a&quot; * 26  吧 ， 感觉这样更好理解一些","like_count":0},{"had_liked":false,"id":300205,"user_name":"阿文","can_delete":false,"product_type":"c1","uid":1467219,"ip_address":"","ucode":"B53454CA52BD7E","user_header":"https://static001.geekbang.org/account/avatar/00/16/63/53/b4590ccc.jpg","comment_is_top":false,"comment_ctime":1625045510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625045510","product_id":100017301,"comment_content":"课后思考：<br>1、模式矩阵 计算hash值；<br>2、遍历主矩阵 按照 模式矩阵，得到子矩阵，并计算hash值，不同于模式矩阵的hash值则添加到一个数组中。相同则通过这个数组的元素个数就能知道 该 子矩阵的位置<br>","like_count":0},{"had_liked":false,"id":297895,"user_name":"海崖","can_delete":false,"product_type":"c1","uid":2552745,"ip_address":"","ucode":"9D42E0B0D30A56","user_header":"https://static001.geekbang.org/account/avatar/00/26/f3/a9/bb9d8450.jpg","comment_is_top":false,"comment_ctime":1623834299,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623834299","product_id":100017301,"comment_content":"叮~打卡","like_count":0},{"had_liked":false,"id":293567,"user_name":"LIFE l=new LIFE()","can_delete":false,"product_type":"c1","uid":2446981,"ip_address":"","ucode":"729BACA3B7FD42","user_header":"https://static001.geekbang.org/account/avatar/00/25/56/85/6da913fa.jpg","comment_is_top":false,"comment_ctime":1621432440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621432440","product_id":100017301,"comment_content":"课后。计算主串矩阵所有子矩阵的hash值，然后用模式串的矩阵hash值比较，时间主要还是花在了计算每一个子矩阵的hash值上；","like_count":0},{"had_liked":false,"id":291387,"user_name":"Dana","can_delete":false,"product_type":"c1","uid":1241142,"ip_address":"","ucode":"FE94F5E3987DBA","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/36/020428c7.jpg","comment_is_top":false,"comment_ctime":1620265165,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620265165","product_id":100017301,"comment_content":"说一个思路，就是模式串的二维矩阵的长度是m的话，把这个m放到主串的n中，按长度m进行截取，然后遍历循环对比，分别把模式串中对应的值取出来，依次和子串中的相对应，至于接下来的比较，就可以直接使用老师这课讲的内容来完成了。","like_count":0},{"had_liked":false,"id":289322,"user_name":"万政","can_delete":false,"product_type":"c1","uid":2019799,"ip_address":"","ucode":"E59C2C660D6582","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Rccaya3zw31Pxu1fRSiakKxjn7gBcXTyy7YE4BHVsGczceABMnKBRicrnxUlcptrOArQdj4hOP8AjRekrDvBx7KQ/132","comment_is_top":false,"comment_ctime":1618976809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618976809","product_id":100017301,"comment_content":"    BF中，主串的子串是n-m+1，每次子串和模式串匹配需要取一次子串的所有字符，一次模式串的所有字符，再比较。因此时间复杂度是(n-m+1)*2m~O(n*m)。<br>    RK中，每次子串和模式串匹配需要取一次子串的哈希值，一次模式串的哈希值，再比较。因此时间复杂度是(n-m+1)*2~O(n)。<br>    但谁提供所有子串和模式串的哈希值呢？难道不需要代价吗？需要！<br>    模式串的哈希值计算简单，时间复杂度O(m)。所有子串的哈希值计算麻烦，一个一个计算，时间复杂度(n-m+1)*m~O(n*m)。但这样一来，总的时间复杂度基本没啥变化？于是我们需要改进一下所有子串的哈希值计算过程，减少时间代价。<br>    我们需要设计一个哈希算法，一个能够借助前驱子串的哈希值计算的信息，来简化后继子串的哈希值计算的过程，的哈希算法。这个哈希算法，小争哥已经举了个例子，即a~z对应26进制的哈希算法。<br>    但是，考虑到文本编辑器不只查找英文，还有中文等各种奇奇怪怪的字符，很难做到字符串和哈希值的一一对应；考虑到可以搜索长得丧心病狂的模式串，让哈希值突破计算机数值表达范围。我们发现，RK算法难点和核心就是哈希算法的选择上。一是要满足：能够借助前驱子串的哈希值计算的信息，来简化后继子串的哈希值计算；二是要满足：减少哈希冲突，避免退化为BF。<br>    如果只为刷题的话，想使用RK，就要记上几个常用的适合RK的哈希函数，方便拿来就用。不会有人刷题还想哈希函数吧。<br>    ","like_count":0},{"had_liked":false,"id":287865,"user_name":"不将就。","can_delete":false,"product_type":"c1","uid":1252586,"ip_address":"","ucode":"FCD26AE0DB1D54","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/ea/70e1ef53.jpg","comment_is_top":false,"comment_ctime":1618202258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618202258","product_id":100017301,"comment_content":"在RK算法中，如果有的同学按照老师的思路写代码，但最后的结果不正确。可以检查一下是不是在求哈希值的时候写错了，老师的思路是左边是高位，右边是低位。我之前写成了左边低位，右边高位，子串的哈希值都是负值。","like_count":0},{"had_liked":false,"id":286454,"user_name":"littlegao","can_delete":false,"product_type":"c1","uid":2526304,"ip_address":"","ucode":"6ADD1E74ADAD29","user_header":"https://static001.geekbang.org/account/avatar/00/26/8c/60/705da7f8.jpg","comment_is_top":false,"comment_ctime":1617327357,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617327357","product_id":100017301,"comment_content":"这是第一遍看老师的书，学到这里平常再看一些技术文章的时候已经可以看懂一些技术优化的点。非常感谢老师的专栏，放假在家准备把前面几章的代码手动一下，多体会。有些看不懂的地方会多看几遍的！","like_count":0},{"had_liked":false,"id":285147,"user_name":"〈😐ノ","can_delete":false,"product_type":"c1","uid":1581352,"ip_address":"","ucode":"A4EBDCE5EF943A","user_header":"https://static001.geekbang.org/account/avatar/00/18/21/28/4c13599a.jpg","comment_is_top":false,"comment_ctime":1616642923,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616642923","product_id":100017301,"comment_content":"hash只是一种&quot;摘要&quot;思想, 利用摘要来实现高性能的&quot;比对&quot;,&quot;定位&quot;等一系列具体的算法需求","like_count":0},{"had_liked":false,"id":281399,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1614738656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614738656","product_id":100017301,"comment_content":"这个 hash 算法思路厉害了","like_count":0},{"had_liked":false,"id":280897,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1614469816,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1614469816","product_id":100017301,"comment_content":"茶艺师学编程<br><br>思考题<br>二维字符串矩阵，把主串可能划分的子集的哈希值算出来，得出hash1数组，再与模式串的哈希值一一比较。时间复杂度会是O(n)","like_count":0},{"had_liked":false,"id":278729,"user_name":"pencilCool","can_delete":false,"product_type":"c1","uid":1461770,"ip_address":"","ucode":"49A9FE2DEE2911","user_header":"https://static001.geekbang.org/account/avatar/00/16/4e/0a/0ff15eaa.jpg","comment_is_top":false,"comment_ctime":1613270491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613270491","product_id":100017301,"comment_content":"总结:减少不必要的比对工作<br>特征值相同，本体不一定相同。本体相同特征值一定相同。逆否命题就是特征值不同本体一定不同。哈希值就是特征值","like_count":0},{"had_liked":false,"id":275334,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1611477002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611477002","product_id":100017301,"comment_content":"课后思考<br>1、我想到的第一个就是暴力算法，其实就遍历每个点，每个点就是模式串的第一个点，之后 向右一个 向下一个 最后一个是对角，如果当前点不等就继续往下移动，如果相当就比较它周围的三个。因为要遍历所有节点所以时间复杂度是O(n),如果再同样遍历所有模式串，那么就是O（n*m)最坏情况。<br>2、同样可以将模式串进行哈希值，然后将二维矩阵主串进行哈希，然后进行对比。","like_count":0},{"had_liked":false,"id":271525,"user_name":"佳楠","can_delete":false,"product_type":"c1","uid":1008809,"ip_address":"","ucode":"A1698AE91992AA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/64/a9/27d63f2e.jpg","comment_is_top":false,"comment_ctime":1609680749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609680749","product_id":100017301,"comment_content":"RK 算法对 utf-8 字符集是否不太友好。","like_count":0},{"had_liked":false,"id":249042,"user_name":"walle斌","can_delete":false,"product_type":"c1","uid":1062848,"ip_address":"","ucode":"0DB3243004951F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","comment_is_top":false,"comment_ctime":1600411683,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600411683","product_id":100017301,"comment_content":"我觉得老师这个26的值，可以不用太大，太大计算也是一个及其损耗性能的，取2的整数做位移更快，例如26其实并不友好，取2的指数与26的max or min都可以，无非是有一定概率冲突或者误判，最后只要比较一下真正的值即可，对于稍大规模的字符串匹配更加友好一些。","like_count":0},{"had_liked":false,"id":247898,"user_name":"Geek_99ae14","can_delete":false,"product_type":"c1","uid":1909732,"ip_address":"","ucode":"268852986A6B69","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLY0FFoux40Negib6LrE7EwT3T2BUbpYzOzUeiaiaXBmNGDGVgIZr5NeWBTEeCuALOg3ODtWa21bHMgg/132","comment_is_top":false,"comment_ctime":1599908269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599908269","product_id":100017301,"comment_content":"将bf算法 rk算法默认实现了一遍<br>&#47;**<br>     * bf暴力算法<br>     * @param a<br>     * @param n<br>     * @param b<br>     * @param m<br>     * @return<br>     *&#47;<br>    public int bf(char[] a, int n, char[] b, int m) {<br>        for (int i = 0; i &lt; n; i++) {<br>            for (int j = 0; j &lt; m; j++) {<br>                if (a[i+j]!=b[j]){<br>                    break;<br>                }<br>                if (j==m-1){<br>                    return i;<br>                }<br>            }<br><br>        }<br>        return -1;<br>    }<br><br>    &#47;**<br>     * rkhash算法<br>     * @param a<br>     * @param n<br>     * @param b<br>     * @param m<br>     * @return<br>     *&#47;<br>    public int rk(char[] a, int n, char[] b, int m) {<br>        int bHash = getHashChar(b);<br>        for (int i = 0; i &lt; n; i++) {<br>            char[] temp = Arrays.copyOfRange(a,i,i+m);<br>            int tempHash = getHashChar(temp);<br>            if (bHash==tempHash){<br>                &#47;&#47;hash值相等再次一个一个判断防止hash冲突<br>                for (int j = 0; j &lt; m; j++) {<br>                    if (a[i+j]!=b[j]){<br>                        break;<br>                    }<br>                    if (j==m-1){<br>                        return i;<br>                    }<br>                }<br>            }<br><br>        }<br>        return -1;<br>    }<br><br>    &#47;**<br>     * 生成数组的hash值 数组中只有a-z<br>     * @param a<br>     * @return<br>     *&#47;<br>    private int getHashChar(char[] a){<br>        Map&lt;Character,Integer&gt; map = new HashMap();<br>        for(int i=1;i&lt;=26;i++){<br>            char temp = (char)(&#39;a&#39;+i-1);      &#47;&#47;将(&#39;a&#39;+i)数字类型强转为char类型，<br>            map.put(temp,i);<br>        }<br>        int sum = 0;<br>        for (int i = 0; i &lt; a.length; i++) {<br>           sum+= map.get(a[i]);<br>        }<br>        return sum;<br>    }","like_count":0},{"had_liked":false,"id":239250,"user_name":"多选参数","can_delete":false,"product_type":"c1","uid":1248326,"ip_address":"","ucode":"B2294D80AB075F","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","comment_is_top":false,"comment_ctime":1596466711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596466711","product_id":100017301,"comment_content":"在专栏结束之后，看到这里，先来冒个泡。这节给我的一个感悟就是，在比较内容是否相同的情况时，可以借助哈希算法将比较的时间复杂度降下来。因为哈希算法的唯一性，或者可以用于标识。另一个感悟就是，链表可以替换成底层数据结构也是链表的数据结构，比如平衡二叉树这些，因为本质是没有变的。<br><br>针对思考题来看的话，其实也可以采用两种方法。一种是从左上角开始遍历比较，另一种是借助哈希值，把二维的想象成一维的即可。","like_count":0},{"had_liked":false,"id":237772,"user_name":"Merry","can_delete":false,"product_type":"c1","uid":1024036,"ip_address":"","ucode":"E2A114E10814BA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/24/68c679c8.jpg","comment_is_top":false,"comment_ctime":1595949113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595949113","product_id":100017301,"comment_content":"可以利用bf算法逐行便利","like_count":0},{"had_liked":false,"id":236348,"user_name":"ɴɪᴋᴇʀ","can_delete":false,"product_type":"c1","uid":1616622,"ip_address":"","ucode":"DB7D92CBB5FD15","user_header":"https://static001.geekbang.org/account/avatar/00/18/aa/ee/15c328ca.jpg","comment_is_top":false,"comment_ctime":1595395252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595395252","product_id":100017301,"comment_content":"个人想到，RK算法计算每个子串的哈希值前，可以进行一次子串首字符与模式串首字符的比较，如果不相等就不进行哈希算法，直接判断下一个子串是否匹配。这样是不是能提高RK算法的效率。<br>","like_count":0},{"had_liked":false,"id":234843,"user_name":"Kennedy","can_delete":false,"product_type":"c1","uid":1049022,"ip_address":"","ucode":"C50627007E5ED0","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/be/be358cab.jpg","comment_is_top":false,"comment_ctime":1594810315,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1594810315","product_id":100017301,"comment_content":"<br>func bf(src,sub string) int {<br>\tsrcArr,subArr := []rune(src),[]rune(sub)<br>\tm,n := len(srcArr),len(subArr)<br>\tk:=0;&#47;&#47;已匹配字节个数<br>\tfor i:=0;i&lt;=m-n;i++{<br>\t\tfor j:=0;j&lt;n;j++{<br>\t\t\tif srcArr[i+j] == subArr[j]{<br>\t\t\t\tk++<br>\t\t\t}else{<br>\t\t\t\tbreak<br>\t\t\t}<br>\t\t}<br>\t\tif k == n {<br>\t\t\treturn i<br>\t\t}<br>\t}<br>\treturn -1<br>}<br>&#47;**<br>rk 算法：<br>rk算法的本质思想是：用最快的方式，验证不存在。<br>通过hash算法，对主串 src 的子串（长度是sub的长度）分别计算hash值。<br>然后分别与模式串（sub）的hash值比较大小，判断是否存在相等的hash值。<br>该算法的主要消耗是hash算法，hash算法的值不要超过int型最大值，hash值相等，再用bf算法对两个子串做相同判断。<br> *&#47;<br>func rk(src,sub string)int  {<br>\t&#47;&#47;hash值求法，ASCII 值相加<br>\tsrcArr,subArr := []rune(src),[]rune(sub)<br>\tm,n := len(srcArr),len(subArr)<br>\tvar subHash int32 &#47;&#47;模式串hash值<br>\tfor i:=0;i&lt;n;i++{<br>\t\tsubHash = subHash + subArr[i];<br>\t}<br><br>\tbf := func(src,sub []rune)int {<br>\t\tfor i:=0;i&lt;len(src);i++{<br>\t\t\tif src[i] != sub[i]{<br>\t\t\t\treturn -1<br>\t\t\t}<br>\t\t}<br>\t\treturn 0<br>\t}<br><br>\tsrcMap := make(map[int32]int,m-n+1) &#47;&#47;key 是hash，value是起始下标<br>\tvar h int32<br>\tfor i:=0;i&lt;=m-n;i++{<br>\t\th = 0 &#47;&#47;求出src 所有子串的hash值，子串的长度就是sub的长度<br>\t\tfor j:=0;j&lt;n;j++{<br>\t\t\th = h + srcArr[i+j]<br>\t\t}<br>\t\tif h == subHash &amp;&amp; bf(srcArr[i:i+n],subArr) == 0 {<br>\t\t\treturn i<br>\t\t}<br>\t\tif k,ok := srcMap[h];ok &amp;&amp; bf(srcArr[k:k+n],subArr) == 0{<br>\t\t\treturn k<br>\t\t}<br>\t\tsrcMap[h] = i<br>\t}<br>\treturn -1<br>}","like_count":0},{"had_liked":false,"id":228655,"user_name":"Geek_sTone","can_delete":false,"product_type":"c1","uid":1665951,"ip_address":"","ucode":"A0D80E0A854313","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKFkwTRL5TY3KNicWGbw8VRPtukNZf08bb7bCJynQu9HQDhYk2sdNJiaj7aliatnegFUfKYqiaZKLvS7w/132","comment_is_top":false,"comment_ctime":1592783665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592783665","product_id":100017301,"comment_content":"可以把字符串的ascll码作为hash值的一部分","like_count":0},{"had_liked":false,"id":224202,"user_name":"tsaishichung","can_delete":false,"product_type":"c1","uid":1980058,"ip_address":"","ucode":"AEB1762D0E1D37","user_header":"","comment_is_top":false,"comment_ctime":1591317095,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1591317095","product_id":100017301,"comment_content":"s【i】-‘a’是什么操作呀，有没有人帮忙解释一下为啥要-‘a’","like_count":0,"discussions":[{"author":{"id":1980058,"avatar":"","nickname":"tsaishichung","note":"","ucode":"AEB1762D0E1D37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283737,"discussion_content":"明白了。自己写了下才明白。借助线性表做hash，-a就可以让字母从线性表下标0开始存储。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592355215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223099,"user_name":"你在不远的未来","can_delete":false,"product_type":"c1","uid":1318404,"ip_address":"","ucode":"5B34C8BD03B71A","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/04/f902047e.jpg","comment_is_top":false,"comment_ctime":1591001141,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591001141","product_id":100017301,"comment_content":"看了下java中的Stirng.indexOf实现，按照给定的思路，给出如下：<br>1. 原始矩阵中从左到右，从上到下这种规则遍历元素，遍历节点为i<br>2.1 如i与匹配举证首矩阵相等，则横向纵向匹配搜索矩阵元素。<br>2.2 如i与匹配举证首矩阵不相等，继续步骤1.<br>3.直至遍历结束。<br>Ps：另外遍历过程中可以优化代码，比如判断横向纵向剩余长度问题等等","like_count":0},{"had_liked":false,"id":219419,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1590024133,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1590024133","product_id":100017301,"comment_content":"字符串匹配的 BF 算法，想法其实很简单，Brute Force，不过看了一下 algs4 里面的实现代码，还是有一些小的技巧的。https:&#47;&#47;algs4.cs.princeton.edu&#47;53substring&#47;Brute.java.html<br><br>for (int i = 0; i &lt;= n - m; i++) {<br>    int j;<br>    for (j = 0; j &lt; m; j++) {<br>        if (txt.charAt(i+j) != pat.charAt(j))<br>            break;<br>    }<br>    if (j == m) return i;            &#47;&#47; found at offset i<br>}<br>...<br>for (i = 0, j = 0; i &lt; n &amp;&amp; j &lt; m; i++) {<br>    if (txt.charAt(i) == pat.charAt(j)) j++;<br>    else {<br>        i -= j;<br>        j = 0;<br>    }<br>}<br><br>同样的，在 Babin-Karp 算法里面，比较核心的就是 search 函数，能看到优化计算公式的影子，当然 hash 的算法也很重要。<br><br>public int search(String txt) {<br>    int n = txt.length();<br>    if (n &lt; m) {<br>        return n;<br>    }<br>    long txtHash = hash(txt, m);<br>    &#47;&#47; check for match at offset 0<br>    if ((patHash == txtHash) &amp;&amp; check(txt, 0)) {<br>        return 0;<br>    }<br><br>    &#47;&#47; check for hash match; if hash match, check for exact match<br>    for (int i = m; i &lt; n; i++) {<br>        &#47;&#47; Remove leading digit, add trailing digit, check for match.<br>        txtHash = (txtHash + q - RM*txt.charAt(i-m) % q) % q;<br>        txtHash = (txtHash * R + txt.charAt(i)) % q;<br><br>        &#47;&#47; match<br>        int offset = i - m + 1;<br>        if ((patHash == txtHash) &amp;&amp; check(txt, offset)) {<br>            return offset;<br>        }<br>    }<br>    &#47;&#47; no match<br>    return n;<br>}","like_count":0},{"had_liked":false,"id":217567,"user_name":"mqray","can_delete":false,"product_type":"c1","uid":1336634,"ip_address":"","ucode":"15664507AD7033","user_header":"https://static001.geekbang.org/account/avatar/00/14/65/3a/bc801fb2.jpg","comment_is_top":false,"comment_ctime":1589534754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589534754","product_id":100017301,"comment_content":"算法思想几乎没有差别，时间复杂度主要由计算每个子矩阵的hashcode决定","like_count":0},{"had_liked":false,"id":216823,"user_name":"eazonshaw","can_delete":false,"product_type":"c1","uid":1493784,"ip_address":"","ucode":"423952F7CEF475","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/18/4877c08b.jpg","comment_is_top":false,"comment_ctime":1589350322,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1589350322","product_id":100017301,"comment_content":"重看才发现，计算26进制数时，26*26*2+26*1+0*1结果应该是1378。。。","like_count":0,"discussions":[{"author":{"id":1334855,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5e/47/b8d03d92.jpg","nickname":"TigerLee","note":"","ucode":"45E3F608AF7A85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541080,"discussion_content":"应该是贴错了 &#34;cab&#34; 计算结果才为 1353","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640250103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214845,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1588830447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588830447","product_id":100017301,"comment_content":"60天攻克算法打卡行动第25天<br><br>学习内容 ：字符串匹配基础（上）：如何借助哈希算法实现高效字符串匹配？<br><br>字符串匹配算法这部分内容，我们一共分为三部分进行学习，在第二阶段的打卡活动中，我们只学习两种基础算法：BF 算法和 RK 算法。<br><br>1.BF 算法的实现思想和应用<br>就是暴力匹配算法，用模式串去跟主串一个一个匹配。<br>2.RK 算法的实现思想和应用<br>a-z 0-26 对应26进制<br>h[i] 与 h[i-1] 存在一定的相同值哈希 h[i]=(h[i-1) - 25^(m-1) * ( s[i-1] - ‘a’) * 26 + 26^0 * (s[i+m-1]-’a’) 文章中老师粗心调调了 s[i-1]前面的 做括号。<br>扫描主串时间复杂度O(n),模式串哈希与每个子串哈希的比较时间复杂度O(1)，总共需要比较 n-m+1 个子串的哈希值，所以这部分的时间复杂度O(n).所以RK的时间复杂度就是O(n)。极端情况下，哈希算法大量冲突，时间复杂度就退化为 O(n*m)。<br>课后思考：<br>这个想起来了那个卷积神经中的矩阵对比，模式串的大小就是主串要切分的大小，然后横向移动的步伐就是一步，对每个小矩阵进行哈希，然后横向移动完毕后在纵向一步步伐移动哈希，都移动完以后，对模式串哈希。之后就是对比。","like_count":0},{"had_liked":false,"id":214463,"user_name":"默默","can_delete":false,"product_type":"c1","uid":1006635,"ip_address":"","ucode":"AF798B9D327F24","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/2b/8b771383.jpg","comment_is_top":false,"comment_ctime":1588752907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588752907","product_id":100017301,"comment_content":"用BF算法解决思路：假设主串为n*m的矩阵字符串，模式串为x*y的矩阵字符串，将主串分解成(n-x+1)*(m-y+1)个子串，将(n-x+1)*(m-y+1)个子串与模式串比对。最坏时间复杂度为为O(m*n*x*y)。<br>用RK算法解决思路：假设主串为n*m的矩阵字符串，模式串为x*y的矩阵字符串，将主串分解成(n-x+1)*(m-y+1)个子串，计算子串和模式串的哈希值，如果子串哈希值与模式串相同，再比较子串和模式串本身(防止哈希冲突)。计算子串哈希值的时间复杂度为O(m*n*max(x,y))，比较模式串与子串的时间复杂度为O(m*n)，总的时间复杂度为O(m*n*max(x,y))。","like_count":0},{"had_liked":false,"id":211042,"user_name":"Jussi Lee","can_delete":false,"product_type":"c1","uid":1211190,"ip_address":"","ucode":"F2F5948CCD52A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/36/fd46331c.jpg","comment_is_top":false,"comment_ctime":1587886630,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587886630","product_id":100017301,"comment_content":"第一步把4*4的矩阵转化为9个2*2的二维矩阵，同时把二维全部转化为一维矩阵，然后不管是用BF还是RK方式均可查找出来是否含有该矩阵","like_count":0},{"had_liked":false,"id":210140,"user_name":"Join","can_delete":false,"product_type":"c1","uid":1014873,"ip_address":"","ucode":"20F51EFFD8FEDE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/59/dc9bbb21.jpg","comment_is_top":false,"comment_ctime":1587691034,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587691034","product_id":100017301,"comment_content":"RK算法中哈希算法的设计真的太巧妙了","like_count":0},{"had_liked":false,"id":206880,"user_name":"梅端","can_delete":false,"product_type":"c1","uid":1525335,"ip_address":"","ucode":"FEC08731457770","user_header":"https://static001.geekbang.org/account/avatar/00/17/46/57/fe38a6db.jpg","comment_is_top":false,"comment_ctime":1586951232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586951232","product_id":100017301,"comment_content":"终于开始系统性地学习字符串匹配算法了，今天的两种算法基本搞懂，后面手动实现一下，继续加油。。","like_count":0},{"had_liked":false,"id":204920,"user_name":"Rob Xu","can_delete":false,"product_type":"c1","uid":1923768,"ip_address":"","ucode":"05CD63AAB9E67D","user_header":"https://static001.geekbang.org/account/avatar/00/1d/5a/b8/ef2de217.jpg","comment_is_top":false,"comment_ctime":1586490653,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586490653","product_id":100017301,"comment_content":"用到矩阵里 模式串就像卷积神经网络里的卷积核","like_count":0},{"had_liked":false,"id":201607,"user_name":"Nullptr","can_delete":false,"product_type":"c1","uid":1911665,"ip_address":"","ucode":"8EC72438680F8D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLpCwvSDHKuwJklN3gosIbJh0AX97ULSXw4cgopjU28eQHR7DxcCWDFSBv7ZQJElBuCFu58xoWaTg/132","comment_is_top":false,"comment_ctime":1585811084,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585811084","product_id":100017301,"comment_content":"开头匹配n应该大于等于m把，万一主串和模式串想通呢。","like_count":0},{"had_liked":false,"id":199428,"user_name":"zhimin","can_delete":false,"product_type":"c1","uid":1312130,"ip_address":"","ucode":"DF6DFBEF6FA297","user_header":"https://static001.geekbang.org/account/avatar/00/14/05/82/51cd0a50.jpg","comment_is_top":false,"comment_ctime":1585488916,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585488916","product_id":100017301,"comment_content":"可以对矩阵应用hash算法比较简单，hash算法选择可以用RK里面的26进制，思想和串比较是一样的。","like_count":0},{"had_liked":false,"id":192263,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1584844472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584844472","product_id":100017301,"comment_content":"当改进后的RKhash计算方法后，文中说有可能存在hash冲突。怎么判断当前的子串与模式串是存在hash冲突呢？<br>自己考虑的思路是：在计算主串中的每个子串的hash的时候将各个子串的hansh值保存到一个数组中，后续的再计算子串hash值完成的时候还需要从这个数组中查找下是否已经存在了这个hash值，若存在这个hash值的话，需要标记当前的子串的hash值是存在hash冲突的，当该子串与模式进行匹配的时候就需要再进行一次内容的匹配了<br>请老师指点我的思路是否正确","like_count":0},{"had_liked":false,"id":191840,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1152017,"ip_address":"","ucode":"232B5F33D68C8C","user_header":"https://static001.geekbang.org/account/avatar/00/11/94/11/d53d9c6f.jpg","comment_is_top":false,"comment_ctime":1584799636,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584799636","product_id":100017301,"comment_content":"大佬，麻烦问下用户积分和等级用hash如何解哈，比如<br>0-100等级是vip1，100-500等级是vip2。","like_count":0},{"had_liked":false,"id":190773,"user_name":"不知","can_delete":false,"product_type":"c1","uid":1803488,"ip_address":"","ucode":"A2ECBFE43ACDAB","user_header":"https://static001.geekbang.org/account/avatar/00/1b/84/e0/cdb6de57.jpg","comment_is_top":false,"comment_ctime":1584691450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584691450","product_id":100017301,"comment_content":"rk算法这个英文缩写有点难记住,hash算法","like_count":0},{"had_liked":false,"id":190681,"user_name":"獨自去遠方","can_delete":false,"product_type":"c1","uid":1503941,"ip_address":"","ucode":"E246B33F397441","user_header":"https://static001.geekbang.org/account/avatar/00/16/f2/c5/2a441c27.jpg","comment_is_top":false,"comment_ctime":1584681747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584681747","product_id":100017301,"comment_content":"字符串匹配基础（1）<br><br>\tBF算法（Brute Force）<br>\t\t主串(n)\t模式串(m) n&gt;m<br>\t\t最坏情况：O(n*m)<br>\t\t比较常用原因：<br>\t\t\t1. 实际开发过程中，主串和模式串都不会很长，中途不能匹配就停止<br>\t\t\t2.代码简单，不容易出错<br><br>\t\t\tKISS设计原则<br><br>\tRK算法（BF的改进）<br>\t\t主串和模式串比较过程比较费时间，将主串的n-m+1个子串分别求哈希值，然后和模式串比较<br>\t\t\t如何提高哈希算法的效率<br>\t\t\t\t前面一个串计算的哈希值，后面一个串可以利用<br><br>\t\t\t\t如果出现hash冲突，对比子串和模式串<br>","like_count":0},{"had_liked":false,"id":186963,"user_name":"起而行","can_delete":false,"product_type":"c1","uid":1131399,"ip_address":"","ucode":"4F116B0B740776","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/87/7604d7a4.jpg","comment_is_top":false,"comment_ctime":1583979575,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583979575","product_id":100017301,"comment_content":"BF算法，在模式串中找到匹配的子串。主串长m,模式串长n,需要比对m-n+1次，RK算法首先计算各个子串的哈希值，再与待匹配串的哈希值做比较，相同则匹配成功。两个问题1.如何提高遍历每个子串的效率，通过26进制计算每个子串的数值，第一个子串需要遍历计算，但是从第二个开始则可以通过数学关系推导，因此提高了效率。当然，计算时要计算26的幂次，可以提前计算，存储在数组里。2.哈希冲突时，比较子串和待匹配串，哈希值不一样肯定匹配成功 哈希值一样再做二次比对","like_count":0},{"had_liked":false,"id":186380,"user_name":"咯咯巴","can_delete":false,"product_type":"c1","uid":1064395,"ip_address":"","ucode":"D6309866B0D2CE","user_header":"https://static001.geekbang.org/account/avatar/00/10/3d/cb/8d07349f.jpg","comment_is_top":false,"comment_ctime":1583832195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583832195","product_id":100017301,"comment_content":"比较字符串又不是单单只有26个字符，真的实用么？","like_count":0},{"had_liked":false,"id":181194,"user_name":"ack","can_delete":false,"product_type":"c1","uid":1440912,"ip_address":"","ucode":"69CA1233EEA8E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/fc/90/c9df0459.jpg","comment_is_top":false,"comment_ctime":1582515667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582515667","product_id":100017301,"comment_content":"RK算法中优化了计算主串中子串hash的实现，省略部分为未优化实现：<br>    public int RK(char[] target, char[] pattern) {<br>        if (target == null || pattern == null || target.length &lt; pattern.length) return -1;<br>        int tLen = target.length;<br>        int pLen = pattern.length;<br>        int[] hashCache = new int[pLen];<br>        int sum = 1;<br>        for (int i = 0; i &lt; hashCache.length; i++) {<br>            hashCache[i] = sum;<br>            sum *= 26;<br>        }<br>        &#47;&#47;模式串hash<br>        int pHash = 0;<br>        for (int i = 0; i &lt; pLen; i++) {<br>            pHash += (pattern[i] - &#39;a&#39;) * hashCache[pLen - i - 1];<br>        }<br>        &#47;&#47;子串hash<br>        int[] targetChildHash = new int[tLen - pLen + 1];<br>        for (int i = 0; i &lt; pLen; i++) {<br>            targetChildHash[0] += (target[i] - &#39;a&#39;) * hashCache[pLen - i - 1];<br>        }<br>        for (int i = 1; i &lt; targetChildHash.length; i++) {<br>&#47;&#47;            int hash = 0;<br>&#47;&#47;            for (int j = 0; j &lt; pLen; j++) {<br>&#47;&#47;                hash += (target[i + j] - &#39;a&#39;) * hashCache[pLen - j - 1];<br>&#47;&#47;            }<br>&#47;&#47;            targetChildHash[i] = hash;<br>            targetChildHash[i] = (targetChildHash[i - 1] - hashCache[pLen - 1] * (target[i - 1] - &#39;a&#39;)) * 26 + (target[i + pLen - 1] - &#39;a&#39;) * hashCache[0];<br>        }<br>        &#47;&#47;比较<br>        for (int i = 0; i &lt; targetChildHash.length; i++) {<br>            &#47;&#47;该hash算法不会存在冲突。如果会出现hash冲突，还需要继续判断对比子串和模式串是否相等<br>            if (targetChildHash[i] == pHash) {<br>                return i;<br>            }<br>        }<br>        return -1;<br>    }","like_count":0},{"had_liked":false,"id":180154,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1582200945,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582200945","product_id":100017301,"comment_content":"思考题中如果数据量比较小 直接BF算法 逐一匹配就好<br>但是如果数据量大了 参考RK算法比较好 ","like_count":0},{"had_liked":false,"id":179993,"user_name":"岁月流年","can_delete":false,"product_type":"c1","uid":1652852,"ip_address":"","ucode":"E0073C35273F82","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLJtGibPEUI02BtJTFng9YGC2SsKf44ZOrqxs7PUKvicmxn7CPgMMNc9O8p1pW9R9SDjwCeV2mfxUOg/132","comment_is_top":false,"comment_ctime":1582161008,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582161008","product_id":100017301,"comment_content":"假设字符串中只包含 a～z 这 26 个英文字母，那我们每个字母对应一个数字，比如 a 对应 1，b 对应 2，以此类推，z 对应 26。我们可以把字符串中每个字母对应的数字相加，最后得到的和作为哈希值。这种哈希算法产生的哈希值的数据范围就相对要小很多了。  老师您说的这句话，如果要查找abc  1+2+3=6 那主串出来了bac  2+1+3=6 很容易冲突的。","like_count":0},{"had_liked":false,"id":179057,"user_name":"MooNight","can_delete":false,"product_type":"c1","uid":1810050,"ip_address":"","ucode":"B5B5876841E33E","user_header":"https://static001.geekbang.org/account/avatar/00/1b/9e/82/61e5acf7.jpg","comment_is_top":false,"comment_ctime":1581905502,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581905502","product_id":100017301,"comment_content":"关于思考题，我的想法是：假如矩阵如上图所示，则按行取子串m1=[&#39;c&#39;, &#39;a&#39;]，m2=[&#39;e&#39;, &#39;f&#39;]，主串为n，则利用BF算法，对主串n[0], n[1], n1[2]依次匹配m1，假如在n[0][1]的位置匹配到了，则直接取n[1][1]的位置与m2进行匹配，如果都匹配成功则成功，否则继续在n[0]中匹配m1；n[0]中未匹配到则继续从n[1]中匹配，依次类推。如果子串为m*m矩阵，主串为n*n矩阵，则最坏的时间复杂度为O((n-m+1)*m*(n-m+1))即O(n²*m)，同理RK算法为O(n²).","like_count":0},{"had_liked":false,"id":176170,"user_name":"短迪大魔王","can_delete":false,"product_type":"c1","uid":1236079,"ip_address":"","ucode":"37E8117E0495B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/6f/5d86dbe9.jpg","comment_is_top":false,"comment_ctime":1580977753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580977753","product_id":100017301,"comment_content":"这节课的hash方法和大量图片找一致的方法相同","like_count":0},{"had_liked":false,"id":176155,"user_name":"短迪大魔王","can_delete":false,"product_type":"c1","uid":1236079,"ip_address":"","ucode":"37E8117E0495B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/6f/5d86dbe9.jpg","comment_is_top":false,"comment_ctime":1580973983,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580973983","product_id":100017301,"comment_content":"整数越界问题可以上对数log，单调的，有效抑制越界","like_count":0},{"had_liked":false,"id":174505,"user_name":"抱小星","can_delete":false,"product_type":"c1","uid":1504652,"ip_address":"","ucode":"BA7B0DAFDA4AF5","user_header":"https://static001.geekbang.org/account/avatar/00/16/f5/8c/82fb5890.jpg","comment_is_top":false,"comment_ctime":1580257052,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1580257052","product_id":100017301,"comment_content":"思考题：将大矩阵的每一行用RK算法找有没有一致的地方，最后找到了，再开始比较下一行相同位置，这样就将二维问题转化为多个一维问题了","like_count":0},{"had_liked":false,"id":173353,"user_name":"飘到站","can_delete":false,"product_type":"c1","uid":1796339,"ip_address":"","ucode":"0C9A9521061127","user_header":"https://static001.geekbang.org/account/avatar/00/1b/68/f3/57456c44.jpg","comment_is_top":false,"comment_ctime":1579509391,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579509391","product_id":100017301,"comment_content":"Java实体类的判等，覆盖hash方法就是RF思想。<br>将多判等条件转换成 单一hash判等条件。","like_count":0},{"had_liked":false,"id":167581,"user_name":"李朝辉","can_delete":false,"product_type":"c1","uid":1152951,"ip_address":"","ucode":"8E4A4469A77A88","user_header":"https://static001.geekbang.org/account/avatar/00/11/97/b7/d5a83264.jpg","comment_is_top":false,"comment_ctime":1577867997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577867997","product_id":100017301,"comment_content":"大家都是用二维转一维，我的第一反应，哈希算法用行列式。。","like_count":0},{"had_liked":false,"id":167051,"user_name":"SteveYang","can_delete":false,"product_type":"c1","uid":1754829,"ip_address":"","ucode":"C42BCA4F40A9EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCbnOvEatUN4ysE2cl6zJNoAJVXXuQVhicQ1jxh6Z2Towrmmc1I6PndaicuQQ0RyyJPyJQicv4tSib9Q/132","comment_is_top":false,"comment_ctime":1577677985,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577677985","product_id":100017301,"comment_content":"将矩阵转按一定顺序转换为一维字符串，再用RK算法做字符串匹配。","like_count":0},{"had_liked":false,"id":165747,"user_name":"无与伦比","can_delete":false,"product_type":"c1","uid":1191604,"ip_address":"","ucode":"F1BBA556971FE3","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/b4/3188f9d5.jpg","comment_is_top":false,"comment_ctime":1577317186,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1577317186","product_id":100017301,"comment_content":"为什么要自己去创建hash算法，不能用MD5或其他hash算法吗","like_count":0,"discussions":[{"author":{"id":1171151,"avatar":"https://static001.geekbang.org/account/avatar/00/11/de/cf/ef2e0501.jpg","nickname":"奇小易","note":"","ucode":"E06B4DFB5352BB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":194323,"discussion_content":"我是这样理解的，也可能不对。\n1 使用自己定义的hash算法，可以很清晰的解释原理和实现\n2 文章中的hash算法可以实现&#34;只用遍历一次主串，就能算出所有子串的hash值&#34;，如果其它hash算法也能实现，那就可以使用。而MD5不行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583205860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165065,"user_name":"港","can_delete":false,"product_type":"c1","uid":1122464,"ip_address":"","ucode":"35931FC6198180","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/a0/1fca96c0.jpg","comment_is_top":false,"comment_ctime":1577154436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577154436","product_id":100017301,"comment_content":"课后题：假设主串矩阵大小n*n,模式串大小m*m，对比BF算法，可以将主串中所有m*m的子区间与模式串进行比较，判断是否匹配。 对比RK算法，我们可以将每个字母对应一个素数，计算区间的和（计算主串区间和的时候可以使用积分矩阵，可以该过程时间复杂度为O(n^2)）作为哈希值，然后匹配哈希值并对比字符串","like_count":0},{"had_liked":false,"id":164478,"user_name":"seven","can_delete":false,"product_type":"c1","uid":1180307,"ip_address":"","ucode":"55CE5F60051F89","user_header":"https://static001.geekbang.org/account/avatar/00/12/02/93/44672231.jpg","comment_is_top":false,"comment_ctime":1577003413,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577003413","product_id":100017301,"comment_content":"用RK算法计算子串的hash值，hash算法用26个字母转化为整数，然后遍历主二维数组的，每次取出数据进行hash运算，然后和子串的hashcode进行对比，如果hashcode一直，再进行子串的对比","like_count":0},{"had_liked":false,"id":164352,"user_name":"book尾汁","can_delete":false,"product_type":"c1","uid":1446375,"ip_address":"","ucode":"AE2B8DFC643ACC","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg","comment_is_top":false,"comment_ctime":1576943239,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576943239","product_id":100017301,"comment_content":"字符串匹配算法：<br>BF算法<br>RK算法<br>BM算法<br>KMP算法<br><br><br>主串：被查找的字符串<br>模式串：查找的字符串<br>KISS设计原则 保持简洁<br>BF算法：暴力匹配算法，即将主串拆分成多个子串，然后分别和模式串对比。<br>RK算法：暴力匹配算法加hash算法，将主串拆分成多个子串，分别计算各个子串的hash值，然后和模式串的hash值对比，可以选择一个好的hash算法，如果hash算法有=避免不了hash冲突，可以先比较hash值是否相等，相等的话再去逐个字符比较。<br><br><br>课后思考题：<br>可以将m阶模式串拆分成m层子串，分别计算其hash值，主串同样拆分。然后在和主串中的子串进行比较，如果第一层相同再比较第二层。<br>最坏情况下，需要比较 (n-m+1)*N2次，时间复杂度为O(N2)<br>也可以将模式串整体hash，最坏情况下需要比较 （n-m+1)^2次,计算hash值时要麻烦一点，平均还是感觉上面的好点。","like_count":0},{"had_liked":false,"id":162991,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1576638311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576638311","product_id":100017301,"comment_content":"在比较之前先将矩阵做每四个元素和模式串转成二进制，比较的时候通过异或进行比较值为0表示匹配，值为1表示不匹配","like_count":0},{"had_liked":false,"id":162975,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1576636961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576636961","product_id":100017301,"comment_content":"我才知道了hash算法的玩法没有你做不到，只有你想不到","like_count":0},{"had_liked":false,"id":162899,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1576630056,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1576630056","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":160492,"user_name":"[耶]友超","can_delete":false,"product_type":"c1","uid":1400962,"ip_address":"","ucode":"890572F77C3670","user_header":"https://static001.geekbang.org/account/avatar/00/15/60/82/9a43504b.jpg","comment_is_top":false,"comment_ctime":1575963648,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575963648","product_id":100017301,"comment_content":"26的25次方都要超过long型的最大值了","like_count":0},{"had_liked":false,"id":159091,"user_name":"black","can_delete":false,"product_type":"c1","uid":1681512,"ip_address":"","ucode":"9B5E0909926674","user_header":"https://static001.geekbang.org/account/avatar/00/19/a8/68/70392fdd.jpg","comment_is_top":false,"comment_ctime":1575536578,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575536578","product_id":100017301,"comment_content":"RK是不是直接在构建的时候直接和子串比较就可以","like_count":0},{"had_liked":false,"id":158129,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1521486,"ip_address":"","ucode":"2B8E634FC4CFB7","user_header":"https://static001.geekbang.org/account/avatar/00/17/37/4e/5c3153b2.jpg","comment_is_top":false,"comment_ctime":1575336493,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575336493","product_id":100017301,"comment_content":"通用字符串怎么办？","like_count":0},{"had_liked":false,"id":158085,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1575330501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575330501","product_id":100017301,"comment_content":"没太明白公式中减  ‘a’ 的作用，如果‘a’=0，那就可以省略，如果不是零，代表的是什么？","like_count":0},{"had_liked":false,"id":157732,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1575251457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575251457","product_id":100017301,"comment_content":"思考题：<br>先把模式串的第一行作为一个模式串，把主串矩阵中的每一行作为一个主串，按照一维的方式在每一个主串中查找，如果未找到就说明没有匹配的。<br>如果找到，则记录位置，然后根据垂直偏移计算下面的值，是否匹配模式串的第二行，依次判断如果都符合，则找到匹配子串。<br>","like_count":0},{"had_liked":false,"id":157274,"user_name":"握不住手中沙","can_delete":false,"product_type":"c1","uid":1097132,"ip_address":"","ucode":"F194E47C4D42C9","user_header":"https://static001.geekbang.org/account/avatar/00/10/bd/ac/49494ed8.jpg","comment_is_top":false,"comment_ctime":1575101130,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575101130","product_id":100017301,"comment_content":"思考题：<br>1、以模式串矩阵的大小，去匹配主串矩阵，每个小矩阵可以构建成字符串，就能用 RK 算法做字符串匹配了。如果主串的大小是 M * N，模式串大小为 m * n，则时间复杂度为 (M - m + 1) * (N - n + 1)。","like_count":0},{"had_liked":false,"id":156339,"user_name":"Airsaid","can_delete":false,"product_type":"c1","uid":1115302,"ip_address":"","ucode":"5B90BC0044F376","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/a6/18c4f73c.jpg","comment_is_top":false,"comment_ctime":1574858809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574858809","product_id":100017301,"comment_content":"为什么我觉得 RK 算法的实用性并不是很大呢？因为实际情况中，不可能只有英文数字这些少数的字符，还会出现中文等，那这样 hash 算法该如何设计呢？老师可以举例有哪些实际的函数库中用到了 RK 算法吗？","like_count":0},{"had_liked":false,"id":155963,"user_name":"momo","can_delete":false,"product_type":"c1","uid":1711813,"ip_address":"","ucode":"EBC2C886E5A222","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1e/c5/4e640126.jpg","comment_is_top":false,"comment_ctime":1574783732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574783732","product_id":100017301,"comment_content":"这节内容的哈希函数设计一下让我想到Java里string比较，set集合里判断重复key的方式","like_count":0},{"had_liked":false,"id":152047,"user_name":"Geek_74cbfd","can_delete":false,"product_type":"c1","uid":1255609,"ip_address":"","ucode":"1BC8208E975F2A","user_header":"https://static001.geekbang.org/account/avatar/00/13/28/b9/b53181d4.jpg","comment_is_top":false,"comment_ctime":1573864839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573864839","product_id":100017301,"comment_content":"hash 算法 a =0, 那么abc 的hash值就等于 bc","like_count":0},{"had_liked":false,"id":148562,"user_name":"Geek_76c573","can_delete":false,"product_type":"c1","uid":1735293,"ip_address":"","ucode":"0FD9A9E9A20188","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo2lq92rQ5eUBIhMPyq6fHP7GAEoJhHFRfIssYmYg2F3HRIiazAIYI6KsnGLhTL8GgorjKh3eyzaiaw/132","comment_is_top":false,"comment_ctime":1573031586,"is_pvip":false,"replies":[{"id":"57638","content":"不影响的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1573425050,"ip_address":"","comment_id":148562,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573031586","product_id":100017301,"comment_content":"请问不会java.等其他语言，只学学了c影响后面阅读吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473537,"discussion_content":"不影响的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573425050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145915,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1572402024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572402024","product_id":100017301,"comment_content":"老师说的是乘法求hash, 我还看到另一种rk算法是 除法求hash, 其实效果一样","like_count":0},{"had_liked":false,"id":141164,"user_name":"Geek","can_delete":false,"product_type":"c1","uid":1520648,"ip_address":"","ucode":"12CC0CE52996C1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKDrwrfgpyaveaqKVTTpwIHSl7a3aicYoa7sVG4fraO6ZJibl1nsj91eSDQC79AIWSicr86hC5m5YMTQ/132","comment_is_top":false,"comment_ctime":1571126904,"is_pvip":false,"replies":[{"id":"54636","content":"发代码上来","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571181673,"ip_address":"","comment_id":141164,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1571126904","product_id":100017301,"comment_content":"老师，根据你的提示，我写了bf的hash匹配，发现bf的效率更高。为什么？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470687,"discussion_content":"发代码上来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571181673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1520648,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKDrwrfgpyaveaqKVTTpwIHSl7a3aicYoa7sVG4fraO6ZJibl1nsj91eSDQC79AIWSicr86hC5m5YMTQ/132","nickname":"Geek","note":"","ucode":"12CC0CE52996C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34285,"discussion_content":"public int bf(String mode,String pattern) {\n\t\tchar[] chm = mode.toCharArray();\n\t\tchar[] chp = pattern.toCharArray();\n\t\tint mlen = chm.length;\n\t\tint plen = chp.length;\n\t\t/**\n\t\t * aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\n\t\t *   aaaaab\n\t\t */\n\t\t\n\t\tfor(int i=0;i<=mlen-plen;i++) {\n\t\t\tint j=0;\n\t\t\tfor(;j<plen;) {\n\t\t\t\t//count++;\n\t\t\t\tif(chm[i+j]==chp[j]) {\n\t\t\t\t\tj++;\n\t\t\t\t}else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j==plen) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\t\n\tpublic int rk(String mode,String pattern) {\n\t\tchar[] chm = mode.toCharArray();\n\t\tchar[] chp = pattern.toCharArray();\n\t\tint mlen = chm.length;\n\t\tint plen = chp.length;\n\t\tint hash = 0;//主串长度为plen的子串hash\n\t\tint phash = 0;//模式串hash\n\t\tfor(int i=0;i<plen;i++) {\n\t\t\tphash = 31*phash + chp[i];\n\t\t}\n\t\tint pow = (int) Math.pow(31,plen-1);\n\t\tfor(int j=0;j<plen;j++) {//计算第一个子串hash，后面的子串hash根据第一个hash计算\n\t\t\thash = 31*hash + chm[j];\n\t\t}\n\t\tif(hash==phash) {\n\t\t\tint i=0;\n\t\t\tfor(;i<plen;i++) {\n\t\t\t\tif(chm[i]!=chp[i]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i==plen) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<(mlen-plen+1);i++) {\n\t\t\thash = (hash - chm[i-1] * pow) * 31 + chm[i+plen-1] ;\n\t\t\tif(hash==phash) {//hash一样，判断是否一样\n\t\t\t\tint j=0;\n\t\t\t\tfor(;j<plen;j++) {\n\t\t\t\t\tif(chm[i+j]!=chp[j]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j==plen) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571190356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139654,"user_name":"Orient","can_delete":false,"product_type":"c1","uid":1665373,"ip_address":"","ucode":"FAC57EA1F4382C","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/5d/b60d2629.jpg","comment_is_top":false,"comment_ctime":1570698953,"is_pvip":false,"replies":[{"id":"53981","content":"暂时没有，等我抽空自己先刷刷leetcode，整理一些放上来。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570747101,"ip_address":"","comment_id":139654,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570698953","product_id":100017301,"comment_content":"有没有大佬推荐些leetcode上的相关题目呀","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470038,"discussion_content":"暂时没有，等我抽空自己先刷刷leetcode，整理一些放上来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570747101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138530,"user_name":"王凯旋","can_delete":false,"product_type":"c1","uid":1084755,"ip_address":"","ucode":"6FDD7BC8B084A5","user_header":"https://static001.geekbang.org/account/avatar/00/10/8d/53/a73ea597.jpg","comment_is_top":false,"comment_ctime":1570295811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570295811","product_id":100017301,"comment_content":"RK对BF改进在于，不用比较模式串，而是比较hash值。所以RK的关键是处理hash的问题。","like_count":0},{"had_liked":false,"id":136432,"user_name":"寻非","can_delete":false,"product_type":"c1","uid":1122048,"ip_address":"","ucode":"7D4944003C07C9","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/00/f1ad685a.jpg","comment_is_top":false,"comment_ctime":1569431566,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569431566","product_id":100017301,"comment_content":"26 *（h[i-1] - 26^(m-1) *S[i]） +  S[i + m]。详细推导见《算法导论》第32章Rabin-Karp算法","like_count":0},{"had_liked":false,"id":136210,"user_name":"Hwan","can_delete":false,"product_type":"c1","uid":1205627,"ip_address":"","ucode":"A728C6790511BD","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/7b/66b9befd.jpg","comment_is_top":false,"comment_ctime":1569383722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569383722","product_id":100017301,"comment_content":"针对二维数组的对比，可以类一维的字符串匹配，假设主串为m*n,模式串为i*j，<br>如果是朴素字符串匹配的话，时间复杂度是O((m-i)*(n-j)*(i*j))，<br>我们可以假设求hash值的时候，hash函数大致设计成，针对思考题的模式串，hash值为，2*26^4+0*26^3+4*26^1+5*26^0,\t<br>时间复杂度是O((m-i)*(n-j))<br>","like_count":0},{"had_liked":false,"id":135902,"user_name":"junjun","can_delete":false,"product_type":"c1","uid":1547322,"ip_address":"","ucode":"1F7EE146B9BE04","user_header":"https://static001.geekbang.org/account/avatar/00/17/9c/3a/bfd73920.jpg","comment_is_top":false,"comment_ctime":1569295819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569295819","product_id":100017301,"comment_content":"可以转成一维的字符串，然后用RK算法","like_count":0},{"had_liked":false,"id":133767,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1568648496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568648496","product_id":100017301,"comment_content":"一、采用BF算法：<br>从主串的最左上角元素开始匹配模式串，查找顺序为从上到下，从左到右，假设主串是m阶矩阵，模式串是n阶矩阵，则最后一个查找的元素为(m-n+1,m-n+1)<br>,且最多需要匹配(m-n+1)^2次。<br><br>二、采用RK算法：<br>（1）首先对待查找(m-n+1)^2个子矩阵计算Hash值，并存贮到Hash表中。<br>（2）对模式矩阵采用同样的算法计算Hash值。<br>（3）采用Hash查找算法，找到和模式串相匹配的子矩阵。","like_count":0},{"had_liked":false,"id":133499,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1568594534,"is_pvip":false,"replies":[{"id":"51418","content":"后面有一篇文章专门写了应该如何循序渐进的去学习各种算法和数据结构，你找找。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568760998,"ip_address":"","comment_id":133499,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568594534","product_id":100017301,"comment_content":"后面就没见老师强调哪一章重不重要了，学算法跟被单词一样，a（数组，链表）开头的挺熟的，z（动态规划）开头的也还行，中间（字符串匹配）是大难题！看过去懂个7分，之后忘了，这部分有没有必要花大力气啃一啃呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467405,"discussion_content":"后面有一篇文章专门写了应该如何循序渐进的去学习各种算法和数据结构，你找找。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568760998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133361,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1568529939,"is_pvip":false,"replies":[{"id":"51216","content":"也可以，看冲突概率了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568588219,"ip_address":"","comment_id":133361,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568529939","product_id":100017301,"comment_content":"老师，我觉得文章中hash算法还是过于复杂了，其实我的想法是最简单的就是取后几位，来一个异或运算最舒服","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467367,"discussion_content":"也可以，看冲突概率了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568588219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133354,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1568527043,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568527043","product_id":100017301,"comment_content":"就应该从暴力慢慢演变过来才好理解","like_count":0},{"had_liked":false,"id":131744,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1567871401,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567871401","product_id":100017301,"comment_content":"矩阵的那个我想法是，用 rk 算法会更好些：<br><br>大矩阵是 n*n，小矩阵是 m*m，<br><br>因为元素相邻，可以用数组 index 下标来计算元素，每次 hash 都选取要匹配的子矩阵的元素<br><br>这样的话，横着的需要遍历：n - m + 1 次，竖着要遍历：n &#47; m 个。<br><br>ecummmmm～～～ 看起来如此的完美～～perfect～～<br><br>","like_count":0},{"had_liked":false,"id":126493,"user_name":"Apple","can_delete":false,"product_type":"c1","uid":1039810,"ip_address":"","ucode":"904D70CF7A6148","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dd/c2/0d58f08b.jpg","comment_is_top":false,"comment_ctime":1566394637,"is_pvip":false,"replies":[{"id":"47246","content":"直接求和有问题的，有可能值太大整型数据表示不了，文章里好像都有提到的~你再仔细看一遍吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1566774008,"ip_address":"","comment_id":126493,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566394637","product_id":100017301,"comment_content":"老师你好， 这里直接ord() 求和， 然后滑动 对比 不就可以了吗， 为什么一定要hash呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464013,"discussion_content":"直接求和有问题的，有可能值太大整型数据表示不了，文章里好像都有提到的~你再仔细看一遍吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566774008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123827,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1565767993,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565767993","product_id":100017301,"comment_content":"github上java代码的rk实现方法是不是有问题，table数组长度是26，如果table[n-1-j]下标越界怎么办？","like_count":0},{"had_liked":false,"id":123111,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1565607234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565607234","product_id":100017301,"comment_content":"github提交的代码好像并没有用那个公式，所以复杂度没有降低","like_count":0},{"had_liked":false,"id":123108,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1565606725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565606725","product_id":100017301,"comment_content":"公式里边-‘a’的部分是为了计算每个字符相对于字符a的值啊","like_count":0},{"had_liked":false,"id":123042,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1565596725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565596725","product_id":100017301,"comment_content":"rk算法求子串哈希值的公式没看明白【哭哭哭】","like_count":0},{"had_liked":false,"id":117133,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1563974576,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563974576","product_id":100017301,"comment_content":"又看懂了一篇👻","like_count":0},{"had_liked":false,"id":111073,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1562465847,"is_pvip":false,"replies":[{"id":"40488","content":"文章里有讲到的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562542973,"ip_address":"","comment_id":111073,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562465847","product_id":100017301,"comment_content":"超过整型范围 该如何解决","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457213,"discussion_content":"文章里有讲到的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562542973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110866,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1562381418,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562381418","product_id":100017301,"comment_content":"还是要多看一些费脑子的东西","like_count":0},{"had_liked":false,"id":99137,"user_name":"Yafei","can_delete":false,"product_type":"c1","uid":1233728,"ip_address":"","ucode":"BEA5B162DF2364","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/40/39d41615.jpg","comment_is_top":false,"comment_ctime":1559159273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559159273","product_id":100017301,"comment_content":"1.将二维数组每行看成一个一维数组，然后对每个一维数组分别按RK算法求子串hash。<br>2.将模式串也同样按行切成M个一维数组，因为是每个一维数组上下相邻，所以在移动比较的时候同时比较这M个串和主串的hash。","like_count":0},{"had_liked":false,"id":93670,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1557556015,"is_pvip":false,"replies":[{"id":"33559","content":"回溯算法","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557703124,"ip_address":"","comment_id":93670,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557556015","product_id":100017301,"comment_content":"请问正则表达式是怎么做字符串匹配的？用到什么算法呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449724,"discussion_content":"回溯算法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557703124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93342,"user_name":"康斯坦丁","can_delete":false,"product_type":"c1","uid":1368096,"ip_address":"","ucode":"C130E800E8D5C9","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/20/003190c1.jpg","comment_is_top":false,"comment_ctime":1557454416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557454416","product_id":100017301,"comment_content":"二维矩阵的宽高 x,y, 模式串 m,n.<br>需要迭代 (x-m+1)*(y-n+1) 次.","like_count":0},{"had_liked":false,"id":91262,"user_name":"James Ren","can_delete":false,"product_type":"c1","uid":1005833,"ip_address":"","ucode":"13FBE6C0DC2264","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/09/d4ec7b58.jpg","comment_is_top":false,"comment_ctime":1556957074,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1556957074","product_id":100017301,"comment_content":"看了Go标准库strings.Index的实现，用了RK算法。我在leecode下用Go语言凭自己的记忆写了RK算法，执行速度比我写的BF要慢，贴标准库代码执行速度一致，可见代码细节很重要。","like_count":0,"discussions":[{"author":{"id":1263932,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","nickname":"静静聆听","note":"","ucode":"0A8600CB928EFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12439,"discussion_content":"java用的是BF算法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568530247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86404,"user_name":"确认过眼神","can_delete":false,"product_type":"c1","uid":1245530,"ip_address":"","ucode":"E6D73A9D27A279","user_header":"https://static001.geekbang.org/account/avatar/00/13/01/5a/f7c989e4.jpg","comment_is_top":false,"comment_ctime":1555375681,"is_pvip":false,"replies":[{"id":"31003","content":"是的，分界点不好明确，这个根据你业务对性能的要求来看，可以自己先测试一下，如果性能允许，直接bf就好了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555379962,"ip_address":"","comment_id":86404,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555375681","product_id":100017301,"comment_content":"在实际场景中，是不是应先确定字符串的长度，如果短的话就用BF，如果长的话就用RK？如果是，分界点在哪里？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447002,"discussion_content":"是的，分界点不好明确，这个根据你业务对性能的要求来看，可以自己先测试一下，如果性能允许，直接bf就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555379962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85657,"user_name":"xfan","can_delete":false,"product_type":"c1","uid":1315147,"ip_address":"","ucode":"48ED8D498D7F56","user_header":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","comment_is_top":false,"comment_ctime":1555163759,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555163759","product_id":100017301,"comment_content":"可以考虑进一步用有序堆来存hash的值，先查查看这个hash在不在里面，而不用遍历整个hash","like_count":0},{"had_liked":false,"id":84457,"user_name":"石将从","can_delete":false,"product_type":"c1","uid":1375617,"ip_address":"","ucode":"12F43E643D1D58","user_header":"https://static001.geekbang.org/account/avatar/00/14/fd/81/1864f266.jpg","comment_is_top":false,"comment_ctime":1554866340,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554866340","product_id":100017301,"comment_content":"有没有实现过rabin-karp算法的，不会用代码实现呀","like_count":0},{"had_liked":false,"id":75764,"user_name":"90飞","can_delete":false,"product_type":"c1","uid":1241944,"ip_address":"","ucode":"9F360D766FB606","user_header":"https://static001.geekbang.org/account/avatar/00/12/f3/58/1ef2fa55.jpg","comment_is_top":false,"comment_ctime":1552465899,"is_pvip":false,"replies":[{"id":"27708","content":"😄  慢慢就会写了，总有个过程的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552531617,"ip_address":"","comment_id":75764,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552465899","product_id":100017301,"comment_content":"图 看完后又google了一些别人写的博客， 看完后，感觉我虽然写不出来，但是我发现我快爱上了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443023,"discussion_content":"😄  慢慢就会写了，总有个过程的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552531617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74364,"user_name":"嘿嘿啊","can_delete":false,"product_type":"c1","uid":1248655,"ip_address":"","ucode":"6CCD7A0AF000A0","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/8f/a0232945.jpg","comment_is_top":false,"comment_ctime":1552203000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552203000","product_id":100017301,"comment_content":"假设二维中的字符都可以用ascii码来表示，能否预先计算目标字符串与自己的卷积，然后在到主串进行一次卷积，相等的值再进行一次匹配","like_count":0},{"had_liked":false,"id":73024,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1551779756,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551779756","product_id":100017301,"comment_content":"加油，坚持","like_count":0},{"had_liked":false,"id":71622,"user_name":"晓龙","can_delete":false,"product_type":"c1","uid":1004576,"ip_address":"","ucode":"78CDCEBD183D3A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/20/93c79f7c.jpg","comment_is_top":false,"comment_ctime":1551402378,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551402378","product_id":100017301,"comment_content":"二维数组匹配，可以设计一个2*2的filter，扫描矩阵，得出很多小的2*1的vector，相加得出一个hash值，在对比模式矩阵的hash值","like_count":0},{"had_liked":false,"id":70320,"user_name":"八百","can_delete":false,"product_type":"c1","uid":1253530,"ip_address":"","ucode":"79F1F79ADF5A00","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/9a/3b1c65fd.jpg","comment_is_top":false,"comment_ctime":1551073586,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551073586","product_id":100017301,"comment_content":"讲的真好，😆","like_count":0},{"had_liked":false,"id":70042,"user_name":"吴昊","can_delete":false,"product_type":"c1","uid":1248635,"ip_address":"","ucode":"CB4F6A46930873","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/7b/e574577a.jpg","comment_is_top":false,"comment_ctime":1550974785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550974785","product_id":100017301,"comment_content":"思考题：<br>       找到二维主串中所有字串和模式串一一对比。这里不适合转化成哈希值再进行对比。因为相邻子串的哈希值计算过程中重复利用数据太少。若是采用进制计算，时间复杂度超过了逐一比较。","like_count":0},{"had_liked":false,"id":69726,"user_name":"泉","can_delete":false,"product_type":"c1","uid":1099760,"ip_address":"","ucode":"914709BE802A8D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/f0/aa2e0749.jpg","comment_is_top":false,"comment_ctime":1550819748,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1550819748","product_id":100017301,"comment_content":"字符串匹配:BF，RK。RK通过哈希函数计算哈希值与子串匹配，很巧妙。","like_count":0},{"had_liked":false,"id":67786,"user_name":"小北","can_delete":false,"product_type":"c1","uid":1120156,"ip_address":"","ucode":"A428FC9B771108","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ercic1LB9N9P1kArjS1f3hOo641elcwFGHWrxeYF4yZjfwiaydLwVeM4ZJEmVkib66GtJoE0cr6Dviauw/132","comment_is_top":false,"comment_ctime":1550277477,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550277477","product_id":100017301,"comment_content":"rk算法公式中最后一行中间少了一个右括号","like_count":0},{"had_liked":false,"id":65959,"user_name":"且听疯吟","can_delete":false,"product_type":"c1","uid":1159459,"ip_address":"","ucode":"B010B16E5465F4","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/23/5df1f341.jpg","comment_is_top":false,"comment_ctime":1549801182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549801182","product_id":100017301,"comment_content":"把矩阵按块进行划分即可。","like_count":0},{"had_liked":false,"id":62841,"user_name":"光","can_delete":false,"product_type":"c1","uid":1108110,"ip_address":"","ucode":"52EBDCABA633E8","user_header":"https://static001.geekbang.org/account/avatar/00/10/e8/8e/197ee632.jpg","comment_is_top":false,"comment_ctime":1548170874,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548170874","product_id":100017301,"comment_content":"正则表达式呢？","like_count":0},{"had_liked":false,"id":62386,"user_name":"睡痴儿😑","can_delete":false,"product_type":"c1","uid":1187204,"ip_address":"","ucode":"750EF858EF2042","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/84/d0ec0064.jpg","comment_is_top":false,"comment_ctime":1548042903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548042903","product_id":100017301,"comment_content":"第一种就是暴力的方式呗，两层循环嵌套。之后依次比较即可。时间复杂度是O(n*n*m*m)？<br>第二种就是按照每一层，使用rk算法，之后按照每个列使用RK，时间复杂度是O(n*m)<br>第三种是将矩阵进行转化，这个还没想起来。","like_count":0},{"had_liked":false,"id":57933,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1546944499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546944499","product_id":100017301,"comment_content":"可以先把模式矩阵通过哈希变成数字，然后用相同的哈希算法将主串里的字幕也变成数字。然后比较数字，时间复杂度是O(n)。","like_count":0},{"had_liked":false,"id":57553,"user_name":"我的腿腿","can_delete":false,"product_type":"c1","uid":1239277,"ip_address":"","ucode":"2AAA36A7C3AD75","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/ed/f9347e5e.jpg","comment_is_top":false,"comment_ctime":1546832462,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546832462","product_id":100017301,"comment_content":"这种算法在java源码中见到过类似的","like_count":0},{"had_liked":false,"id":55876,"user_name":"o my love","can_delete":false,"product_type":"c1","uid":1243331,"ip_address":"","ucode":"307601ACAC5DCC","user_header":"https://static001.geekbang.org/account/avatar/00/12/f8/c3/1d557354.jpg","comment_is_top":false,"comment_ctime":1546337196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546337196","product_id":100017301,"comment_content":"h[i] = 26*(h[i-1]-26^(m-1)*(s[i-1]-&#39;a&#39;)) + (s[i+m-1]-&#39;a&#39;);<br>其中, h[i]、h[i-1] 分别对应 s[i] 和 s[i-1] 两个子串的哈希值<br>有点懵😵","like_count":0},{"had_liked":false,"id":55169,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1546057102,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546057102","product_id":100017301,"comment_content":"思路：将左上角 元素*26^3，右上角元素*26^2 右下角 元素值*26 右下角*1，哈希算法。 ","like_count":0},{"had_liked":false,"id":54596,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1545909990,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545909990","product_id":100017301,"comment_content":"我们每次都比对 m 个字符，要比对 n-m+1 次，所以，这种算法的最坏情况时间复杂度是 O(n*m)。<br><br><br>需要比对(n-m+1)次，每次比对m个，所以时间复杂度是O( m*(n-m+1))  ，忽略常数、低阶，所以为O(n*m)","like_count":0},{"had_liked":false,"id":53657,"user_name":"追风者","can_delete":false,"product_type":"c1","uid":1055092,"ip_address":"","ucode":"879BC372A6B605","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjUDIRQ0gRiciax3Wo78c5rVjuWDiaw4ibcCiby8xiaMXJh5ibjU5242vfCGOK4ehibe1IKyxex2A4IX4XSA/132","comment_is_top":false,"comment_ctime":1545705867,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545705867","product_id":100017301,"comment_content":"王老师，关于RK算法利用s[i-1]计算s[i]的哈希值的公式能否再用文字解释一下，公式没看懂。<br>另外一个问题是：正则匹配是怎样实现的呢？","like_count":0},{"had_liked":false,"id":52824,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1545535902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545535902","product_id":100017301,"comment_content":"<br>h[i] = 26*(h[i-1]-26^(m-1)*(s[i-1]-&#39;a&#39;)) + (s[i+m-1]-&#39;a&#39;);<br><br><br>请老师详细讲解下这个公式的推导过程吧。。","like_count":0},{"had_liked":false,"id":52406,"user_name":"唯她命","can_delete":false,"product_type":"c1","uid":1240398,"ip_address":"","ucode":"8F687E8D306840","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4e/ef406442.jpg","comment_is_top":false,"comment_ctime":1545376538,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545376538","product_id":100017301,"comment_content":"那这种RK算法   不是a-z  而是任意字符，hash算法该如何设计呢","like_count":0},{"had_liked":false,"id":52092,"user_name":"李东勇","can_delete":false,"product_type":"c1","uid":1236071,"ip_address":"","ucode":"7D1EA72D326F32","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/67/5149a60b.jpg","comment_is_top":false,"comment_ctime":1545308518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545308518","product_id":100017301,"comment_content":"思考题：<br>    二维字符串矩阵可以转化成上面的一维的字符串匹配，模式串等于“caef&quot;, 主串等于”dabcefadccafdefc“， 只不过匹配的时候， 主串中的子串不再是向后取指定的长度， 而是按照模式串生成的规则来生成子串， 比如对于第一个d， 它对应的子串应该为”daef“(程序中用二维数组来拼接出来)， 当然对于第一个c， 因为它拼不出子串（超过了数组边界）， 就直接忽略掉","like_count":0},{"had_liked":false,"id":51302,"user_name":"Douglas","can_delete":false,"product_type":"c1","uid":1073027,"ip_address":"","ucode":"CFDE3D76B9DAE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","comment_is_top":false,"comment_ctime":1545149470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545149470","product_id":100017301,"comment_content":"我明白了，有可能同一个k进制数字，对应不同的字符串","like_count":0},{"had_liked":false,"id":51124,"user_name":"永昌","can_delete":false,"product_type":"c1","uid":1025006,"ip_address":"","ucode":"A572DDE33DFAD9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/ee/636415d8.jpg","comment_is_top":false,"comment_ctime":1545118409,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1545118409","product_id":100017301,"comment_content":"直接比较，和 hash后比较，比较的次数应该都是一样的吧？而后一种方法，还需要将数据hash化，也需要增加不少的开销","like_count":0},{"had_liked":false,"id":50118,"user_name":"啃","can_delete":false,"product_type":"c1","uid":1138590,"ip_address":"","ucode":"A4A4A72A0F8684","user_header":"","comment_is_top":false,"comment_ctime":1544871222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544871222","product_id":100017301,"comment_content":"RK算法可以使用蒙特卡洛算法或者拉斯维加斯算法降低hash冲突的概率，这样就不用回退文本指针进行再比较了","like_count":0},{"had_liked":false,"id":49865,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1544781839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544781839","product_id":100017301,"comment_content":"BF简单粗暴，但由于字符串一般比较短，所以也很适用<br>RK是BF的升级版O(n)，在冲突频发的情况下，时间复杂度会退化为O(n*m)<br>朴素字符串匹配算法<br>在满足新能要求的前提下，简单首选<br>思考题，二维跟一维应该是一样的","like_count":0},{"had_liked":false,"id":48037,"user_name":"程序员大天地","can_delete":false,"product_type":"c1","uid":1249001,"ip_address":"","ucode":"7A21F15FEE2D5B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg","comment_is_top":false,"comment_ctime":1544328116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544328116","product_id":100017301,"comment_content":"二维数组的匹配是一样类比的，先应用上面的方法匹配模式串的第一行，匹配到第一行之后直接找到后续的行相同位子是否匹配即可。","like_count":0},{"had_liked":false,"id":47247,"user_name":"晓晨","can_delete":false,"product_type":"c1","uid":1197179,"ip_address":"","ucode":"8651F6A162C74B","user_header":"https://static001.geekbang.org/account/avatar/00/12/44/7b/3d5175a6.jpg","comment_is_top":false,"comment_ctime":1544088725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544088725","product_id":100017301,"comment_content":"思考题：<br><br>以模式串矩阵的大小，去匹配主串矩阵，每个小矩阵可以构建成字符串，就能用 RK 算法做字符串匹配了。<br>使用PK算法：<br>如果主串的大小是 M * N，模式串大小为 m * n，则子串个数为 (M - m + 1) * (N - n + 1)。<br>每次子串比较需要遍历所有子串需要比较 m*n次，最快情况时间复杂度为(M - m + 1) * (N - n + 1)*m*n<br>使用RK算法，每个小矩阵构建hash。hash不冲突，理想情况下时间复杂度为(M - m + 1) * (N - n + 1)","like_count":0}]}