{"id":218375,"title":"64 | 状态模式：游戏、工作流引擎中常用的状态机是如何实现的？","content":"<p>从今天起，我们开始学习状态模式。在实际的软件开发中，状态模式并不是很常用，但是在能够用到的场景里，它可以发挥很大的作用。从这一点上来看，它有点像我们之前讲到的组合模式。</p><p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。不过，状态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法。今天，我们就详细讲讲这几种实现方式，并且对比一下它们的优劣和应用场景。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>什么是有限状态机？</h2><p>有限状态机，英文翻译是Finite State Machine，缩写为FSM，简称为状态机。状态机有3个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p><p>对于刚刚给出的状态机的定义，我结合一个具体的例子，来进一步解释一下。</p><p>“超级马里奥”游戏不知道你玩过没有？在游戏中，马里奥可以变身为多种形态，比如小马里奥（Small Mario）、超级马里奥（Super Mario）、火焰马里奥（Fire Mario）、斗篷马里奥（Cape Mario）等等。在不同的游戏情节下，各个形态会互相转化，并相应的增减积分。比如，初始形态是小马里奥，吃了蘑菇之后就会变成超级马里奥，并且增加100积分。</p><!-- [[[read_end]]] --><p>实际上，马里奥形态的转变就是一个状态机。其中，马里奥的不同形态就是状态机中的“状态”，游戏情节（比如吃了蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动作”。比如，吃蘑菇这个事件，会触发状态的转移：从小马里奥转移到超级马里奥，以及触发动作的执行（增加100积分）。</p><p>为了方便接下来的讲解，我对游戏背景做了简化，只保留了部分状态和事件。简化之后的状态转移如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/5a/6c/5aa0310b9b3ea08794cfc2f376c8f96c.jpg?wh=1704*1563\" alt=\"\"></p><p>我们如何编程来实现上面的状态机呢？换句话说，如何将上面的状态转移图翻译成代码呢？</p><p>我写了一个骨架代码，如下所示。其中，obtainMushRoom()、obtainCape()、obtainFireFlower()、meetMonster()这几个函数，能够根据当前的状态和事件，更新状态和增减积分。不过，具体的代码实现我暂时并没有给出。你可以把它当做面试题，试着补全一下，然后再来看我下面的讲解，这样你的收获会更大。</p><pre><code>public enum State {\n  SMALL(0),\n  SUPER(1),\n  FIRE(2),\n  CAPE(3);\n\n  private int value;\n\n  private State(int value) {\n    this.value = value;\n  }\n\n  public int getValue() {\n    return this.value;\n  }\n}\n\npublic class MarioStateMachine {\n  private int score;\n  private State currentState;\n\n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = State.SMALL;\n  }\n\n  public void obtainMushRoom() {\n    //TODO\n  }\n\n  public void obtainCape() {\n    //TODO\n  }\n\n  public void obtainFireFlower() {\n    //TODO\n  }\n\n  public void meetMonster() {\n    //TODO\n  }\n\n  public int getScore() {\n    return this.score;\n  }\n\n  public State getCurrentState() {\n    return this.currentState;\n  }\n}\n\npublic class ApplicationDemo {\n  public static void main(String[] args) {\n    MarioStateMachine mario = new MarioStateMachine();\n    mario.obtainMushRoom();\n    int score = mario.getScore();\n    State state = mario.getCurrentState();\n    System.out.println(&quot;mario score: &quot; + score + &quot;; state: &quot; + state);\n  }\n}\n</code></pre><h2>状态机实现方式一：分支逻辑法</h2><p>对于如何实现状态机，我总结了三种方式。其中，最简单直接的实现方式是，参照状态转移图，将每一个状态转移，原模原样地直译成代码。这样编写的代码会包含大量的if-else或switch-case分支判断逻辑，甚至是嵌套的分支判断逻辑，所以，我把这种方法暂且命名为分支逻辑法。</p><p>按照这个实现思路，我将上面的骨架代码补全一下。补全之后的代码如下所示：</p><pre><code>public class MarioStateMachine {\n  private int score;\n  private State currentState;\n\n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = State.SMALL;\n  }\n\n  public void obtainMushRoom() {\n    if (currentState.equals(State.SMALL)) {\n      this.currentState = State.SUPER;\n      this.score += 100;\n    }\n  }\n\n  public void obtainCape() {\n    if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) {\n      this.currentState = State.CAPE;\n      this.score += 200;\n    }\n  }\n\n  public void obtainFireFlower() {\n    if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) {\n      this.currentState = State.FIRE;\n      this.score += 300;\n    }\n  }\n\n  public void meetMonster() {\n    if (currentState.equals(State.SUPER)) {\n      this.currentState = State.SMALL;\n      this.score -= 100;\n      return;\n    }\n\n    if (currentState.equals(State.CAPE)) {\n      this.currentState = State.SMALL;\n      this.score -= 200;\n      return;\n    }\n\n    if (currentState.equals(State.FIRE)) {\n      this.currentState = State.SMALL;\n      this.score -= 300;\n      return;\n    }\n  }\n\n  public int getScore() {\n    return this.score;\n  }\n\n  public State getCurrentState() {\n    return this.currentState;\n  }\n}\n</code></pre><p>对于简单的状态机来说，分支逻辑这种实现方式是可以接受的。但是，对于复杂的状态机来说，这种实现方式极易漏写或者错写某个状态转移。除此之外，代码中充斥着大量的if-else或者switch-case分支判断逻辑，可读性和可维护性都很差。如果哪天修改了状态机中的某个状态转移，我们要在冗长的分支逻辑中找到对应的代码进行修改，很容易改错，引入bug。</p><h2>状态机实现方式二：查表法</h2><p>实际上，上面这种实现方法有点类似hard code，对于复杂的状态机来说不适用，而状态机的第二种实现方式查表法，就更加合适了。接下来，我们就一块儿来看下，如何利用查表法来补全骨架代码。</p><p>实际上，除了用状态转移图来表示之外，状态机还可以用二维表来表示，如下所示。在这个二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到的新状态及其执行的动作。</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/91/4f4ea3787bd955918578181e18173491.jpg?wh=2263*913\" alt=\"\"></p><p>相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好。当修改状态机时，我们只需要修改transitionTable和actionTable两个二维数组即可。实际上，如果我们把这两个二维数组存储在配置文件中，当需要修改状态机时，我们甚至可以不修改任何代码，只需要修改配置文件就可以了。具体的代码如下所示：</p><pre><code>public enum Event {\n  GOT_MUSHROOM(0),\n  GOT_CAPE(1),\n  GOT_FIRE(2),\n  MET_MONSTER(3);\n\n  private int value;\n\n  private Event(int value) {\n    this.value = value;\n  }\n\n  public int getValue() {\n    return this.value;\n  }\n}\n\npublic class MarioStateMachine {\n  private int score;\n  private State currentState;\n\n  private static final State[][] transitionTable = {\n          {SUPER, CAPE, FIRE, SMALL},\n          {SUPER, CAPE, FIRE, SMALL},\n          {CAPE, CAPE, CAPE, SMALL},\n          {FIRE, FIRE, FIRE, SMALL}\n  };\n\n  private static final int[][] actionTable = {\n          {+100, +200, +300, +0},\n          {+0, +200, +300, -100},\n          {+0, +0, +0, -200},\n          {+0, +0, +0, -300}\n  };\n\n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = State.SMALL;\n  }\n\n  public void obtainMushRoom() {\n    executeEvent(Event.GOT_MUSHROOM);\n  }\n\n  public void obtainCape() {\n    executeEvent(Event.GOT_CAPE);\n  }\n\n  public void obtainFireFlower() {\n    executeEvent(Event.GOT_FIRE);\n  }\n\n  public void meetMonster() {\n    executeEvent(Event.MET_MONSTER);\n  }\n\n  private void executeEvent(Event event) {\n    int stateValue = currentState.getValue();\n    int eventValue = event.getValue();\n    this.currentState = transitionTable[stateValue][eventValue];\n    this.score += actionTable[stateValue][eventValue];\n  }\n\n  public int getScore() {\n    return this.score;\n  }\n\n  public State getCurrentState() {\n    return this.currentState;\n  }\n\n}\n</code></pre><h2>状态机实现方式三：状态模式</h2><p>在查表法的代码实现中，事件触发的动作只是简单的积分加减，所以，我们用一个int类型的二维数组actionTable就能表示，二维数组中的值表示积分的加减值。但是，如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作（比如加减积分、写数据库，还有可能发送消息通知等等），我们就没法用如此简单的二维数组来表示了。这也就是说，查表法的实现方式有一定局限性。</p><p>虽然分支逻辑的实现方式不存在这个问题，但它又存在前面讲到的其他问题，比如分支判断逻辑较多，导致代码可读性和可维护性不好等。实际上，针对分支逻辑法存在的问题，我们可以使用状态模式来解决。</p><p>状态模式通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑。我们还是结合代码来理解这句话。</p><p>利用状态模式，我们来补全MarioStateMachine类，补全后的代码如下所示。</p><p>其中，IMario是状态的接口，定义了所有的事件。SmallMario、SuperMario、CapeMario、FireMario是IMario接口的实现类，分别对应状态机中的4个状态。原来所有的状态转移和动作执行的代码逻辑，都集中在MarioStateMachine类中，现在，这些代码逻辑被分散到了这4个状态类中。</p><pre><code>public interface IMario { //所有状态类的接口\n  State getName();\n  //以下是定义的事件\n  void obtainMushRoom();\n  void obtainCape();\n  void obtainFireFlower();\n  void meetMonster();\n}\n\npublic class SmallMario implements IMario {\n  private MarioStateMachine stateMachine;\n\n  public SmallMario(MarioStateMachine stateMachine) {\n    this.stateMachine = stateMachine;\n  }\n\n  @Override\n  public State getName() {\n    return State.SMALL;\n  }\n\n  @Override\n  public void obtainMushRoom() {\n    stateMachine.setCurrentState(new SuperMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() + 100);\n  }\n\n  @Override\n  public void obtainCape() {\n    stateMachine.setCurrentState(new CapeMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() + 200);\n  }\n\n  @Override\n  public void obtainFireFlower() {\n    stateMachine.setCurrentState(new FireMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() + 300);\n  }\n\n  @Override\n  public void meetMonster() {\n    // do nothing...\n  }\n}\n\npublic class SuperMario implements IMario {\n  private MarioStateMachine stateMachine;\n\n  public SuperMario(MarioStateMachine stateMachine) {\n    this.stateMachine = stateMachine;\n  }\n\n  @Override\n  public State getName() {\n    return State.SUPER;\n  }\n\n  @Override\n  public void obtainMushRoom() {\n    // do nothing...\n  }\n\n  @Override\n  public void obtainCape() {\n    stateMachine.setCurrentState(new CapeMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() + 200);\n  }\n\n  @Override\n  public void obtainFireFlower() {\n    stateMachine.setCurrentState(new FireMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() + 300);\n  }\n\n  @Override\n  public void meetMonster() {\n    stateMachine.setCurrentState(new SmallMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() - 100);\n  }\n}\n\n// 省略CapeMario、FireMario类...\n\npublic class MarioStateMachine {\n  private int score;\n  private IMario currentState; // 不再使用枚举来表示状态\n\n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = new SmallMario(this);\n  }\n\n  public void obtainMushRoom() {\n    this.currentState.obtainMushRoom();\n  }\n\n  public void obtainCape() {\n    this.currentState.obtainCape();\n  }\n\n  public void obtainFireFlower() {\n    this.currentState.obtainFireFlower();\n  }\n\n  public void meetMonster() {\n    this.currentState.meetMonster();\n  }\n\n  public int getScore() {\n    return this.score;\n  }\n\n  public State getCurrentState() {\n    return this.currentState.getName();\n  }\n\n  public void setScore(int score) {\n    this.score = score;\n  }\n\n  public void setCurrentState(IMario currentState) {\n    this.currentState = currentState;\n  }\n}\n</code></pre><p>上面的代码实现不难看懂，我只强调其中的一点，即MarioStateMachine和各个状态类之间是双向依赖关系。MarioStateMachine依赖各个状态类是理所当然的，但是，反过来，各个状态类为什么要依赖MarioStateMachine呢？这是因为，各个状态类需要更新MarioStateMachine中的两个变量，score和currentState。</p><p>实际上，上面的代码还可以继续优化，我们可以将状态类设计成单例，毕竟状态类中不包含任何成员变量。但是，当将状态类设计成单例之后，我们就无法通过构造函数来传递MarioStateMachine了，而状态类又要依赖MarioStateMachine，那该如何解决这个问题呢？</p><p>实际上，在<a href=\"https://time.geekbang.org/column/article/194068\">第42讲</a>单例模式的讲解中，我们提到过几种解决方法，你可以回过头去再查看一下。在这里，我们可以通过函数参数将MarioStateMachine传递进状态类。根据这个设计思路，我们对上面的代码进行重构。重构之后的代码如下所示：</p><pre><code>public interface IMario {\n  State getName();\n  void obtainMushRoom(MarioStateMachine stateMachine);\n  void obtainCape(MarioStateMachine stateMachine);\n  void obtainFireFlower(MarioStateMachine stateMachine);\n  void meetMonster(MarioStateMachine stateMachine);\n}\n\npublic class SmallMario implements IMario {\n  private static final SmallMario instance = new SmallMario();\n  private SmallMario() {}\n  public static SmallMario getInstance() {\n    return instance;\n  }\n\n  @Override\n  public State getName() {\n    return State.SMALL;\n  }\n\n  @Override\n  public void obtainMushRoom(MarioStateMachine stateMachine) {\n    stateMachine.setCurrentState(SuperMario.getInstance());\n    stateMachine.setScore(stateMachine.getScore() + 100);\n  }\n\n  @Override\n  public void obtainCape(MarioStateMachine stateMachine) {\n    stateMachine.setCurrentState(CapeMario.getInstance());\n    stateMachine.setScore(stateMachine.getScore() + 200);\n  }\n\n  @Override\n  public void obtainFireFlower(MarioStateMachine stateMachine) {\n    stateMachine.setCurrentState(FireMario.getInstance());\n    stateMachine.setScore(stateMachine.getScore() + 300);\n  }\n\n  @Override\n  public void meetMonster(MarioStateMachine stateMachine) {\n    // do nothing...\n  }\n}\n\n// 省略SuperMario、CapeMario、FireMario类...\n\npublic class MarioStateMachine {\n  private int score;\n  private IMario currentState;\n\n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = SmallMario.getInstance();\n  }\n\n  public void obtainMushRoom() {\n    this.currentState.obtainMushRoom(this);\n  }\n\n  public void obtainCape() {\n    this.currentState.obtainCape(this);\n  }\n\n  public void obtainFireFlower() {\n    this.currentState.obtainFireFlower(this);\n  }\n\n  public void meetMonster() {\n    this.currentState.meetMonster(this);\n  }\n\n  public int getScore() {\n    return this.score;\n  }\n\n  public State getCurrentState() {\n    return this.currentState.getName();\n  }\n\n  public void setScore(int score) {\n    this.score = score;\n  }\n\n  public void setCurrentState(IMario currentState) {\n    this.currentState = currentState;\n  }\n}\n</code></pre><p>实际上，像游戏这种比较复杂的状态机，包含的状态比较多，我优先推荐使用查表法，而状态模式会引入非常多的状态类，会导致代码比较难维护。相反，像电商下单、外卖下单这种类型的状态机，它们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天我们讲解了状态模式。虽然网上有各种状态模式的定义，但是你只要记住状态模式是状态机的一种实现方式即可。状态机又叫有限状态机，它有3个部分组成：状态、事件、动作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p><p>针对状态机，今天我们总结了三种实现方式。</p><p>第一种实现方式叫分支逻辑法。利用if-else或者switch-case分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。</p><p>第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。</p><p>第三种实现方式叫状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。</p><h2>课堂讨论</h2><p>状态模式的代码实现还存在一些问题，比如，状态接口中定义了所有的事件函数，这就导致，即便某个状态类并不需要支持其中的某个或者某些事件，但也要实现所有的事件函数。不仅如此，添加一个事件到状态接口，所有的状态类都要做相应的修改。针对这些问题，你有什么解决方法吗？</p><p>欢迎留言和我分享你的想法。如果有收获，欢迎你把这篇文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":199943,"user_name":"张先生丶","can_delete":false,"product_type":"c1","uid":1138723,"ip_address":"","ucode":"D8AE94C76318D7","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/23/efd87e29.jpg","comment_is_top":false,"comment_ctime":1585503573,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"598585957717","product_id":100039001,"comment_content":"关于课堂讨论，可以在接口和实现类中间加一层抽象类解决此问题，抽象类实现状态接口，状态类继承抽象类，只需要重写需要的方法即可","like_count":140,"discussions":[{"author":{"id":1073650,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/f2/ca989d6f.jpg","nickname":"Leon Wong","note":"","ucode":"B49B327367CF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296601,"discussion_content":"或者可以用default 方法","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1596598554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369305,"discussion_content":"之前看到这个方案的话, 感觉好高大上, 现在再看的话, 感觉是一个老套路, 这种感觉真好","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1619000204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1299470,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d4/0e/496d6d7c.jpg","nickname":"冯志","note":"","ucode":"DA50D8322FD52F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549615,"discussion_content":"good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644138528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2188142,"avatar":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","nickname":"Z宇锤锤","note":"","ucode":"7DB36E986A7A51","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535516,"discussion_content":"可以的放在抽象类里，就可以按照需要自定义实现了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638457067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311125,"avatar":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","nickname":"布拉姆","note":"","ucode":"479FF27D73BCAD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394689,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631984615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206384,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1586851017,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"220630183113","product_id":100039001,"comment_content":"Java中Spring也有有限状态机的框架 ：https:&#47;&#47;github.com&#47;spring-projects&#47;spring-statemachine","like_count":51},{"had_liked":false,"id":199962,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1585523776,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"126139575360","product_id":100039001,"comment_content":"课后题<br>最小接口原则<br><br>具体做法:状态类只关心与自己相关的接口，将状态接口中定义的事件函数按事件分类，拆分到不同接口中，通过这些新接口的组合重新实现状态类即可！","like_count":30,"discussions":[{"author":{"id":1345640,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKubuofHB43wdIwvnWSIdL6YzfGZhic7abWu06ia8BwnMBDCbCFDIF1RQB4nN46Ldv6ALQf025E2mRA/132","nickname":"Geek_palmlan","note":"","ucode":"B62A6372CB6376","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402532,"discussion_content":"那你的状态机岂不是要依赖多个状态类？还需要增加选择哪一种状态类的逻辑。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633914028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200067,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1585539443,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"96074819955","product_id":100039001,"comment_content":"课后思考：要解决这个问题可以有两种方式1. 直接使用抽象类替代接口，抽象类中对每个时间有个默认的实现，比如抛出unimplemented exception，这样子类要使用的话必须自己实现。2. 就是还是使用接口定义事件，但是额外创建一个抽象类实现这个接口，然后具体的状态实现类继承这个抽象类，这种方式好处在于可扩展性强，可以处理将来有不相关的事件策略加入进来的情况。","like_count":22},{"had_liked":false,"id":263009,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1605947252,"is_pvip":true,"replies":[{"id":"96113","content":"好吧","user_name":"作者回复","comment_id":263009,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700865,"user_name_real":"王争"}],"discussion_count":4,"race_medal":0,"score":"78915358580","product_id":100039001,"comment_content":"不太赞同老师的这种抽象方式，状态机中的每个状态应该具有事件、触发条件、转移（方法）列表，每一个应该都可以抽象为一个接口或者泛型类，状态机作为一个单例这个没问题，但是状态机应该只是作为一个状态的注册工厂，里面具有的应该是多种状态，状态间的流转才是状态机最重要的功能抽象。score放在状态和状态机中都不合适，这应该是状态机操纵的一个对象&#47;资源，应该单独抽象出来，在状态间流转","like_count":19,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510067,"discussion_content":"好吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098917,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a5/c8cb87cc.jpg","nickname":"明才","note":"","ucode":"17F5A9E7FB777C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588624,"discussion_content":"同意，状态机里面为什么有分数？状态机不应带业务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663914329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1345640,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKubuofHB43wdIwvnWSIdL6YzfGZhic7abWu06ia8BwnMBDCbCFDIF1RQB4nN46Ldv6ALQf025E2mRA/132","nickname":"Geek_palmlan","note":"","ucode":"B62A6372CB6376","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402538,"discussion_content":"我理解对象多的时候可以共用一个状态机类，对象少的时候就没必要，由状态机直接包含对象的属性即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633915216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2181661,"avatar":"https://static001.geekbang.org/account/avatar/00/21/4a/1d/3567f117.jpg","nickname":"乔宏民","note":"","ucode":"B6A9F971E9CC96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377080,"discussion_content":"这里的score相当于全局变量，所有的马里奥状态都可以获取到当前score变量。这个场景还是合适的吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622483431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200162,"user_name":"J.D.Chi","can_delete":false,"product_type":"c1","uid":1035855,"ip_address":"","ucode":"34812AEF95C7AB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ce/4f/3a89d29a.jpg","comment_is_top":false,"comment_ctime":1585551935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53125159487","product_id":100039001,"comment_content":"Flutter里引入了Bloc框架后，就是非常典型的状态模式（或是有限状态机）。https:&#47;&#47;bloclibrary.dev&#47;#&#47;coreconcepts","like_count":12},{"had_liked":false,"id":200101,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1585544115,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53125151667","product_id":100039001,"comment_content":"1.解决方法的话，java可以用接口的def函数解决，也可以在实现类和接口间加一个def实现来过度。但这都是不好的设计。事实上接口def函数的实现是一种无奈之举，我们在使用接口时应依旧遵循其语意限制？而非滥用语言特性。<br><br>2.所以上诉解决方案，个人认为最好的方式就是细分接口包含的函数，对现有的函数重新归类，划分成不同的接口。实现时以实现多接口的方式去组合出目标实现。这也是接口隔离的体现。","like_count":12},{"had_liked":false,"id":200041,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1585536063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53125143615","product_id":100039001,"comment_content":"设计模式_63:<br># 作业<br>组合优于继承<br>- 即使不需要，也必须实现所有的函数<br>&gt;&gt;&gt; 最小接口原则，每个函数拆分到单独的接口中<br><br>- 新增事件要修改所有状态实现<br>&gt;&gt;&gt; 观察者模式，用注解动态地把事件函数注册到观察队列中。<br><br># 感想<br>看到状态接口类中直接使用了`obtainMushRoom()`这样具体的事件函数，感觉很不舒服。就像结尾的讨论，所有的状态类必须实现所有事件函数，新增一种事件状态接口和实现都要改。。。","like_count":12},{"had_liked":false,"id":299183,"user_name":"Amon Tin","can_delete":false,"product_type":"c1","uid":2618193,"ip_address":"","ucode":"25391BEEB6A719","user_header":"https://static001.geekbang.org/account/avatar/00/27/f3/51/c8eb2d0c.jpg","comment_is_top":false,"comment_ctime":1624502410,"is_pvip":true,"discussion_count":5,"race_medal":0,"score":"44574175370","product_id":100039001,"comment_content":"状态和事件都可能随需求增加，可以利用callback的方式，将这类组合逻辑注册到对应状态类。代码实现如下：<br>&#47;**<br> * 事件枚举<br> *&#47;<br>public enum Event {<br>    A,B,C<br>}<br><br>&#47;**<br> * 事件回调<br> * Created on 2021-06-24<br> *&#47;<br>public interface IEventCallback {<br><br>    void onEvent(StateMachine sm);<br><br>}<br><br>&#47;**<br> * 状态抽象类<br> *&#47;<br>public abstract class State {<br><br>    protected String name;<br><br>    protected Map&lt;Event, IEventCallback&gt; events = new HashMap&lt;&gt;();<br><br>    public final void triggerEvent(Event e, StateMachine sm) {<br>        IEventCallback call = events.get(e);<br>        if (call != null) {<br>            call.onEvent(sm);<br>        }<br>    }<br>}<br><br>&#47;&#47;S1状态类<br>public class S1State extends State {<br>    private static final S1State instance = new S1State();<br><br>    Map&lt;Event, IEventCallback&gt; events = new HashMap&lt;&gt;();<br><br>    public static S1State getInstance() {<br>        return instance;<br>    }<br><br>    &#47;&#47;S1状态只关心A、B事件<br>    private S1State() {<br>        name = &quot;S1&quot;;<br>        events.put(Event.A, sm -&gt; {<br>            sm.currentState = S2State.getInstance();<br>            sm.score++;<br>        });<br>        events.put(Event.B, sm -&gt; {<br>            sm.score *= 10;<br>        });<br>    }<br><br>}<br><br>&#47;&#47;S2状态类<br>public class S2State extends State {<br>    private static final S2State instance = new S2State();<br><br>    public static S2State getInstance() {<br>        return instance;<br>    }<br><br>    &#47;&#47;S2状态只关心B、C事件<br>    private S2State() {<br>        name = &quot;S2&quot;;<br>        events.put(Event.B, sm -&gt; {<br>            sm.score = 0;<br>        });<br>        events.put(Event.C, sm -&gt; {<br>            sm.score--;<br>            sm.currentState = S1State.getInstance();<br>        });<br>    }<br><br>}<br><br>&#47;**<br> * 状态机核心类，状态流转的入口<br> *&#47;<br>public class StateMachine {<br>    int score;<br>    State currentState;<br><br>    public StateMachine() {<br>        score = 0;<br>        currentState = S1State.getInstance();<br>    }<br><br>    public void triggerAB() {<br>        currentState.triggerEvent(Event.A, this);<br>        currentState.triggerEvent(Event.B, this);<br>    }<br><br>    public void triggerBC() {<br>        currentState.triggerEvent(Event.B, this);<br>        currentState.triggerEvent(Event.C, this);<br>    }<br>}<br><br>","like_count":10},{"had_liked":false,"id":202142,"user_name":"进击的前端er","can_delete":false,"product_type":"c1","uid":1506085,"ip_address":"","ucode":"9229B410F48B85","user_header":"https://static001.geekbang.org/account/avatar/00/16/fb/25/f6743e97.jpg","comment_is_top":false,"comment_ctime":1585908774,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"44535581734","product_id":100039001,"comment_content":"我有个前端组件，很适合这个模式，我正在尝试重构，发现代码缩减量可能达到50%以上，而且更容易理解","like_count":10,"discussions":[{"author":{"id":1113737,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","nickname":"xuanyuan","note":"","ucode":"1EC79B9372868F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76760,"discussion_content":"开放封闭的判断依据：\n1. 对已有测试的影响\n2. 新的功能尽量通过增加类而不是修改类\n3. 不必过于纠结是否修改类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575852735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200014,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1585533006,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23060369486","product_id":100039001,"comment_content":"课堂讨论：给新增的方法一个默认实现。","like_count":5},{"had_liked":false,"id":242316,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1597668477,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18777537661","product_id":100039001,"comment_content":"查表法看上去很6","like_count":4,"discussions":[{"author":{"id":1334015,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5a/ff/e89eb122.jpg","nickname":"LipLipLip","note":"","ucode":"6D5EC6B5BEC600","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393745,"discussion_content":"但是要穷举所有状态，容易把自己搞懵逼吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631583494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231672,"user_name":"Javatar","can_delete":false,"product_type":"c1","uid":2032840,"ip_address":"","ucode":"E216645CDF632C","user_header":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","comment_is_top":false,"comment_ctime":1593745293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18773614477","product_id":100039001,"comment_content":"增加一个MarioSupport的抽象类，其中getName是抽象方法。其他四个事件方法都默认实现为空。那么四个具体的状态类，就extend这个MarioSupport，根据自身状态，override需要覆盖的方法就可以了","like_count":5},{"had_liked":false,"id":200013,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1585532935,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18765402119","product_id":100039001,"comment_content":"（一直觉得状态机是个非常高大上的东西，心中一直有疑问，今天才算是基本弄懂了。）<br><br>对于一个全局对象的依赖，当做方法参数传递是个不错的设计。像之前提到的servlet中的过滤器的过滤方法中，参数就有FilterChain这一对象。一个方法需要依赖（广义）一个对象，无非来自于对象属性和方法自身。前者叫做组合，后者叫做依赖。在接口设计中，由于没有属性一说，所以只能通过参数传递了。这样看来，说是设计，实际上是不得已而为之啊（还能怎样啊）。<br><br>一直分不清状态模式和观察者模式，两者不都是状态变化之后触发一定的动作吗？","like_count":4,"discussions":[{"author":{"id":1077406,"avatar":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","nickname":"jaryoung","note":"","ucode":"6E72D107DB7E51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217344,"discussion_content":"关注点不一样吧？状态模式，解决同样内容互相转换的问题。但是，观察者模式，关注某个事物是否有变化，不存在转换的问题呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585546387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201281,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1585745047,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14470646935","product_id":100039001,"comment_content":"实际上，上面的代码还可以继续优化，我们可以将状态类设计成单例，毕竟状态类中不包含任何成员变量。但是，当将状态类设计成单例之后，我们就无法通过构造函数来传递 MarioStateMachine 了，而状态类又要依赖 MarioStateMachine，那该如何解决这个问题呢？<br><br>实际上状态类可以设计为单例，MarioStateMachine也可以通过函数的参数方式传入，但是这样做的优势是什么呢?<br>","like_count":3,"discussions":[{"author":{"id":1597071,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLe9iavda8ia7vNkbMVEHsCKs43l6U6HGWibiaxxKd9PuiaYu5wRedicC96PLicZ9VIh0ic5Jg8YHPrta3IAQ/132","nickname":"Geek_00e01b","note":"","ucode":"BC76A83B53D0EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385667,"discussion_content":"每次状态切换不需要进行额外的的对象创建和销毁工作","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1627200702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":251302,"user_name":"阿骨打","can_delete":false,"product_type":"c1","uid":2122539,"ip_address":"","ucode":"35EADA5550162A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","comment_is_top":false,"comment_ctime":1601454669,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10191389261","product_id":100039001,"comment_content":"我跟老师的实现方法不太一样，关于最后的那个优化，我使用的是接口中的default方法，给状态类加一个default void setStateMachine(MarioStateMachine machine) {<br>        &#47;&#47;留给子类实现<br>    } ，每个状态子类去实现它，就可以保证状态机的this可以传进来了。<br>2、同时，之前 状态类中，new SuperMario(stateMachine) 的地方 都可以删掉了，改为工厂类存储的 状态类<br>stateMachine.setCurrentState(MarioStateFactory.getByStateType(State.SUPER));<br>3、状态机中： currentState.setStateMachine(this); &#47;&#47; 每次改变状态类，顺便把自己传给状态类中。<br>4、没改变几条代码 完成<br>","like_count":2},{"had_liked":false,"id":201133,"user_name":"eason2017","can_delete":false,"product_type":"c1","uid":1009422,"ip_address":"","ucode":"E070BA624FA490","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","comment_is_top":false,"comment_ctime":1585721496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10175656088","product_id":100039001,"comment_content":"也可以基于jdk8的接口提供默认实现来做。","like_count":2},{"had_liked":false,"id":200812,"user_name":"攻城拔寨","can_delete":false,"product_type":"c1","uid":1053934,"ip_address":"","ucode":"CBC37183DAB6B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/ee/d72a8222.jpg","comment_is_top":false,"comment_ctime":1585655075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10175589667","product_id":100039001,"comment_content":"多写个抽象类默认实现接口，实现类继承抽象类就行了","like_count":2},{"had_liked":false,"id":200057,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1585537745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10175472337","product_id":100039001,"comment_content":"打卡 今日学习状态模式，收获如下：<br>状态模式通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑。与策略模式一样，状态模式可以解决if-else或着switch-case分支逻辑过多的问题。同时也了解到了有限状态机的概念，以前在看一些资料时遇到这个概念，之前不太理解这个状态机时干嘛用的，通过今天的学习，理解了状态机就是一种数学模型，该模型中有几个状态（有限的），在不同的场景下，不同的状态之间发生转移，在状态转移过程可能伴随着不同的事件发生。<br>对于课堂讨论，有两种方法：1. 在实现类和接口中间定义一层中间类，中间类来实现接口，中间类中的方法都时空实现，实现类继承中间类，有选择性的覆写自己需要的方法。之后修改了接口，只需要修改中间类即可，这种方式引入了中间类，使类个数变多，一旦接口中的抽象方法变多，中间类相应的方法也随着变多，这种思路不是很优雅。2. 使用在模版模式那一节课中提到的回调方法。","like_count":2},{"had_liked":false,"id":347701,"user_name":"熊猫宝宝","can_delete":false,"product_type":"c1","uid":1663921,"ip_address":"","ucode":"F082F925933C4E","user_header":"https://static001.geekbang.org/account/avatar/00/19/63/b1/6b9b9d8e.jpg","comment_is_top":false,"comment_ctime":1654329224,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5949296520","product_id":100039001,"comment_content":"说实话这一节建议优化 看不懂","like_count":2},{"had_liked":false,"id":345121,"user_name":"Void","can_delete":false,"product_type":"c1","uid":2719557,"ip_address":"","ucode":"1E7007EEB99A2C","user_header":"https://static001.geekbang.org/account/avatar/00/29/7f/45/914a2bfe.jpg","comment_is_top":false,"comment_ctime":1652063254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5947030550","product_id":100039001,"comment_content":"有一个点不明白，这种互相持有对象的设计，以后要改动是不是麻烦得很？相当于是相互依赖关系，如果是A调B，想要B也调A，可以做callBack设计。<br>还有一点。其实可以从事件流设计出发，不从状态出发，那么就是状态是一个简单的实体类，而E1~E4 是不同的事件类的实现，只要E1-E4事件类去操作状态类实例就可以完成更简单，且单向的依赖和操作。简单的一个E1事件的实现如下：<br>&#47;&#47;1、先定义一个事件接口<br>public interface IMarioEvent {<br>    &#47;**<br>     * 事件名<br>     *<br>     * @return<br>     *&#47;<br>    String eventName();<br>    &#47;**<br>     * 事件内容，即经过此事件后把当前的状态修改成经过事件之后的状态<br>     *<br>     * @param marioState<br>     *&#47;<br>     void doEvent(MarioState marioState);<br>}<br>&#47;&#47;2、定义需要操作的状态类<br>public class MarioState {<br>    &#47;&#47;状态<br>    private State state;<br>    &#47;&#47;分数值<br>    private int score;<br>    &#47;&#47;最后更新状态的时间<br>    private long lastUpdateTime;<br>    &#47;&#47;...........其他setter、getter、construct......<br>}\t<br>&#47;&#47;3、E1：吃磨菇事件实现<br>public class EatMushroomEvent implements IMarioEvent {<br>    @Override<br>    public String eventName() {<br>        return &quot;Eat_Mushroom&quot;;<br>    }<br>    @Override<br>    public void doEvent(MarioState marioState) {<br>        switch (marioState.getState()) {<br>            case SMALL:<br>                marioState.setScore(marioState.getScore() + 100);<br>                marioState.setState(State.SUPER);<br>                marioState.setLastUpdateTime(System.currentTimeMillis());<br>                break;<br>            default:<br>                &#47;&#47;doing nothing<br>        }<br>    }<br>}<br>&#47;&#47;4、TestCase<br>public class TestCase {<br>    public static void main(String[] args) {<br>        MarioState priState = new MarioState();<br>        IMarioEvent eatMushroomEvent = new EatMushroomEvent();<br>        eatMushroomEvent.doEvent(priState);<br>        System.out.println(&quot;state=&quot; + priState.getState() + &quot;:score=&quot; + priState.getScore());<br>    }<br>}","like_count":2},{"had_liked":false,"id":283524,"user_name":"Geek_8593e5","can_delete":false,"product_type":"c1","uid":1736807,"ip_address":"","ucode":"B316E40C400CC8","user_header":"","comment_is_top":false,"comment_ctime":1615807026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5910774322","product_id":100039001,"comment_content":"像电商下单、外卖下单这种类型的状态机，它们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现。  老师能举个例子吗？","like_count":1},{"had_liked":false,"id":280955,"user_name":"...？","can_delete":false,"product_type":"c1","uid":1590038,"ip_address":"","ucode":"8CB8669180F9D8","user_header":"https://static001.geekbang.org/account/avatar/00/18/43/16/d18be4c5.jpg","comment_is_top":false,"comment_ctime":1614502712,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5909470008","product_id":100039001,"comment_content":"目前项目中的订单状态还是使用的第一层实现，大量if-else....","like_count":1},{"had_liked":false,"id":264529,"user_name":"进击的巨人","can_delete":false,"product_type":"c1","uid":1167120,"ip_address":"","ucode":"DB62D77D460BF1","user_header":"https://static001.geekbang.org/account/avatar/00/11/cf/10/9fa2e5ba.jpg","comment_is_top":false,"comment_ctime":1606490962,"is_pvip":false,"replies":[{"id":"96070","content":"嗯嗯 ","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700583,"ip_address":"","comment_id":264529,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5901458258","product_id":100039001,"comment_content":"感觉状态模式就是一个策略模式","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510590,"discussion_content":"嗯嗯 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1227840,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","nickname":"大力水手Jerry","note":"","ucode":"E4A6C71E275DB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339529,"discussion_content":"只是形似而已，都是“基础接口+实例实现”，然后在主业务逻辑中调用接口实例方法，这是解耦的元方法。但显然，我们不会真的将其视为一致，因为我们应用某种模式的前提是意图相吻合，状态模式下，驱动StateMachine实例的方法其实也对应基础接口对应的方法，即事件及其处理，从这个角度说，它与代理模式和装饰器模式更类似，但我们认为代理和装饰器模式是结构型，而状态模式是行为型，关键区别在于基础接口：结构型模式中我们用接口抽象的是对象，因此我们往往会定义该对象的所有行为；行为型模式中我们用接口抽象的是对象的行为，因此我们往往只定义一组行为（模板方法模式）或一类行为（状态模式）。某些情况下，主体对象本身就是对行为的抽象，此时结构性与行为型的区别就更模糊了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609722914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201300,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1585747494,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5880714790","product_id":100039001,"comment_content":"老师讲状态模式，对比三种实现，之前项目中用过方法三，也是在用方法一的过程中，觉得太繁琐了，容易出错后才使用的。但对方法二，没有使用过，竟然也不知道。自己学知识不全面，仅仅为了使用、解决眼前的问题，学到的非常肤浅，没能抓到本质。感谢老师！","like_count":1,"discussions":[{"author":{"id":1202482,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ydFhHonicUQibGlAfsAYBibNOfSxpCG5cJNp9oRibTJm3TrxM7Hj4WPPCRE3vluZJb0TGQqpKCaBWLdmra5Su1KF5Q/132","nickname":"yudidi","note":"","ucode":"70283DE39D86F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239312,"discussion_content":"厉害了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587292663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200884,"user_name":"lmdcx","can_delete":false,"product_type":"c1","uid":1334409,"ip_address":"","ucode":"F2CDD0091ADFD7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjRETqRjvLESLDZkNTjIiaSibtNYBaS1o8WMUicOFn3ycF3Mgh6LRJibqSBjVBjiaO2ibW0gHkafATb21A/132","comment_is_top":false,"comment_ctime":1585667474,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880634770","product_id":100039001,"comment_content":"课后作业，与过滤器上的解决方法一样:<br>……<br>针对这个问题，我们对代码进行重构，利用模板模式，将调用 successor.handle() 的逻辑从具体的处理器类中剥离出来，放到抽象父类中。这样具体的处理器类只需要实现自己的业务逻辑就可以了。<br>……<br>","like_count":1},{"had_liked":false,"id":200864,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1585664005,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5880631301","product_id":100039001,"comment_content":"代码中：<br>public enum State {<br>    SMALL(0),<br>    SUPER(1),<br>    FIRE(2),<br>    CAPE(3);<br><br>    private int value;<br><br>    private State(int value) {<br>        this.value = value;<br>    }<br><br>    public int getValue() {<br>        return this.value;<br>    }<br>}<br>建议修改成：<br>public enum State {<br>    SMALL(0),<br>    SUPER(1),<br>    CAPE(2),<br>    FIRE(3);<br><br>    private int value;<br><br>    private State(int value) {<br>        this.value = value;<br>    }<br><br>    public int getValue() {<br>        return this.value;<br>    }<br>}<br>不然查表法会有索引的问题呢，希望争哥改一下哈。","like_count":1,"discussions":[{"author":{"id":1880582,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/b2/06/2086d76d.jpg","nickname":"buggetout","note":"","ucode":"63A948EF415FDD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274226,"discussion_content":"我觉得咋们不要纠结这些细节。说实话我看案例中的方法一方法二根本没有看代码，而是争哥说了个分支逻辑法，那我就能想到他是咋实现的。说了查表法我就能想到他是咋实现的，所以这些基础代码基本不看，也不浪费时间在这上面。如果咋们好好听马里奥这个例子，相信不难想出不用设计模式是怎么实现的。我觉得咋们更应该聚焦于方法三中的代码，但是也不要吹毛求疵，比如score减错了等等。更应该关注这个设计模式的框架代码。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590556711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1077406,"avatar":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","nickname":"jaryoung","note":"","ucode":"6E72D107DB7E51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1880582,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/b2/06/2086d76d.jpg","nickname":"buggetout","note":"","ucode":"63A948EF415FDD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275026,"discussion_content":"这个可能也是程序员的洁癖罢了，看到错误，提醒一下不对吗？小步快跑","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590649067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":274226,"ip_address":""},"score":275026,"extra":""}]},{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350238,"discussion_content":"初看愣没发现上下有什么不同，看了又看才发现是枚举2和3互换了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613781169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200143,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1585549650,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880516946","product_id":100039001,"comment_content":"思考题，可以用回调来替换接口，状态机类的方法增加一个回调对象的入参","like_count":1},{"had_liked":false,"id":199911,"user_name":"Tommy","can_delete":false,"product_type":"c1","uid":1092893,"ip_address":"","ucode":"4A3C9C4720799A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIGoUQicibTtscELH4GLlA9NMWCHWceib3sg8lZqEhh2vHnhcicm7qiaklJGCP98zHQ9ibnaaicTVYbRsHWQ/132","comment_is_top":false,"comment_ctime":1585498256,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5880465552","product_id":100039001,"comment_content":"老师，状态机模式怎么防止状态回退呢？","like_count":2,"discussions":[{"author":{"id":1077406,"avatar":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","nickname":"jaryoung","note":"","ucode":"6E72D107DB7E51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217348,"discussion_content":"遇到异常情况，直接中断流程，抛出异常。一般好像是这样子做的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585546878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1119609,"avatar":"https://static001.geekbang.org/account/avatar/00/11/15/79/efde2a69.jpg","nickname":"马球先生","note":"","ucode":"858C2CE0E494C5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217261,"discussion_content":"当遇到可能会回退的事件时，处理方法里抛出异常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585534186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352426,"user_name":"FOCUS","can_delete":false,"product_type":"c1","uid":2942404,"ip_address":"","ucode":"C1AD031F155EFE","user_header":"","comment_is_top":false,"comment_ctime":1658657668,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658657668","product_id":100039001,"comment_content":"状态模式的三个核心要素: 状态，事件，动作<br>事件驱动状态改变和动作执行(不是必要)<br>三种实现方法: <br>1.逻辑分支法，优点实现简单，缺点有很多的if-else或switch分支，代码可读性和可维护性不好。对于简单的状态机可以用这种方法实现。<br>2.查表法，可以实现复杂的状态转换，也没有分支逻辑。适用于逻辑状态转换复杂，行为比较简单的场合。对于比较复杂的行为不适用。<br>3.状态模式，优点代码耦合性降低了，缺点是在状态比较多的情况下，状态类很多，可维护性也会下降，所以适用于状态不多，转换比较简单，但是行为比较复杂的场合。和方法2互为补充。","like_count":0},{"had_liked":false,"id":347478,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1654069989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654069989","product_id":100039001,"comment_content":"可以定义枚举类，枚举类里写方法引用, 和execute 方法<br>public enum StateEnum {<br>ACTIVE(&quot;正在进行&quot;, State::active);<br>  private String desc;<br><br>    private Handle handle;<br><br>    StateEnum(String desc, Handle handle) {<br>        this.desc = desc;<br>        this.handle = handle;<br>    }<br><br>    public void execute(State state, Domain domain) {<br>        this.handle.accept(state, domain);<br>    }<br>}<br><br>@FunctionalInterface<br>interface Handle {<br>    void accept(State dealState, Domain domain);<br>}<br>","like_count":0},{"had_liked":false,"id":343961,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1651144096,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1651144096","product_id":100039001,"comment_content":"这里例子状态有点复杂，要是可以举简单点的例子来说明就好了。","like_count":1},{"had_liked":false,"id":343956,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1651142805,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1651142805","product_id":100039001,"comment_content":"看着看着，我想到了动态规划。到查表法的时候。","like_count":0},{"had_liked":false,"id":340404,"user_name":"Zzz😴","can_delete":false,"product_type":"c1","uid":2957444,"ip_address":"","ucode":"FBB5E611996272","user_header":"https://static001.geekbang.org/account/avatar/00/2d/20/84/658801d4.jpg","comment_is_top":false,"comment_ctime":1648800939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648800939","product_id":100039001,"comment_content":"没有什么是加一层解决不了的哈哈","like_count":0},{"had_liked":false,"id":334468,"user_name":"devilyaos","can_delete":false,"product_type":"c1","uid":1064902,"ip_address":"","ucode":"5FE075608F03F7","user_header":"https://static001.geekbang.org/account/avatar/00/10/3f/c6/c2bf55bd.jpg","comment_is_top":false,"comment_ctime":1644971622,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644971622","product_id":100039001,"comment_content":"是不是可以把状态改变作为一个事件，查表发送事件，然后通过订阅事件做复杂操作","like_count":0},{"had_liked":false,"id":331080,"user_name":"张晓永","can_delete":false,"product_type":"c1","uid":1529668,"ip_address":"","ucode":"C728459C061A13","user_header":"https://static001.geekbang.org/account/avatar/00/17/57/44/a0ed355d.jpg","comment_is_top":false,"comment_ctime":1642413402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642413402","product_id":100039001,"comment_content":"把事件抽象成工厂，给事件传入，当前状态","like_count":0},{"had_liked":false,"id":329819,"user_name":"云川","can_delete":false,"product_type":"c1","uid":1087077,"ip_address":"","ucode":"49EC5972B9EB1C","user_header":"https://static001.geekbang.org/account/avatar/00/10/96/65/aaf5985b.jpg","comment_is_top":false,"comment_ctime":1641550198,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641550198","product_id":100039001,"comment_content":"1.接口可以多实现，拆分。2.多用组合，少用继承，组合进来。","like_count":0},{"had_liked":false,"id":325158,"user_name":"gggggggb","can_delete":false,"product_type":"c1","uid":1350738,"ip_address":"","ucode":"4DA862E45C331D","user_header":"https://static001.geekbang.org/account/avatar/00/14/9c/52/8a4902ce.jpg","comment_is_top":false,"comment_ctime":1638845301,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638845301","product_id":100039001,"comment_content":"hadoop yarn中的状态机转换是真的头皮发麻，用了好多","like_count":0},{"had_liked":false,"id":320723,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1636469130,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636469130","product_id":100039001,"comment_content":"可以在二维表的值存储处理动作的类名，似乎也是可以的呢","like_count":1},{"had_liked":false,"id":317174,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1634699806,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634699806","product_id":100039001,"comment_content":"可以利用接口的default方法，只需要重写和自己状态相关的方法即可。Spring的WebMvcConfigurer就是利用default方法，简化一些自定义配置。 而Spring旧版本就是利用抽象类WebMvcConfigurerAdapter解决该问题，但是现在弃用，说明还是default还是比较简洁，推荐使用。","like_count":0},{"had_liked":false,"id":304034,"user_name":"Geek_00e01b","can_delete":false,"product_type":"c1","uid":1597071,"ip_address":"","ucode":"BC76A83B53D0EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLe9iavda8ia7vNkbMVEHsCKs43l6U6HGWibiaxxKd9PuiaYu5wRedicC96PLicZ9VIh0ic5Jg8YHPrta3IAQ/132","comment_is_top":false,"comment_ctime":1627200381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627200381","product_id":100039001,"comment_content":"在前端的业务开发，稍微复杂一些的需求，感觉本质都是状态机","like_count":0},{"had_liked":false,"id":302236,"user_name":"扭高达💨🌪","can_delete":false,"product_type":"c1","uid":1906054,"ip_address":"","ucode":"3737A3DCD58EA3","user_header":"https://static001.geekbang.org/account/avatar/00/1d/15/86/15b942d6.jpg","comment_is_top":false,"comment_ctime":1626143272,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626143272","product_id":100039001,"comment_content":"接口加上default关键词即可","like_count":0},{"had_liked":false,"id":298303,"user_name":"王玉彬","can_delete":false,"product_type":"c1","uid":2346455,"ip_address":"","ucode":"8DA1ADB9B4026C","user_header":"https://static001.geekbang.org/account/avatar/00/23/cd/d7/c932f32a.jpg","comment_is_top":false,"comment_ctime":1624007947,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624007947","product_id":100039001,"comment_content":"可以实现一个状态基类，实现状态接口，并提供默认的事件函数。对于某个状态类不需要支持其中某些事件时，集成这个状态基类，并实现自己需要实现的方法即可。","like_count":0},{"had_liked":false,"id":295443,"user_name":"xaresx","can_delete":false,"product_type":"c1","uid":1270666,"ip_address":"","ucode":"7A16B87D42CB27","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLibEOeFibyr9xHD7yicAxw8OH5PKB1VUkc54xJB7iczHT0hv82X7E9pCBylxRIT733YyHUXLicr0Yvdgw/132","comment_is_top":false,"comment_ctime":1622431814,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622431814","product_id":100039001,"comment_content":"老师，状态较多的情况下采用状态模式，会造成类比较多，还有加一个状态，也会有对应的事件和行为，这个怎么破？我留言区里没看见答案。","like_count":0},{"had_liked":false,"id":293831,"user_name":"jackhance","can_delete":false,"product_type":"c1","uid":1261634,"ip_address":"","ucode":"934B0D20CCD06C","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/42/d5c23178.jpg","comment_is_top":false,"comment_ctime":1621568533,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1621568533","product_id":100039001,"comment_content":"我不太同意游戏优先使用查表法，游戏单元的状态多，且状态变化同时的动作复杂，状态模式显得更易维护","like_count":0},{"had_liked":false,"id":291275,"user_name":"江南一笑","can_delete":false,"product_type":"c1","uid":2234620,"ip_address":"","ucode":"E38938A1178827","user_header":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","comment_is_top":false,"comment_ctime":1620178647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620178647","product_id":100039001,"comment_content":"有些人说在父类中给出默认实现（比如空函数），我觉得这个办法有点差劲。如果子类明明用不到这个函数，却可见这个函数，如果这个空函数被错误调用了呢？有点坑。","like_count":0},{"had_liked":false,"id":282063,"user_name":"当你的世界里有风吹过","can_delete":false,"product_type":"c1","uid":2051946,"ip_address":"","ucode":"42712891366309","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4f/6a/0a6b437e.jpg","comment_is_top":false,"comment_ctime":1615041472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615041472","product_id":100039001,"comment_content":"状态、动作、事件单独成立模块。 仔细分析发现，状态的转移只依赖事件，动作的执行依赖的是状态和事件的组合。所以在把状态和事件的转移单独成立模块，建立表，表的建立支持动态注入的方式，而动作依赖的方式同理独立模块。","like_count":0},{"had_liked":false,"id":280937,"user_name":"释空code","can_delete":false,"product_type":"c1","uid":1171964,"ip_address":"","ucode":"415714AACC5D4F","user_header":"https://static001.geekbang.org/account/avatar/00/11/e1/fc/30156792.jpg","comment_is_top":false,"comment_ctime":1614496824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614496824","product_id":100039001,"comment_content":"课堂讨论<br>接口改成抽象类，每个函数都提供默认实现<br><br>疑问：状态模式是不是对开闭原则不太友好，各种状态类应该属于框架，不属于客户端！如果增加一种状态，除了必要的该状态类的增加之外，其他状态类也需要改动！","like_count":0},{"had_liked":false,"id":275198,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1611385618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611385618","product_id":100039001,"comment_content":"可以构造一个 default 实现类，提供默认的实现，其他状态继承该类","like_count":0},{"had_liked":false,"id":273501,"user_name":"doc技术学习","can_delete":false,"product_type":"c1","uid":2322879,"ip_address":"","ucode":"2DA6E398B6B5A9","user_header":"https://static001.geekbang.org/account/avatar/00/23/71/bf/c324a7de.jpg","comment_is_top":false,"comment_ctime":1610615348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610615348","product_id":100039001,"comment_content":"状态模式和策略模式有本质差异吗？ 感觉策略模式更像是简单版本的策略模式，场景上相对也会更简单。 不知道理解的是否对","like_count":0},{"had_liked":false,"id":269338,"user_name":"kevin","can_delete":false,"product_type":"c1","uid":1008672,"ip_address":"","ucode":"D8B3926E6961D2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLC7J2Pc268VShg82ZYL7nasUYLvjTJwx6tQJPsu03LuWwakNrHiaHqlHeDv0icJYDBhtklfCsUjFfQ/132","comment_is_top":false,"comment_ctime":1608617016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608617016","product_id":100039001,"comment_content":"接口default 实现也是个思路，里面空逻辑即可","like_count":0},{"had_liked":false,"id":265848,"user_name":"狼行天下","can_delete":false,"product_type":"c1","uid":1053161,"ip_address":"","ucode":"A3F22B276B88B1","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/e9/13f28df2.jpg","comment_is_top":false,"comment_ctime":1607051196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607051196","product_id":100039001,"comment_content":"总结：1、状态机可以通过if语句来实现，缺点是改变业务逻辑，修改起来容易出错，代码也不容易看懂；2、通过查表发来实现，可以件简化代码逻辑，缺点是不适合处理状态变化后，比较复杂的业务逻辑；3、通过状态模式来实现，状态转移比较简单，对于事件触发执行的动作包含的业务罗比较复杂的状态机来说，状态模式比较合适；","like_count":0},{"had_liked":false,"id":265349,"user_name":"吃鱼","can_delete":false,"product_type":"c1","uid":2005742,"ip_address":"","ucode":"CB7AC741E0E4B7","user_header":"https://static001.geekbang.org/account/avatar/00/1e/9a/ee/f996f864.jpg","comment_is_top":false,"comment_ctime":1606875325,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606875325","product_id":100039001,"comment_content":"看到争哥说查表法的actiontable只能存储整型时，第一反应的优化措施是在actiontable中存储预先准备好的action接口实现类，这样在actiontable中也能够存储复杂逻辑，而且感觉逻辑更加清晰。","like_count":0},{"had_liked":false,"id":264546,"user_name":"Geek_78eadb","can_delete":false,"product_type":"c1","uid":1712955,"ip_address":"","ucode":"843C6C380D28FA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/OYQh8KlUgMx0sZ35felqqRlboXkcOFib0qGgRHuvFCNIMzxRzxN8SjZpwtDuS0PGV0L0Pneiak7yzcd043f2efbg/132","comment_is_top":false,"comment_ctime":1606518444,"is_pvip":false,"replies":[{"id":"96068","content":"嗯嗯 ������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700573,"ip_address":"","comment_id":264546,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1606518444","product_id":100039001,"comment_content":"课后题：<br>1. 使用抽象工厂模式实现 Action 类：即根据不同的状态实现 ObtainMushRoom 等动作类，比如 ObtainMushRoom 的初始化需要传入目前状态和目前分数， ObtainMushRoom 可以利用状态机的查表法进行状态转移和其它动作<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510593,"discussion_content":"嗯嗯 ������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2006342,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/9d/46/ce8f7a26.jpg","nickname":"I LOVE DM","note":"","ucode":"6EA297D5A0E4C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366597,"discussion_content":"如果事件触发执行的动作包含的业务逻辑不复杂，这种解决方法很优雅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618129193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261268,"user_name":"打工人233号","can_delete":false,"product_type":"c1","uid":2269643,"ip_address":"","ucode":"3B5E4EDA7C9C0E","user_header":"https://static001.geekbang.org/account/avatar/00/22/a1/cb/d8014937.jpg","comment_is_top":false,"comment_ctime":1605254347,"is_pvip":false,"replies":[{"id":"96152","content":"这个好像没有这种情况吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606701516,"ip_address":"","comment_id":261268,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605254347","product_id":100039001,"comment_content":"如果一种状态转移对应多种状态如何处理呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509435,"discussion_content":"这个好像没有这种情况吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606701516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258823,"user_name":"Geek_c0cc9c","can_delete":false,"product_type":"c1","uid":2261235,"ip_address":"","ucode":"FD15ECC029DB65","user_header":"","comment_is_top":false,"comment_ctime":1604563667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604563667","product_id":100039001,"comment_content":"课堂讨论 可以使用职责链模式，做成多个处理器","like_count":0},{"had_liked":false,"id":257164,"user_name":"RedDevil","can_delete":false,"product_type":"c1","uid":1131128,"ip_address":"","ucode":"F8F5DC209BB3B9","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/78/7ba89c75.jpg","comment_is_top":false,"comment_ctime":1603868957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603868957","product_id":100039001,"comment_content":"我觉得IMario接口和几个实现类之间可以增加一层抽象类作为适配器，这样子不同状态只需要处理有对应动作的事件","like_count":0},{"had_liked":false,"id":253953,"user_name":"Gopher","can_delete":false,"product_type":"c1","uid":1206229,"ip_address":"","ucode":"3C1F9012BB486D","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","comment_is_top":false,"comment_ctime":1602989011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602989011","product_id":100039001,"comment_content":"核心在于 上下文 的事件委托，状态转移，和保存当前状态","like_count":0},{"had_liked":false,"id":252870,"user_name":"查理","can_delete":false,"product_type":"c1","uid":1111297,"ip_address":"","ucode":"A9FEA901E3A05D","user_header":"https://static001.geekbang.org/account/avatar/00/10/f5/01/5389295c.jpg","comment_is_top":false,"comment_ctime":1602504675,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602504675","product_id":100039001,"comment_content":"课堂讨论，两种实现方法<br>1.继承法。一个类实现接口，状态类继承这个类，只需要复写需要的方法即可<br>2.组合法。将状态类接口中的动作分别创建成多个接口，实现类需要实现哪个动作，就实现哪个接口","like_count":0},{"had_liked":false,"id":252804,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1602491870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602491870","product_id":100039001,"comment_content":"实际unity客户端开发过程中  查表法几乎没用过，简单就是用enum 解决，更多的是状态机模式，感觉更面向对象一些 容易直观理解，","like_count":0},{"had_liked":false,"id":241591,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1597366621,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597366621","product_id":100039001,"comment_content":"思考题<br>1.把接口拆成单个方法的接口 ，实现类选择性实现 。<br>2.增加抽象类提供默认实现，子类复写用到的方法。","like_count":0},{"had_liked":false,"id":238851,"user_name":"Vastfy","can_delete":false,"product_type":"c1","uid":2090415,"ip_address":"","ucode":"E293A5E23A05BE","user_header":"https://static001.geekbang.org/account/avatar/00/1f/e5/af/6ff950c9.jpg","comment_is_top":false,"comment_ctime":1596342464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596342464","product_id":100039001,"comment_content":"将单个事件也抽象成接口，状态需要哪些事件则继承对应的事件接口即可","like_count":0},{"had_liked":false,"id":237944,"user_name":"慕枫技术笔记","can_delete":false,"product_type":"c1","uid":1244009,"ip_address":"","ucode":"6FD05C90D6D859","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/69/67a0519b.jpg","comment_is_top":false,"comment_ctime":1596011265,"is_pvip":true,"replies":[{"id":"88023","content":"没法做到一点都不修改代码的哦","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1596109727,"ip_address":"","comment_id":237944,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1596011265","product_id":100039001,"comment_content":"查表法在状态新增的情况下怎么做到不修改代码的？","like_count":0,"discussions":[{"author":{"id":1323102,"avatar":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","nickname":"Younger Ku","note":"","ucode":"D157DC38BDB515","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304649,"discussion_content":"如今作为计算机行业的佼佼者，Barbara在谈到自己的经验时，体会最深刻的就是：没有专心致志的精神就不会成功，创造性偶尔会出现，但这不是人所能计划的。专心做一件事，不一定会有创造性的想法，但是这总会让你有所进步，因此，她第一个经验就是，你必须要专心地解决一些问题；但是，同时要谨记不要时时刻刻都想着它，很多有创意的想法都是在比较轻松的时刻出现的。她从来不晚上在家工作，而是喜欢早晨进入工作状态之后再想应该做什么，这个时候往往会有一些好的想法涌现，因此，既要有精力高度集中的时刻，也需要有喘息的机会。她说，有些年轻人整天不停的工作，忽略了朋友，丢掉了爱好，这些都是不可取的，有一个平衡的生活状态是非常重要的，富有幽默感也很重要。有很多人爱抱怨，如果你能微笑着面对许多的不如意，事情往往就会向一个积极的方向发展。最后，还要信任他人。","likes_number":30,"is_delete":false,"is_hidden":false,"ctime":1599635048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1458302,"avatar":"https://static001.geekbang.org/account/avatar/00/16/40/7e/97a8d96d.jpg","nickname":"李小任","note":"","ucode":"BF738A5C1678DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295940,"discussion_content":"one of the first women","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596385546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2096765,"avatar":"","nickname":"Geek_cde7db","note":"","ucode":"D8A7F8EA700009","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1458302,"avatar":"https://static001.geekbang.org/account/avatar/00/16/40/7e/97a8d96d.jpg","nickname":"李小任","note":"","ucode":"BF738A5C1678DE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296466,"discussion_content":"如同 世界上最高的山之一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596549551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":295940,"ip_address":""},"score":296466,"extra":""}]},{"author":{"id":1333094,"avatar":"https://static001.geekbang.org/account/avatar/00/14/57/66/e57bdb18.jpg","nickname":"liliumss","note":"","ucode":"A52AC5042F3115","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115614,"discussion_content":"lisvo原来是女得 豪杰啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578022608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1333094,"avatar":"https://static001.geekbang.org/account/avatar/00/14/57/66/e57bdb18.jpg","nickname":"liliumss","note":"","ucode":"A52AC5042F3115","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115618,"discussion_content":"是呀！不看不知道！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578022774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":115614,"ip_address":""},"score":115618,"extra":""}]},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84466,"discussion_content":"增强已有实现。为这一点点赞👍！不理解为什么老师只说了违背的案例没说遵守的案例。不像数据结构课程的质量啊！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576497953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1027352,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ad/18/41831eae.jpg","nickname":"AaronChun","note":"","ucode":"0D4A4CBD676A3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":92867,"discussion_content":"个人认为增强已有实现应该是面向对象中多态特性的一种实践阐述，毕竟里氏替换是一种设计思想，本质上关注的是“怎么做”的问题，“做的好”应该是实现语言范畴内的一种要求。PS：其实不用过于深究，多态和里氏替换都都可以做到增强已有实现，争哥没提可能有这方面的考虑（都是自己猜猜的^_^）","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576890811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":84466,"ip_address":""},"score":92867,"extra":""},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1027352,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ad/18/41831eae.jpg","nickname":"AaronChun","note":"","ucode":"0D4A4CBD676A3D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93193,"discussion_content":"为你点赞👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576913119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":92867,"ip_address":""},"score":93193,"extra":""}]},{"author":{"id":1443663,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIang00R9vkklnkFCLhzRysNfocr0sLnCdoZwOT3UkulAPefk5BDvd0PfIeQSODSQg1DjKWUmJOaA/132","nickname":"陈迎春","note":"","ucode":"2870BA6D6E5B1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80106,"discussion_content":"赞一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576147191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79302,"discussion_content":"棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576072764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048799,"avatar":"https://static001.geekbang.org/account/avatar/00/10/00/df/58fe37df.jpg","nickname":"左","note":"","ucode":"FE02803AE2C0F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79132,"discussion_content":"你是最棒的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576060145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1048799,"avatar":"https://static001.geekbang.org/account/avatar/00/10/00/df/58fe37df.jpg","nickname":"左","note":"","ucode":"FE02803AE2C0F0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79185,"discussion_content":"我也这么觉着😀","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576066501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":79132,"ip_address":""},"score":79185,"extra":""}]},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78925,"discussion_content":"棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576033234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233703,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1594395458,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1594395458","product_id":100039001,"comment_content":"imaro接口违反接口隔离原则（不应强迫依赖不需要的接口）。按照接口隔离原则，以及实际情况来看，马里奥会有更多事件，所以还是应该把事件单独抽象成独立的事件接口，根据需要实现相应的接口即可。如果换个场景，事件类型不会再增多，其实可以搞个抽象类，实现imaro接口提供默认实现也行。但是还是推荐第一种","like_count":0},{"had_liked":false,"id":228443,"user_name":"攻城拔寨","can_delete":false,"product_type":"c1","uid":1053934,"ip_address":"","ucode":"CBC37183DAB6B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/ee/d72a8222.jpg","comment_is_top":false,"comment_ctime":1592678871,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592678871","product_id":100039001,"comment_content":"事件一多，状态类就会膨胀，怎么解决","like_count":0},{"had_liked":false,"id":228367,"user_name":"吃饭睡觉打酱油","can_delete":false,"product_type":"c1","uid":1071668,"ip_address":"","ucode":"95EC98C2B5045B","user_header":"https://static001.geekbang.org/account/avatar/00/10/5a/34/4cbadca6.jpg","comment_is_top":false,"comment_ctime":1592649038,"is_pvip":false,"replies":[{"id":"85672","content":"嗯嗯 ","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1593910513,"ip_address":"","comment_id":228367,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592649038","product_id":100039001,"comment_content":"老师，在使用状态机的时候，初始状态应该是可以支持初始化的吧。","like_count":0,"discussions":[{"author":{"id":1440025,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f9/19/7c3b12ee.jpg","nickname":"Geek_deb968","note":"","ucode":"2305597B009AF3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289126,"discussion_content":"传统这个词用的好ヾ ^_^♪","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1593999235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":227242,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1592322043,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592322043","product_id":100039001,"comment_content":"OC中，协议（protocol）相当于Java里的interface了，但是protocol中可以给方法设置@optional，表示该方法可选，就能避免所有实现类中一定要实现这个方法的问题；<br>如果要给默认实现，就还是一样的，需要定义一个基类默认实现protocol中的一些方法","like_count":0},{"had_liked":false,"id":226015,"user_name":"阿    鲍","can_delete":false,"product_type":"c1","uid":1189884,"ip_address":"","ucode":"7418826B7986E1","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/fc/2169bf4a.jpg","comment_is_top":false,"comment_ctime":1591928798,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591928798","product_id":100039001,"comment_content":"课堂讨论：可以用增加抽象类来实现，也可以通过写一个带默认实现的接口方法来实现","like_count":0},{"had_liked":false,"id":216076,"user_name":"小人物大希望","can_delete":false,"product_type":"c1","uid":1945605,"ip_address":"","ucode":"8EF313AA26D4B8","user_header":"https://static001.geekbang.org/account/avatar/00/1d/b0/05/c9da834e.jpg","comment_is_top":false,"comment_ctime":1589183381,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589183381","product_id":100039001,"comment_content":"用Go语言实现了一份马里奥状态机，欢迎拍砖<br>https:&#47;&#47;github.com&#47;1k2222&#47;geek_time&#47;tree&#47;master&#47;beauty_of_design_pattern&#47;064_state_machine&#47;mario_state_machine","like_count":0},{"had_liked":false,"id":214884,"user_name":"唯有学习不止","can_delete":false,"product_type":"c1","uid":1721251,"ip_address":"","ucode":"52DA78BBEC4D38","user_header":"https://static001.geekbang.org/account/avatar/00/1a/43/a3/53f7f1fe.jpg","comment_is_top":false,"comment_ctime":1588841713,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588841713","product_id":100039001,"comment_content":"课后讨论除了加个抽象类之外，还可接口中加上default关键字，实现默认方法内容。实现就可以按需是否实现了","like_count":0},{"had_liked":false,"id":212901,"user_name":"silence_wh","can_delete":false,"product_type":"c1","uid":1016299,"ip_address":"","ucode":"95FB5D6C02EC89","user_header":"https://static001.geekbang.org/account/avatar/00/0f/81/eb/04c16c3e.jpg","comment_is_top":false,"comment_ctime":1588235784,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588235784","product_id":100039001,"comment_content":"Redux 中 Model 的定义与用法，觉得类似状态机。","like_count":0},{"had_liked":false,"id":209731,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1587605889,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587605889","product_id":100039001,"comment_content":"可以做成适配器模式，用一个Adaptor类实现所有的接口及方法（空实现）。然后可以继承并重写某一个方法即可。当然了，这种做法也有缺点，就是用了继承关系。不过接口比较多的时候，还是挺有优势的。","like_count":0},{"had_liked":false,"id":206309,"user_name":"空空","can_delete":false,"product_type":"c1","uid":1444122,"ip_address":"","ucode":"8F6EFE5A6F6F64","user_header":"https://static001.geekbang.org/account/avatar/00/16/09/1a/e0f95684.jpg","comment_is_top":false,"comment_ctime":1586837973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586837973","product_id":100039001,"comment_content":"关于状态机的几点思考：<br>1. 分支判断的做法，即使是简单场景，考虑到以后的扩展性也是不建议采用的；<br>2.关于查表法，老师提到如果action业务过于复杂，就不推荐，这里我有一点思路，可以将action 定义为函数式接口，通过Function 传递来具体实现，这样就不从在action过于复杂的问题；<br>3. 个人理解，状态模式更适合状态和事件不多，且业务相对复杂的场景。","like_count":0},{"had_liked":false,"id":205777,"user_name":"pippin","can_delete":false,"product_type":"c1","uid":1784022,"ip_address":"","ucode":"F7619FCE24D481","user_header":"","comment_is_top":false,"comment_ctime":1586738438,"is_pvip":false,"replies":[{"id":"86796","content":"没有啊，你看看上面那个表格","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594904767,"ip_address":"","comment_id":205777,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1586738438","product_id":100039001,"comment_content":"查表法的这个数组有问题吧，transitionTable[0][0]应该是SMALL吧。这里应该是写错了吧。private static final State[][] transitionTable = {<br>          {SUPER, CAPE, FIRE, SMALL},<br>          {SUPER, CAPE, FIRE, SMALL},<br>          {CAPE, CAPE, CAPE, SMALL},<br>          {FIRE, FIRE, FIRE, SMALL}<br>  };","like_count":0,"discussions":[{"author":{"id":1608383,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8a/bf/3f7c45c9.jpg","nickname":"X_L～","note":"","ucode":"6BD8C24750F86B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302855,"discussion_content":"对于老祖宗定下的规矩,只能修订,不能修改","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599048418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049576,"avatar":"https://static001.geekbang.org/account/avatar/00/10/03/e8/4c943503.jpg","nickname":"乐","note":"","ucode":"4505CB6BD9C144","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86994,"discussion_content":"避免二意性，说的很到位","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576636481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1095997,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b9/3d/e061a652.jpg","nickname":"Geek_109a0b","note":"","ucode":"93A45B581947FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287095,"discussion_content":"简单点说就是继承了父类，最好只做代码添加，不做逻辑改动","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593359650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91801,"discussion_content":"兄弟你提到的：“而应该抽出一个排序方法，然后再写一个获取排序的方法，父类获取排序调用金额排序，子类就重写调用排序方法，获取日期排序。” 可以解释得再具体一些嘛？如果父类实现了sort方法，那么子类也要重写sort方法吗？还是说不重写sort方法，而新写一个sortByDate方法？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576848041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258380,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/8c/23eef8d7.jpg","nickname":"feifei","note":"","ucode":"BFA3BE8D8773A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87512,"discussion_content":"你这说得好像跟文章里说的相反吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576671375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1258380,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/8c/23eef8d7.jpg","nickname":"feifei","note":"","ucode":"BFA3BE8D8773A7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87543,"discussion_content":"哪里相反了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576672423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":87512,"ip_address":""},"score":87543,"extra":""}]},{"author":{"id":1298279,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cf/67/057e5d93.jpg","nickname":"flying","note":"","ucode":"69AB7872B36B23","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80242,"discussion_content":"说的好，子类要是不能比父类功能多，感觉除了提高性能外，感觉就没啥用了。关键还是要扩展其他接口，提供更多的功能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576156567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205311,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1586590089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586590089","product_id":100039001,"comment_content":"一、定义（理解）：<br> 有限状态机，英文翻译是 Finite State Machine，缩写为 FSM，简称为状态机。状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。<br><br>二、使用场景：<br>对场景进行抽象之后，需要解决的问题就是处理状态转移。 <br><br>三、实现方式：<br>首先定义事件、状态以及状态转移之后的动作。<br>1、分支逻辑法<br>获得某个事件之后，使用if-else进行判断状态进行转移<br>2、查表法<br>第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到的新状态及其执行的动作<br>3、状态模式<br>定义一个状态接口或是抽象类，每一个状态对应一个实现类，这逻辑和处理被分散到了每个实现类中了。<br><br>四、分支逻辑法、查表法和状态模式的对比<br>分支逻辑法：if-else,switch-case对于简单的状态转移，这种实现最简单最直接。<br>查表法：对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。<br>状态模式：对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。<br>","like_count":0},{"had_liked":false,"id":202242,"user_name":"Hubbert伟涛","can_delete":false,"product_type":"c1","uid":1303556,"ip_address":"","ucode":"000C6A0BD4A102","user_header":"https://static001.geekbang.org/account/avatar/00/13/e4/04/05677b68.jpg","comment_is_top":false,"comment_ctime":1585931232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585931232","product_id":100039001,"comment_content":"不懂就要问，评论中对第二题课后题“所有的状态类都要做相应的修改”使用了模板方法的，想不出要怎么实现。使用抽象类继承，然后默认都抛出一个方法未实现的异常即可，简单易懂。但是使用模板方法这个我想不出要怎么实现。请指教","like_count":0},{"had_liked":false,"id":201007,"user_name":"Jesse","can_delete":false,"product_type":"c1","uid":1368038,"ip_address":"","ucode":"727CA882B84DA0","user_header":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","comment_is_top":false,"comment_ctime":1585705161,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585705161","product_id":100039001,"comment_content":"方法一：可以使用将事件拆分成不同接口，不同的状态实现不同事件。<br>方法二：用java1.8 接口提供的default实现。","like_count":0},{"had_liked":false,"id":200969,"user_name":"Bern","can_delete":false,"product_type":"c1","uid":1765806,"ip_address":"","ucode":"5A979552D5800D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLlxr0eX6ZPlpiaUkH8SXoNibmOK9MJz2ZDYq5y57UfFHBu6dDc5VxKic1rAPiawLBVdSMl8y1Mwtp9Yg/132","comment_is_top":false,"comment_ctime":1585700263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585700263","product_id":100039001,"comment_content":"添加一个默认抽象实现，空实现，所有状态类继承默认抽象实现。","like_count":0},{"had_liked":false,"id":200923,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1585675975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585675975","product_id":100039001,"comment_content":"查表法好用","like_count":0},{"had_liked":false,"id":200782,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1585650229,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585650229","product_id":100039001,"comment_content":"1.接口增加默认设置，方法体中抛出 UnsupportOperateException<br>2.增加一个抽象类<br>------<br>涉及到多个状态转换的场景，状态机真的是可以提高代码的可读程度，也能保证状态的正常流转。","like_count":0,"discussions":[{"author":{"id":1313115,"avatar":"https://static001.geekbang.org/account/avatar/00/14/09/5b/e9ee3b41.jpg","nickname":"音为","note":"","ucode":"D78E4CBCE6BF45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587080,"discussion_content":"里氏替换原则还可以指导版本的向后兼容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662767598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1637228,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fb/6c/12fdc372.jpg","nickname":"迈向架构师","note":"","ucode":"2476594CF76001","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":135576,"discussion_content":"诶？ 里式替换还能用来指导版本升级的吗？  我以为是用来约束同个版本的不同子类的行为","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579097020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1637228,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fb/6c/12fdc372.jpg","nickname":"迈向架构师","note":"","ucode":"2476594CF76001","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":136313,"discussion_content":"版本和原则两码事。spring里面xxxapplication这种一般都是模板模式。2.x引入注解驱动，该驱动实现其操作和父类保持一致，所以1.x只要加上注解改用注解驱动，其他不用动。springboot1.0-1.4部分注解（注解的伴生关系算得上是一种伪继承实现），内部有比较大变化，比如xxxoncondition，升级版本（功能迭代），会导致api调用方异常。\n例子不好，大概这个意思。看的是代码变动后的影响，而不是版本。里式替换指的子父类的这种关系，但其实往宽的看就是针对代码变动后，对所有api调用方的影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579137393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":135576,"ip_address":""},"score":136313,"extra":""}]}]},{"had_liked":false,"id":200756,"user_name":"Geek_27a248","can_delete":false,"product_type":"c1","uid":1542778,"ip_address":"","ucode":"6AC3AC42E6EEC9","user_header":"https://static001.geekbang.org/account/avatar/00/17/8a/7a/54003392.jpg","comment_is_top":false,"comment_ctime":1585646880,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585646880","product_id":100039001,"comment_content":"在需要使用的实现类上面在封装一层，最少接口原则，抽象一个只有自己需要的接口","like_count":0},{"had_liked":false,"id":200440,"user_name":"前端西瓜哥","can_delete":false,"product_type":"c1","uid":1248576,"ip_address":"","ucode":"150130C34CD1C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/40/f70e5653.jpg","comment_is_top":false,"comment_ctime":1585583984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585583984","product_id":100039001,"comment_content":"可以把接口改成抽象类，然后抽象类添加事件方法的默认实现（通常是 do nothing）。状态类根据需要选择性对事件方法重写。","like_count":0},{"had_liked":false,"id":200382,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1585578959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585578959","product_id":100039001,"comment_content":"对于这个问题,可以使用模板模式那一节的课后解决思路的,进行默认实现,在不应该调用的地方调用了,会直接抛出异常,或者将其进行拆分为多个接口,针对性的实现,但是对于存储的格式,就是另一个问题了","like_count":0},{"had_liked":false,"id":200346,"user_name":"一壶浊酒","can_delete":false,"product_type":"c1","uid":1145530,"ip_address":"","ucode":"5D90F8F8121BBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/ba/8545f2d7.jpg","comment_is_top":false,"comment_ctime":1585575157,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585575157","product_id":100039001,"comment_content":"可以在状态接口上使用java 8 中的default 关键字","like_count":0},{"had_liked":false,"id":200336,"user_name":"我的黄金时代","can_delete":false,"product_type":"c1","uid":1062070,"ip_address":"","ucode":"D7825B45B372F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/34/b6/0feb574b.jpg","comment_is_top":false,"comment_ctime":1585573503,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585573503","product_id":100039001,"comment_content":"课堂讨论：<br>1、最简单的是在接口中定义默认实现，也就是default；<br>2、在计算机的世界，任何一个问题都可以通过增加一个虚拟层来解决：加个中间层（抽象类）。","like_count":0},{"had_liked":false,"id":200121,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1585546517,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585546517","product_id":100039001,"comment_content":"今天的状态机讲得挺不错的，晚上回去有时间将代码重新自己实现一下。<br>课后习题，个人也偏向，实现一个抽象顶层类，然后让各种的子类自己实现。或者多个操作定义成不同的接口，让不同的子类选择不同的接口去实现自己的标准。","like_count":0},{"had_liked":false,"id":200115,"user_name":"乐天","can_delete":false,"product_type":"c1","uid":1519344,"ip_address":"","ucode":"1DC138F7BD536E","user_header":"https://static001.geekbang.org/account/avatar/00/17/2e/f0/0bbb0df5.jpg","comment_is_top":false,"comment_ctime":1585545780,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1585545780","product_id":100039001,"comment_content":"实现一个抽象类，增加一些默认方法，各个状态类继承抽象类，只需实现与默认不同的方法！","like_count":0},{"had_liked":false,"id":200065,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1585539302,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585539302","product_id":100039001,"comment_content":"课堂讨论: <br>使用接口适配器模式. <br>Adapter提供接口的默认实现或空实现&#47;throw runtime exception<br><br>public class IMarioStateAdapter implements IMarioState {<br>    private static final String TAG = &quot;IMarioStateAdapter&quot;;<br><br>    @Override<br>    public void obtainMushroom(MarioStateMachine stateMachine) {<br>        throw new IllegalStateException(&quot;&quot;);<br>    }<br><br>    @Override<br>    public void obtainCape(MarioStateMachine stateMachine) {<br>        throw new IllegalStateException(&quot;&quot;);<br>    }<br><br>    @Override<br>    public void obtainFireFlower(MarioStateMachine stateMachine) {<br>        throw new IllegalStateException(&quot;&quot;);<br>    }<br><br>    @Override<br>    public void meetMonster(MarioStateMachine stateMachine) {<br>        throw new IllegalStateException(&quot;&quot;);<br>    }<br>}<br><br>&#47;&#47;具体状态继承自接口适配器<br>public class SuperMarioState extends IMarioStateAdapter {}<br>","like_count":0},{"had_liked":false,"id":200019,"user_name":"Jackey","can_delete":false,"product_type":"c1","uid":1063751,"ip_address":"","ucode":"125DE81993FEDD","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg","comment_is_top":false,"comment_ctime":1585533371,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585533371","product_id":100039001,"comment_content":"可以再抽象出来一层抽象类，canTransToSmall、canTransToFire这样，在这一层提供一些默认实现，子类只需要实现必须重写的方法即可","like_count":0}]}