{"id":41588,"title":"27 | 条件变量sync.Cond （上）","content":"<p>在上篇文章中，我们主要说的是互斥锁，今天我和你来聊一聊条件变量（conditional variable）。</p><h2>前导内容：条件变量与互斥锁</h2><p>我们常常会把条件变量这个同步工具拿来与互斥锁一起讨论。实际上，条件变量是基于互斥锁的，它必须有互斥锁的支撑才能发挥作用。</p><p>条件变量并不是被用来保护临界区和共享资源的，它是用于协调想要访问共享资源的那些线程的。当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程。</p><p>比如说，我们两个人在共同执行一项秘密任务，这需要在不直接联系和见面的前提下进行。我需要向一个信箱里放置情报，你需要从这个信箱中获取情报。这个信箱就相当于一个共享资源，而我们就分别是进行写操作的线程和进行读操作的线程。</p><p>如果我在放置的时候发现信箱里还有未被取走的情报，那就不再放置，而先返回。另一方面，如果你在获取的时候发现信箱里没有情报，那也只能先回去了。这就相当于写的线程或读的线程阻塞的情况。</p><p>虽然我们俩都有信箱的钥匙，但是同一时刻只能有一个人插入钥匙并打开信箱，这就是锁的作用了。更何况咱们俩是不能直接见面的，所以这个信箱本身就可以被视为一个临界区。</p><p>尽管没有协调好，咱们俩仍然要想方设法的完成任务啊。所以，如果信箱里有情报，而你却迟迟未取走，那我就需要每过一段时间带着新情报去检查一次，若发现信箱空了，我就需要及时地把新情报放到里面。</p><!-- [[[read_end]]] --><p>另一方面，如果信箱里一直没有情报，那你也要每过一段时间去打开看看，一旦有了情报就及时地取走。这么做是可以的，但就是太危险了，很容易被敌人发现。</p><p>后来，我们又想了一个计策，各自雇佣了一个不起眼的小孩儿。如果早上七点有一个戴红色帽子的小孩儿从你家楼下路过，那么就意味着信箱里有了新情报。另一边，如果上午九点有一个戴蓝色帽子的小孩儿从我家楼下路过，那就说明你已经从信箱中取走了情报。</p><p>这样一来，咱们执行任务的隐蔽性高多了，并且效率的提升非常显著。这两个戴不同颜色帽子的小孩儿就相当于条件变量，在共享资源的状态产生变化的时候，起到了通知的作用。</p><p>当然了，我们是在用Go语言编写程序，而不是在执行什么秘密任务。因此，条件变量在这里的最大优势就是在效率方面的提升。当共享资源的状态不满足条件的时候，想操作它的线程再也不用循环往复地做检查了，只要等待通知就好了。</p><p>说到这里，想考考你知道怎么使用条件变量吗？所以，<strong>我们今天的问题就是：条件变量怎样与互斥锁配合使用？</strong></p><p><strong>这道题的典型回答是：条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的。</strong></p><p>条件变量提供的方法有三个：等待通知（wait）、单发通知（signal）和广播通知（broadcast）。</p><p>我们在利用条件变量等待通知的时候，需要在它基于的那个互斥锁保护下进行。而在进行单发通知或广播通知的时候，却是恰恰相反的，也就是说，需要在对应的互斥锁解锁之后再做这两种操作。</p><h2>问题解析</h2><p>这个问题看起来很简单，但其实可以基于它,延伸出很多其他的问题。比如，每个方法的使用时机是什么？又比如，每个方法执行的内部流程是怎样的？</p><p>下面，我们一边用代码实现前面那个例子，一边讨论条件变量的使用。</p><p>首先，我们先来创建如下几个变量。</p><pre><code>var mailbox uint8\nvar lock sync.RWMutex\nsendCond := sync.NewCond(&amp;lock)\nrecvCond := sync.NewCond(lock.RLocker())\n</code></pre><p><strong>变量<code>mailbox</code>代表信箱，是<code>uint8</code>类型的。</strong> 若它的值为<code>0</code>则表示信箱中没有情报，而当它的值为<code>1</code>时则说明信箱中有情报。<code>lock</code>是一个类型为<code>sync.RWMutex</code>的变量，是一个读写锁，也可以被视为信箱上的那把锁。</p><p>另外，基于这把锁，我还创建了两个代表条件变量的变量，<strong>名字分别叫<code>sendCond</code>和<code>recvCond</code>。</strong> 它们都是<code>*sync.Cond</code>类型的，同时也都是由<code>sync.NewCond</code>函数来初始化的。</p><p>与<code>sync.Mutex</code>类型和<code>sync.RWMutex</code>类型不同，<code>sync.Cond</code>类型并不是开箱即用的。我们只能利用<code>sync.NewCond</code>函数创建它的指针值。这个函数需要一个<code>sync.Locker</code>类型的参数值。</p><p>还记得吗？我在前面说过，条件变量是基于互斥锁的，它必须有互斥锁的支撑才能够起作用。因此，这里的参数值是不可或缺的，它会参与到条件变量的方法实现当中。</p><p><code>sync.Locker</code>其实是一个接口，在它的声明中只包含了两个方法定义，即：<code>Lock()</code>和<code>Unlock()</code>。<code>sync.Mutex</code>类型和<code>sync.RWMutex</code>类型都拥有<code>Lock</code>方法和<code>Unlock</code>方法，只不过它们都是指针方法。因此，这两个类型的指针类型才是<code>sync.Locker</code>接口的实现类型。</p><p>我在为<code>sendCond</code>变量做初始化的时候，把基于<code>lock</code>变量的指针值传给了<code>sync.NewCond</code>函数。</p><p>原因是，<strong><code>lock</code>变量的<code>Lock</code>方法和<code>Unlock</code>方法分别用于对其中写锁的锁定和解锁，它们与<code>sendCond</code>变量的含义是对应的。</strong><code>sendCond</code>是专门为放置情报而准备的条件变量，向信箱里放置情报，可以被视为对共享资源的写操作。</p><p>相应的，<strong><code>recvCond</code>变量代表的是专门为获取情报而准备的条件变量。</strong> 虽然获取情报也会涉及对信箱状态的改变，但是好在做这件事的人只会有你一个，而且我们也需要借此了解一下，条件变量与读写锁中的读锁的联用方式。所以，在这里，我们暂且把获取情报看做是对共享资源的读操作。</p><p>因此，为了初始化<code>recvCond</code>这个条件变量，我们需要的是<code>lock</code>变量中的读锁，并且还需要是<code>sync.Locker</code>类型的。</p><p>可是，<code>lock</code>变量中用于对读锁进行锁定和解锁的方法却是<code>RLock</code>和<code>RUnlock</code>，它们与<code>sync.Locker</code>接口中定义的方法并不匹配。</p><p>好在<code>sync.RWMutex</code>类型的<code>RLocker</code>方法可以实现这一需求。我们只要在调用<code>sync.NewCond</code>函数时，传入调用表达式<code>lock.RLocker()</code>的结果值，就可以使该函数返回符合要求的条件变量了。</p><p>为什么说通过<code>lock.RLocker()</code>得来的值就是<code>lock</code>变量中的读锁呢？实际上，这个值所拥有的<code>Lock</code>方法和<code>Unlock</code>方法，在其内部会分别调用<code>lock</code>变量的<code>RLock</code>方法和<code>RUnlock</code>方法。也就是说，前两个方法仅仅是后两个方法的代理而已。</p><p>好了，我们现在有四个变量。一个是代表信箱的<code>mailbox</code>，一个是代表信箱上的锁的<code>lock</code>。还有两个是，代表了蓝帽子小孩儿的<code>sendCond</code>，以及代表了红帽子小孩儿的<code>recvCond</code>。</p><p><img src=\"https://static001.geekbang.org/resource/image/36/5d/3619456ade9d45a4d9c0fbd22bb6fd5d.png?wh=1627*829\" alt=\"\"></p><p>（互斥锁与条件变量）</p><p>我，现在是一个goroutine（携带的<code>go</code>函数），想要适时地向信箱里放置情报并通知你，应该怎么做呢？</p><pre><code>lock.Lock()\nfor mailbox == 1 {\n sendCond.Wait()\n}\nmailbox = 1\nlock.Unlock()\nrecvCond.Signal()\n</code></pre><p>我肯定需要先调用<code>lock</code>变量的<code>Lock</code>方法。注意，这个<code>Lock</code>方法在这里意味的是：持有信箱上的锁，并且有打开信箱的权利，而不是锁上这个锁。</p><p>然后，我要检查<code>mailbox</code>变量的值是否等于<code>1</code>，也就是说，要看看信箱里是不是还存有情报。如果还有情报，那么我就回家去等蓝帽子小孩儿了。</p><p>这就是那条<code>for</code>语句以及其中的调用表达式<code>sendCond.Wait()</code>所表示的含义了。你可能会问，为什么这里是<code>for</code>语句而不是<code>if</code>语句呢？我在后面会对此进行解释的。</p><p>我们再往后看，如果信箱里没有情报，那么我就把新情报放进去，关上信箱、锁上锁，然后离开。用代码表达出来就是<code>mailbox = 1</code>和<code>lock.Unlock()</code>。</p><p>离开之后我还要做一件事，那就是让红帽子小孩儿准时去你家楼下路过。也就是说，我会及时地通知你“信箱里已经有新情报了”，我们调用<code>recvCond</code>的<code>Signal</code>方法就可以实现这一步骤。</p><p>另一方面，你现在是另一个goroutine，想要适时地从信箱中获取情报，然后通知我。</p><pre><code>lock.RLock()\nfor mailbox == 0 {\n recvCond.Wait()\n}\nmailbox = 0\nlock.RUnlock()\nsendCond.Signal()\n</code></pre><p>你跟我做的事情在流程上其实基本一致，只不过每一步操作的对象是不同的。你需要调用的是<code>lock</code>变量的<code>RLock</code>方法。因为你要进行的是读操作，并且会使用<code>recvCond</code>变量作为辅助。<code>recvCond</code>与<code>lock</code>变量的读锁是对应的。</p><p>在打开信箱后，你要关注的是信箱里是不是没有情报，也就是检查<code>mailbox</code>变量的值是否等于<code>0</code>。如果它确实等于<code>0</code>，那么你就需要回家去等红帽子小孩儿，也就是调用<code>recvCond</code>的<code>Wait</code>方法。这里使用的依然是<code>for</code>语句。</p><p>如果信箱里有情报，那么你就应该取走情报，关上信箱、锁上锁，然后离开。对应的代码是<code>mailbox = 0</code>和<code>lock.RUnlock()</code>。之后，你还需要让蓝帽子小孩儿准时去我家楼下路过。这样我就知道信箱中的情报已经被你获取了。</p><p>以上这些，就是对咱们俩要执行秘密任务的代码实现。其中的条件变量的用法需要你特别注意。</p><p>再强调一下，只要条件不满足，我就会通过调用<code>sendCond</code>变量的<code>Wait</code>方法，去等待你的通知，只有在收到通知之后我才会再次检查信箱。</p><p>另外，当我需要通知你的时候，我会调用<code>recvCond</code>变量的<code>Signal</code>方法。你使用这两个条件变量的方式正好与我相反。你可能也看出来了，利用条件变量可以实现单向的通知，而双向的通知则需要两个条件变量。这也是条件变量的基本使用规则。</p><p>你可以打开demo61.go文件，看到上述例子的全部实现代码。</p><h2>总结</h2><p>我们这两期的文章会围绕条件变量的内容展开，条件变量是基于互斥锁的一种同步工具，它必须有互斥锁的支撑才能发挥作用。  条件变量可以协调那些想要访问共享资源的线程。当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程。我在文章举了一个两人访问信箱的例子，并用代码实现了这个过程。</p><h2>思考题</h2><p><code>*sync.Cond</code>类型的值可以被传递吗？那<code>sync.Cond</code>类型的值呢？</p><p>感谢你的收听，我们下期再见。</p><p><a href=\"https://github.com/hyper0x/Golang_Puzzlers\">戳此查看Go语言专栏文章配套详细代码。</a></p><p></p>","neighbors":{"left":{"article_title":"26 | sync.Mutex与sync.RWMutex","id":41350},"right":{"article_title":"28 | 条件变量sync.Cond （下）","id":41717}},"comments":[{"had_liked":false,"id":35370,"user_name":"hello peter","can_delete":false,"product_type":"c1","uid":1201338,"ip_address":"","ucode":"4839DC4442CB0E","user_header":"https://static001.geekbang.org/account/avatar/00/12/54/ba/8721e403.jpg","comment_is_top":false,"comment_ctime":1540526510,"is_pvip":false,"replies":[{"id":"13311","content":"优势是并发流程上的协同，chan的主要任务是传递数据。另外cond是更低层次的工具，效率更高一些，但是肯定没有chan方便。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1541482062,"ip_address":"","comment_id":35370,"utype":1}],"discussion_count":2,"race_medal":0,"score":"143274447278","product_id":100013101,"comment_content":"老师, 感觉这个送信的例子似乎用chanel实现更简单.在网上也查了一些例子, 发现都可以用chanel替代. 那使用sync.Cond 的优势是什么呢, 或者有哪些独特的使用场景?","like_count":34,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427523,"discussion_content":"优势是并发流程上的协同，chan的主要任务是传递数据。另外cond是更低层次的工具，效率更高一些，但是肯定没有chan方便。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1541482062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1557834,"avatar":"https://static001.geekbang.org/account/avatar/00/17/c5/4a/340bda41.jpg","nickname":"水阡墨","note":"","ucode":"87C949F0E295A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343003,"discussion_content":"这个问题问的好，涨姿势了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610897594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31987,"user_name":"属雨","can_delete":false,"product_type":"c1","uid":1202624,"ip_address":"","ucode":"700236847A5C94","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/c0/6f02c096.jpg","comment_is_top":false,"comment_ctime":1539350133,"is_pvip":false,"replies":[{"id":"11828","content":"基本正确。Locker是接口，是引用类型，nocopy是结构体，所以直接拷贝值的话，底层锁还是用的同一个，使用上容易出问题。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1539578589,"ip_address":"","comment_id":31987,"utype":1}],"discussion_count":1,"race_medal":0,"score":"126093401717","product_id":100013101,"comment_content":"个人理解，不确定对不对，请老师评判一下：<br>因为Go语言传递对象时，使用的是浅拷贝的值传递，所以，当传递一个Cond对象时复制了这个Cond对象，但是低层保存的L(Locker类型)，noCopy(noCopy类型)，notify(notifyList类型)，checker(copyChecker)对象的指针没变，因此，*sync.Cond和sync.Cond都可以传递。","like_count":30,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426596,"discussion_content":"基本正确。Locker是接口，是引用类型，nocopy是结构体，所以直接拷贝值的话，底层锁还是用的同一个，使用上容易出问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539578589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204578,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1586423919,"is_pvip":false,"replies":[{"id":"76910","content":"👍","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1586745777,"ip_address":"","comment_id":204578,"utype":1}],"discussion_count":1,"race_medal":0,"score":"66010933359","product_id":100013101,"comment_content":"这几天一直对条件变量的理解比较模糊，但是我想既然要学就学好 于是又去翻了Unix环境高级编程 总算把它跟互斥锁区分开了<br>互斥锁 是对一个共享区域进行加锁 所有线程都是一种竞争的状态去访问<br>而条件变量 主要是通过条件状态来判断，实际上他还是会阻塞 只不过不会像互斥锁一样去参与竞争，而是在哪里等待条件变量的状态发生改变过后的通知 再被唤醒","like_count":15,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491220,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586745777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123095,"user_name":"Geek_a8be59","can_delete":false,"product_type":"c1","uid":1563985,"ip_address":"","ucode":"BEC0F57B51DC44","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdiaUiaCYQe9tibemaNU5ya7RrU3MYcSGEIG7zF27u0ZDnZs5lYxPb7KPrAsj3bibM79QIOnPXAatfIw/132","comment_is_top":false,"comment_ctime":1565604248,"is_pvip":false,"replies":[{"id":"45481","content":"如果都用同一个互斥量的话，操作双方就无法独立行事，这就是完全串行的操作了，效率上会大打折扣。<br><br>进一步说，本来就是一个发一个收，理应一个用写锁一个用读锁，这样效率高，之后扩展起来也方便。因为读之间不用互斥。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1565795418,"ip_address":"","comment_id":123095,"utype":1}],"discussion_count":3,"race_medal":0,"score":"57400179096","product_id":100013101,"comment_content":"var mailbox uint8<br>var lock sync.RWMutex<br>sendCond := sync.NewCond(&amp;lock)<br>recvCond := sync.NewCond(&amp;lock)<br>为什么不能向上面那样都用同一个互斥量，非要两个不同呢？老师，能讲一下区别么<br>","like_count":13,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462537,"discussion_content":"如果都用同一个互斥量的话，操作双方就无法独立行事，这就是完全串行的操作了，效率上会大打折扣。\n\n进一步说，本来就是一个发一个收，理应一个用写锁一个用读锁，这样效率高，之后扩展起来也方便。因为读之间不用互斥。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565795418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2275396,"avatar":"","nickname":"13549804879","note":"","ucode":"303DFF7082E504","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326149,"discussion_content":"老师，多个读之间也能并行吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605532743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1954540,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/d2/ec/27de7020.jpg","nickname":"zzz","note":"","ucode":"DF8939F2D953BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2275396,"avatar":"","nickname":"13549804879","note":"","ucode":"303DFF7082E504","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354415,"discussion_content":"可以的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615290280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":326149,"ip_address":""},"score":354415,"extra":""}]}]},{"had_liked":false,"id":160353,"user_name":"疯琴","can_delete":false,"product_type":"c1","uid":1099379,"ip_address":"","ucode":"82ACAA4A27753D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/73/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1575940234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31640711306","product_id":100013101,"comment_content":"秘密接头的类比形象生动，学习过程轻松有趣又不失深度。","like_count":7},{"had_liked":false,"id":31815,"user_name":"文@雨路","can_delete":false,"product_type":"c1","uid":1103072,"ip_address":"","ucode":"1EE59E03F9939C","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/e0/513d185e.jpg","comment_is_top":false,"comment_ctime":1539306626,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27309110402","product_id":100013101,"comment_content":"指针可以传递，值不可以，传递值会拷贝一份，导致出现两份条件变量，彼此之间没有联系","like_count":6},{"had_liked":false,"id":84283,"user_name":"🐻","can_delete":false,"product_type":"c1","uid":1043072,"ip_address":"","ucode":"534EDAD496A0E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/80/8759e4c1.jpg","comment_is_top":false,"comment_ctime":1554819295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23029655775","product_id":100013101,"comment_content":"需传递 *sync.Cond<br><br>因为 Cond 结构体中的 notify 变量和 checker 变量都是值类型，传递sync.Cond 会复制值，这样两个锁保留的被阻塞的 Goroutine 就不同了。","like_count":6},{"had_liked":false,"id":55631,"user_name":"beiliu","can_delete":false,"product_type":"c1","uid":1292128,"ip_address":"","ucode":"06E1EC1244A52B","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLmBgic9UlGySyG377pCVzNnbgsGttrKTCFztunJlBTDS32oTyHsJjAFJJsYJyhk9cNE5OZeGKWJ6Q/132","comment_is_top":false,"comment_ctime":1546247086,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"23021083566","product_id":100013101,"comment_content":"您好，老师，官方文档是建议，singal在锁住的情况下使用的“Signal唤醒等待c的一个线程（如果存在）。调用者在调用本方法时，建议（但并非必须）保持c.L的锁定“","like_count":5},{"had_liked":false,"id":50765,"user_name":"ming","can_delete":false,"product_type":"c1","uid":1108056,"ip_address":"","ucode":"65E4A1E07D11A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/e8/58/ecb493dc.jpg","comment_is_top":false,"comment_ctime":1545041640,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"23019878120","product_id":100013101,"comment_content":"多routine从信箱中获取情报, 都在等mailbox变量的值不为0的时候再把它的值变为0，<br>这个 RLock 限制不了写操作，可能会有多个routine同时将 mailbox 变为0的，跟文中的场景有些不合。 <br>不知道我理解的有没有问题<br>","like_count":5,"discussions":[{"author":{"id":1033740,"avatar":"","nickname":"Sky","note":"","ucode":"7C585132491E8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449,"discussion_content":"我觉得是有问题的，这里面的假设“RLock 限制不了写操作”是不对的，RLock获取之后，是写不了的（因为写入方这时候没法获取到写锁Lock）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561597008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108056,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e8/58/ecb493dc.jpg","nickname":"ming","note":"","ucode":"65E4A1E07D11A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364510,"discussion_content":"代码中使用,单发通知（signal），不会存在多个routine同时被唤醒所以没有问题。\n如果使用 广播通知（broadcast），则有可能出问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617505954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108056,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e8/58/ecb493dc.jpg","nickname":"ming","note":"","ucode":"65E4A1E07D11A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109883,"discussion_content":"\nlock.RLock()\nfor mailbox == 0 {\n recvCond.Wait()\n}\nmailbox = 0\nlock.RUnlock()\nsendCond.Signal()\n\n第五行代码就是，写操作哟。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577713895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258259,"user_name":"q","can_delete":false,"product_type":"c1","uid":1038802,"ip_address":"","ucode":"9FE8DF709D9953","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d9/d2/4ae9b17f.jpg","comment_is_top":false,"comment_ctime":1604362830,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14489264718","product_id":100013101,"comment_content":"个人感觉，从底层原理解释条件变量可能更容易理解","like_count":4},{"had_liked":false,"id":245645,"user_name":"郭星","can_delete":false,"product_type":"c1","uid":1182219,"ip_address":"","ucode":"8A0F5DF80E0C61","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/0b/985d3800.jpg","comment_is_top":false,"comment_ctime":1599015775,"is_pvip":false,"replies":[{"id":"90344","content":"我在文章里说了啊，有可能会碰到“假唤醒”的情况。而且，如果存在“有多个wait但只需唤醒一个”的情况，也需要用for语句。在for语句里，唤醒后可以再次检查状态，如果状态符合就开始后续工作，如果不符合就再次wait。用if语句就办不到。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1599019386,"ip_address":"","comment_id":245645,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10188950367","product_id":100013101,"comment_content":"在for 循环中使用 wait,在我的测试中,当条件变量处于wait状态时,如果没有唤醒,当前协程会一直阻塞等待在wait这行代码,因此使用for 和 使用if 实际最终结果是相同的,为什么要使用for呢?<br><br>package lesson27<br><br>import (<br>\t&quot;sync&quot;<br>\t&quot;testing&quot;<br>\t&quot;time&quot;<br>)<br><br>&#47;&#47; 利用条件变量实现协调多协程发取信件操作<br>func TestCond(t *testing.T) {<br>\tvar wg sync.WaitGroup<br>\tvar mu sync.RWMutex<br>\t&#47;&#47; 信箱<br>\tmail := false<br>\t&#47;&#47; 两个条件变量<br>\t&#47;&#47; 发送信条件变量<br>\tsendCond := sync.NewCond(&amp;mu)<br>\t&#47;&#47; 接收信条件变量, 对于接收实际是只读操作,因此只需要使用读锁就可以<br>\treceiveCond := sync.NewCond(mu.RLocker())<br>\t&#47;&#47; 最大发送接收次数<br>\tmax := 5<br>\twg.Add(2)<br>\t&#47;&#47; 发送人协程<br>\tgo func(i int) {<br>\t\tfor ; i &gt; 0; i-- {<br>\t\t\ttime.Sleep(time.Second * 3)<br>\t\t\tmu.Lock()<br>\t\t\t&#47;&#47; 如果信箱不为空,则需要等待<br>\t\t\t&#47;&#47;for mail {<br>\t\t\tif mail {<br>\t\t\t\t&#47;&#47; 发送者等待<br>\t\t\t\tt.Log(&quot;sendCond准备进入等待队列&quot;)<br>\t\t\t\tsendCond.Wait()<br>\t\t\t\tt.Log(&quot;sendCond进入等待队列&quot;)<br>\t\t\t}<br>\t\t\tmail = true<br>\t\t\tt.Log(&quot;发送信件成功&quot;)<br>\t\t\tmu.Unlock()<br>\t\t\t&#47;&#47; 通知发送者<br>\t\t\treceiveCond.Signal()<br>\t\t\tt.Log(&quot;唤醒receiveCond&quot;)<br>\t\t}<br>\t\twg.Done()<br>\t}(max)<br><br>\tgo func(i int) {<br>\t\tfor ; i &gt; 0; i-- {<br>\t\t\tmu.RLock()<br>\t\t\t&#47;&#47;for !mail {<br>\t\t\tif !mail {<br>\t\t\t\t&#47;&#47;接收者等待<br>\t\t\t\tt.Log(&quot;receiveCond准备进入等待队列&quot;)<br>\t\t\t\treceiveCond.Wait() &#47;&#47; 如果没有被唤醒会一直阻塞在此<br>\t\t\t\tt.Log(&quot;receiveCond进入等待队列&quot;)<br>\t\t\t}<br>\t\t\tmail = false<br>\t\t\tt.Log(&quot;获取信件成功&quot;)<br>\t\t\tmu.RUnlock()<br>\t\t\t&#47;&#47; 通知接收者<br>\t\t\tsendCond.Signal()<br>\t\t\tt.Log(&quot;唤醒sendCond&quot;)<br>\t\t}<br>\t\twg.Done()<br>\t}(max)<br>\twg.Wait()<br>}<br>","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504939,"discussion_content":"我在文章里说了啊，有可能会碰到“假唤醒”的情况。而且，如果存在“有多个wait但只需唤醒一个”的情况，也需要用for语句。在for语句里，唤醒后可以再次检查状态，如果状态符合就开始后续工作，如果不符合就再次wait。用if语句就办不到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599019386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217468,"user_name":"会玩code","can_delete":false,"product_type":"c1","uid":1325282,"ip_address":"","ucode":"9220B072AF68C7","user_header":"https://static001.geekbang.org/account/avatar/00/14/38/e2/28aa8e6c.jpg","comment_is_top":false,"comment_ctime":1589510149,"is_pvip":false,"replies":[{"id":"80472","content":"在只有一个“取信者”的情况下，这里使用读锁是没问题的。但如果有多个“取信者”就需要用写锁啦。你可以看一看下一篇文章对应的demo文件（demo62.go），其中就有多个“取信者”的演示。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1589523751,"ip_address":"","comment_id":217468,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10179444741","product_id":100013101,"comment_content":"老师，不懂这里的recvCond为什么可以用读锁呢？这里也是有对资源做操作的呀（将mailbox置为0），用读锁不会有问题吗？","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495159,"discussion_content":"在只有一个“取信者”的情况下，这里使用读锁是没问题的。但如果有多个“取信者”就需要用写锁啦。你可以看一看下一篇文章对应的demo文件（demo62.go），其中就有多个“取信者”的演示。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589523751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1449647,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1e/af/5b59f524.jpg","nickname":"yinyin","note":"","ucode":"D6C6E74D213EB4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553949,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646140693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347904,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":3020525,"ip_address":"","ucode":"243C4F9C12F87D","user_header":"https://static001.geekbang.org/account/avatar/00/2e/16/ed/acd6df5e.jpg","comment_is_top":false,"comment_ctime":1654570136,"is_pvip":false,"replies":[{"id":"126806","content":"“一组相关临界区”可以是操作同一个共享资源的多段代码，也可以是在逻辑上有强相关关系的多段代码。在这里，这两段代码都是针对 mailbox 变量的，属于前者。只不过其中还夹杂了 不同条件变量 的 Wait 操作。<br><br>我总体再说一下吧，我们可以从两个维度来理解互斥锁的保护作用：<br><br>1. 多个goroutine并发执行同一段代码（如一个函数或方法），且这段代码访问或修改了共享的状态或资源。这时候，我们需要使用互斥锁保护这段代码。这相当于保护了那个共享状态或资源。这里的“这段代码”就是一个临界区。<br><br>2. （如本例）多个goroutine中的代码（确切地说，是go函数）直接访问或修改了共享的状态或资源。这时候，我们往往就需要使用同一个互斥锁同时去保护那几段相关的代码。这里的几段代码各自成为独立的临界区，但它们是相关的。这就是我说的“一组相关的临界区”。<br><br>以上这两个维度说的就是互斥锁的常用场景。一个是“单段代码的并发执行”，一个是“多段代码的各自执行（也是并发执行）”。关键是，不管是单段代码还是多段代码，它们都分别访问了同一个共享的东西。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1654601810,"ip_address":"","comment_id":347904,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5949537432","product_id":100013101,"comment_content":"想请问下老师，两个goroutine都使用了同一把锁，26讲（Mutex）里不是说明，尽量使用：是让每一个互斥锁都只保护一个临界区或一组相关临界区。有点搞不明白，望老师指点<br><br><br><br>go func(max int) { &#47;&#47; 用于发信。<br>\t\tdefer func() {<br>\t\t\tsign &lt;- struct{}{}<br>\t\t}()<br>\t\tfor i := 1; i &lt;= max; i++ {<br>\t\t\ttime.Sleep(time.Millisecond * 500)<br>\t\t\tlock.Lock()<br>\t\t\tfor mailbox == 1 {<br>\t\t\t\tsendCond.Wait()<br>\t\t\t}<br>\t\t\tlog.Printf(&quot;sender [%d]: the mailbox is empty.&quot;, i)<br>\t\t\tmailbox = 1<br>\t\t\tlog.Printf(&quot;sender [%d]: the letter has been sent.&quot;, i)<br>\t\t\tlock.Unlock()<br>\t\t\trecvCond.Signal()<br>\t\t}<br>\t}(max)<br>\tgo func(max int) { &#47;&#47; 用于收信。<br>\t\tdefer func() {<br>\t\t\tsign &lt;- struct{}{}<br>\t\t}()<br>\t\tfor j := 1; j &lt;= max; j++ {<br>\t\t\ttime.Sleep(time.Millisecond * 500)<br>\t\t\tlock.RLock()<br>\t\t\tfor mailbox == 0 {<br>\t\t\t\trecvCond.Wait()<br>\t\t\t}<br>\t\t\tlog.Printf(&quot;receiver [%d]: the mailbox is full.&quot;, j)<br>\t\t\tmailbox = 0<br>\t\t\tlog.Printf(&quot;receiver [%d]: the letter has been received.&quot;, j)<br>\t\t\tlock.RUnlock()<br>\t\t\tsendCond.Signal()<br>\t\t}<br>\t}(max)","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575117,"discussion_content":"“一组相关临界区”可以是操作同一个共享资源的多段代码，也可以是在逻辑上有强相关关系的多段代码。在这里，这两段代码都是针对 mailbox 变量的，属于前者。只不过其中还夹杂了 不同条件变量 的 Wait 操作。\n\n我总体再说一下吧，我们可以从两个维度来理解互斥锁的保护作用：\n\n1. 多个goroutine并发执行同一段代码（如一个函数或方法），且这段代码访问或修改了共享的状态或资源。这时候，我们需要使用互斥锁保护这段代码。这相当于保护了那个共享状态或资源。这里的“这段代码”就是一个临界区。\n\n2. （如本例）多个goroutine中的代码（确切地说，是go函数）直接访问或修改了共享的状态或资源。这时候，我们往往就需要使用同一个互斥锁同时去保护那几段相关的代码。这里的几段代码各自成为独立的临界区，但它们是相关的。这就是我说的“一组相关的临界区”。\n\n以上这两个维度说的就是互斥锁的常用场景。一个是“单段代码的并发执行”，一个是“多段代码的各自执行（也是并发执行）”。关键是，不管是单段代码还是多段代码，它们都分别访问了同一个共享的东西。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654601810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307335,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1629034684,"is_pvip":false,"replies":[{"id":"111311","content":"正因为有了条件变量才会有这样的同步状态啊。条件变量就相当于信号弹的发射器。<br><br>双方各有一个信号弹发射器（就像示例程序中的 sendCond 和 recvCond）并互相发送信号，这就是 demo61 所做的。<br><br><br>这个程序你也可以这样理解：<br><br>A 和 B 在下象棋。步骤如下：<br><br>A 走了一步棋，并发送信号示意让 B 走一步；<br>B 收到信号走了一步棋，然后反过来向 A 发送信号示意“我走了一步，该你了”；<br>A 再走一步棋，并再次发射信号示意让 B 再走一步；<br>B 再走一步后，再发射信号告诉 A；<br>如此循环往复。<br><br><br>再做一个类比：<br><br>单个条件变量用于“教官”指挥“士兵”，“教官”只能有一个，而“士兵”可以有多个（demo61 中只有一个士兵）。在 demo61 中，我们又多加了一个用于“反馈”的信号弹发射器。这样一来，“士兵”按照指挥行进一步之后，就可以及时告诉指挥官并请求下一步的行动了。<br><br><br><br>","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1629095904,"ip_address":"","comment_id":307335,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5924001980","product_id":100013101,"comment_content":"郝林老师，demo61.go 中的  两个go function（收信 和 发信），是怎么保证先 发信 后收信的呢？<br><br>不是说 go function 函数 的执行 是 随机的么？ 我打印了很多遍，发现 都是执行的 发信 操作，然后是 收信 操作。","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525116,"discussion_content":"正因为有了条件变量才会有这样的同步状态啊。条件变量就相当于信号弹的发射器。\n\n双方各有一个信号弹发射器（就像示例程序中的 sendCond 和 recvCond）并互相发送信号，这就是 demo61 所做的。\n\n\n这个程序你也可以这样理解：\n\nA 和 B 在下象棋。步骤如下：\n\nA 走了一步棋，并发送信号示意让 B 走一步；\nB 收到信号走了一步棋，然后反过来向 A 发送信号示意“我走了一步，该你了”；\nA 再走一步棋，并再次发射信号示意让 B 再走一步；\nB 再走一步后，再发射信号告诉 A；\n如此循环往复。\n\n\n再做一个类比：\n\n单个条件变量用于“教官”指挥“士兵”，“教官”只能有一个，而“士兵”可以有多个（demo61 中只有一个士兵）。在 demo61 中，我们又多加了一个用于“反馈”的信号弹发射器。这样一来，“士兵”按照指挥行进一步之后，就可以及时告诉指挥官并请求下一步的行动了。\n\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629095904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230214,"user_name":"www","can_delete":false,"product_type":"c1","uid":1898338,"ip_address":"","ucode":"ADC9BC655EA16C","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f7/62/947004d0.jpg","comment_is_top":false,"comment_ctime":1593313712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5888281008","product_id":100013101,"comment_content":"这篇讲解太棒了，看了lock.RLocker()的源码，又返回去看了前面第14篇讲解接口的文章。多看多写，逐步提升","like_count":1},{"had_liked":false,"id":209419,"user_name":"😳","can_delete":false,"product_type":"c1","uid":1452857,"ip_address":"","ucode":"9AFB87EF308539","user_header":"https://static001.geekbang.org/account/avatar/00/16/2b/39/19041d78.jpg","comment_is_top":false,"comment_ctime":1587547282,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5882514578","product_id":100013101,"comment_content":"这个类比生动形象，很有趣，简单易懂","like_count":1},{"had_liked":false,"id":196628,"user_name":"Lywane","can_delete":false,"product_type":"c1","uid":1446512,"ip_address":"","ucode":"2B0027AA069CE9","user_header":"https://static001.geekbang.org/account/avatar/00/16/12/70/10faf04b.jpg","comment_is_top":false,"comment_ctime":1585298252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880265548","product_id":100013101,"comment_content":"recvCond.Signal()表示接收方可以接受了，发送这个信号的是发送方。<br>sendCond.Signal()表示发送方可以再次发送了，发送这个信号的是接收方。","like_count":1},{"had_liked":false,"id":172402,"user_name":"lfn","can_delete":false,"product_type":"c1","uid":1026593,"ip_address":"","ucode":"2E1558C6A12A89","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/21/6c3ba9af.jpg","comment_is_top":false,"comment_ctime":1579170103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5874137399","product_id":100013101,"comment_content":"打卡，2020-01-16.","like_count":1},{"had_liked":false,"id":118468,"user_name":"党","can_delete":false,"product_type":"c1","uid":1071974,"ip_address":"","ucode":"EE531DB3EA124D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/66/ad35bc68.jpg","comment_is_top":false,"comment_ctime":1564370672,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5859337968","product_id":100013101,"comment_content":"demo60太经典了 不仅体会到了锁的用法 还体会到了 如何利用chan 阻塞主线程 以使goroutine完全跑完 算是chan经典用法吧","like_count":1,"discussions":[{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","nickname":"MClink","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579389,"discussion_content":"对头，一开始还一脸懵逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657421987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69075,"user_name":"...","can_delete":false,"product_type":"c1","uid":1142098,"ip_address":"","ucode":"9D73E00133C236","user_header":"https://static001.geekbang.org/account/avatar/00/11/6d/52/404912c3.jpg","comment_is_top":false,"comment_ctime":1550656410,"is_pvip":false,"replies":[{"id":"25231","content":"每次执行结束前都会释放，要不其他goroutine没法进入锁保护的临界区。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1551178792,"ip_address":"","comment_id":69075,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5845623706","product_id":100013101,"comment_content":"老师 wait会释放锁吗","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439942,"discussion_content":"每次执行结束前都会释放，要不其他goroutine没法进入锁保护的临界区。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551178792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1312212,"avatar":"https://static001.geekbang.org/account/avatar/00/14/05/d4/e06bf86d.jpg","nickname":"长杰","note":"","ucode":"DD52C9494005F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57414,"discussion_content":"wait本身不释放锁吧？因为后面的代码执行了 lock.RUnlock()方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574604654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1312212,"avatar":"https://static001.geekbang.org/account/avatar/00/14/05/d4/e06bf86d.jpg","nickname":"长杰","note":"","ucode":"DD52C9494005F7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363190,"discussion_content":"释放，点进去看看wait的源码，有个很大的c.L.Unlock()","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617121017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57414,"ip_address":""},"score":363190,"extra":""}]}]},{"had_liked":false,"id":31914,"user_name":"骏Jero","can_delete":false,"product_type":"c1","uid":1133122,"ip_address":"","ucode":"C0D505B088275E","user_header":"https://static001.geekbang.org/account/avatar/00/11/4a/42/b2c7dd30.jpg","comment_is_top":false,"comment_ctime":1539329228,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834296524","product_id":100013101,"comment_content":"为什么这里使用for mailbox == 1 { }, 看wait内部实现，等待是wait中runtime_notifyListWait(&amp;c.notify, t)起到的作用，感觉用if一样达到效果","like_count":1},{"had_liked":false,"id":346539,"user_name":"川川","can_delete":false,"product_type":"c1","uid":2615426,"ip_address":"","ucode":"4296324E6C506B","user_header":"","comment_is_top":false,"comment_ctime":1653220863,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653220863","product_id":100013101,"comment_content":"func (f *FIFO) Add(obj interface{}) error {<br>\tid, err := f.keyFunc(obj)<br>\tif err != nil {<br>\t\treturn KeyError{obj, err}<br>\t}<br>\tf.lock.Lock()<br>\tdefer f.lock.Unlock()<br>\tf.populated = true<br>\tif _, exists := f.items[id]; !exists {<br>\t\tf.queue = append(f.queue, id)<br>\t}<br>\tf.items[id] = obj<br>\tf.cond.Broadcast()<br>\treturn nil<br>}<br><br><br>源码中好多广播都是在锁内发生的啊","like_count":0},{"had_liked":false,"id":346538,"user_name":"川川","can_delete":false,"product_type":"c1","uid":2615426,"ip_address":"","ucode":"4296324E6C506B","user_header":"","comment_is_top":false,"comment_ctime":1653220787,"is_pvip":true,"replies":[{"id":"126631","content":"这要看你初始化 cond 的时候用的是哪个锁（以下称这个锁为 L）了。<br><br>原则上，如果调用的是 Signal 或者 Broadcast ，无需锁定 L 。而 Wait 在被调用时会自动解锁 L ，并且在被唤醒时会先自动锁定 L ，所以我们在调用 Wait 之前一般需要先锁定 L ，这里一定要注意。<br><br>在我们的这个例子里，是有两个 cond 的，所以为了配合，此类操作与相应的锁之间存在一定先后的关系。具体解释在文章中是有的。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1653893117,"ip_address":"","comment_id":346538,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1653220787","product_id":100013101,"comment_content":"老师，我没太理解为啥 广播 是要在解锁之后再 触发吗？  client-go 中广播都是在锁内发生的啊<br><br>func (f *FIFO) Add(obj interface{}) error {<br>\tid, err := f.keyFunc(obj)<br>\tif err != nil {<br>\t\treturn KeyError{obj, err}<br>\t}<br>\tf.lock.Lock()<br>\tdefer f.lock.Unlock()<br>\tf.populated = true<br>\tif _, exists := f.items[id]; !exists {<br>\t\tf.queue = append(f.queue, id)<br>\t}<br>\tf.items[id] = obj<br>\tf.cond.Broadcast()<br>\treturn nil<br>}","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574188,"discussion_content":"这要看你初始化 cond 的时候用的是哪个锁（以下称这个锁为 L）了。\n\n原则上，如果调用的是 Signal 或者 Broadcast ，无需锁定 L 。而 Wait 在被调用时会自动解锁 L ，并且在被唤醒时会先自动锁定 L ，所以我们在调用 Wait 之前一般需要先锁定 L ，这里一定要注意。\n\n在我们的这个例子里，是有两个 cond 的，所以为了配合，此类操作与相应的锁之间存在一定先后的关系。具体解释在文章中是有的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653893117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321622,"user_name":"lofaith","can_delete":false,"product_type":"c1","uid":1322553,"ip_address":"","ucode":"5DF6922BBF1AD5","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/39/7682b49e.jpg","comment_is_top":false,"comment_ctime":1636968372,"is_pvip":false,"replies":[{"id":"116805","content":"读写锁中的读-写、写-写是互斥的，但是读-读不互斥。<br><br>```<br>lock.Lock() <br>for mailbox == 1 { <br>    sendCond.Wait() &#47;&#47; 至于这里都做了什么，你看到下集应该就明白了<br>}<br>mailbox = 1<br>lock.Unlock()<br>recvCond.Signal()<br>```<br><br>说到场景，条件变量最简单的应用场景就是生产-消费协作。这篇文章中的例子只不过是“生产-消费协作”的双向叠加版。<br><br>因此，我们在分别用多个goroutine针对同一个共享资源进行读写的时候就可以运用条件变量，尤其是“单写多读”或“单读多写”的时候。发信号的一方作为“单”的一方，收信号的一方作为“多”的一方（或者“单”的另一方）。<br><br>这里的“单”是指，只有一个goroutine在进行读或写的操作，“多”自然是指有多个goroutine在进行相应的操作。<br><br>当然了，我们也可以把它适用于更复杂的场景，也就是存在多组“单写N读”或“单读N写”的情况。不过，每一组通常会分别对应不同的共享资源。<br><br>多组针对同一个共享资源的情况也是有的。本文的例子就是两组“单写单读”的情况，而且针对的是同一个共享资源，并互为“对立”信号的收发方（即双向叠加版）。<br><br>最后请记住，条件变量的重点在于多goroutine间的紧密协作，而非简单的互斥。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1636989961,"ip_address":"","comment_id":321622,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636968372","product_id":100013101,"comment_content":"老师，读写锁之间不是互斥的吗，我理解应该在加上读锁的时候，写锁就会阻塞在lock这里，不会走到 sendCond.Wait() 这里啊。虽然能明白条件变量的作用了，但还是不清楚它的使用场景，老师能说一下使用场景吗","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530322,"discussion_content":"读写锁中的读-写、写-写是互斥的，但是读-读不互斥。\n\n```\nlock.Lock() \nfor mailbox == 1 { \n    sendCond.Wait() // 至于这里都做了什么，你看到下集应该就明白了\n}\nmailbox = 1\nlock.Unlock()\nrecvCond.Signal()\n```\n\n说到场景，条件变量最简单的应用场景就是生产-消费协作。这篇文章中的例子只不过是“生产-消费协作”的双向叠加版。\n\n因此，我们在分别用多个goroutine针对同一个共享资源进行读写的时候就可以运用条件变量，尤其是“单写多读”或“单读多写”的时候。发信号的一方作为“单”的一方，收信号的一方作为“多”的一方（或者“单”的另一方）。\n\n这里的“单”是指，只有一个goroutine在进行读或写的操作，“多”自然是指有多个goroutine在进行相应的操作。\n\n当然了，我们也可以把它适用于更复杂的场景，也就是存在多组“单写N读”或“单读N写”的情况。不过，每一组通常会分别对应不同的共享资源。\n\n多组针对同一个共享资源的情况也是有的。本文的例子就是两组“单写单读”的情况，而且针对的是同一个共享资源，并互为“对立”信号的收发方（即双向叠加版）。\n\n最后请记住，条件变量的重点在于多goroutine间的紧密协作，而非简单的互斥。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636989961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317524,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1634824209,"is_pvip":false,"replies":[{"id":"115336","content":"mailbox 代表了信箱的状态，状态的变更肯定需要赋值操作。不要把 mailbox 看成文件之类的读写句柄。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1635178440,"ip_address":"","comment_id":317524,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634824209","product_id":100013101,"comment_content":"在运行读取mailbox的goroutine中，当mailbox=1时，可以取信，在这段由读锁锁定的临界区中，mailbox=0实际是一个写入操作，怎么理解这个读锁锁定的临界区中实则为一个写操作呢<br>log.Printf(&quot;receiver [%d]: the mailbox is full.&quot;, j)<br>mailbox = 0<br>log.Printf(&quot;receiver [%d]: the letter has been received.&quot;, j)<br>lock.RUnlock()","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528847,"discussion_content":"mailbox 代表了信箱的状态，状态的变更肯定需要赋值操作。不要把 mailbox 看成文件之类的读写句柄。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635178440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307273,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1628999196,"is_pvip":false,"replies":[{"id":"111269","content":"你有哪里不明白尽管在这里问","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1629034044,"ip_address":"","comment_id":307273,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1628999196","product_id":100013101,"comment_content":"郝林老师，如果能对照代码的打印输出流程讲就好了，有好多讲我看代码的输出挺懵的。","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525100,"discussion_content":"你有哪里不明白尽管在这里问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629034044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291099,"user_name":"moonfox","can_delete":false,"product_type":"c1","uid":1526355,"ip_address":"","ucode":"902BFF40EFA9FA","user_header":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","comment_is_top":false,"comment_ctime":1620023290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620023290","product_id":100013101,"comment_content":"防止假唤醒 for 用的妙呀","like_count":0},{"had_liked":false,"id":289510,"user_name":"槑·先生","can_delete":false,"product_type":"c1","uid":1445744,"ip_address":"","ucode":"897F0475592E3A","user_header":"https://static001.geekbang.org/account/avatar/00/16/0f/70/f59db672.jpg","comment_is_top":false,"comment_ctime":1619058155,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1619058155","product_id":100013101,"comment_content":"从java转过来的表示这一讲还是非常好懂的。另外条件判断那儿用循环是为了避免虚假唤醒。","like_count":0},{"had_liked":false,"id":286053,"user_name":"lzh","can_delete":false,"product_type":"c1","uid":1336951,"ip_address":"","ucode":"C3D83DF4230109","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","comment_is_top":false,"comment_ctime":1617121602,"is_pvip":false,"replies":[{"id":"103883","content":"因为底层实现就是同一个读写锁啊。RLocker 方法返回的锁其实就是这个读写锁中的读锁的简单包装而已（使得这个读锁也成为 sync.Locker 接口的实现）。但是从概念上讲，一个读写锁是由一对写锁和读锁组成的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1617184123,"ip_address":"","comment_id":286053,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1617121602","product_id":100013101,"comment_content":"a := &amp;lock<br>b := lock.RLocker()<br><br>fmt.Printf(&quot;%p\\n&quot;, a)<br>fmt.Printf(&quot;%p\\n&quot;, b)<br><br>它们地址都是一样的呀，为什么说是不同的lock呢？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517858,"discussion_content":"因为底层实现就是同一个读写锁啊。RLocker 方法返回的锁其实就是这个读写锁中的读锁的简单包装而已（使得这个读锁也成为 sync.Locker 接口的实现）。但是从概念上讲，一个读写锁是由一对写锁和读锁组成的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617184123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275257,"user_name":"寻路人","can_delete":false,"product_type":"c1","uid":1195917,"ip_address":"","ucode":"1711F740D4D60A","user_header":"https://static001.geekbang.org/account/avatar/00/12/3f/8d/a89be8f9.jpg","comment_is_top":false,"comment_ctime":1611412795,"is_pvip":false,"replies":[{"id":"99907","content":"sync.RWMutex当然是读写锁，但一个sync.Cond实例只会用实现了sync.Locker接口的单锁啊。所以这里才应用了两个sync.Cond实例。<br><br>另外，“放信”和“取信”这两个操作之间理应是互斥的。如果双方每次都直接碰面，那就不叫“地下工作者”了，也就没有设立这个“信箱”的必要了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1611471899,"ip_address":"","comment_id":275257,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1611412795","product_id":100013101,"comment_content":"var lock sync.RWMutex明明是读写锁，<br>一个goroutine使用了lock.Lock()，另一个goroutine再调用lock.RLock()会互斥。<br>这里作者应该忽略了告诉读者Wait()会释放独占锁的一个概念。","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514285,"discussion_content":"sync.RWMutex当然是读写锁，但一个sync.Cond实例只会用实现了sync.Locker接口的单锁啊。所以这里才应用了两个sync.Cond实例。\n\n另外，“放信”和“取信”这两个操作之间理应是互斥的。如果双方每次都直接碰面，那就不叫“地下工作者”了，也就没有设立这个“信箱”的必要了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611471899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1195917,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3f/8d/a89be8f9.jpg","nickname":"寻路人","note":"","ucode":"1711F740D4D60A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344482,"discussion_content":"谢谢，其实在下一篇中就做了比较详细的解释，如果两篇都看完其实就没有这些疑惑了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611475127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":274305,"user_name":"清风","can_delete":false,"product_type":"c1","uid":1142539,"ip_address":"","ucode":"ED1B6DECC3A102","user_header":"https://static001.geekbang.org/account/avatar/00/11/6f/0b/06480912.jpg","comment_is_top":false,"comment_ctime":1610960015,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610960015","product_id":100013101,"comment_content":"package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;math&#47;rand&quot;<br>\t&quot;sync&quot;<br>\t&quot;time&quot;<br>)<br><br>type User struct { &#47;&#47;模拟用户<br>\tmail *Mail<br>\tname string<br>}<br><br>type Mail struct { &#47;&#47;模拟邮箱<br>\tmail     bool<br>\tmsg int<br>\tsendCond *sync.Cond<br>\trecvCond *sync.Cond<br>\tlock     sync.RWMutex<br>}<br><br>func NewMail() *Mail {<br>\tm := Mail{}<br>\tm.sendCond = sync.NewCond(&amp;m.lock)<br>\tm.recvCond = sync.NewCond(&amp;m.lock)<br>\treturn &amp;m<br>}<br><br>func (u *User) SendMail() {<br>\tu.mail.lock.Lock()<br>\tfor u.mail.mail {<br>\t\tfmt.Println(u.name + &quot;:已经有邮件了等待接收&quot;)<br>\t\tu.mail.sendCond.Wait()<br>\t}<br>\tu.mail.mail = true<br>\tu.mail.msg = rand.Intn(1000000)<br>\tfmt.Println(u.name + &quot;发送了一封邮件&quot;)<br>\tu.mail.lock.Unlock()<br>\tu.mail.recvCond.Broadcast() &#47;&#47;向接收者发送消息<br>}<br><br>func (u *User) RecvMail() {<br>\tu.mail.lock.Lock()<br>\tfor !u.mail.mail {<br>\t\tfmt.Println(u.name + &quot;:没有邮件，等待发送邮件&quot;)<br>\t\tu.mail.recvCond.Wait()<br>\t}<br>\tu.mail.mail = false<br>\tfmt.Printf(&quot;%s:收到一封邮件: %d\\n&quot;, u.name, u.mail.msg)<br>\tu.mail.lock.Unlock()<br>\tu.mail.sendCond.Signal()<br>}<br><br>func main() {<br>\tmail := NewMail()<br>\tlock := make(chan struct{}, 3)<br>\tuse1 := User{<br>\t\tmail: mail,<br>\t\tname: &quot;jacky&quot;,<br>\t}<br>\tuse2 := User{<br>\t\tmail: mail,<br>\t\tname: &quot;rose&quot;,<br>\t}<br>\tuse3 := User{<br>\t\tmail: mail,<br>\t\tname: &quot;allen&quot;,<br>\t}<br><br>\t&#47;&#47;send mail<br>\tgo func() {<br>\t\tdefer func() {<br>\t\t\tlock &lt;- struct{}{}<br>\t\t}()<br><br>\t\tfor {<br>\t\t\tuse1.SendMail()<br>\t\t\ttime.Sleep(time.Second + time.Millisecond * time.Duration(rand.Intn(100)))<br>\t\t}<br>\t}()<br><br>\t&#47;&#47;recv mail<br>\tgo func() {<br>\t\tdefer func() {<br>\t\t\tlock &lt;- struct{}{}<br>\t\t}()<br>\t\tfor {<br>\t\t\tuse2.RecvMail()<br>\t\t\ttime.Sleep(time.Second + time.Millisecond * time.Duration(rand.Intn(100)))<br>\t\t}<br>\t}()<br><br>\t&#47;&#47;recv mail<br>\tgo func() {<br>\t\tdefer func() {<br>\t\t\tlock &lt;- struct{}{}<br>\t\t}()<br>\t\tfor {<br>\t\t\tuse3.RecvMail()<br>\t\t\ttime.Sleep(time.Second + time.Millisecond * time.Duration(rand.Intn(100)))<br>\t\t\tfmt.Println()<br>\t\t}<br>\t}()<br><br>\t&lt;-lock<br>\t&lt;-lock<br>\t&lt;-lock<br>}","like_count":0},{"had_liked":false,"id":223908,"user_name":"Geek_2d276a","can_delete":false,"product_type":"c1","uid":1295596,"ip_address":"","ucode":"866B39EBE71356","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIBJYQ73yYqmiaU7Zg0BHPh9gpSglI79Dzcbob7I2tZOhTjbTTCw13KzVusYhLbKkukV9Ru5UfJMxQ/132","comment_is_top":false,"comment_ctime":1591231091,"is_pvip":true,"replies":[{"id":"82493","content":"条件变量的唤醒操作利用的正是它包含的互斥锁的唤醒功能啊。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1591259051,"ip_address":"","comment_id":223908,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1591231091","product_id":100013101,"comment_content":"有个疑问：互斥锁的解锁操作可以唤醒之前因为加锁导致的阻塞的协程，为什么还要用条件变量来实现唤醒阻塞的协程呢？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497295,"discussion_content":"条件变量的唤醒操作利用的正是它包含的互斥锁的唤醒功能啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591259051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1811495,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a4/27/15e75982.jpg","nickname":"小袁","note":"","ucode":"3F5D8721F577D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349162,"discussion_content":"你还是没回答问题。为啥互斥锁有唤醒的作用，还要设计条件变量来唤醒？这难道不是重复设计么？go的设计者不至于这么无聊吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612942640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203649,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1586246898,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586246898","product_id":100013101,"comment_content":"感觉就像是把之前的阻塞改完了循环？<br>还不如让出cpu时间片等待唤醒","like_count":0},{"had_liked":false,"id":196024,"user_name":"给力","can_delete":false,"product_type":"c1","uid":1113645,"ip_address":"","ucode":"646EE4AFC17224","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/2d/2c9177ca.jpg","comment_is_top":false,"comment_ctime":1585231260,"is_pvip":false,"replies":[{"id":"74425","content":"是的，这样会造成不一致的问题，而且如果不是事先想到原因的话很难排查。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1585282547,"ip_address":"","comment_id":196024,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585231260","product_id":100013101,"comment_content":"指针类型可以被传递，因为底层数据是同一份。<br>传值的话<br>type Cond struct {<br>\tnoCopy noCopy<br><br>\t&#47;&#47; L is held while observing or changing the condition<br>\tL Locker<br><br>\tnotify  notifyList<br>\tchecker copyChecker<br>}<br>Locker 是接口，传递时是引用类型<br>notifyList 是结构体，会被浅拷贝<br>checker 是数值类型，也会被拷贝<br><br>如果sync.Cond在传递过程中，结构体和数值类型各层都有一份备份数据，容易造成不一致情况，所以极容易出问题。<br>","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489209,"discussion_content":"是的，这样会造成不一致的问题，而且如果不是事先想到原因的话很难排查。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585282547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172663,"user_name":"海盗船长","can_delete":false,"product_type":"c1","uid":1363634,"ip_address":"","ucode":"ECB28BA21A4113","user_header":"https://static001.geekbang.org/account/avatar/00/14/ce/b2/1f914527.jpg","comment_is_top":false,"comment_ctime":1579248032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579248032","product_id":100013101,"comment_content":"“如果信箱里没有情报，那么我就把新情报放进去，关上信箱、锁上锁，然后离开。用代码表达出来就是mailbox = 1和lock.Unlock()。”  文中这句，锁上锁 对应的是lock.Unlock()  费解!!","like_count":0},{"had_liked":false,"id":162257,"user_name":"Howard","can_delete":false,"product_type":"c1","uid":1321620,"ip_address":"","ucode":"3634F77FF76746","user_header":"https://static001.geekbang.org/account/avatar/00/14/2a/94/8c128d36.jpg","comment_is_top":false,"comment_ctime":1576487675,"is_pvip":false,"replies":[{"id":"61746","content":"不可以，共享资源总是需要受到保护。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1576492643,"ip_address":"","comment_id":162257,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1576487675","product_id":100013101,"comment_content":"我能把mailbox = 0放到lock.RUnlock()外面吗？总觉得读锁里面改动mailbox有点不好。","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477991,"discussion_content":"不可以，共享资源总是需要受到保护。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576492643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1321620,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2a/94/8c128d36.jpg","nickname":"Howard","note":"","ucode":"3634F77FF76746","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84799,"discussion_content":"谢谢回答，这样的好处就是进入写锁的时候，这里不会加载读锁。扩展一下问题，如果这里有多个携程进行读操作，这里就应该换一种实现方法了，对不？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576506420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126632,"user_name":"qiushye","can_delete":false,"product_type":"c1","uid":1322164,"ip_address":"","ucode":"D005A152F8BEDC","user_header":"","comment_is_top":false,"comment_ctime":1566438904,"is_pvip":false,"replies":[{"id":"46959","content":"你说的是 recvCond？这可不是收信的意思啊。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1566526081,"ip_address":"","comment_id":126632,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1566438904","product_id":100013101,"comment_content":"文章的例子是“我发信，你收信”，示例图表达的是“你发信，我收信”，稍有不足.","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464093,"discussion_content":"你说的是 recvCond？这可不是收信的意思啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566526081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1321620,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2a/94/8c128d36.jpg","nickname":"Howard","note":"","ucode":"3634F77FF76746","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84093,"discussion_content":"recvCon是通知信已经放好了，你可以收信的信使。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576487483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123686,"user_name":"bluuus","can_delete":false,"product_type":"c1","uid":1218438,"ip_address":"","ucode":"274D5063B5F542","user_header":"https://static001.geekbang.org/account/avatar/00/12/97/86/fb564a19.jpg","comment_is_top":false,"comment_ctime":1565743766,"is_pvip":false,"replies":[{"id":"45595","content":"你对 demo61.go 有改动吗？","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1565845338,"ip_address":"","comment_id":123686,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1565743766","product_id":100013101,"comment_content":"我试了一下demo61.go, 发现永远只有一个协程可以进到wait方法，当mailbox初始值是0，只有可能收协程进到wait方法；当mailbox初始值为1，只有可能发协程进到wait方法。为什么会这样","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462769,"discussion_content":"你对 demo61.go 有改动吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565845338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/97/86/fb564a19.jpg","nickname":"bluuus","note":"","ucode":"274D5063B5F542","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4937,"discussion_content":"没有，我复制下来重复跑了几次","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565845404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37931,"user_name":"打你","can_delete":false,"product_type":"c1","uid":1075199,"ip_address":"","ucode":"18403CA411C6C7","user_header":"https://static001.geekbang.org/account/avatar/00/10/67/ff/d4f31b87.jpg","comment_is_top":false,"comment_ctime":1541814830,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541814830","product_id":100013101,"comment_content":"我肯定需要先调用lock变量的Lock方法。注意，这个Loc...<br><br>极客时间版权所有: https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;41588<br><br>这一段写得太拗口啦。什么叫持有锁，而不锁上锁。后面然后又unlock，费解。<br>在我看来，这不是读写锁中的写锁么，相当于获取了写锁","like_count":0},{"had_liked":false,"id":33545,"user_name":"云学","can_delete":false,"product_type":"c1","uid":1027233,"ip_address":"","ucode":"366AE90BA06356","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/a1/43d83698.jpg","comment_is_top":false,"comment_ctime":1539824032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539824032","product_id":100013101,"comment_content":"本文的例子如果只用一个条件变量，不用2个，是不是也可以呢？","like_count":0},{"had_liked":false,"id":32699,"user_name":"卒迹","can_delete":false,"product_type":"c1","uid":1202095,"ip_address":"","ucode":"FAE1AA6038402C","user_header":"https://static001.geekbang.org/account/avatar/00/12/57/af/0b39cab7.jpg","comment_is_top":false,"comment_ctime":1539671567,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1539671567","product_id":100013101,"comment_content":"\t\t\tif mailbox ==0 {<br>\t\t\t\trecvCond.Wait()<br>\t\t\t}<br>为什么发送goroutine和发送goroutine用if 替换for打印的结果和用for结构一样的","like_count":0,"discussions":[{"author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541076,"discussion_content":"这个是有偶然性的， for的目的是去检查一次， if的话， 当有多个发送者， 会出现进来了但是mailbox不是0\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640249870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}