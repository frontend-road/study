{"id":40359,"title":"21 | panic函数、recover函数以及defer语句 （上）","content":"<p>我在上两篇文章中，详细地讲述了Go语言中的错误处理，并从两个视角为你总结了错误类型、错误值的处理技巧和设计方式。</p><p>在本篇，我要给你展示Go语言的另外一种错误处理方式。不过，严格来说，它处理的不是错误，而是异常，并且是一种在我们意料之外的程序异常。</p><h2>前导知识：运行时恐慌panic</h2><p>这种程序异常被叫做panic，我把它翻译为运行时恐慌。其中的“恐慌”二字是由panic直译过来的，而之所以前面又加上了“运行时”三个字，是因为这种异常只会在程序运行的时候被抛出来。</p><p>我们举个具体的例子来看看。</p><p>比如说，一个Go程序里有一个切片，它的长度是5，也就是说该切片中的元素值的索引分别为<code>0</code>、<code>1</code>、<code>2</code>、<code>3</code>、<code>4</code>，但是，我在程序里却想通过索引<code>5</code>访问其中的元素值，显而易见，这样的访问是不正确的。</p><p>Go程序，确切地说是程序内嵌的Go语言运行时系统，会在执行到这行代码的时候抛出一个“index out of range”的panic，用以提示你索引越界了。</p><p>当然了，这不仅仅是个提示。当panic被抛出之后，如果我们没有在程序里添加任何保护措施的话，程序（或者说代表它的那个进程）就会在打印出panic的详细情况（以下简称panic详情）之后，终止运行。</p><!-- [[[read_end]]] --><p>现在，就让我们来看一下这样的panic详情中都有什么。</p><pre><code>panic: runtime error: index out of range\n\ngoroutine 1 [running]:\nmain.main()\n /Users/haolin/GeekTime/Golang_Puzzlers/src/puzzlers/article19/q0/demo47.go:5 +0x3d\nexit status 2\n</code></pre><p>这份详情的第一行是“panic: runtime error: index out of range”。其中的“runtime error”的含义是，这是一个<code>runtime</code>代码包中抛出的panic。在这个panic中，包含了一个<code>runtime.Error</code>接口类型的值。<code>runtime.Error</code>接口内嵌了<code>error</code>接口，并做了一点点扩展，<code>runtime</code>包中有不少它的实现类型。</p><p>实际上，此详情中的“panic：”右边的内容，正是这个panic包含的<code>runtime.Error</code>类型值的字符串表示形式。</p><p>此外，panic详情中，一般还会包含与它的引发原因有关的goroutine的代码执行信息。正如前述详情中的“goroutine 1 [running]”，它表示有一个ID为<code>1</code>的goroutine在此panic被引发的时候正在运行。</p><p>注意，这里的ID其实并不重要，因为它只是Go语言运行时系统内部给予的一个goroutine编号，我们在程序中是无法获取和更改的。</p><p>我们再看下一行，“main.main()”表明了这个goroutine包装的<code>go</code>函数就是命令源码文件中的那个<code>main</code>函数，也就是说这里的goroutine正是主goroutine。再下面的一行，指出的就是这个goroutine中的哪一行代码在此panic被引发时正在执行。</p><p>这包含了此行代码在其所属的源码文件中的行数，以及这个源码文件的绝对路径。这一行最后的<code>+0x3d</code>代表的是：此行代码相对于其所属函数的入口程序计数偏移量。不过，一般情况下它的用处并不大。</p><p>最后，“exit status 2”表明我的这个程序是以退出状态码<code>2</code>结束运行的。在大多数操作系统中，只要退出状态码不是<code>0</code>，都意味着程序运行的非正常结束。在Go语言中，因panic导致程序结束运行的退出状态码一般都会是<code>2</code>。</p><p>综上所述，我们从上边的这个panic详情可以看出，作为此panic的引发根源的代码处于demo47.go文件中的第5行，同时被包含在<code>main</code>包（也就是命令源码文件所在的代码包）的<code>main</code>函数中。</p><p>那么，我的第一个问题也随之而来了。我今天的问题是：<strong>从panic被引发到程序终止运行的大致过程是什么？</strong></p><p><strong>这道题的典型回答是这样的。</strong></p><p>我们先说一个大致的过程：某个函数中的某行代码有意或无意地引发了一个panic。这时，初始的panic详情会被建立起来，并且该程序的控制权会立即从此行代码转移至调用其所属函数的那行代码上，也就是调用栈中的上一级。</p><p>这也意味着，此行代码所属函数的执行随即终止。紧接着，控制权并不会在此有片刻的停留，它又会立即转移至再上一级的调用代码处。控制权如此一级一级地沿着调用栈的反方向传播至顶端，也就是我们编写的最外层函数那里。</p><p>这里的最外层函数指的是<code>go</code>函数，对于主goroutine来说就是<code>main</code>函数。但是控制权也不会停留在那里，而是被Go语言运行时系统收回。</p><p>随后，程序崩溃并终止运行，承载程序这次运行的进程也会随之死亡并消失。与此同时，在这个控制权传播的过程中，panic详情会被逐渐地积累和完善，并会在程序终止之前被打印出来。</p><h2>问题解析</h2><p>panic可能是我们在无意间（或者说一不小心）引发的，如前文所述的索引越界。这类panic是真正的、在我们意料之外的程序异常。不过，除此之外，我们还是可以有意地引发panic。</p><p>Go语言的内建函数<code>panic</code>是专门用于引发panic的。<code>panic</code>函数使程序开发者可以在程序运行期间报告异常。</p><p>注意，这与从函数返回错误值的意义是完全不同的。当我们的函数返回一个非<code>nil</code>的错误值时，函数的调用方有权选择不处理，并且不处理的后果往往是不致命的。</p><p>这里的“不致命”的意思是，不至于使程序无法提供任何功能（也可以说僵死）或者直接崩溃并终止运行（也就是真死）。</p><p>但是，当一个panic发生时，如果我们不施加任何保护措施，那么导致的直接后果就是程序崩溃，就像前面描述的那样，这显然是致命的。</p><p>为了更清楚地展示答案中描述的过程，我编写了demo48.go文件。你可以先查看一下其中的代码，再试着运行它，并体会它打印的内容所代表的含义。</p><p>我在这里再提示一点。panic详情会在控制权传播的过程中，被逐渐地积累和完善，并且，控制权会一级一级地沿着调用栈的反方向传播至顶端。</p><p>因此，在针对某个goroutine的代码执行信息中，调用栈底端的信息会先出现，然后是上一级调用的信息，以此类推，最后才是此调用栈顶端的信息。</p><p>比如，<code>main</code>函数调用了<code>caller1</code>函数，而<code>caller1</code>函数又调用了<code>caller2</code>函数，那么<code>caller2</code>函数中代码的执行信息会先出现，然后是<code>caller1</code>函数中代码的执行信息，最后才是<code>main</code>函数的信息。</p><pre><code>goroutine 1 [running]:\nmain.caller2()\n /Users/haolin/GeekTime/Golang_Puzzlers/src/puzzlers/article19/q1/demo48.go:22 +0x91\nmain.caller1()\n /Users/haolin/GeekTime/Golang_Puzzlers/src/puzzlers/article19/q1/demo48.go:15 +0x66\nmain.main()\n /Users/haolin/GeekTime/Golang_Puzzlers/src/puzzlers/article19/q1/demo48.go:9 +0x66\nexit status 2\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/60/d7/606ff433a6b58510f215e57792822bd7.png?wh=887*1060\" alt=\"\"></p><p>（从panic到程序崩溃）</p><p>好了，到这里，我相信你已经对panic被引发后的程序终止过程有一定的了解了。深入地了解此过程，以及正确地解读panic详情应该是我们的必备技能，这在调试Go程序或者为Go程序排查错误的时候非常重要。</p><h2>总结</h2><p>最近的两篇文章，我们是围绕着panic函数、recover函数以及defer语句进行的。今天我主要讲了panic函数。这个函数是专门被用来引发panic的。panic也可以被称为运行时恐慌，它是一种只能在程序运行期间抛出的程序异常。</p><p>Go语言的运行时系统可能会在程序出现严重错误时自动地抛出panic，我们在需要时也可以通过调用<code>panic</code>函数引发panic。但不论怎样，如果不加以处理，panic就会导致程序崩溃并终止运行。</p><h2>思考题</h2><p>一个函数怎样才能把panic转化为<code>error</code>类型值，并将其作为函数的结果值返回给调用方？</p><p><a href=\"https://github.com/hyper0x/Golang_Puzzlers\">戳此查看Go语言专栏文章配套详细代码。</a></p><p></p>","comments":[{"had_liked":false,"id":30781,"user_name":"江山如画","can_delete":false,"product_type":"c1","uid":1188280,"ip_address":"","ucode":"BEB6228E6135B5","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/b8/aca814dd.jpg","comment_is_top":false,"comment_ctime":1538996370,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"156157819026","product_id":100013101,"comment_content":"一个函数如果要把 panic 转化为error类型值，并将其结果返回给调用方，可以考虑把 defer 语句封装到一个匿名函数之中，下面是实验的一个例子，所用函数是一个除法函数，当除数为0的时候会抛出 panic并捕获。<br><br>func divide(a, b int) (res int, err error) {<br>\tfunc() {<br>\t\tdefer func() {<br>\t\t\tif rec := recover(); rec != nil {<br>\t\t\t\terr = fmt.Errorf(&quot;%s&quot;, rec)<br>\t\t\t}<br>\t\t}()<br>\t\tres = a &#47; b<br>\t}()<br>\treturn<br>}<br><br>func main() {<br>\tres, err := divide(1, 0)<br>\tfmt.Println(res, err) &#47;&#47; 0 runtime error: integer divide by zero<br><br>\tres, err = divide(2, 1)<br>\tfmt.Println(res, err) &#47;&#47; 2 &lt;nil&gt;<br>}<br>","like_count":37,"discussions":[{"author":{"id":2735072,"avatar":"https://static001.geekbang.org/account/avatar/00/29/bb/e0/c7cd5170.jpg","nickname":"Bynow","note":"","ucode":"1E4F3ADD65CF18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576016,"discussion_content":"兄弟你里面那个函数嵌套没必要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655232350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","nickname":"MClink","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2735072,"avatar":"https://static001.geekbang.org/account/avatar/00/29/bb/e0/c7cd5170.jpg","nickname":"Bynow","note":"","ucode":"1E4F3ADD65CF18","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579157,"discussion_content":"确实","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657203884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":576016,"ip_address":""},"score":579157,"extra":""}]}]},{"had_liked":false,"id":184973,"user_name":"锋","can_delete":false,"product_type":"c1","uid":1807836,"ip_address":"","ucode":"F26BC1F14AB0D7","user_header":"https://static001.geekbang.org/account/avatar/00/1b/95/dc/07195a63.jpg","comment_is_top":false,"comment_ctime":1583460559,"is_pvip":false,"replies":[{"id":"71507","content":"Go的错误处理机制是由两个部分组成的，panic代表着特殊的（或者说意外的）错误，error代表着普通的错误。与try-catch不同，error并不是打断正常的控制流程的执行。单单这一点来讲，就已经是非常好的进步了。相比之下，panic会打断正常的控制流程。从这一点上看，panic与try-catch很像。<br><br>说到这里，你可能也意识到了，try-catch是一套行为单一的错误处理机制，而Go语言的（error+panic）把错误处理机制在代码级别分为了两个部分。<br><br>这样的好处是，倒逼开发者去思考，什么时候应该返回普通的错误，什么时候应该抛出意外的错误。这种思考在设计一个程序的错误体系的时候是非常重要的，关系到程序运行的稳定性。<br><br>至于缺点，error容易被滥用，导致程序中到处是 if err != nil 的代码。但是我们要清楚的是，这往往是程序设计上的问题，而不是语言层面的问题。如果不当心，try-catch照样会被弄的满屏都是。而且try-catch还有一个颗粒度和数量的问题（与临界区的颗粒度和数量问题类似）。<br><br>总之，我个人认为Go语言的错误处理机制是一种创新和进步。不过，由于容易被滥用，Go语言团队不是还在近几年一直在考虑更好的解决方案吗。我也很期待他们新的设计。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1583477835,"ip_address":"","comment_id":184973,"utype":1}],"discussion_count":8,"race_medal":0,"score":"70302937295","product_id":100013101,"comment_content":"老师，你好，我有一个疑问，请教一下，谢谢~<br>Go在设计的时候没有设计try...catch...finally这样的方式来捕获异常。<br>我在网上查很多人用panic、defer和recover组合来实现异常的捕获，甚至很多都将这个二次封装之后作为一个库来进行使用。<br>我的疑问是，从Go的设计角度为什么要这么做？是出于什么样的目的，还是他俩之间有什么优劣？<br>非常感谢~，烦请解答。","like_count":17,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486198,"discussion_content":"Go的错误处理机制是由两个部分组成的，panic代表着特殊的（或者说意外的）错误，error代表着普通的错误。与try-catch不同，error并不是打断正常的控制流程的执行。单单这一点来讲，就已经是非常好的进步了。相比之下，panic会打断正常的控制流程。从这一点上看，panic与try-catch很像。\n\n说到这里，你可能也意识到了，try-catch是一套行为单一的错误处理机制，而Go语言的（error+panic）把错误处理机制在代码级别分为了两个部分。\n\n这样的好处是，倒逼开发者去思考，什么时候应该返回普通的错误，什么时候应该抛出意外的错误。这种思考在设计一个程序的错误体系的时候是非常重要的，关系到程序运行的稳定性。\n\n至于缺点，error容易被滥用，导致程序中到处是 if err != nil 的代码。但是我们要清楚的是，这往往是程序设计上的问题，而不是语言层面的问题。如果不当心，try-catch照样会被弄的满屏都是。而且try-catch还有一个颗粒度和数量的问题（与临界区的颗粒度和数量问题类似）。\n\n总之，我个人认为Go语言的错误处理机制是一种创新和进步。不过，由于容易被滥用，Go语言团队不是还在近几年一直在考虑更好的解决方案吗。我也很期待他们新的设计。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1583477835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1174199,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ea/b7/1a18a39d.jpg","nickname":"5-刘新波(Arvin)","note":"","ucode":"DBD135D2587A93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394780,"discussion_content":"panic相当于java中的[运行时]异常，处理不可预知的错误，error相当于[检查]异常，但不强制处理，主要用于可预测和回避的错误","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632050488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047637,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcwXucibksEYWRmibTZj9pb3d5ibfVQHFS9shvJmgMgtN3BM3r9qiaL5YTZSFdLvPZiaEHfBia4dFODVqw/132","nickname":"北国骑士","note":"","ucode":"AC657FCA2014ED","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376307,"discussion_content":"设计垃圾就是垃圾，还说这么多理由，既然很好，为啥又要改？如果写程序时不能专注业务本身，把大量的时间用来思考如何设计error处理上，这种编程语言和石器时代的语言好多少啊？既然容易滥用，为啥不考虑是语言本身的问题导致的滥用？c语言更牛逼，更考验水平，为啥写业务不用c？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622077942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1047637,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcwXucibksEYWRmibTZj9pb3d5ibfVQHFS9shvJmgMgtN3BM3r9qiaL5YTZSFdLvPZiaEHfBia4dFODVqw/132","nickname":"北国骑士","note":"","ucode":"AC657FCA2014ED","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":401562,"discussion_content":"哥， try cache 好在哪? 用着恶心死了， 让你更专注于业务了？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633692395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":376307,"ip_address":""},"score":401562,"extra":""}]},{"author":{"id":1000237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/43/2d/af86d73f.jpg","nickname":"enjoylearning","note":"","ucode":"DCAF8538DEA277","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590410,"discussion_content":"感觉是业务类型的错误用error,不可预知的系统错误用panic","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665723906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401563,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633692430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1208981,"avatar":"https://static001.geekbang.org/account/avatar/00/12/72/95/5f83598c.jpg","nickname":"Hello World","note":"","ucode":"368D87D53DC58F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362468,"discussion_content":"golang error相当于C中的错误码处理，正常的出错处理不会随便导致进程退出，保证可用性。而panic就相当于bug on，走到了不符合预期的不可恢复错误，进程会core掉，必须修改代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616945286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1807836,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/95/dc/07195a63.jpg","nickname":"锋","note":"","ucode":"F26BC1F14AB0D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198140,"discussion_content":"谢谢老师的解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583480397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28385,"user_name":"Bang","can_delete":false,"product_type":"c1","uid":1160079,"ip_address":"","ucode":"0CB8A52B177868","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/8f/4caf7f03.jpg","comment_is_top":false,"comment_ctime":1538064932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53077672484","product_id":100013101,"comment_content":"先使用go中的类似try catch这样的语句，将异常捕获的异常转为相应的错误error就可以了","like_count":12},{"had_liked":false,"id":28421,"user_name":"唐丹","can_delete":false,"product_type":"c1","uid":1204418,"ip_address":"","ucode":"B45D936E6C4744","user_header":"https://static001.geekbang.org/account/avatar/00/12/60/c2/6d50bfdf.jpg","comment_is_top":false,"comment_ctime":1538092512,"is_pvip":false,"replies":[{"id":"10647","content":"只要在调用栈路径上就都可以处理，如果你用了defer语句和recover函数等正确处理方式还是不行的话，就要看看这个panic是不是不了恢复的。一些runtime抛出来的panic是不可恢复的，因为问题很严重必须整改代码才行。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1538452603,"ip_address":"","comment_id":28421,"utype":1}],"discussion_count":5,"race_medal":0,"score":"48782732768","product_id":100013101,"comment_content":"郝大，你好，我在golang 8中通过recover处理panic时发现，必须在引发panic的当前协程就处理掉，否则待其传递到父协程直至main方法中，都不能通过recover成功处理掉了，程序会因此结束。请问这样设计的原因是什么？那么协程是通过panic中记录的协程id来区分是不是在当前协程引发的panic的吗？另外，这样的话，我们应用程序中每一个通过go新起的协程都应该在开始的地方recover，否则即使父协程有recover也不能阻止程序因为一个意外的panic而挂掉？盼望解答，谢谢🙏","like_count":11,"discussions":[{"author":{"id":1112676,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","nickname":"Sam Fu","note":"","ucode":"EA285A4943271F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541708,"discussion_content":"defer 关键字对应的 runtime.deferproc 会将延迟调用函数与调用方所在 Goroutine 进行关联。所以当程序发生崩溃时只会调用当前 Goroutine 的延迟调用函数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640524681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1112676,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","nickname":"Sam Fu","note":"","ucode":"EA285A4943271F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541707,"discussion_content":"感觉答非所问啊 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640524542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425260,"discussion_content":"只要在调用栈路径上就都可以处理，如果你用了defer语句和recover函数等正确处理方式还是不行的话，就要看看这个panic是不是不了恢复的。一些runtime抛出来的panic是不可恢复的，因为问题很严重必须整改代码才行。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1538452603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401560,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633692161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242292,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f4/b4/da161b60.jpg","nickname":"Tracy","note":"","ucode":"5DA6F44D096B7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344296,"discussion_content":"panic不会传播到主groutine","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611394523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219676,"user_name":"沐夜星光","can_delete":false,"product_type":"c1","uid":1447220,"ip_address":"","ucode":"22F699E237B179","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia2EwyyEVs3tWRnMlqaAG7R7HvlW4vGvxthKsicgsCEeXO1qL7mMy6GAzgdkSKcH3c70Qa2hY3JLw/132","comment_is_top":false,"comment_ctime":1590061911,"is_pvip":false,"replies":[{"id":"81169","content":"这会经过main函数，异步调用也是调用。main函数就是主goroutine的go函数。<br><br>go回收进程？这没什么稀奇的啊，就是调用操作系统的底层API，你可以查看 runtime.main 函数了解相关过程，或者查看 runtime.exit 函数了解进程退出时调用的API。<br><br>在一个goroutine中的go函数执行完之后，这个goroutine会转为_Gidle状态，其中的所有关键字段都会被重置，它的栈内存也会被释放。最后，它会被放入自由G列表。你可以通过查看 runtime.goexit0 了解到。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1590118225,"ip_address":"","comment_id":219676,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18769931095","product_id":100013101,"comment_content":"“控制权如此一级一级地沿着调用栈的反方向传播至顶端，也就是我们编写的最外层函数那里”。最外层函数是go函数，也就说当panic触发，通过其所在的goroutine，将控制权转移给运行时系统时，是不一定经过main函数的吗？另外老师能不能讲讲，go是怎么回收一个进程的，怎么处理运行中的goroutine以及涉及的资源。","like_count":4,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495899,"discussion_content":"这会经过main函数，异步调用也是调用。main函数就是主goroutine的go函数。\n\ngo回收进程？这没什么稀奇的啊，就是调用操作系统的底层API，你可以查看 runtime.main 函数了解相关过程，或者查看 runtime.exit 函数了解进程退出时调用的API。\n\n在一个goroutine中的go函数执行完之后，这个goroutine会转为_Gidle状态，其中的所有关键字段都会被重置，它的栈内存也会被释放。最后，它会被放入自由G列表。你可以通过查看 runtime.goexit0 了解到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590118225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401564,"discussion_content":"Mark， 老师强","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633692494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29552,"user_name":"冰激凌的眼泪","can_delete":false,"product_type":"c1","uid":1087945,"ip_address":"","ucode":"5DCB974667E93A","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg","comment_is_top":false,"comment_ctime":1538437329,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14423339217","product_id":100013101,"comment_content":"panic时，会捕获异常及异常上下文（函数名+文件行）<br>类似看作有一个异常上下文列表，始于异常触发处，沿着函数调用逆向展开，每一级append自己的异常上下文，直至goroutine入口函数，最终被runtime捕获<br>最终异常信息被打印，异常上下文列表被顺序打印，程序退出","like_count":3},{"had_liked":false,"id":72327,"user_name":"🐻","can_delete":false,"product_type":"c1","uid":1043072,"ip_address":"","ucode":"534EDAD496A0E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/80/8759e4c1.jpg","comment_is_top":false,"comment_ctime":1551587661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10141522253","product_id":100013101,"comment_content":"https:&#47;&#47;gist.github.com&#47;bwangelme&#47;9ce1c606ba9f69c72f82722adf1402e1","like_count":2},{"had_liked":false,"id":34993,"user_name":"A 凡","can_delete":false,"product_type":"c1","uid":1197361,"ip_address":"","ucode":"BDC8DB599B8284","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/31/53910b61.jpg","comment_is_top":false,"comment_ctime":1540377077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10130311669","product_id":100013101,"comment_content":"之前自己学习时候的一些模糊点更加清晰了，支持！","like_count":2},{"had_liked":false,"id":285231,"user_name":"MClink","can_delete":false,"product_type":"c1","uid":1435733,"ip_address":"","ucode":"F479190923355C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","comment_is_top":false,"comment_ctime":1616678355,"is_pvip":true,"replies":[{"id":"103551","content":"每种语言的风格都不同啊，习惯习惯就好了（注意力可以更多的放在“怎样高效构建优秀软件上” ，语法的一些特点不属于关键问题 :-) ），而且后续Go在这方面会有改善。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1616737048,"ip_address":"","comment_id":285231,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5911645651","product_id":100013101,"comment_content":"初学go都会吐槽说没有 try catch , 应该不止我一个","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517623,"discussion_content":"每种语言的风格都不同啊，习惯习惯就好了（注意力可以更多的放在“怎样高效构建优秀软件上” ，语法的一些特点不属于关键问题 :-) ），而且后续Go在这方面会有改善。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616737048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/43/2d/af86d73f.jpg","nickname":"enjoylearning","note":"","ucode":"DCAF8538DEA277","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590411,"discussion_content":"不是满屏的try-catch而是error，这确实是人的问题，跟语言设计没关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665724131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047637,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcwXucibksEYWRmibTZj9pb3d5ibfVQHFS9shvJmgMgtN3BM3r9qiaL5YTZSFdLvPZiaEHfBia4dFODVqw/132","nickname":"北国骑士","note":"","ucode":"AC657FCA2014ED","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376310,"discussion_content":"你语法都这么垃圾，我怎么专注在构建优秀软件上，时间都浪费在垃圾语法上了，连个三目运算符都不支持","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622078186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047637,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcwXucibksEYWRmibTZj9pb3d5ibfVQHFS9shvJmgMgtN3BM3r9qiaL5YTZSFdLvPZiaEHfBia4dFODVqw/132","nickname":"北国骑士","note":"","ucode":"AC657FCA2014ED","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376308,"discussion_content":"你这个而且已经证明了，还狡辩啥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622078110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350800,"user_name":"MClink","can_delete":false,"product_type":"c1","uid":1435733,"ip_address":"","ucode":"F479190923355C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","comment_is_top":false,"comment_ctime":1657204457,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657204457","product_id":100013101,"comment_content":"这个看起来比较简单<br>func main() {<br>\tres, err := divide(1, 0)<br>\tif err != nil {<br>\t\tfmt.Println(err)<br>\t}<br>\tfmt.Println(res)<br>}<br><br>func divide(a, b int) (res int, err error) {<br>\tdefer func() {<br>\t\tif r := recover(); r != nil {<br>\t\t\terr = fmt.Errorf(&quot;omg, panic ! err:%v&quot;, r)<br>\t\t\treturn<br>\t\t}<br>\t}()<br>\tres = a &#47; b<br>\treturn<br>}","like_count":0},{"had_liked":false,"id":306834,"user_name":"Harlan","can_delete":false,"product_type":"c1","uid":2134882,"ip_address":"","ucode":"F43595A0A00B19","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erpYZalYvFGcBs7zZvYwaQAZwTLiaw0mycJ4PdYpP3VxAYkAtyIRHhjSOrOK0yESaPpgEbVQUwf6LA/132","comment_is_top":false,"comment_ctime":1628739470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628739470","product_id":100013101,"comment_content":"go这种满屏幕都是 判断 err!=nil 这种没有意义的代码  代码侵入性极强  也不优雅","like_count":0},{"had_liked":false,"id":267941,"user_name":"Geek_37a441","can_delete":false,"product_type":"c1","uid":2369701,"ip_address":"","ucode":"72A2EEBA0C1DBC","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PeibZXsEcwic1zvrAQpDlnNlPxZvmAtIZ6XCenC8NaPbVVfCk7PXgAYzb8icqrYlb9cJd82hia9FYTicxqSdgyCEP4w/132","comment_is_top":false,"comment_ctime":1608000921,"is_pvip":false,"replies":[{"id":"97316","content":"当然不是了，是执行程序的程序碰到严重错误就抛出来，属于Go运行时系统的职责范围。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1608031203,"ip_address":"","comment_id":267941,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1608000921","product_id":100013101,"comment_content":"老师，你好，我想问下，panic触发的时机，比如指令执行过程中，在什么时候会调用到相关的panic，比如数组越界是什么时候调用runtime.panicIndex，是有个额外的线程不断检测有异常了吗？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511798,"discussion_content":"当然不是了，是执行程序的程序碰到严重错误就抛出来，属于Go运行时系统的职责范围。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608031203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2925541,"avatar":"","nickname":"Geek_f0ae52","note":"","ucode":"C0CF6A54280522","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558203,"discussion_content":"这个应该是在编译的过程中，但凡永奥数组取值的地方，编译器会直接插入一条检测角标是否越界的代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648132740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2369701,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/PeibZXsEcwic1zvrAQpDlnNlPxZvmAtIZ6XCenC8NaPbVVfCk7PXgAYzb8icqrYlb9cJd82hia9FYTicxqSdgyCEP4w/132","nickname":"Geek_37a441","note":"","ucode":"72A2EEBA0C1DBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335280,"discussion_content":"感觉还是有点没太明白，Go运行时候系统怎么知道该跳转到panic呢？，就比如访问一个空指针的成员，对应指令可能就是取这个空指针的内容，取出来发现是nil，cpu怎么知道该跳转到call  panic了呢 ，假如是编译器编译时候检测到可能访问了某个空指针的成员，预先把指令跳转到这个指令 call  runtime.panic的逻辑编译到可执行程序的指令集中。  但假如编译时候就能发现可能发生panic，为啥还要放到运行时抛出呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608134145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2369701,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/PeibZXsEcwic1zvrAQpDlnNlPxZvmAtIZ6XCenC8NaPbVVfCk7PXgAYzb8icqrYlb9cJd82hia9FYTicxqSdgyCEP4w/132","nickname":"Geek_37a441","note":"","ucode":"72A2EEBA0C1DBC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401565,"discussion_content":"好问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633692603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":335280,"ip_address":""},"score":401565,"extra":""}]}]},{"had_liked":false,"id":195107,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1585137064,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585137064","product_id":100013101,"comment_content":"今日总结<br>今天主要是讲了panic运行时恐慌，一般发生在运行时<br>同样也可以自己调用内置的panic来主动引起恐慌 一般用来自己调试程序异常等等<br>主要掌握panic的执行过程 <br>首先从某一行引起了panic 然后返回到其调用函数 这样一级一级的返回 直到最顶层也即main函数中 最后把控制权交给了go运行时状态，最后程序奔溃 进程退出<br>panic的信息一般也在这个返回过程中不断的完善<br>panic: runtime error: index out of range &#47;&#47;错误信息<br>&#47;&#47;以下是调用堆栈<br>goroutine 1 [running]:<br>main.caller2()<br>        &#47;home&#47;ubuntu&#47;geek_go&#47;Golang_Puzzlers&#47;src&#47;puzzlers&#47;article19&#47;q1&#47;demo48.go:22 +0x91<br>main.caller1()<br>        &#47;home&#47;ubuntu&#47;geek_go&#47;Golang_Puzzlers&#47;src&#47;puzzlers&#47;article19&#47;q1&#47;demo48.go:15 +0x66<br>main.main()<br>        &#47;home&#47;ubuntu&#47;geek_go&#47;Golang_Puzzlers&#47;src&#47;puzzlers&#47;article19&#47;q1&#47;demo48.go:9 +0x66<br>exit status 2<br>关于思考题 我也先想了一下 我们捕获异常并将错误信息封装到一个error当中最后返回这个err<br>后来又去翻了解答 好像就是这个 样子的","like_count":0},{"had_liked":false,"id":62485,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1548068907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548068907","product_id":100013101,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":53672,"user_name":"melody_future","can_delete":false,"product_type":"c1","uid":1072632,"ip_address":"","ucode":"AEF6218FDA0B0A","user_header":"https://static001.geekbang.org/account/avatar/00/10/5d/f8/62a8b90d.jpg","comment_is_top":false,"comment_ctime":1545708478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545708478","product_id":100013101,"comment_content":"panic、recover 有点像try、、catch。这样应该会好理解很多","like_count":0}]}