{"id":73161,"title":"15 | 答疑文章（一）：日志和索引相关问题","content":"<p>在今天这篇答疑文章更新前，MySQL实战这个专栏已经更新了14篇。在这些文章中，大家在评论区留下了很多高质量的留言。现在，每篇文章的评论区都有热心的同学帮忙总结文章知识点，也有不少同学提出了很多高质量的问题，更有一些同学帮忙解答其他同学提出的问题。</p><p>在浏览这些留言并回复的过程中，我倍受鼓舞，也尽我所知地帮助你解决问题、和你讨论。可以说，你们的留言活跃了整个专栏的氛围、提升了整个专栏的质量，谢谢你们。</p><p>评论区的大多数留言我都直接回复了，对于需要展开说明的问题，我都拿出小本子记了下来。这些被记下来的问题，就是我们今天这篇答疑文章的素材了。</p><p>到目前为止，我已经收集了47个问题，很难通过今天这一篇文章全部展开。所以，我就先从中找了几个联系非常紧密的问题，串了起来，希望可以帮你解决关于日志和索引的一些疑惑。而其他问题，我们就留着后面慢慢展开吧。</p><h1>日志相关问题</h1><p>我在第2篇文章<a href=\"https://time.geekbang.org/column/article/68633\">《日志系统：一条SQL更新语句是如何执行的？》</a>中，和你讲到binlog（归档日志）和redo log（重做日志）配合崩溃恢复的时候，用的是反证法，说明了如果没有两阶段提交，会导致MySQL出现主备数据不一致等问题。</p><p>在这篇文章下面，很多同学在问，在两阶段提交的不同瞬间，MySQL如果发生异常重启，是怎么保证数据完整性的？</p><!-- [[[read_end]]] --><p>现在，我们就从这个问题开始吧。</p><p>我再放一次两阶段提交的图，方便你学习下面的内容。</p><p><img src=\"https://static001.geekbang.org/resource/image/ee/2a/ee9af616e05e4b853eba27048351f62a.jpg?wh=1142*1522\" alt=\"\"></p><center><span class=\"reference\">图1 两阶段提交示意图</span></center><p>这里，我要先和你解释一个误会式的问题。有同学在评论区问到，这个图不是一个update语句的执行流程吗，怎么还会调用commit语句？</p><p>他产生这个疑问的原因，是把<strong>两个“commit”的概念</strong>混淆了：</p><ul>\n<li>他说的“commit语句”，是指MySQL语法中，用于提交一个事务的命令。一般跟begin/start transaction 配对使用。</li>\n<li>而我们图中用到的这个“commit步骤”，指的是事务提交过程中的一个小步骤，也是最后一步。当这个步骤执行完成后，这个事务就提交完成了。</li>\n<li>“commit语句”执行的时候，会包含“commit 步骤”。</li>\n</ul><p>而我们这个例子里面，没有显式地开启事务，因此这个update语句自己就是一个事务，在执行完成后提交事务时，就会用到这个“commit步骤“。</p><p>接下来，我们就一起分析一下<strong>在两阶段提交的不同时刻，MySQL异常重启会出现什么现象。</strong></p><p>如果在图中时刻A的地方，也就是写入redo log 处于prepare阶段之后、写binlog之前，发生了崩溃（crash），由于此时binlog还没写，redo log也还没提交，所以崩溃恢复的时候，这个事务会回滚。这时候，binlog还没写，所以也不会传到备库。到这里，大家都可以理解。</p><p>大家出现问题的地方，主要集中在时刻B，也就是binlog写完，redo log还没commit前发生crash，那崩溃恢复的时候MySQL会怎么处理？</p><p>我们先来看一下崩溃恢复时的判断规则。</p><ol>\n<li>\n<p>如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交；</p>\n</li>\n<li>\n<p>如果redo log里面的事务只有完整的prepare，则判断对应的事务binlog是否存在并完整：<br>\na.  如果是，则提交事务；<br>\nb.  否则，回滚事务。</p>\n</li>\n</ol><p>这里，时刻B发生crash对应的就是2(a)的情况，崩溃恢复过程中事务会被提交。</p><p>现在，我们继续延展一下这个问题。</p><h2>追问1：MySQL怎么知道binlog是完整的?</h2><p>回答：一个事务的binlog是有完整格式的：</p><ul>\n<li>statement格式的binlog，最后会有COMMIT；</li>\n<li>row格式的binlog，最后会有一个XID event。</li>\n</ul><p>另外，在MySQL 5.6.2版本以后，还引入了binlog-checksum参数，用来验证binlog内容的正确性。对于binlog日志由于磁盘原因，可能会在日志中间出错的情况，MySQL可以通过校验checksum的结果来发现。所以，MySQL还是有办法验证事务binlog的完整性的。</p><h2>追问2：redo log 和 binlog是怎么关联起来的?</h2><p>回答：它们有一个共同的数据字段，叫XID。崩溃恢复的时候，会按顺序扫描redo log：</p><ul>\n<li>如果碰到既有prepare、又有commit的redo log，就直接提交；</li>\n<li>如果碰到只有parepare、而没有commit的redo log，就拿着XID去binlog找对应的事务。</li>\n</ul><h2>追问3：处于prepare阶段的redo log加上完整binlog，重启就能恢复，MySQL为什么要这么设计?</h2><p>回答：其实，这个问题还是跟我们在反证法中说到的数据与备份的一致性有关。在时刻B，也就是binlog写完以后MySQL发生崩溃，这时候binlog已经写入了，之后就会被从库（或者用这个binlog恢复出来的库）使用。</p><p>所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p><h2>追问4：如果这样的话，为什么还要两阶段提交呢？干脆先redo log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？</h2><p>回答：其实，两阶段提交是经典的分布式系统问题，并不是MySQL独有的。</p><p>如果必须要举一个场景，来说明这么做的必要性的话，那就是事务的持久性问题。</p><p>对于InnoDB引擎来说，如果redo log提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。而如果redo log直接提交，然后binlog写入的时候失败，InnoDB又回滚不了，数据和binlog日志又不一致了。</p><p>两阶段提交就是为了给所有人一个机会，当每个人都说“我ok”的时候，再一起提交。</p><h2>追问5：不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？</h2><p>回答：这位同学的意思是，只保留binlog，然后可以把提交流程改成这样：… -&gt; “数据更新到内存” -&gt; “写 binlog” -&gt; “提交事务”，是不是也可以提供崩溃恢复的能力？</p><p>答案是不可以。</p><p>如果说<strong>历史原因</strong>的话，那就是InnoDB并不是MySQL的原生存储引擎。MySQL的原生引擎是MyISAM，设计之初就有没有支持崩溃恢复。</p><p>InnoDB在作为MySQL的插件加入MySQL引擎家族之前，就已经是一个提供了崩溃恢复和事务支持的引擎了。</p><p>InnoDB接入了MySQL后，发现既然binlog没有崩溃恢复的能力，那就用InnoDB原有的redo log好了。</p><p>而如果说<strong>实现上的原因</strong>的话，就有很多了。就按照问题中说的，只用binlog来实现崩溃恢复的流程，我画了一张示意图，这里就没有redo log了。</p><p><img src=\"https://static001.geekbang.org/resource/image/eb/63/eb838b87e9c20fa00aca50ef154f2a63.jpg?wh=1142*856\" alt=\"\"></p><center><span class=\"reference\">图2 只用binlog支持崩溃恢复</span></center><p>这样的流程下，binlog还是不能支持崩溃恢复的。我说一个不支持的点吧：binlog没有能力恢复“数据页”。</p><p>如果在图中标的位置，也就是binlog2写完了，但是整个事务还没有commit的时候，MySQL发生了crash。</p><p>重启后，引擎内部事务2会回滚，然后应用binlog2可以补回来；但是对于事务1来说，系统已经认为提交完成了，不会再应用一次binlog1。</p><p>但是，InnoDB引擎使用的是WAL技术，执行事务的时候，写完内存和日志，事务就算完成了。如果之后崩溃，要依赖于日志来恢复数据页。</p><p>也就是说在图中这个位置发生崩溃的话，事务1也是可能丢失了的，而且是数据页级的丢失。此时，binlog里面并没有记录数据页的更新细节，是补不回来的。</p><p>你如果要说，那我优化一下binlog的内容，让它来记录数据页的更改可以吗？但，这其实就是又做了一个redo log出来。</p><p>所以，至少现在的binlog能力，还不能支持崩溃恢复。</p><h2>追问6：那能不能反过来，只用redo log，不要binlog？</h2><p>回答：如果只从崩溃恢复的角度来讲是可以的。你可以把binlog关掉，这样就没有两阶段提交了，但系统依然是crash-safe的。</p><p>但是，如果你了解一下业界各个公司的使用场景的话，就会发现在正式的生产库上，binlog都是开着的。因为binlog有着redo log无法替代的功能。</p><p>一个是归档。redo log是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log也就起不到归档的作用。</p><p>一个就是MySQL系统依赖于binlog。binlog作为MySQL一开始就有的功能，被用在了很多地方。其中，MySQL系统高可用的基础，就是binlog复制。</p><p>还有很多公司有异构系统（比如一些数据分析系统），这些系统就靠消费MySQL的binlog来更新自己的数据。关掉binlog的话，这些下游系统就没法输入了。</p><p>总之，由于现在包括MySQL高可用在内的很多系统机制都依赖于binlog，所以“鸠占鹊巢”redo log还做不到。你看，发展生态是多么重要。</p><h2>追问7：redo log一般设置多大？</h2><p>回答：redo log太小的话，会导致很快就被写满，然后不得不强行刷redo log，这样WAL机制的能力就发挥不出来了。</p><p>所以，如果是现在常见的几个TB的磁盘的话，就不要太小气了，直接将redo log设置为4个文件、每个文件1GB吧。</p><h2>追问8：正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的还是从buffer pool更新过来的呢？</h2><p>回答：这个问题其实问得非常好。这里涉及到了，“redo log里面到底是什么”的问题。</p><p>实际上，redo log并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就不存在“数据最终落盘，是由redo log更新过去”的情况。</p><ol>\n<li>\n<p>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与redo log毫无关系。</p>\n</li>\n<li>\n<p>在崩溃恢复场景中，InnoDB如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让redo log更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。</p>\n</li>\n</ol><h2>追问9：redo log buffer是什么？是先修改内存，还是先写redo log文件？</h2><p>回答：这两个问题可以一起回答。</p><p>在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：</p><pre><code>begin;\ninsert into t1 ...\ninsert into t2 ...\ncommit;\n</code></pre><p>这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没commit的时候就直接写到redo log文件里。</p><p>所以，redo log buffer就是一块内存，用来先存redo日志的。也就是说，在执行第一个insert的时候，数据的内存被修改了，redo log buffer也写入了日志。</p><p>但是，真正把日志写到redo log文件（文件名是 ib_logfile+数字），是在执行commit语句的时候做的。</p><p>（这里说的是事务执行过程中不会“主动去刷盘”，以减少不必要的IO消耗。但是可能会出现“被动写入磁盘”，比如内存不够、其他事务提交等情况。这个问题我们会在后面第22篇文章《MySQL有哪些“饮鸩止渴”的提高性能的方法？》中再详细展开）。</p><p>单独执行一个更新语句的时候，InnoDB会自己启动一个事务，在语句执行完成的时候提交。过程跟上面是一样的，只不过是“压缩”到了一个语句里面完成。</p><p>以上这些问题，就是把大家提过的关于redo log和binlog的问题串起来，做的一次集中回答。如果你还有问题，可以在评论区继续留言补充。</p><h1>业务设计问题</h1><p>接下来，我再和你分享@ithunter 同学在第8篇文章<a href=\"https://time.geekbang.org/column/article/70562\">《</a><a href=\"https://time.geekbang.org/column/article/70562\">事务到底是隔离的还是不隔离的？</a><a href=\"https://time.geekbang.org/column/article/70562\">》</a>的评论区提到的跟索引相关的一个问题。我觉得这个问题挺有趣、也挺实用的，其他同学也可能会碰上这样的场景，在这里解答和分享一下。</p><p>问题是这样的（我文字上稍微做了点修改，方便大家理解）：</p><blockquote>\n<p>业务上有这样的需求，A、B两个用户，如果互相关注，则成为好友。设计上是有两张表，一个是like表，一个是friend表，like表有user_id、liker_id两个字段，我设置为复合唯一索引即uk_user_id_liker_id。语句执行逻辑是这样的：</p>\n</blockquote><blockquote>\n<p>以A关注B为例：<br>\n第一步，先查询对方有没有关注自己（B有没有关注A）<br>\nselect * from like where user_id = B and liker_id = A;</p>\n</blockquote><blockquote>\n<p>如果有，则成为好友<br>\ninsert into friend;</p>\n</blockquote><blockquote>\n<p>没有，则只是单向关注关系<br>\ninsert into like;</p>\n</blockquote><blockquote>\n<p>但是如果A、B同时关注对方，会出现不会成为好友的情况。因为上面第1步，双方都没关注对方。第1步即使使用了排他锁也不行，因为记录不存在，行锁无法生效。请问这种情况，在MySQL锁层面有没有办法处理？</p>\n</blockquote><p>首先，我要先赞一下这样的提问方式。虽然极客时间现在的评论区还不能追加评论，但如果大家能够一次留言就把问题讲清楚的话，其实影响也不大。所以，我希望你在留言提问的时候，也能借鉴这种方式。</p><p>接下来，我把@ithunter 同学说的表模拟出来，方便我们讨论。</p><pre><code>CREATE TABLE `like` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `user_id` int(11) NOT NULL,\n  `liker_id` int(11) NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uk_user_id_liker_id` (`user_id`,`liker_id`)\n) ENGINE=InnoDB;\n\nCREATE TABLE `friend` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `friend_1_id` int(11) NOT NULL,\n  `friend_2_id` int(11) NOT NULL,\n  UNIQUE KEY `uk_friend` (`friend_1_id`,`friend_2_id`),\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB;\n</code></pre><p>虽然这个题干中，并没有说到friend表的索引结构。但我猜测friend_1_id和friend_2_id也有索引，为便于描述，我给加上唯一索引。</p><p>顺便说明一下，“like”是关键字，我一般不建议使用关键字作为库名、表名、字段名或索引名。</p><p>我把他的疑问翻译一下，在并发场景下，同时有两个人，设置为关注对方，就可能导致无法成功加为朋友关系。</p><p>现在，我用你已经熟悉的时刻顺序表的形式，把这两个事务的执行语句列出来：<br>\n<img src=\"https://static001.geekbang.org/resource/image/c4/ed/c45063baf1ae521bf5d98b6d7c0e0ced.png?wh=1248*694\" alt=\"\"></p><center><span class=\"reference\">图3 并发“喜欢”逻辑操作顺序</span></center><p>由于一开始A和B之间没有关注关系，所以两个事务里面的select语句查出来的结果都是空。</p><p>因此，session 1的逻辑就是“既然B没有关注A，那就只插入一个单向关注关系”。session 2也同样是这个逻辑。</p><p>这个结果对业务来说就是bug了。因为在业务设定里面，这两个逻辑都执行完成以后，是应该在friend表里面插入一行记录的。</p><p>如提问里面说的，“第1步即使使用了排他锁也不行，因为记录不存在，行锁无法生效”。不过，我想到了另外一个方法，来解决这个问题。</p><p>首先，要给“like”表增加一个字段，比如叫作 relation_ship，并设为整型，取值1、2、3。</p><blockquote>\n<p>值是1的时候，表示user_id 关注 liker_id;<br>\n值是2的时候，表示liker_id 关注 user_id;<br>\n值是3的时候，表示互相关注。</p>\n</blockquote><p>然后，当 A关注B的时候，逻辑改成如下所示的样子：</p><p>应用代码里面，比较A和B的大小，如果A&lt;B，就执行下面的逻辑</p><pre><code>mysql&gt; begin; /*启动事务*/\ninsert into `like`(user_id, liker_id, relation_ship) values(A, B, 1) on duplicate key update relation_ship=relation_ship | 1;\nselect relation_ship from `like` where user_id=A and liker_id=B;\n/*代码中判断返回的 relation_ship，\n  如果是1，事务结束，执行 commit\n  如果是3，则执行下面这两个语句：\n  */\ninsert ignore into friend(friend_1_id, friend_2_id) values(A,B);\ncommit;\n</code></pre><p>如果A&gt;B，则执行下面的逻辑</p><pre><code>mysql&gt; begin; /*启动事务*/\ninsert into `like`(user_id, liker_id, relation_ship) values(B, A, 2) on duplicate key update relation_ship=relation_ship | 2;\nselect relation_ship from `like` where user_id=B and liker_id=A;\n/*代码中判断返回的 relation_ship，\n  如果是2，事务结束，执行 commit\n  如果是3，则执行下面这两个语句：\n*/\ninsert ignore into friend(friend_1_id, friend_2_id) values(B,A);\ncommit;\n</code></pre><p>这个设计里，让“like”表里的数据保证user_id &lt; liker_id，这样不论是A关注B，还是B关注A，在操作“like”表的时候，如果反向的关系已经存在，就会出现行锁冲突。</p><p>然后，insert … on duplicate语句，确保了在事务内部，执行了这个SQL语句后，就强行占住了这个行锁，之后的select 判断relation_ship这个逻辑时就确保了是在行锁保护下的读操作。</p><p>操作符 “|” 是按位或，连同最后一句insert语句里的ignore，是为了保证重复调用时的幂等性。</p><p>这样，即使在双方“同时”执行关注操作，最终数据库里的结果，也是like表里面有一条关于A和B的记录，而且relation_ship的值是3， 并且friend表里面也有了A和B的这条记录。</p><p>不知道你会不会吐槽：之前明明还说尽量不要使用唯一索引，结果这个例子一上来我就创建了两个。这里我要再和你说明一下，之前文章我们讨论的，是在“业务开发保证不会插入重复记录”的情况下，着重要解决性能问题的时候，才建议尽量使用普通索引。</p><p>而像这个例子里，按照这个设计，业务根本就是保证“我一定会插入重复数据，数据库一定要要有唯一性约束”，这时就没啥好说的了，唯一索引建起来吧。</p><h1>小结</h1><p>这是专栏的第一篇答疑文章。</p><p>我针对前14篇文章，大家在评论区中的留言，从中摘取了关于日志和索引的相关问题，串成了今天这篇文章。这里我也要再和你说一声，有些我答应在答疑文章中进行扩展的话题，今天这篇文章没来得及扩展，后续我会再找机会为你解答。所以，篇幅所限，评论区见吧。</p><p>最后，虽然这篇是答疑文章，但课后问题还是要有的。</p><p>我们创建了一个简单的表t，并插入一行，然后对这一行做修改。</p><pre><code>mysql&gt; CREATE TABLE `t` (\n`id` int(11) NOT NULL primary key auto_increment,\n`a` int(11) DEFAULT NULL\n) ENGINE=InnoDB;\ninsert into t values(1,2);\n</code></pre><p>这时候，表t里有唯一的一行数据(1,2)。假设，我现在要执行：</p><pre><code>mysql&gt; update t set a=2 where id=1;\n</code></pre><p>你会看到这样的结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/36/70/367b3f299b94353f32f75ea825391170.png?wh=691*103\" alt=\"\"><br>\n结果显示，匹配(rows matched)了一行，修改(Changed)了0行。</p><p>仅从现象上看，MySQL内部在处理这个命令的时候，可以有以下三种选择：</p><ol>\n<li>\n<p>更新都是先读后写的，MySQL读出数据，发现a的值本来就是2，不更新，直接返回，执行结束；</p>\n</li>\n<li>\n<p>MySQL调用了InnoDB引擎提供的“修改为(1,2)”这个接口，但是引擎发现值与原来相同，不更新，直接返回；</p>\n</li>\n<li>\n<p>InnoDB认真执行了“把这个值修改成(1,2)\"这个操作，该加锁的加锁，该更新的更新。</p>\n</li>\n</ol><p>你觉得实际情况会是以上哪种呢？你可否用构造实验的方式，来证明你的结论？进一步地，可以思考一下，MySQL为什么要选择这种策略呢？</p><p>你可以把你的验证方法和思考写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1>上期问题时间</h1><p>上期的问题是，用一个计数表记录一个业务表的总行数，在往业务表插入数据的时候，需要给计数值加1。</p><p>逻辑实现上是启动一个事务，执行两个语句：</p><ol>\n<li>\n<p>insert into 数据表；</p>\n</li>\n<li>\n<p>update 计数表，计数值加1。</p>\n</li>\n</ol><p>从系统并发能力的角度考虑，怎么安排这两个语句的顺序。</p><p>这里，我直接复制 @阿建 的回答过来供你参考：</p><blockquote>\n<p>并发系统性能的角度考虑，应该先插入操作记录，再更新计数表。<br>\n知识点在<a href=\"https://time.geekbang.org/column/article/70215\">《行锁功过：怎么减少行锁对性能的影响？》</a><br>\n因为更新计数表涉及到行锁的竞争，先插入再更新能最大程度地减少事务之间的锁等待，提升并发度。</p>\n</blockquote><p>评论区有同学说，应该把update计数表放后面，因为这个计数表可能保存了多个业务表的计数值。如果把update计数表放到事务的第一个语句，多个业务表同时插入数据的话，等待时间会更长。</p><p>这个答案的结论是对的，但是理解不太正确。即使我们用一个计数表记录多个业务表的行数，也肯定会给表名字段加唯一索引。类似于下面这样的表结构：</p><pre><code>CREATE TABLE `rows_stat` (\n  `table_name` varchar(64) NOT NULL,\n  `row_count` int(10) unsigned NOT NULL,\n  PRIMARY KEY (`table_name`)\n) ENGINE=InnoDB;\n</code></pre><p>在更新计数表的时候，一定会传入where table_name=$table_name，使用主键索引，更新加行锁只会锁在一行上。</p><p>而在不同业务表插入数据，是更新不同的行，不会有行锁。</p><p>评论区留言点赞板：</p><blockquote>\n<p>@北天魔狼、@斜面镜子 Bil 和@Bin 等同学，都给出了正确答案；<br>\n@果然如此 同学提了一个好问题，虽然引入事务，避免看到”业务上还没提交的更新”，但是Redis的计数被提前看到了。核心原因还是两个系统，不支持一致性视图；<br>\n@ 帆帆帆帆帆帆帆帆 同学的问题提醒了大家，count(id)也是可以走普通索引得到的。</p>\n</blockquote>","comments":[{"had_liked":false,"id":50628,"user_name":"萤火虫","can_delete":false,"product_type":"c1","uid":1333142,"ip_address":"","ucode":"FA4AB9636C53C4","user_header":"https://static001.geekbang.org/account/avatar/00/14/57/96/b65bdf43.jpg","comment_is_top":true,"comment_ctime":1545017865,"is_pvip":false,"replies":[{"id":"18172","content":"加油。<br><br>说下我自己的理解。<br><br>我在带新人的时候，要求大家在写SQL语句的时候，心里是有数的，知道每个语句执行的结果，以及这些代码会消耗什么资源、如果慢了会慢在哪里、每个语句执行会占用哪些锁等等。<br><br>有的新人会问“为什么需要这么麻烦，我执行一下，看看结果对不对，对了就行，不对就改，是不是也可以？”<br><br>我说不可以。因为如果这样，我们就会受到很多局限，即使我们定位自己是业务开发人员。<br><br>这里我说一个限制：<br><br>这会限制基于数据库的业务架构能力。一个语句可以试，一个五个语句的事务分析就要试很多次，一个复杂业务系统的数据库设计，是试不出来的。<br><br>原理可以帮我们剪枝，排除掉那些理论上明显错误的方案，这样才有精力真的去试那些有限的、可能正确的方案。<br><br><br>我们不需要100%精通MySQL(我自己离这个目标也相去甚远），但是只要多知道一些原理，就能多剪一些枝，架构设计就能少一些错误选项的干扰，设计出来的项目架构正确的可能性更高。<br><br>我自己特别喜欢这个剪枝的过程和感觉，他表示我用以前学习的时间，来节省了现在工作的时间。<br><br><br>当然，“原理”是一个很大的概念，有的原理更接近实战，有的远一些。这个专栏我挑的是跟平时使用相关的原理，以便大家可以有机会边学边用。<br><br>一起加油吧🤝<br><br>","user_name":"作者回复","comment_id":50628,"uid":"1264162","ip_address":"","utype":1,"ctime":1545020674,"user_name_real":"林晓斌"}],"discussion_count":15,"race_medal":0,"score":"9.2233741858834002e+18","product_id":100020801,"comment_content":"林老师的每次更新我都会跟着看 跟着学 已经坚持15节课了 受益良多 只是心里有时会反问自己 底层原理有那么重要吗？ 会用不就行了吗？ 自己不知道该怎么推翻这些想法 加上自己有个不好的习惯 就是容易放弃 希望自己能够坚持到最后。 ","like_count":501,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433041,"discussion_content":"加油。\n\n说下我自己的理解。\n\n我在带新人的时候，要求大家在写SQL语句的时候，心里是有数的，知道每个语句执行的结果，以及这些代码会消耗什么资源、如果慢了会慢在哪里、每个语句执行会占用哪些锁等等。\n\n有的新人会问“为什么需要这么麻烦，我执行一下，看看结果对不对，对了就行，不对就改，是不是也可以？”\n\n我说不可以。因为如果这样，我们就会受到很多局限，即使我们定位自己是业务开发人员。\n\n这里我说一个限制：\n\n这会限制基于数据库的业务架构能力。一个语句可以试，一个五个语句的事务分析就要试很多次，一个复杂业务系统的数据库设计，是试不出来的。\n\n原理可以帮我们剪枝，排除掉那些理论上明显错误的方案，这样才有精力真的去试那些有限的、可能正确的方案。\n\n\n我们不需要100%精通MySQL(我自己离这个目标也相去甚远），但是只要多知道一些原理，就能多剪一些枝，架构设计就能少一些错误选项的干扰，设计出来的项目架构正确的可能性更高。\n\n我自己特别喜欢这个剪枝的过程和感觉，他表示我用以前学习的时间，来节省了现在工作的时间。\n\n\n当然，“原理”是一个很大的概念，有的原理更接近实战，有的远一些。这个专栏我挑的是跟平时使用相关的原理，以便大家可以有机会边学边用。\n\n一起加油吧🤝\n\n","likes_number":16,"is_delete":false,"is_hidden":false,"ctime":1545020674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1180967,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/27/36c74bcd.jpg","nickname":"杨溢","note":"","ucode":"AC8D8896B3AAE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":573372,"discussion_content":"林老师真的很耐心且友善，点赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653380081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":433041,"ip_address":""},"score":573372,"extra":""},{"author":{"id":1296063,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c6/bf/52b3f71d.jpg","nickname":"dawn","note":"","ucode":"1757B28F1EF5C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":583379,"discussion_content":"前端有一本书叫《锋利的jequery》，作者的观点是学的越多，写的越快，这只是针对一些简单的语法类的知识。当遇到复杂问题时，最艰难的一步是根据表象抽丝剥茧，找到真正的原因。某大型视频公司，搜索服务挂了，导致首页客户端搜索都不可用，一看搜索的机器cpu被打满，按照经验看是出现了死循环，但这些服务最近一个月都没有发版，只有最近下游发布了个实验，最后查出来是下游实验，在很低频的情况下，没有按照约定传递参数，导致搜索服务使用位移操作符无法正确退出，进入了死循环。\n\n回头看真简单的原因，但发布了两次，花了一天，拉了三四个团队才真正解决，这是由生产环境复杂性决定的。你并不知道你需要面对怎样一场硬仗，你唯一能做的，就是磨好你的刀。如果你不想一到战场就手足无措被乱刀砍死，亦或者你想成为那个闪着光的男人，都请练好基本功。\n","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1660089894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":433041,"ip_address":"江苏"},"score":583379,"extra":""}]},{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4751,"discussion_content":"说到底还是面得少。。。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1565704570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2014285,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKNv880TlsNuKaWcKbxiaAZTQIBWfJAddC8wfOROnwRPRwJXaEGSTBH2sic4jK7IGpxZn79tTDcREjw/132","nickname":"Geek_7482f6","note":"","ucode":"F3565F78525D30","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407560,"discussion_content":"哈哈哈哈，真实。不过也能理解啊~理解这些底层知识还是很费力的尤其是平时还是996的情况下，发发牢骚还是蛮正常的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635059643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4751,"ip_address":""},"score":407560,"extra":""}]},{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203076,"discussion_content":"我要能遇到老师这样的带人方式就太好了","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1583992387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35799,"discussion_content":"“我用以前学习的时间，来节省了现在工作的时间”你所有的努力何尝不是如此呢？！从订阅专栏到一直坚持到现在，对于每一讲不懂的地方都查看评论，去网上搜索，感觉自己了解了很多！感谢","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1571305685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1302228,"avatar":"https://static001.geekbang.org/account/avatar/00/13/de/d4/b83c4185.jpg","nickname":"David.cui","note":"","ucode":"AB46F310403612","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3793,"discussion_content":"现在不学习原理，以后就等着埋坑吧。我遇到一个客户，delete了上亿条数据；他居然不知道truncate。同样的功能可以实现，但是他不理解delete的代价有多大","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1564815060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2039257,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/1d/d9/746e45be.jpg","nickname":"黄时捷","note":"","ucode":"C9FC8F8812F7B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1302228,"avatar":"https://static001.geekbang.org/account/avatar/00/13/de/d4/b83c4185.jpg","nickname":"David.cui","note":"","ucode":"AB46F310403612","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292090,"discussion_content":"truncate不是drop+create吗 跟delete有什么关系?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595079504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3793,"ip_address":""},"score":292090,"extra":""},{"author":{"id":1155646,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKotsBr2icbYNYlRSlicGUD1H7lulSTQUAiclsEz9gnG5kCW9qeDwdYtlRMXic3V6sj9UrfKLPJnQojag/132","nickname":"ppd0705","note":"","ucode":"EB63D4E3FD1E9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2039257,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/1d/d9/746e45be.jpg","nickname":"黄时捷","note":"","ucode":"C9FC8F8812F7B1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299774,"discussion_content":"truncate和detele all 效果类似 TRUNCATE TABLE is similar to a DELETE statement that deletes all rows, or a sequence of DROP TABLE and CREATE TABLE statements.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597812894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":292090,"ip_address":""},"score":299774,"extra":""}]},{"author":{"id":1683256,"avatar":"https://static001.geekbang.org/account/avatar/00/19/af/38/37301993.jpg","nickname":"爱的旅途","note":"","ucode":"1184646EFBDCE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381084,"discussion_content":"如果你一辈子想做一个码农，就不用学原理。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1624889047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1183672,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0f/b8/d10bc2d4.jpg","nickname":"Pp、x","note":"","ucode":"9623E33BE20C1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309415,"discussion_content":"老师真好诶，可惜编码路上没有遇到过良师","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601283510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1834181,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/fc/c5/ff8b770e.jpg","nickname":"BugBean","note":"","ucode":"B51232281AD9BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258232,"discussion_content":"听老师这样讲阔然开朗，果然评论区是最大的宝藏","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588668393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1052821,"avatar":"https://static001.geekbang.org/account/avatar/00/10/10/95/17a9a042.jpg","nickname":"coco","note":"","ucode":"7BC3AB84E8434E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536694,"discussion_content":"多好的指点，我之前遇到的都是你管那么多干嘛，先这么弄，以后有问题再说","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638846912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1032000,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bf/40/94eaca1b.jpg","nickname":"wei","note":"","ucode":"8B14D27AE7C54E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394047,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631697947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50743,"user_name":"某、人","can_delete":false,"product_type":"c1","uid":1308784,"ip_address":"","ucode":"ADB42AA12A11C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/f8/70/f3a33a14.jpg","comment_is_top":true,"comment_ctime":1545037678,"is_pvip":false,"replies":[{"id":"18225","content":"老板看完板，正要告知孔乙己今日总账是赊账二两酒，<br>小二连忙过来拦住，“老板，刚刚孔乙己刚又赊账了一碟茴香豆。”<br>老板大惊，“差点亏了我一碟豆子！我怎不知？”<br>小二道，“老板你方才看板的之时没拿记账笔，我看记账笔没人使用，按店规自然可用。老板你自己没看”<br><br>老板惊呼，“亏的你小心”。<br><br>暗地想店规确有不妥。<br><br>于是把店规“变账须用记账笔。” 改为<br>“改帐均须动笔。纵为不变之帐，仍需覆写之”<br><br>😄","user_name":"作者回复","comment_id":50743,"uid":"1264162","ip_address":"","utype":1,"ctime":1545051054,"user_name_real":"林晓斌"}],"discussion_count":10,"race_medal":0,"score":"9.2233741815885005e+18","product_id":100020801,"comment_content":"孔乙己来到酒馆大喊一声老板来二两酒赊着,酒馆生意太好,老板把孔乙己的欠账记录记到小黑板上并记录了孔乙己点的菜单。孔乙己跟别人吹了会牛,忘了叫的几两酒了。又给老板说,老板把酒改成二两。老板也不确定孔乙己叫没叫酒,就去查菜单,发现孔乙己确实点了酒,但是本来就二两,也就难得麻烦了,又要修改小黑板,又要改菜单。直接就给孔乙己说已经改好了。😄","like_count":499,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433079,"discussion_content":"老板看完板，正要告知孔乙己今日总账是赊账二两酒，\n小二连忙过来拦住，“老板，刚刚孔乙己刚又赊账了一碟茴香豆。”\n老板大惊，“差点亏了我一碟豆子！我怎不知？”\n小二道，“老板你方才看板的之时没拿记账笔，我看记账笔没人使用，按店规自然可用。老板你自己没看”\n\n老板惊呼，“亏的你小心”。\n\n暗地想店规确有不妥。\n\n于是把店规“变账须用记账笔。” 改为\n“改帐均须动笔。纵为不变之帐，仍需覆写之”\n\n😄","likes_number":16,"is_delete":false,"is_hidden":false,"ctime":1545051054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1806081,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/8f/01/2fbc5cc9.jpg","nickname":"xiaozeng","note":"","ucode":"C517E55357315C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293250,"discussion_content":"有意思 双簧","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1595492343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1806081,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/8f/01/2fbc5cc9.jpg","nickname":"xiaozeng","note":"","ucode":"C517E55357315C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401123,"discussion_content":"双簧是一个人坐前面无声演，一个人躲后面说。:)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633572033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":293250,"ip_address":""},"score":401123,"extra":""}]},{"author":{"id":2120690,"avatar":"","nickname":"风间","note":"","ucode":"2DA14C209AD31F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404302,"discussion_content":"所以老板最终的选择是 3！","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1634284017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136267,"avatar":"https://static001.geekbang.org/account/avatar/00/11/56/8b/6f547e7d.jpg","nickname":"Mercury","note":"","ucode":"AE7A9DA3591A74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388732,"discussion_content":"👍，被耽误的小说家。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1628929177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1966594,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/fs63ENRylGMQnk5giaSic6m3gRmhcUEGdIQgaTjAsTWetcSicEsxTOdMiaVHUdxy3WNA4LJkZy1cJ69sEMKzJw5PHg/132","nickname":"無道者","note":"","ucode":"59DEABFE838C12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361773,"discussion_content":"读书人！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1616748607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306712,"discussion_content":"厉害。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600352406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300785,"discussion_content":"也就是说，默认是不会覆写的，但是可以配置为覆写","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598264103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1019302,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/a6/22c37c91.jpg","nickname":"楊_宵夜","note":"","ucode":"7BA0CADC5F23BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308602,"discussion_content":"必须覆写, 事务1update同一时刻, 事务2也update, 事务1, 2都必须抢锁, 才能执行各自的update逻辑, 不管update逻辑是什么, 都必须抢锁再update.","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1601003483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300785,"ip_address":""},"score":308602,"extra":""}]},{"author":{"id":2678569,"avatar":"https://static001.geekbang.org/account/avatar/00/28/df/29/3c956177.jpg","nickname":"上海","note":"","ucode":"6A4F9D80D25028","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410915,"discussion_content":"好活🐶","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635814767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50756,"user_name":"Gavin","can_delete":false,"product_type":"c1","uid":1134148,"ip_address":"","ucode":"0C7C27BC2736B6","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/44/66450d97.jpg","comment_is_top":true,"comment_ctime":1545040026,"is_pvip":false,"replies":[{"id":"18202","content":"漂亮","user_name":"作者回复","comment_id":50756,"uid":"1264162","ip_address":"","utype":1,"ctime":1545041335,"user_name_real":"林晓斌"}],"discussion_count":16,"race_medal":0,"score":"9.2233730047675003e+18","product_id":100020801,"comment_content":"课后问题：<br>在命令行先执行以下命令（注意不要提交事务）：<br>BEGIN;<br>UPDATE t SET a=2 WHERE id=1;<br><br>新建一个命令行终端，执行以下命令：<br>UPDATE t SET a=2 WHERE id=1;<br><br>从新建的命令行终端的执行结果看，这条更新语句被阻塞了，如果时间足够的话（InnoDB行锁默认等待时间是50秒），还会报锁等待超时的错误。<br>综上，MySQL应该是采用第3种方式处理题述场景。<br><br>对于MySQL为什么采用这种方式，我们可以利用《08 | 事务到底是隔离的还是不隔离的？》图5的更新逻辑图来解释：假设事务C更新后a的值就是2，而事务B执行再执行UPDATE t SET a=2 WHERE id=1;时不按第3种方式处理，即不加锁不更新，那么在事务B中接下来查询a的值将还是1，因为对事务B来说，trx_id为102版本的数据是不可见的，这就违反了“当前读的规则”。<br><br>以上是我的理解与分析，不是很确定准确与否。<br>","like_count":225,"discussions":[{"author":{"id":1237327,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/4f/00476b4c.jpg","nickname":"Remember九离","note":"","ucode":"97EE6E6344689F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278939,"discussion_content":"不是很懂 a一直是2啊，就算没更新 a在创建的时候不就是2吗","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1591261421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1762602,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e5/2a/38e4c07e.jpg","nickname":"ZHI","note":"","ucode":"573BB83EC7086D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1237327,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/4f/00476b4c.jpg","nickname":"Remember九离","note":"","ucode":"97EE6E6344689F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534135,"discussion_content":"他假设的a初始等于1，事务B和事务C都去更新这个值，相互隔离但内部能看到自己的修改，都能读到2。所以两个事务都切实做出了更新操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638105677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":278939,"ip_address":""},"score":534135,"extra":""}]},{"author":{"id":2035912,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/10/c8/325f1463.jpg","nickname":"叫练","note":"","ucode":"ABAFDFE0FAFEA2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287708,"discussion_content":"是的，假如开启了事务A，再开启事务B,事务B更新了一条数据并提交事务B，此时事务A是看不到B更新的数据，那事务怎么样才能看的到呢？事务A更新，会在B的版本基础上再创建一个新版本，称为当前读（其实也就是在B的基础上再加版本），回到问题，如果此时A的update不更新，相当于就不会创建版本，那事务A的值，还是原值，完全看不到了，mvcc版本失效","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1593515883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1477324,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8a/cc/da9adc82.jpg","nickname":"小太阳","note":"","ucode":"3B1C90425E485D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2035912,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/10/c8/325f1463.jpg","nickname":"叫练","note":"","ucode":"ABAFDFE0FAFEA2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319452,"discussion_content":"简单总结就是说:如果不更新，会使当前读失效","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1604033605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":287708,"ip_address":""},"score":319452,"extra":""}]},{"author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6966,"discussion_content":"大佬怎么才能和你这么优秀","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1567229463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2287841,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e8/e1/6045b299.jpg","nickname":"LPF","note":"","ucode":"036C552D7251E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328262,"discussion_content":"用更新语句的当前读特性来测试这个更新，到底更新没更新，厉害呀~","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606113954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433085,"discussion_content":"漂亮","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1545041335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1710489,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/19/99/ba3719e1.jpg","nickname":"The brain is a good thing","note":"","ucode":"7CE2C85BC5C092","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287642,"discussion_content":"MVCC看来确实影响了很多策略","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593502044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1263932,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","nickname":"静静聆听","note":"","ucode":"0A8600CB928EFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287580,"discussion_content":"怎么才能像你这么优秀，大佬","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593485300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1723655,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/4d/07/7d331b04.jpg","nickname":"小码渣","note":"","ucode":"8432409D9616D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114108,"discussion_content":"那怎么解释 Changed: 0 呢 ？ ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577958239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1335293,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","nickname":"周治慧","note":"","ucode":"7D56C4E66BEE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1723655,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/4d/07/7d331b04.jpg","nickname":"小码渣","note":"","ucode":"8432409D9616D1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187623,"discussion_content":"更新语句返回的影响的行数数据一致的话就是0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582757922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":114108,"ip_address":""},"score":187623,"extra":""},{"author":{"id":1155646,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKotsBr2icbYNYlRSlicGUD1H7lulSTQUAiclsEz9gnG5kCW9qeDwdYtlRMXic3V6sj9UrfKLPJnQojag/132","nickname":"ppd0705","note":"","ucode":"EB63D4E3FD1E9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1335293,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","nickname":"周治慧","note":"","ucode":"7D56C4E66BEE17","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299775,"discussion_content":"请问一致是怎么判断的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597813200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":187623,"ip_address":""},"score":299775,"extra":""}]},{"author":{"id":2135401,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/b24L6aN3myzq1dTibqq40yQWq8kj6OZRc3PFZUtKVcHl8x69DAPERZibbuUBGCK8ibUiaic7adhB42HTAOnc0PqUuPw/132","nickname":"Geek_92b6bb","note":"","ucode":"ECDBF12771D0D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300791,"discussion_content":"这个不需要关注bin log 是row 还是 statement吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598264878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2843604,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/63/d4/b63373c3.jpg","nickname":"金金","note":"","ucode":"807EDDCDB2E939","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2135401,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/b24L6aN3myzq1dTibqq40yQWq8kj6OZRc3PFZUtKVcHl8x69DAPERZibbuUBGCK8ibUiaic7adhB42HTAOnc0PqUuPw/132","nickname":"Geek_92b6bb","note":"","ucode":"ECDBF12771D0D4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560757,"discussion_content":"需要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649432109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300791,"ip_address":""},"score":560757,"extra":""}]},{"author":{"id":1599454,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLOKzDVXse2WibsBGOR27GVYOlv8WRtFBfQe4ekNia2S5986QibD6Wv17gyDpZqmQt3kJcAcbhl3rroQ/132","nickname":"itsxun","note":"","ucode":"69E6CEA3FCB4F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285500,"discussion_content":"漂亮","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592845037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1672786,"avatar":"https://static001.geekbang.org/account/avatar/00/19/86/52/91c7d112.jpg","nickname":"Garen","note":"","ucode":"0608C88F83EF0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":33519,"discussion_content":"我思考了一下为什么我会没想到：还是因为我思维太狭窄，没想过多事务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571131142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51096,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":true,"comment_ctime":1545113514,"is_pvip":false,"replies":[{"id":"18417","content":"“我说，这次查了缓存”<br><br>哈哈，这个场景好棒，这个画面感，有一种扫地僧的感觉👍🏿<br><br>一起加油<br><br>","user_name":"作者回复","comment_id":51096,"uid":"1264162","ip_address":"","utype":1,"ctime":1545116709,"user_name_real":"林晓斌"}],"discussion_count":11,"race_medal":0,"score":"9.2233727212996997e+18","product_id":100020801,"comment_content":"看到自己的问题上榜，这是对自己的最大鼓励。<br><br>学习专栏之前，自己只是一个 CRUD boy，平时同事间讨论 MySQL 的问题，自己完全搭不上话，因为对 MySQL 底层原理完全不懂。对 MySQL 的认知就仅限一点：索引能提高查询效率。但是为什么能提高？不知道！！<br><br>现在回想，以前犯过很多错误：<br>1. 主键使用 UUID，非自增主键。<br>2. 滥用索引，其实可以通过“最左前缀原则”来精减索引。<br>3. 不管 SQL 语句是否合理，只要能返回结果集就是好 SQL。<br>4. 建表时字段类型拿捏不准。<br><br>现在都会反复学习专栏的每一篇文章，每次学习都有不一样的收获。<br>第一次可能是：喔，原来有这么个知识点，但对它的实现原理一知半解。<br>第二次却是：对它的实现原理有了更深的认识，加强对知识的理解，基本会形成一个比较清晰的逻辑。<br>第三次是，MySQL 的这种实现原理，是为了解决什么问题等等。<br><br>现在感觉有点“走火入魔”了，以前执行查询语句，关注的多久能返回结果集。<br>现在关注的却是：连接器、分析器、优化器、执行器和 InnoDB 引擎。<br>连接成功后，获取我的权限，查询缓存，命中缓存直接返回，否则进行后续的操作。（记得老师留言区回复过：连接器取权限，执行器用权限。而编写留言到这产生了一个疑问：查询缓存前，应该会校验权限，所以连接器也会用权限？）<br>分析器阶段进行词法分析，解析关键字，字段名，表名等。语法分析判断语法是否正确。（记得第一篇《基础架构》留言提到语义分析，今晚要找资料学习下）。<br>优化器阶段生成执行计划，选择索引（这时会怀疑 MySQL 选择的索引是否最优），能否使用索引下推和覆盖索引减少回表查询，提高性能。<br>执行器阶段调用引擎接口查询数据，Server 层要啥，引擎给啥，InnoDB 只给必要的值。<br>查询结束后，返回结果集，并将结果集放入查询缓存。<br><br>更新语句的关注点是隔离性，视图，MVCC，回滚日志，redo log，binlog，两阶段提交等。<br>写业务代码时，会考虑事务内的 SQL 语句，能否调整 SQL 语句的顺序，减少更新表时行锁对性能的影响。<br>在建表的时，会反复推敲这个索引是否合理。使用普通索引还是唯一索引更为合适。能否通过“最左前缀原则”来减少创建索引的个数。如果索引字段的类型是字符串并长度太长，如何优化使用前缀索引，减少空间占用，提高查询性能。<br><br>学习专栏后，基本上涉及到 MySQL 的内容，这些知识点都会浮现在脑海中。昨天还差点应用这些知识，帮同事优化他的 SQL 语句。昨天跟往常一样，当写代码写累了，就跑到同事那溜达溜达。<br>他正在线上的备库测试查询百万数据要多久，另一位同事建议他使用 force index 强制索引，这次执行 5 秒，再执行零点几秒。<br>他惊乎，为啥这次这么快。我说，这次查了缓存。我还想帮他看看 SQL 语句，是否 MySQL 选择错了索引，导致使用 force index 显式指定索引。说不定使用 order by field 就解决了呢，哈哈哈哈。后面有事，没有继续跟进他这问题了。<br><br>非常感恩，跟着老师学习，让我体会到了学习是一件自然而又充满魅力的事情，也让我从一个基础不牢固的小白，一步步地充实了自己的知识库，另外老师非常尽责，经常半夜回复答疑，希望老师保重身体。谢谢！！","like_count":160,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433280,"discussion_content":"“我说，这次查了缓存”\n\n哈哈，这个场景好棒，这个画面感，有一种扫地僧的感觉👍🏿\n\n一起加油\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545116709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1262519,"avatar":"https://static001.geekbang.org/account/avatar/00/13/43/b7/74a91222.jpg","nickname":"寒浅","note":"","ucode":"6846680A3B04AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4466,"discussion_content":"完全说出了我的心声666","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1565442975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1324314,"avatar":"https://static001.geekbang.org/account/avatar/00/14/35/1a/9fa38dc9.jpg","nickname":"子瞻","note":"","ucode":"5C26FF10934534","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163987,"discussion_content":"看到你的评论，非常感同身受！以后多多向你学习","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1581133702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401129,"discussion_content":"兄弟临走时应该来句：一下子聊不完，你要好奇的话，可以去极客时间看《MySQL实战45讲》。:)","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1633572519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1941769,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/a1/09/5e21297f.jpg","nickname":"小平","note":"","ucode":"A0FAFEDDEFFEC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227133,"discussion_content":"8.0  query cache 已经弃用了，这画面是不是应该消失了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586456857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":2009461,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/a9/75/dbccd12d.jpg","nickname":"稻草人","note":"","ucode":"6694EE2CD36B8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1941769,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/a1/09/5e21297f.jpg","nickname":"小平","note":"","ucode":"A0FAFEDDEFFEC2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327912,"discussion_content":"不能这么说，知道8.0弃用查缓存是要的。但是目前来说企业为了求稳，大部分用的还是5.6-5.7之类的版本，查缓存还是在的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606016396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":227133,"ip_address":""},"score":327912,"extra":""},{"author":{"id":1926222,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/64/4e/83c61c7f.jpg","nickname":"靓仔","note":"","ucode":"077A290A2DCF42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1941769,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/a1/09/5e21297f.jpg","nickname":"小平","note":"","ucode":"A0FAFEDDEFFEC2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577010,"discussion_content":"有buffer_pool LRU缓存页 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655882121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":227133,"ip_address":""},"score":577010,"extra":""},{"author":{"id":1780797,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/2c/3d/0bd58aa4.jpg","nickname":"Em","note":"","ucode":"32012A5C603C8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1941769,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/a1/09/5e21297f.jpg","nickname":"小平","note":"","ucode":"A0FAFEDDEFFEC2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577077,"discussion_content":"innodb自己本身就有缓存页  buffer_pool  弃用的是server层的cache","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655907412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":227133,"ip_address":""},"score":577077,"extra":""}]},{"author":{"id":1335293,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","nickname":"周治慧","note":"","ucode":"7D56C4E66BEE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187626,"discussion_content":"嗯 平时工作还是要多去思考 多帮人去处理问题,只有知识储备足够应对问题才能不手忙脚乱","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582758479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2821728,"avatar":"","nickname":"600988292","note":"","ucode":"24BAE2B7A7B1E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539635,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639794536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1974935,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/22/97/1aefb289.jpg","nickname":"廿一","note":"","ucode":"4B672E258C6B04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388896,"discussion_content":"大佬了..","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629030656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52093,"user_name":"力挽狂澜爆炸输出的臭臭宁","can_delete":false,"product_type":"c1","uid":1155904,"ip_address":"","ucode":"E8D26181129BCA","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/40/e0df3b84.jpg","comment_is_top":true,"comment_ctime":1545309381,"is_pvip":false,"replies":[{"id":"18915","content":"是的，binlog一来时机控制不好（就是你说的这个），二来内容的能力不足（没有页面信息）<br>👍🏿<br>","user_name":"作者回复","comment_id":52093,"uid":"1264162","ip_address":"","utype":1,"ctime":1545315361,"user_name_real":"林晓斌"}],"discussion_count":9,"race_medal":0,"score":"9.2233721715441009e+18","product_id":100020801,"comment_content":"针对不能只用binlog完成数据恢复我的理解：<br>按照文中这个话题下的示例，因为MySQL写数据是写在内存里的，不保证落盘，所以commit1的数据也可能丢失；但是恢复只恢复binlog失败的也就是commit2的数据，所以数据会丢失。<br>这样理解对吗？","like_count":31,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433737,"discussion_content":"是的，binlog一来时机控制不好（就是你说的这个），二来内容的能力不足（没有页面信息）\n👍🏿\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545315361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293483,"discussion_content":"落盘一般是调用linux底层的fsync  无非是 是主动调用还是自动的周期性的调用fsync","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1595556180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2142240,"avatar":"https://static001.geekbang.org/account/avatar/00/20/b0/20/6d0f4587.jpg","nickname":"美好的未来","note":"","ucode":"2E2432913874D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387889,"discussion_content":"binlog的刷盘时机是有配置的，sync_binlog=1的时候每次提交事务都刷盘。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628488762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053553,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/71/3762b089.jpg","nickname":"stevensafin","note":"","ucode":"CC692A740C5FD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340387,"discussion_content":"这里如果说binlog是row格式的话  是不是就没有这个问题  row格式的可能会导致一个数据多次刷盘，但是数据的可靠性应该是不会有损失的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609991738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1685743,"avatar":"https://static001.geekbang.org/account/avatar/00/19/b8/ef/06dc955b.jpg","nickname":"ftuokl","note":"","ucode":"2C27EE145EDB5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32645,"discussion_content":"那binlog什么时候才落盘？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571054695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1685743,"avatar":"https://static001.geekbang.org/account/avatar/00/19/b8/ef/06dc955b.jpg","nickname":"ftuokl","note":"","ucode":"2C27EE145EDB5B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158838,"discussion_content":"binlog不落盘，落盘靠内存","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580632487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":32645,"ip_address":""},"score":158838,"extra":""},{"author":{"id":1335293,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","nickname":"周治慧","note":"","ucode":"7D56C4E66BEE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187627,"discussion_content":"binlog自身是会落盘的 你说的落盘靠内存是内存中脏页数据的落盘","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582758567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":158838,"ip_address":""},"score":187627,"extra":""},{"author":{"id":2287841,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e8/e1/6045b299.jpg","nickname":"LPF","note":"","ucode":"036C552D7251E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1335293,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","nickname":"周治慧","note":"","ucode":"7D56C4E66BEE17","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328338,"discussion_content":"binlog cache写入binlog文件，但不会立即刷盘","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606124635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":187627,"ip_address":""},"score":328338,"extra":""}]}]},{"had_liked":false,"id":50714,"user_name":"于海","can_delete":false,"product_type":"c1","uid":1054754,"ip_address":"","ucode":"19C026AC2A5A9E","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/22/e817914c.jpg","comment_is_top":false,"comment_ctime":1545033908,"is_pvip":false,"replies":[{"id":"18206","content":"谢谢🙏 <br>希望大家都有收获","user_name":"作者回复","comment_id":50714,"uid":"1264162","ip_address":"","utype":1,"ctime":1545041673,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"272127973556","product_id":100020801,"comment_content":"在极客时间也学了不少课程，林老师是这其中最认真负责的，好的课程是用“心”写出来的","like_count":63,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433071,"discussion_content":"谢谢🙏 \n希望大家都有收获","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545041673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50621,"user_name":"陈新仁","can_delete":false,"product_type":"c1","uid":1309925,"ip_address":"","ucode":"C0F8E3BC334A45","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/e5/c26c67ea.jpg","comment_is_top":false,"comment_ctime":1545017207,"is_pvip":false,"replies":[{"id":"18189","content":"你说得对，是按位或，看得很细致👍🏿<br><br>我发个堪误","user_name":"作者回复","comment_id":50621,"uid":"1264162","ip_address":"","utype":1,"ctime":1545027363,"user_name_real":"林晓斌"}],"discussion_count":9,"race_medal":0,"score":"224883316599","product_id":100020801,"comment_content":"【操作符“|”是逻辑或，连同最后一句insert语句里...】<br>老师，“|” 这应该叫位运算符的按位或操作符，逻辑或是“||”吧？<br>这里的幂等性原理就是：A &lt; B: relation_ship = 2 | 1; A &gt; B:relation_ship = 1 | 2；重复插入 3 | 1 或者 3 | 2 。位运算： 2 | 1 == 1 | 2 == 3 | 1 == 3 | 2 == 3。感觉这里想法很巧妙。","like_count":52,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433039,"discussion_content":"你说得对，是按位或，看得很细致👍🏿\n\n我发个堪误","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545027363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1159317,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbUHD8KH3mYz39QuHj5BXB06VqCus5WR4oHfNuSYdPVLno3Tq61yhMiaugxpMicKibDFQ4KwX7icoDWQ/132","nickname":"ipromiseu","note":"","ucode":"775E2CC0E7CA69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":131012,"discussion_content":"这里的设计虽是巧妙，单不具备通用性，不是每次遇到类似的问题都能找到巧妙的方案。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578819194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2009461,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/a9/75/dbccd12d.jpg","nickname":"稻草人","note":"","ucode":"6694EE2CD36B8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1159317,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbUHD8KH3mYz39QuHj5BXB06VqCus5WR4oHfNuSYdPVLno3Tq61yhMiaugxpMicKibDFQ4KwX7icoDWQ/132","nickname":"ipromiseu","note":"","ucode":"775E2CC0E7CA69","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327916,"discussion_content":"设计的思想是通用的。。。精妙的设计思路有了，可以举一反三的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606016770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":131012,"ip_address":""},"score":327916,"extra":""}]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293485,"discussion_content":"其实我理解 这个业务场景，业务更好规避，比如每次做关注动作之后发送mq，由另外一个好友服务检查是否要成为好友，可以让mq消息一定时间之后消费。因为本身这个业务逻辑并不是一定要实时的。只需要在业务容许范围成立即可。这样db性能足够高，设计也更精简，唯一的缺陷就是可能不那么即使，但是 如果玩微博的知道，一般关注完之后，再找到好友沟通栏，再搜索，这个耗时极大。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595556342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2009461,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/a9/75/dbccd12d.jpg","nickname":"稻草人","note":"","ucode":"6694EE2CD36B8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327915,"discussion_content":"但其实还是没有从根本上解决并发问题，mq消息还是会有并发可能的：比如刚好两个好友关注的消息同时到达，就又还是回到文章的问题中。。。\nmq并不能解决并发问题，只是说能起到削峰、异步等的作用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606016693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":293485,"ip_address":""},"score":327915,"extra":""}]},{"author":{"id":1723655,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/4d/07/7d331b04.jpg","nickname":"小码渣","note":"","ucode":"8432409D9616D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114109,"discussion_content":"这里的设计确实巧妙，老师为什么在这里设置的是1 2 3 呢？ 如果设置其他值，会不会也能达到同样的效果 ？ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577958314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1997293,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/79/ed/4737a49b.jpg","nickname":"雪の雫·雨の音","note":"","ucode":"0693DA3939A321","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1723655,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/4d/07/7d331b04.jpg","nickname":"小码渣","note":"","ucode":"8432409D9616D1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267330,"discussion_content":"只要你能找到 a | b = c的这样满足关系的三个数就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589633146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":114109,"ip_address":""},"score":267330,"extra":""}]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37592,"discussion_content":"如果是按位或的话2 | 1 结果应该为3吧。我看@陈新仁给出的答案是1，即“2 | 1 == 1”，是我计算错了吗？请指正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571642859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1014615,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/57/18b61282.jpg","nickname":"dullduck","note":"","ucode":"25293558309704","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51094,"discussion_content":"你理解错了，别人是说 2|1==1|2 ,结果都等于3","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1573810196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":37592,"ip_address":""},"score":51094,"extra":""}]}]},{"had_liked":false,"id":50576,"user_name":"Eric","can_delete":false,"product_type":"c1","uid":1056767,"ip_address":"","ucode":"30300D7B752917","user_header":"https://static001.geekbang.org/account/avatar/00/10/1f/ff/aadcf237.jpg","comment_is_top":false,"comment_ctime":1545011230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"190523572254","product_id":100020801,"comment_content":"老师，您实在是太良心了。整理这些问题应该很费时间吧。看完答疑之后感觉又加深了一遍印象。像很多知识点都需要反复理解才能真正掌握。答疑来的很及时，感谢！","like_count":44},{"had_liked":false,"id":52647,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1545466221,"is_pvip":false,"replies":[{"id":"19165","content":"1. 刷脏页是只把内存上最新版本的数据页写到磁盘上。 第一个碰到的redolog会把这个脏页刷下去，注意redolog并没有修改内存数据页的数据（这个不是崩溃恢复过程哦）<br>后面再碰到这个页面的redolog,这个页面是干净页了，不用刷直接跳过<br><br>2. 第二个问题的两个问号是一个答案：不用清除。 下次redo log来刷的时候看到是干净页就直接过了。<br><br>好问题。","user_name":"作者回复","comment_id":52647,"uid":"1264162","ip_address":"","utype":1,"ctime":1545478884,"user_name_real":"林晓斌"}],"discussion_count":14,"race_medal":0,"score":"160459256173","product_id":100020801,"comment_content":"关于刷脏页有两个问题请教老师:<br>1. 当redo log空间不足时,  按照redo log的顺序把脏页更新到磁盘, 那么假如一个脏页在第1条redo log中已经被持久化到磁盘,  后面第1000条redo log又有这个关于这个脏页的信息, 那么innoDB是直接丢弃掉这条redo log的记录吗? 还有这个时候, 是要把redo log上的全部内容更新到磁盘吗, 还是更新一部分?<br><br>2. 当内存不足开始刷脏页的时候, 以内存为刷脏页发起点, 这时是把最久不使用的数据页从内存中淘汰掉, 那么这个时候, 对应的额redo log是不是也会清除? 而对于该脏页的操作可能在redo log中并不是连续的记录, redo log有只能顺序读写, 那么redo log是怎么清除掉关于这个脏页的所有记录的?","like_count":37,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433936,"discussion_content":"1. 刷脏页是只把内存上最新版本的数据页写到磁盘上。 第一个碰到的redolog会把这个脏页刷下去，注意redolog并没有修改内存数据页的数据（这个不是崩溃恢复过程哦）\n后面再碰到这个页面的redolog,这个页面是干净页了，不用刷直接跳过\n\n2. 第二个问题的两个问号是一个答案：不用清除。 下次redo log来刷的时候看到是干净页就直接过了。\n\n好问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545478884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2287841,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e8/e1/6045b299.jpg","nickname":"LPF","note":"","ucode":"036C552D7251E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328351,"discussion_content":"看LSN吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606125672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1526355,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","nickname":"moonfox","note":"","ucode":"902BFF40EFA9FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2287841,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e8/e1/6045b299.jpg","nickname":"LPF","note":"","ucode":"036C552D7251E9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330536,"discussion_content":"＋1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606642480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":328351,"ip_address":""},"score":330536,"extra":""}]},{"author":{"id":2036924,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/14/bc/326284b1.jpg","nickname":"ambrella","note":"","ucode":"9C0019364DCBB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390240,"discussion_content":"好问题啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629725210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1644104,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","nickname":"茶没喝完","note":"","ucode":"D72D88C42A1258","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332999,"discussion_content":"对一个页的多次修改只要刷一次脏页就行了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607412926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2287841,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e8/e1/6045b299.jpg","nickname":"LPF","note":"","ucode":"036C552D7251E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328348,"discussion_content":"刷脏页是把最新版本的数据写到磁盘上，但是之前版本不就没了？怎么保证MVCC","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606125203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1970443,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIx1V1QAxC4NHaxYZGyuibBN8lcURJWc5nrnO4yic1kxnDemYV2FJGialf47kYX9qtDnZZOfe1SJeLicg/132","nickname":"lleft","note":"","ucode":"D573EB509455AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2287841,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e8/e1/6045b299.jpg","nickname":"LPF","note":"","ucode":"036C552D7251E9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372301,"discussion_content":"MVCC是跟undo相关，跟redo没关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620279785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":328348,"ip_address":""},"score":372301,"extra":""},{"author":{"id":2083187,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/c9/73/047f51d2.jpg","nickname":"ybonfire","note":"","ucode":"9A8D541DEFFBB4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2287841,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e8/e1/6045b299.jpg","nickname":"LPF","note":"","ucode":"036C552D7251E9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380653,"discussion_content":"最新数据+Undo Log","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624616715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":328348,"ip_address":""},"score":380653,"extra":""}]},{"author":{"id":1282641,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/51/0505254d.jpg","nickname":"Fighter","note":"","ucode":"B1925EE400372D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310947,"discussion_content":"没太明白老师对这两个问题的回答，redo log里面页不一定在内存里，还有一些change buffer的变更，没来得及merge的，在write pos跟checkpoint重合的时候就要将磁盘读取这些页，第一个问题是想问的是假如有该页的多条变更的情况如何处理，我的理解是移动checkpoint的时候，读到操作，merge操作到page，此时page就是脏页了，后续对该页更新跟读都是依赖mvcc（undo redo）？烦请老师解答下，迷糊了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602152442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1140175,"avatar":"https://static001.geekbang.org/account/avatar/00/11/65/cf/326c0eea.jpg","nickname":"x-ray","note":"","ucode":"8363F0C4D0AC0B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1282641,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/51/0505254d.jpg","nickname":"Fighter","note":"","ucode":"B1925EE400372D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323614,"discussion_content":"我看了几遍，说下我的想法，redo log里面的页，可能确实不一定在内存里，就像你说的，可能会先写入到chang buffer里。按照原先的理解，这部分数据被read的时候才会merge，然后变成脏页。如果在刷盘前，发生读事件，导致merge，那后面刷盘的行为应该和其它脏页一样，这个我觉得问题不大。问题在于，要刷盘时，如果还没有merge，会怎么处理？1.如果是redo log 要擦除的部分恰好是change buffer的数据。2.如果是内存不够，要淘汰的内存，恰好是change buffer的数据。我觉得无论哪一种，都应该会强行merge，不知道是不是这样？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604975013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310947,"ip_address":""},"score":323614,"extra":""},{"author":{"id":2166073,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/k3YD3y3BzGDSdrwRJyJY4BXsNJibfM4uzOdDVKIAlFApR2FZCLg2ibrZtJ4vuahA3LHLW9GKzH5CMGqCDhWjhZqg/132","nickname":"戒酒的李白","note":"","ucode":"744E1A22761647","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1140175,"avatar":"https://static001.geekbang.org/account/avatar/00/11/65/cf/326c0eea.jpg","nickname":"x-ray","note":"","ucode":"8363F0C4D0AC0B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403075,"discussion_content":"1. redo 擦除的时候，分为两种情况： 如果页在内存中， 那这个页肯定是merge过了（页载入内存的时候， 就会先应用Change Buffer），这个时候只需要判断是否为脏页，如果是脏页， 则刷脏；如果是干净页，则直接清除redolog。  如果页不在内存中， 则会先将磁盘页载入到内存中 ， 然后应用change buffer（如果 有的话）， 然后走判断是否为脏页的逻辑。\n2. 要淘汰的内存是change buffer的数据， 也没关系， change buffer也有落盘的。   \n总之， 磁盘页载入内存的时候（一般是有查询请求涉及到该页，或者是崩溃恢复）， 一定会触发merge操作。 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634003729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":323614,"ip_address":""},"score":403075,"extra":""}]},{"author":{"id":1547667,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9d/93/4159edaa.jpg","nickname":"朴素柠檬c","note":"","ucode":"2D4CBB70D801B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245889,"discussion_content":"redolog是个保底的东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587708689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1145404,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg","nickname":"堵车","note":"","ucode":"7BC1E50A4F8D3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57592,"discussion_content":"mysql怎么判断这个页是干净页，不需要刷磁盘？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574622601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1762252,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e3/cc/0947ff0b.jpg","nickname":"nestle","note":"","ucode":"469800BED81B54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1145404,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg","nickname":"堵车","note":"","ucode":"7BC1E50A4F8D3D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84934,"discussion_content":"LSN","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1576508646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57592,"ip_address":""},"score":84934,"extra":""}]}]},{"had_liked":false,"id":82078,"user_name":"刘志兵","can_delete":false,"product_type":"c1","uid":1441734,"ip_address":"","ucode":"A90C2FA49EDC23","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/c6/8b5cbe97.jpg","comment_is_top":false,"comment_ctime":1554115169,"is_pvip":false,"replies":[{"id":"30015","content":"是这样的<br>一个事务的binlog如果回放，就是重做这个事务，一个事务更新的可能不止一个page。<br><br>比如一个事务更新了page ABC<br>然后崩溃回复了，B坏了，AC没问题，而且AC还落盘了。<br>这样如果重做事务，B好了，AC又坏了","user_name":"作者回复","comment_id":82078,"uid":"1264162","ip_address":"","utype":1,"ctime":1554432249,"user_name_real":"林晓斌"}],"discussion_count":11,"race_medal":0,"score":"117518232161","product_id":100020801,"comment_content":"老师您好，读了很久其他问题都明白了，还是没太明白只用binlog为啥不能恢复数据，根本原因还是对binlog和redolog都记录的内容没掌握清楚，我的理解跟评论区里“得不到de颜色”说的一样，就是binlog也同样记录了一行数据，但是不知道该从哪里回放，所以没法恢复，但是redo log可以从check_point开始扫描所以能恢复；<br>看到你回复的是binlog没有能力做出来一页的数据，反正缺失的数据都记在binlog里了，如果能有办法知道binlog从哪里回放，回放一遍就可以了，为啥一定要做一页数据出来，麻烦老师解答一下，谢谢","like_count":27,"discussions":[{"author":{"id":2278559,"avatar":"https://static001.geekbang.org/account/avatar/00/22/c4/9f/a01e4bd1.jpg","nickname":"海浪","note":"","ucode":"091941B3556B4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326462,"discussion_content":"数据的落盘是以page为最小单位，而redo log记录的维度也是page。而对于binglog，记录的维度太粗，是以单条语句的维度记录的。","likes_number":16,"is_delete":false,"is_hidden":false,"ctime":1605600073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1096248,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ba/38/cc5b50f6.jpg","nickname":"森淼👌","note":"","ucode":"B98AE9B22F50F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413162,"discussion_content":"binlog是逻辑日志，可能包含多个page，假设记录了一条逻辑日志update table set a=a+1;多次重放后结果一定是有问题的。如果是redo log，它和具体的page挂钩，“page 111， table, a, old value 1, new value 5&#34;，像这条物理日志不论重放多少次，a的值结果不会有问题","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1636387792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110149,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f0/85/fca692bf.jpg","nickname":"zhendecai","note":"","ucode":"DD27D314F8177D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260052,"discussion_content":"如果采用的row，同时记录所有行的信息，理论上回写的时候可以做到和redolog一样的幂等操作吧。其实也是这个数据页做了什么操作变成了什么样子，那是不是也可以做成crash-safe","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588844315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":7,"child_discussions":[{"author":{"id":2036468,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/12/f4/c5cc59f0.jpg","nickname":"naadp","note":"","ucode":"2C853E7E89EC00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1110149,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f0/85/fca692bf.jpg","nickname":"zhendecai","note":"","ucode":"DD27D314F8177D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287426,"discussion_content":"我也是这么想的呢，有些不理解。大哥想明白了的话，麻烦和我说声儿哈。谢谢您！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593439081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":260052,"ip_address":""},"score":287426,"extra":""},{"author":{"id":1607318,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqWicbfC66qKRx32V1pNNSxJPhytPyZ612s9xN0uYHPnRJqNSWibdWg34jgKQn4YGLbs7hvAuHm0Sjg/132","nickname":"Geek_dc6fe6","note":"","ucode":"BA388E87D88D02","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2036468,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/12/f4/c5cc59f0.jpg","nickname":"naadp","note":"","ucode":"2C853E7E89EC00","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287942,"discussion_content":"我的理解是这样，按老师上面的例子继续说：\n比如一个事务更新了page ABC，崩溃了之后，B坏了，AC没问题，而且AC还落盘了，这时候如果用redo log恢复，只用单独恢复B这个数据页，就保证了ABC 3个数据页都正常，而binlog并不具备恢复单个数据页的能力，所以如果用binlog恢复，会同时恢复ABC三个数据页的内容，而AC数据页本来内容已经是对的，这样恢复后反而就坏了。（比如原先对AC是新增操作，那等于又对正确数据错误的新增了）","likes_number":25,"is_delete":false,"is_hidden":false,"ctime":1593596548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":287426,"ip_address":""},"score":287942,"extra":""},{"author":{"id":1112491,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f9/ab/90f972d3.jpg","nickname":"ey","note":"","ucode":"5965D70E6A0F19","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1607318,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqWicbfC66qKRx32V1pNNSxJPhytPyZ612s9xN0uYHPnRJqNSWibdWg34jgKQn4YGLbs7hvAuHm0Sjg/132","nickname":"Geek_dc6fe6","note":"","ucode":"BA388E87D88D02","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":288589,"discussion_content":"但如果binlog是row级别，那是不是可以只恢复数据页B上的数据行，而不是恢复ABC所有？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593806659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":287942,"ip_address":""},"score":288589,"extra":""}]},{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445458,"discussion_content":"是这样的\n一个事务的binlog如果回放，就是重做这个事务，一个事务更新的可能不止一个page。\n\n比如一个事务更新了page ABC\n然后崩溃回复了，B坏了，AC没问题，而且AC还落盘了。\n这样如果重做事务，B好了，AC又坏了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1554432249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50652,"user_name":"melon","can_delete":false,"product_type":"c1","uid":1023773,"ip_address":"","ucode":"7A80C20EBCAAA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/1d/ec173090.jpg","comment_is_top":false,"comment_ctime":1545024243,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"74559468275","product_id":100020801,"comment_content":"思考题：应该是第三种，因为两个事务并行执行该update，有一个会卡住，说明有加锁，而且update语句执行后，查看ibd文件和redo log文件的修改时间都更新了。通过show engine innodb status 进一步验证，查看LSN确实增加了，而且Number of rows updated 也加+1了。","like_count":17},{"had_liked":false,"id":50650,"user_name":"信信","can_delete":false,"product_type":"c1","uid":1303865,"ip_address":"","ucode":"8DF0EC045579FD","user_header":"https://static001.geekbang.org/account/avatar/00/13/e5/39/951f89c8.jpg","comment_is_top":false,"comment_ctime":1545023651,"is_pvip":false,"replies":[{"id":"18279","content":"不是哦，<br>在事务执行期间是在redo log buffer.<br><br>在图中写binlog之前，就已经都写了盘并且fsync了","user_name":"作者回复","comment_id":50650,"uid":"1264162","ip_address":"","utype":1,"ctime":1545056146,"user_name_real":"林晓斌"}],"discussion_count":13,"race_medal":0,"score":"65969533091","product_id":100020801,"comment_content":"如果图1的“写入redo log”是写内存，当时刻B发生crash，重启后这部分redo log都丢失了，那么何谈判断redo log是否有完整的prepare还是commit标志呢？","like_count":15,"discussions":[{"author":{"id":1060556,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2e/cc/964a8bcb.jpg","nickname":"ad","note":"","ucode":"7AC650031EB7A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272453,"discussion_content":"文中不是说“真正把日志写到 redo log 文件（文件名是 ib_logfile+ 数字），是在执行 commit 语句的时候做的。”，还是不太清楚为什么在写binlog之前，redo log buffer的数据为什么都落盘了","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1590310859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1060556,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2e/cc/964a8bcb.jpg","nickname":"ad","note":"","ucode":"7AC650031EB7A9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293955,"discussion_content":"这块我也有迷惑。在时刻B crash时，感觉可能会出现binlog已经持久化到磁盘，但由于之前的redolog还是记录在log buffer中，而crash发生后内存中的数据都已经丢失了。就会造成只有binlog，没有redo的情况，如果从库对Binlog进行重放就会造成主从数据不一致的状态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595739675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":272453,"ip_address":""},"score":293955,"extra":""},{"author":{"id":2131215,"avatar":"https://static001.geekbang.org/account/avatar/00/20/85/0f/5cb822d6.jpg","nickname":"shadow","note":"","ucode":"64DCFAEC37EFBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301459,"discussion_content":"所以在写binlog是 事务提交了 redo buffer 也落盘了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598530860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":293955,"ip_address":""},"score":301459,"extra":""},{"author":{"id":1526355,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","nickname":"moonfox","note":"","ucode":"902BFF40EFA9FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1060556,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2e/cc/964a8bcb.jpg","nickname":"ad","note":"","ucode":"7AC650031EB7A9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330548,"discussion_content":"当你执行 commit语句的时候，即，开始提交，这时执行图中 写redo log file，把redo log buffer的内容写入。才有后面的prepare等一系列操作。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606644459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":272453,"ip_address":""},"score":330548,"extra":""}]},{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433053,"discussion_content":"不是哦，\n在事务执行期间是在redo log buffer.\n\n在图中写binlog之前，就已经都写了盘并且fsync了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1545056146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1727799,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/5d/37/b3c7d6a0.jpg","nickname":"装睡的小5郎","note":"","ucode":"F4CD1B8E65B6E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341798,"discussion_content":"我也有这个疑问，binlog落盘了，redolog可能没落盘呀，这样的话主从数据就不一致了\nredolog和binlog落盘是由单独的参数控制的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610526677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1970443,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIx1V1QAxC4NHaxYZGyuibBN8lcURJWc5nrnO4yic1kxnDemYV2FJGialf47kYX9qtDnZZOfe1SJeLicg/132","nickname":"lleft","note":"","ucode":"D573EB509455AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1727799,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/5d/37/b3c7d6a0.jpg","nickname":"装睡的小5郎","note":"","ucode":"F4CD1B8E65B6E5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372311,"discussion_content":"通过两阶段提交来解决的这个问题呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620284438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":341798,"ip_address":""},"score":372311,"extra":""}]},{"author":{"id":1986739,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","nickname":"LWD","note":"","ucode":"DDA444DB113C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587472,"discussion_content":"双1才能保证不丢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663078082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1518795,"avatar":"","nickname":"Geek_2ac804","note":"","ucode":"EDF69B20030BB8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570773,"discussion_content":"如果binlog_sync=1,innodb_flush_log_at_trx_commit=2。就可能出现主机掉电，redolog丢数据，但是binlog中的数据是没有丢的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651907602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2083270,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/c9/c6/cf8e9852.jpg","nickname":"dhlpj","note":"","ucode":"250ADDFEBC969D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387800,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628419597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89481,"user_name":"greatcl","can_delete":false,"product_type":"c1","uid":1009449,"ip_address":"","ucode":"44D3C55394EC08","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/29/b0ec5430.jpg","comment_is_top":false,"comment_ctime":1556182723,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"57390757571","product_id":100020801,"comment_content":"看评论里有人说足够有钱把redo log设置无限大，老师已经回复说不能设置无限大。<br>在MySQL的一个文档里https:&#47;&#47;dev.mysql.com&#47;doc&#47;refman&#47;5.6&#47;en&#47;innodb-init-startup-configuration.html#innodb-startup-log-file-configuration看到全部redo log文件的大小是不能超过512GB的。<br>文档里建议redo log全部文件总大小的设置要能满足业务系统一个小时写操作的量，当然如果磁盘足够这个是能尽量大点就大点的。<br>二刷能学到更多的知识^_^","like_count":13,"discussions":[{"author":{"id":1770180,"avatar":"","nickname":"Geek_f5dbdf","note":"","ucode":"E21FBF68F7C6D0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572519,"discussion_content":"MARK","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652836647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1605161,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7e/29/3ff55537.jpg","nickname":"舟潇","note":"","ucode":"01380F36DA7560","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390517,"discussion_content":"redo log无限大是不是意味着内存无限大...U·ェ·U","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629872988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":70465,"user_name":"Cy190622","can_delete":false,"product_type":"c1","uid":1381528,"ip_address":"","ucode":"578D804C29248E","user_header":"https://static001.geekbang.org/account/avatar/00/15/14/98/0251b8fd.jpg","comment_is_top":false,"comment_ctime":1551102701,"is_pvip":false,"replies":[{"id":"25198","content":"1. “flush 操作:就是在刷新change buffer中数据页上的新数据。” 除了这句不太明确啥意思， 其他对的。<br>2. merge是change buffer应用到数据页，   flush是数据页从内存写到磁盘<br>","user_name":"作者回复","comment_id":70465,"uid":"1264162","ip_address":"","utype":1,"ctime":1551147958,"user_name_real":"林晓斌"}],"discussion_count":3,"race_medal":0,"score":"48795742957","product_id":100020801,"comment_content":"老师有几个问题，请教一下：<br>疑惑点：<br>1. change buffer：存在buffer pool中的数据库缓存数据，里面的数据呈数据页形式存在，<br>2.redo log；将change buffer 操作数据库的语句按照顺序记录，后再适当的时候一次提交。<br>我的理解为另一种缓存。<br>3.flush 操作:就是在刷新change buffer中数据页上的新数据。<br>merge 将change buffer中的数据同步到数据库，并获取新的数据页的过程。 <br><br>问题：1.麻烦老师指一下前面有错误的地方<br>\t  2.感觉merge 和flush两个过程很象，这两个有什么区别？<br>\t  最后感谢老师的耐心解答，谢谢您。","like_count":11,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440648,"discussion_content":"1. “flush 操作:就是在刷新change buffer中数据页上的新数据。” 除了这句不太明确啥意思， 其他对的。\n2. merge是change buffer应用到数据页，   flush是数据页从内存写到磁盘\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551147958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2805095,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/cd/67/8e8e65ce.jpg","nickname":"安之若素","note":"","ucode":"3B407E50680740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558285,"discussion_content":"flush 是落盘， merge 是从磁盘取出数据页到内存，对部分数据进行更新","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648190828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1785448,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3e/68/c2b2a285.jpg","nickname":"will","note":"","ucode":"6843B14B09192F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339524,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609720311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87022,"user_name":"小白","can_delete":false,"product_type":"c1","uid":1202143,"ip_address":"","ucode":"717B408EDC07FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Z8t0JKFjnmdx4s4wuRePZXRL2L9awEpicp0rjT9rfXmZKOBIleZuOC86OzZE0tSdkfy3LWWa7YU67MicWeiaFd3jA/132","comment_is_top":false,"comment_ctime":1555497740,"is_pvip":true,"discussion_count":8,"race_medal":0,"score":"35915236108","product_id":100020801,"comment_content":"老师，请教个问题，为什么要比较AB的大小，这快逻辑没有看懂<br><br>如果是 a喜欢b  那就insert into `like`(user_id, liker_id, relation_ship) values(A, B, 1)<br>如果是 b喜欢a  那就insert into `like`(user_id, liker_id, relation_ship) values(B, A, 1)<br>不是应该这个逻辑么？我理解错了哪里老师<br>","like_count":8,"discussions":[{"author":{"id":1723655,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/4d/07/7d331b04.jpg","nickname":"小码渣","note":"","ucode":"8432409D9616D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114120,"discussion_content":"这个地方我也是看了不止一遍，这里的AB，并不是确切的用户a和用户b，而是如方程里面的变量x，y，假设：\n第一次的时候，a的id位3，b的id为4，当a关注b时，（此时a对应的是文中的A，b对应的是文中的B）由于A的id小于B的id，所以采用 insert into `like`(user_id, liker_id, relation_ship) values(A, B, 1)，此时 like 表中 user_id = 3,liker_id 为4，relation_ship = 1。\n第二次的时候，当b关注a时，（此时b对应的是文中的A，a对应的是文中的B），由于A的id大于B的id，所以采用insert into `like`(user_id, liker_id, relation_ship) values(B, A, 2)，B对应的id为3，A对应的id为4，relation_ship = 2,由于采用了insert … on duplicate语句，此时relation_ship采用位运算 1 ｜ 2 ，结果是3，即用户a与用户b是相互喜欢，变成了事件3，就会在friend 表中添加两者相互喜欢的记录。","likes_number":18,"is_delete":false,"is_hidden":false,"ctime":1577958955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1324314,"avatar":"https://static001.geekbang.org/account/avatar/00/14/35/1a/9fa38dc9.jpg","nickname":"子瞻","note":"","ucode":"5C26FF10934534","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1723655,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/4d/07/7d331b04.jpg","nickname":"小码渣","note":"","ucode":"8432409D9616D1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163993,"discussion_content":"谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581134878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":114120,"ip_address":""},"score":163993,"extra":""},{"author":{"id":1324314,"avatar":"https://static001.geekbang.org/account/avatar/00/14/35/1a/9fa38dc9.jpg","nickname":"子瞻","note":"","ucode":"5C26FF10934534","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1723655,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/4d/07/7d331b04.jpg","nickname":"小码渣","note":"","ucode":"8432409D9616D1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318961,"discussion_content":"请问一下，你觉得老师方案中的这段sql，实际场景中实现的话直接自己封装在一个mybatis的dao层接口里面吗？\nmysql> begin; /*启动事务*/\ninsert into `like`(user_id, liker_id, relation_ship) values(B, A, 2) on duplicate key update relation_ship=relation_ship | 2;\nselect relation_ship from `like` where user_id=B and liker_id=A;\n/*代码中判断返回的 relation_ship，\n  如果是2，事务结束，执行 commit\n  如果是3，则执行下面这两个语句：\n*/\ninsert ignore into friend(friend_1_id, friend_2_id) values(B,A);\ncommit;\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603892780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":114120,"ip_address":""},"score":318961,"extra":""},{"author":{"id":2069957,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/95/c5/3307c1ca.jpg","nickname":"else","note":"","ucode":"201824A7615D6B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1324314,"avatar":"https://static001.geekbang.org/account/avatar/00/14/35/1a/9fa38dc9.jpg","nickname":"子瞻","note":"","ucode":"5C26FF10934534","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582257,"discussion_content":"这个还是得加个where 判断 要不然重复更新的时候会出现问题 因为|的时候是增量的 在新旧ship不相等的时候才能更新成功就没问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659339268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318961,"ip_address":"北京"},"score":582257,"extra":""}]},{"author":{"id":1324314,"avatar":"https://static001.geekbang.org/account/avatar/00/14/35/1a/9fa38dc9.jpg","nickname":"子瞻","note":"","ucode":"5C26FF10934534","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318960,"discussion_content":"你这种不是还是会出现并发场景下，A\\B同时关注对方，结果friend表丢失互相关注的问题吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603892276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1674602,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJPHfGiaByESiaHPWbfQicjgap3unxDsxlG6JuUCNvEFJNLibNjeX4CQYNtsvXBXqTpBERUIPyiagGBXbg/132","nickname":"Geek_55a272","note":"","ucode":"7B12A9B322B3BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":136998,"discussion_content":"为了维护字段的唯一索引关系，所以需要先查询ab的大小","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579174658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4756,"discussion_content":"为了维护relation_ship的意义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565705047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1357056,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b5/00/f4e8fbaf.jpg","nickname":"chenpiing","note":"","ucode":"C847A30B3FDB8F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1885,"discussion_content":"只用一行记录表示ab之间的关系，这样ab同时关注对方的时候需要的是同一个行锁，因此不会丢失更新？加上relation_ship是用按位与更新的，只用这一个字段就知道ab之间是单向关注还是可以成为朋友","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563033347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131038,"user_name":"leozhang","can_delete":false,"product_type":"c1","uid":1093819,"ip_address":"","ucode":"DAC9015821DAF1","user_header":"https://static001.geekbang.org/account/avatar/00/10/b0/bb/fc698888.jpg","comment_is_top":false,"comment_ctime":1567606457,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"31632377529","product_id":100020801,"comment_content":"只要binlog做宕机恢复，不知道我理解对不对，请解答下，我看留言中很多有和我类似的疑问！<br><br>假如现在有内存中的数据页 pageA,pageB,pageC,<br>假如此时pageA 有id=1,name=liu; pageB有id=2,name=liu; pageC有id=3,name=liu三个记录，<br>同事和数据库磁盘数据保持一致.假设所有liu的初始money为0<br>此时执行update t set money=money+1 where name=liu;<br>这个时候写了binlog，假设statement模式则log日志是 update t set money=money+1 where name=liu；<br>同时binlog日志写磁盘成功，<br>现在去吧pageA，pageB，pageC刷到磁盘。<br>刷盘的过程中突然断电，pageA，pageB成功，pageC失败了<br>此时就悲催了，pageA和pageB的liu money为1，pageC的liu money为0<br>假设有了binlog。事物提交，那么肯定就不对了，因为pageC数据是错误的<br>假如现在重做事物，也就是再一次执行刚刚binlog的重做日志。<br>这个时候如果重做事务，结果也不对了，是不是pageC的 money就为-1了，请指教，可能不对<br><br>其实最根本的还是，当初设计binlog的时候就没想crash恢复，<br>再就是binlog是没有记录数据页的改动的。","like_count":7,"discussions":[{"author":{"id":1112676,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","nickname":"Sam Fu","note":"","ucode":"EA285A4943271F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413105,"discussion_content":"感觉你说的对 redo log能做到crash safe\n是因为。这是我对redo log 的理解，不知道对不对 \n1. redo log是记录的某个表空间，某个数据页的某地址做了什么修改。\n2. redo log通过checkpoint维护哪些数据还未刷盘，来实现crash safe的能力。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636382498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1215167,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8a/bf/e9cc7d33.jpg","nickname":"你可以的","note":"","ucode":"685A2307830876","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342604,"discussion_content":"懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610727253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85177,"user_name":"Geek_maxwell","can_delete":false,"product_type":"c1","uid":1446442,"ip_address":"","ucode":"15FBD7BE46AC81","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbtcXw5PHzibHcXlupLmnZOYXBLR10U4Hvn5tib14EYlkMBERYgGlgZ63BxgFSBTQmUErfSXibcKl6w/132","comment_is_top":false,"comment_ctime":1554995016,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"31619766088","product_id":100020801,"comment_content":"看了一点留言，有几个问题我思考后老师帮我看看是否正确：<br>1 binlog不能恢复数据，这个是因为binlog是不清楚存储引擎有多少增量没有处理，因为存储引擎对它是透明的，所以binlog设计之初就认为要恢复就是回放所有的binlog，或者从某个时间点从库备份开始恢复剩下所有binlog<br>2 innodb具有恢复，这个主要是因为它将数据分为存量（落盘） + 增量（changeBuffer+内存中脏页），而这个增也正好是WAL中的redolog + checkpoint两个持久化的数据以及存量联合得到，那么这个增量的恢复就是一个可行性很高，代价很小的操作，因此就是可以具有数据恢复能力<br>3 redologBuffer， 这个我感觉主要作用不是说为了prepare阶段加速，因为prepare必然要sync 磁盘，因为二阶段sync也是具有持久化的保证，那么它的加速应该是为了事务过程中对于快速得到多版本信息吧，因为需要用到多版本的情况下，所需要回溯的数据总不能读redolog，那就是随机读了，而且多版本一般情况下存在的量不大，可以在内存中存在，这是为了优化随机读","like_count":7,"discussions":[{"author":{"id":1450778,"avatar":"https://static001.geekbang.org/account/avatar/00/16/23/1a/db7dd0e5.jpg","nickname":"梧桐街灯丶","note":"","ucode":"CC15DDDD933ABF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320305,"discussion_content":"多版本信息那里，能细讲下吗没看懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604316943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020492,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/4c/40783447.jpg","nickname":"何骧","note":"","ucode":"11DCC74CE2F300","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301148,"discussion_content":"第三点我觉得很有道理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598424466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63907,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1548590428,"is_pvip":false,"replies":[{"id":"22633","content":"<br><br>1. 两阶段提交主要还是因为有了两份日志😆，两份日志的历史原因多些；<br>2. 对的，XID<br>3. 是，要考虑binlog和数据的一致性；<br>4. 对的<br>5. 是脏页哈<br>6. 😅<br>7. 不能设置无限大<br>8. 是不是暗恋的妹子向你表白了😝","user_name":"作者回复","comment_id":63907,"uid":"1264162","ip_address":"","utype":1,"ctime":1548637749,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"31613361500","product_id":100020801,"comment_content":"由于工作的原因最近一段时间，没有看，为此这周末赶紧恶补了一下，在redo log和binlog的答疑中，写下自己的理解，老师帮忙看下哦<br>1、redo log和binlog采用两阶段提交，目的是为了双方能多一个选择，在mysql宕机时，如果redo log处于commit，事务直接提交，如果redo log处于prepare，binlog完整事务也提交，只有在binlog不完整时，事务会回滚，以前更新数据页会丢失。<br>2、redo log如何和binlog联系在一起，XID，在服务重启启动时，会扫描redo log中xid字段到binlog中，找相对应的事务，判断binlog的状态是否需要提交<br>3、能否在redo log写完整在写binlog么？不行，因为redo log写完，表示事务已经提交，如果在binlog写入的过程中出现异常，会导致redo log和binlog的数据不一致的问题，如果使用binlog恢复库，会导致主库和从库的数据不一致，因为redo log已提交，binlog没有写入成功，为此需要采用两阶段提交。<br>4、redo log和redo buffer的联系？<br>即在数据更新时，会先写redo buffer，因为这样可以在写redo log时，先把数据保存起来，在commit时在把数据写入redo log中，因为这样更新的时候会更快，直接更新内存，在事务处于cmmit时，才将内存中的数据写到redo log中。<br>5、数据页回复是使用buffer pool还是redo log？<br>redo log只有在数据页出现异常的时候，将其拿来恢复上次更新的数据页，但是redo log没有记录完整的数据页数据，为此在正常的情况下，都没有使用redo log，是使用buffer pool将起内部以前的数据刷新到磁盘中，其实想说，脏（这个字不会打，尴尬的一批）数据？<br>6、redo log一般设置多大？这个老师上面说的很清楚，如果磁盘的容量大，就多搞点，如果小的话可以向公司申请买好设备，要是不同意的话，就得问你们老板了，项目已si，开玩笑，哈哈哈。<br>7、只用redo log？其实你要是公司机器够大，可以设置成无限大，额，可以假装binlog，额，开玩笑的，因为redo log只有循环写，没法当做binlog，只要有钱就不好说了。<br>8、只用binlog？不行，为啥不行，百度啊，不行谷歌，好啦，开玩笑，发一下烧，因为如果在一个事务里面，同时写binlog，你看看会有什么问题，一个成功执行，一个执行失败，那会导致一个binlog可以回复数据页，一个不行，为此，导致数据页不一致，好了，今天不知道为啥那么兴奋，额，可能是，你猜吧，好了，写完我也忘了，一起拍砖","like_count":7,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437758,"discussion_content":"\n\n1. 两阶段提交主要还是因为有了两份日志😆，两份日志的历史原因多些；\n2. 对的，XID\n3. 是，要考虑binlog和数据的一致性；\n4. 对的\n5. 是脏页哈\n6. 😅\n7. 不能设置无限大\n8. 是不是暗恋的妹子向你表白了😝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548637749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50485,"user_name":"某、人","can_delete":false,"product_type":"c1","uid":1308784,"ip_address":"","ucode":"ADB42AA12A11C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/f8/70/f3a33a14.jpg","comment_is_top":false,"comment_ctime":1544980948,"is_pvip":false,"replies":[{"id":"18171","content":"1. 嗯，它有单独的内存，redo log buffer<br><br>2. Binlog cache size也是global 的呀，我还去确认了5.5～5.7，你用的是哪个版本？<br><br>3. 这个数据是怎么得到的😄<br><br>4. 写完磁盘就发，然后再回来flush。 <br>     不是，放在binlog cache表示“这事务还没做完”，不发的","user_name":"作者回复","comment_id":50485,"uid":"1264162","ip_address":"","utype":1,"ctime":1545018930,"user_name_real":"林晓斌"}],"discussion_count":9,"race_medal":0,"score":"27314784724","product_id":100020801,"comment_content":"老师提几个问题：<br>1.事务在执行过程中，binlog是否像redo log一样记录到binlog_cache里？<br>2.为什么把redo log buffer设置成全局参数，binlog cache设置为事务级别参数？<br>3.为什么一般是binlog落盘比redo log更耗时？<br>4.如果sync为1，dump线程是等到binlog 成功flush，再从binlog cache中把binlog event发送给从库？如果非1,是在最后xid写入就从binlog cache中把binlog event发送给从库？","like_count":6,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432994,"discussion_content":"1. 嗯，它有单独的内存，redo log buffer\n\n2. Binlog cache size也是global 的呀，我还去确认了5.5～5.7，你用的是哪个版本？\n\n3. 这个数据是怎么得到的😄\n\n4. 写完磁盘就发，然后再回来flush。 \n     不是，放在binlog cache表示“这事务还没做完”，不发的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545018930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592754,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4d/b2/f6c20f2f.jpg","nickname":"庚午马","note":"","ucode":"F3FD8C8D8352AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579406,"discussion_content":"跨IDC或者跨城半同步，或者不支持事务的Binlog事件解析，触发概率更高","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657433498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107305,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e5/69/719ec5d0.jpg","nickname":"Jian","note":"","ucode":"17ED4919F22DEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335250,"discussion_content":"第4点，我们最近在主从架构下，出现⼀种很极端的情况，从库收到binlog然后解析里面的内容，再根据里面的内容去主库查，正常应该是最新记录，但我们查出了老的记录，怀疑主库还没刷盘，现在这个问题还没得解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608128112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1308784,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f8/70/f3a33a14.jpg","nickname":"某、人","note":"","ucode":"ADB42AA12A11C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1107305,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e5/69/719ec5d0.jpg","nickname":"Jian","note":"","ucode":"17ED4919F22DEC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335405,"discussion_content":"如果主库查不到记录，那么说明主库上该事务还未提交成功，跟数据页刷不刷盘没有关系。如果提交成功了，都是先查buffer pool,没有才会去查磁盘。这个是什么场景下，才会出现你说的问题呢？主库同步过程中挂了嘛，还是提交过程中hang住了啊？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608185461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":335250,"ip_address":""},"score":335405,"extra":""},{"author":{"id":1308784,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f8/70/f3a33a14.jpg","nickname":"某、人","note":"","ucode":"ADB42AA12A11C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1107305,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e5/69/719ec5d0.jpg","nickname":"Jian","note":"","ucode":"17ED4919F22DEC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335406,"discussion_content":"sync binlog是否不为1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608185559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":335250,"ip_address":""},"score":335406,"extra":""},{"author":{"id":1107305,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e5/69/719ec5d0.jpg","nickname":"Jian","note":"","ucode":"17ED4919F22DEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1308784,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f8/70/f3a33a14.jpg","nickname":"某、人","note":"","ucode":"ADB42AA12A11C1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335726,"discussion_content":"你说了对，感觉是主库的事务还没提交成功。但binlog都落盘了，这时redo log把状态该为commit应该很快呀，但通过binlog里的内容再去查主库，事务竟然还没提交成功。是不是redo log必须是要全部落盘才会改状态为commit呀？因为我们这个场景类似与这篇文章https://mp.weixin.qq.com/s/Wb5gpeXAJKs45zIKJKLzKw。另外我们是在一个大事务里才出现过这种情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608285399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":335405,"ip_address":""},"score":335726,"extra":""}]}]},{"had_liked":false,"id":56311,"user_name":"观弈道人","can_delete":false,"product_type":"c1","uid":1016905,"ip_address":"","ucode":"F3BB619A33C605","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","comment_is_top":false,"comment_ctime":1546419546,"is_pvip":false,"replies":[{"id":"20255","content":"不是A关注B，就是A大于B，说的是用户id哦","user_name":"作者回复","comment_id":56311,"uid":"1264162","ip_address":"","utype":1,"ctime":1546421215,"user_name_real":"林晓斌"}],"discussion_count":3,"race_medal":0,"score":"23021256026","product_id":100020801,"comment_content":"丁老师，不好意思，刚才提的A &gt; B, A &lt; B问题，我要再重复一下。A &gt; B: 应该是表示当前业务操作为A用户关注B用户, sql为: insert into like(&#39;a_user_id&#39;, &#39;b_user_id&#39;, 1), 如果反向关联则为insert into like(&#39;b_user_id&#39;, &#39;a_user_id&#39;, 2), 互相关联则relation_ship update 为3, 您的意思是通过relation_ship表示user_id,liker_id哪个为被关注方,哪个是关注方，所以，我还是理解 A &gt; B ,不应该理解成 A 大于 B,而是A 关注 B，我认为A 大于 B的比较是没有意义的，比较疑惑我这样理解偏差在哪里?😖","like_count":5,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434982,"discussion_content":"不是A关注B，就是A大于B，说的是用户id哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546421215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2457254,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/suQ8EerOp4VHR1NCIAnoc2xuUw4V4ticYZMeOZhZG3yDEH0o7Cnsc3IS2m3ES1cvmibekzjQCSZzsq63pjGicPdlg/132","nickname":"Geek_a733e5","note":"","ucode":"A556FCD8643347","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577672,"discussion_content":"同学，你搞明白了没？我也不懂，为啥 user_id会有和like_id的大小关系，大于，就是1,","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656292738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1614499,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLRXPleVJnXU4gib2Hib5xR7jMmAgVPs1GKuJ39ib8HvnVk79Q3k8STLhOcCcO2rjKSuuMLFRekCyL2A/132","nickname":"Geek_slk","note":"","ucode":"413CDBEF0B7679","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381344,"discussion_content":"用户id 指的userID么 还是说like表的主键id","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625018757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63257,"user_name":"念你如昔","can_delete":false,"product_type":"c1","uid":1323531,"ip_address":"","ucode":"FCAD88AB57D084","user_header":"https://static001.geekbang.org/account/avatar/00/14/32/0b/981b4e93.jpg","comment_is_top":false,"comment_ctime":1548312923,"is_pvip":false,"replies":[{"id":"22412","content":"是的，所以它叫做“buffer”，还算是顾名思义的","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548321799,"ip_address":"","comment_id":63257,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18728182107","product_id":100020801,"comment_content":"对redo  log  buffer 来说，我认为他存在的必要就是仅仅是做个缓存使用而已，也就是让在事务中执行dml快点而已，毕竟写到buffer比直接写到redologfile快。而redo log buffer 是有触发机制的，一个大事务中，如果生成的redolog很多，在事务未提交之前，log 是还会从 redolog buffer写到 redolog file里的。","like_count":4,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437524,"discussion_content":"是的，所以它叫做“buffer”，还算是顾名思义的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548321799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51011,"user_name":"mahonebags","can_delete":false,"product_type":"c1","uid":1326752,"ip_address":"","ucode":"A5327768A558E9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqWbl76C5icKJ0NvTQ7hWMXZq99srhzUlpmD4xcatNFia9tdvbBGHSwXvnXo1Lhp8U9T2V3iauImSf7w/132","comment_is_top":false,"comment_ctime":1545098787,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14430000675","product_id":100020801,"comment_content":"我给表新加了一个update_time on update current_timestamp字段，发现会加锁，但是提交后update_time不会变化，而且也没有binlog生成，所以是加锁了但是实际没更新？","like_count":3},{"had_liked":false,"id":50859,"user_name":"Laputa","can_delete":false,"product_type":"c1","uid":1079345,"ip_address":"","ucode":"64C157042CF138","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/31/c7f8d1db.jpg","comment_is_top":false,"comment_ctime":1545056031,"is_pvip":false,"replies":[{"id":"18285","content":"有索引的话，加一个间隙锁；<br>没索引的话，加所有行的行锁和所有间隙的间隙锁","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545057027,"ip_address":"","comment_id":50859,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14429957919","product_id":100020801,"comment_content":"老师，如果给不存在的id加锁会怎样，会加不上锁还是？","like_count":3,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433145,"discussion_content":"有索引的话，加一个间隙锁；\n没索引的话，加所有行的行锁和所有间隙的间隙锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545057027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1788647,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","nickname":"汉江","note":"","ucode":"01622D984B8F9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342704,"discussion_content":"老师  你的回答应该要说明隔离级别吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610783721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50696,"user_name":"郭江伟","can_delete":false,"product_type":"c1","uid":1313994,"ip_address":"","ucode":"613D638619B5A2","user_header":"https://static001.geekbang.org/account/avatar/00/14/0c/ca/6173350b.jpg","comment_is_top":false,"comment_ctime":1545030826,"is_pvip":false,"replies":[{"id":"18278","content":"Hexdump前有没有关闭MySQL?","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545055802,"ip_address":"","comment_id":50696,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14429932714","product_id":100020801,"comment_content":"创建测试数据：<br>mysql&gt; create table t(id int primary key auto_increment,a int );<br>mysql&gt; insert into t values(1,2);<br>mysql&gt; begin;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; update t set a=2 where id=1;<br>Query OK, 0 rows affected (0.00 sec)<br>查看系统锁情况：<br>show engine innodb status<br>---TRANSACTION 958998, ACTIVE 51 sec<br>2 lock struct(s), heap size 1136, 1 row lock(s)<br>MySQL thread id 2, OS thread handle 139663691581184, query id 22 localhost root<br>mysql&gt; show processlist;<br>+----+------+-----------+--------------------+---------+------+----------+------------------+<br>| Id | User | Host      | db                 | Command | Time | State    | Info             |<br>+----+------+-----------+--------------------+---------+------+----------+------------------+<br>|  2 | root | localhost | sysbench           | Sleep   |  352 |          | NULL             |<br>|  3 | root | localhost | NULL               | Sleep   |  301 |          | NULL             |<br>+----+------+-----------+--------------------+---------+------+----------+------------------+<br>其中Thread id=2 为update会话，说明系统有锁<br>另一会话执行 update t set a=2 where id=1;<br>ERROR 1205 (HY000): Unknown error 1205 MySQL error code 1205 (ER_LOCK_WAIT_TIMEOUT): Lock wait timeout exceeded; try restarting transaction<br>提交第一个会话查看生成的binlog<br>### INSERT INTO `sysbench`.`t`<br>### SET<br>###   @1=1 &#47;* INT meta=0 nullable=0 is_null=0 *&#47;<br>###   @2=2 &#47;* INT meta=0 nullable=1 is_null=0 *&#47;<br># at 858<br>#181217 14:28:21 server id 9012  end_log_pos 889 CRC32 0xf96f7fcb \tXid = 20<br>COMMIT&#47;*!*&#47;;<br># at 889<br>#181217 14:42:14 server id 9012  end_log_pos 930 CRC32 0x3de034ba \tRotate to bin.000089  pos: 4<br>SET @@SESSION.GTID_NEXT= &#39;AUTOMATIC&#39; &#47;* added by mysqlbinlog *&#47; &#47;*!*&#47;;<br>DELIMITER ;<br># End of log file<br>&#47;*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*&#47;;<br>&#47;*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*&#47;;<br>发现没有update的binlog产生，也就是说该语句在server层没有实际执行<br>用hexdump对比update前后的数据行，发现事务id和回滚id也没变，说明innodb没有实际更新行。<br>鉴于该语句产生了行锁，有事务信息，但是没有实际修改，可判断innodb在更新前后值一样时不会实际更新数据","like_count":3,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433063,"discussion_content":"Hexdump前有没有关闭MySQL?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545055802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231543,"user_name":"Geek_a9b0fb","can_delete":false,"product_type":"c1","uid":2054473,"ip_address":"","ucode":"C22079C38EB7D7","user_header":"","comment_is_top":false,"comment_ctime":1593702782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10183637374","product_id":100020801,"comment_content":"麻烦问下：binlog 没有能力恢复“数据页”没明白这句话啥意思？有点懵","like_count":2},{"had_liked":false,"id":206613,"user_name":"海强","can_delete":false,"product_type":"c1","uid":1645684,"ip_address":"","ucode":"EF4971CD58E4E5","user_header":"https://static001.geekbang.org/account/avatar/00/19/1c/74/eb472cc3.jpg","comment_is_top":false,"comment_ctime":1586910359,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10176844951","product_id":100020801,"comment_content":"我理解，并不是说binlog不能恢复出数据，从最近一个全量备份开始，逐个回放binlog是可以恢复数据的，只不过这个代价很高，不适合用于平时的崩溃恢复。","like_count":2},{"had_liked":false,"id":96650,"user_name":"开封菜","can_delete":false,"product_type":"c1","uid":1543595,"ip_address":"","ucode":"6C25DAB0C4E1B3","user_header":"https://static001.geekbang.org/account/avatar/00/17/8d/ab/4dcbbc63.jpg","comment_is_top":false,"comment_ctime":1558484180,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10148418772","product_id":100020801,"comment_content":"老师你好，我想问个日常dba和开发人员经常问的问题。慢SQL第一次查询很慢，再跑就快了。查询缓存是关闭的。我的解释是数据和索引缓存到buffer pool，因为有时要查看优化后的效果，但由于有缓存而不知道实际的优化效果。我选择重启，在测试环境里做实验。但是发现重启后原来慢SQL还是快了。查了资料连预热数据预加载是关闭了的。找了很久资料没有解决。期间还试过对表进行ddl操作没效果，各种flush操作没效果，比如flush tables。不知道如何才能还原SQL之前的慢场景，谢谢。","like_count":2,"discussions":[{"author":{"id":1986739,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","nickname":"LWD","note":"","ucode":"DDA444DB113C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557317,"discussion_content":"可能是那次慢查询的时候数据库本身压力就很大\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1647763099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71396,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1551332502,"is_pvip":false,"replies":[{"id":"25558","content":"1. 你的理解是对的 。 我们单独写一个update语句的时候，就默认提交，我们的两阶段，是发生在“提交阶段”的<br>   如果是有begin...commit; 的语句序列，那提交阶段是在执行“commit”这个语句的时候发生的<br><br>2. “如果这里是以事务的粒度同步redo log的话，那么如果在commit之前，mysql crash，那么这个事务就肯定是丢失了的吧？” 这个看下23篇","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1551354025,"ip_address":"","comment_id":71396,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10141267094","product_id":100020801,"comment_content":"老师，有个疑问：之前在《一条sql更新语言的执行流程》中提到的两阶段提交举的例子是一条更新语句，但是在这篇文章中，老师说只有事务在commit的时候，日志才会真正从redo log buffer写入redo log。这里到底以哪一个为准？或者说前面提到的update语句其实就是指的一个事务。而两阶段流程就是由事务的commit语句触发的？如果这里是以事务的粒度同步redo log的话，那么如果在commit之前，mysql crash，那么这个事务就肯定是丢失了的吧？","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441134,"discussion_content":"1. 你的理解是对的 。 我们单独写一个update语句的时候，就默认提交，我们的两阶段，是发生在“提交阶段”的\n   如果是有begin...commit; 的语句序列，那提交阶段是在执行“commit”这个语句的时候发生的\n\n2. “如果这里是以事务的粒度同步redo log的话，那么如果在commit之前，mysql crash，那么这个事务就肯定是丢失了的吧？” 这个看下23篇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551354025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306721,"discussion_content":"你可能把事务的commit和两阶段提交的commit 理解错误了吧。\n这里的commit 是事务的提交之后，把redo log buffer 写到 redo log 里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600356031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1970443,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIx1V1QAxC4NHaxYZGyuibBN8lcURJWc5nrnO4yic1kxnDemYV2FJGialf47kYX9qtDnZZOfe1SJeLicg/132","nickname":"lleft","note":"","ucode":"D573EB509455AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":372343,"discussion_content":"两阶段提交是在commit语句执行的时候发生的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620291138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":306721,"ip_address":""},"score":372343,"extra":""}]}]},{"had_liked":false,"id":70109,"user_name":"不惑ing","can_delete":false,"product_type":"c1","uid":1207079,"ip_address":"","ucode":"AF04E417D38027","user_header":"https://static001.geekbang.org/account/avatar/00/12/6b/27/8c964e52.jpg","comment_is_top":false,"comment_ctime":1550998749,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10140933341","product_id":100020801,"comment_content":"问：2.追问5：binlog1丢失的原因是因为数据还在内存没刷到磁盘？如果设置innodb_flush_log_at_trx_commit=1 每次commit都刷到磁盘是不是就不会丢失了？这个两个理解有问题么？<br><br>Re:2. 追问5的回答的意思是，如果没有两阶段，redo log先提交完成再写binlog的话，就会导致binlog写入过程如果发生错误，无法回滚<br><br>老师您好，不好意思我没表达清楚，非常抱歉，重新问一遍，您文中的意思是【只用binlog做崩溃恢复，在图二crash位置，无法持崩溃恢复，图中binlog1已经commit了也会丢失】，<br>这段我没理解，为啥binlog1已经commit了还会丢失数据，所以引发了后面的思考<br>【binlog1丢失的原因是因为数据还在内存没刷到磁盘？如果设置innodb_flush_log_at_trx_commit=1 每次commit都刷到磁盘是不是就不会丢失了？】","like_count":2,"discussions":[{"author":{"id":1786788,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJINWmZjibZA4eibL31PzMDia2yt1icOc9QnFWwTKuXbWTFCAZaMgCrqO7Oa5sZka81pHoibPgSM8nCjibA/132","nickname":"超能力先生","note":"","ucode":"C042DB628CAA86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":118593,"discussion_content":"这个设置应该是让binlog保存。重启后丢失不是因为binlog丢失了，binlog都在，但是数据库不知道哪些是已经落盘的，哪些是没有落盘的。只能选择没有commit的运行，这样已经commit却未落盘的就丢失了所以需要一个check point来记录哪些落盘了。只通过binlog也能完全恢复 但是就需要从全备份点开始一个一个来，比起redolog会很慢。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1578157328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1232273,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cd/91/3d6c53f8.jpg","nickname":"Nash.Z","note":"","ucode":"76B14722664402","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":27856,"discussion_content":"同问，这里没搞懂，为什么binlog1已经commit了，数据还会丢失。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570677291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022507,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOpANMwDibLmj5IGJh6dTw300sZ1BHM5sG3sZv1A1rvCHOiblPD3jgFOiaMVVujtctWnQbVFoNPpRgw/132","nickname":"alioo","note":"","ucode":"F36A38C1F5FFAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7698,"discussion_content":"你现在搞懂了吗？这里我也没有搞懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567644950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64451,"user_name":"家有邹太","can_delete":false,"product_type":"c1","uid":1320050,"ip_address":"","ucode":"5636BD37EB1A99","user_header":"https://static001.geekbang.org/account/avatar/00/14/24/72/9e2a651c.jpg","comment_is_top":false,"comment_ctime":1548806244,"is_pvip":false,"replies":[{"id":"22817","content":"这个就是堆表和索引组织表的区别哈😅","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548808606,"ip_address":"","comment_id":64451,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10138740836","product_id":100020801,"comment_content":"有点不太明白，oracle，DB2的次级索引叶子结点都是包含了rowid的，访问路径走次级索引也可以直接根据rowid去查表，为啥mysql二级索引不包含rowid，还要返回主键索引再去查表。老师能帮忙解释下吗？谢谢！","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438004,"discussion_content":"这个就是堆表和索引组织表的区别哈😅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548808606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50760,"user_name":"郭刚","can_delete":false,"product_type":"c1","uid":1292032,"ip_address":"","ucode":"22CB8ECE8E3DCA","user_header":"https://static001.geekbang.org/account/avatar/00/13/b7/00/12149f4e.jpg","comment_is_top":false,"comment_ctime":1545040494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10134975086","product_id":100020801,"comment_content":"结论是方式3：<br>autocommit设置的是0<br><br>实验过程：<br>session1:<br>mysql&gt; update t set a=2 where id=1;<br>Query OK, 0 rows affected (0.00 sec)<br>Rows matched: 1  Changed: 0  Warnings: 0<br>session2:<br>mysql&gt; update t set a=2 where id=1;<br>ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction","like_count":2},{"had_liked":false,"id":50601,"user_name":"miche","can_delete":false,"product_type":"c1","uid":1318659,"ip_address":"","ucode":"9B6B7E14008094","user_header":"","comment_is_top":false,"comment_ctime":1545015114,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10134949706","product_id":100020801,"comment_content":"老师，经过前面的精彩内容，redo log和binlog已经理解的差不多了，能不能说一下undo log是怎么工作的吗？一个update语句从开始到结束，这undo和redo是先开始写哪个日志的？","like_count":2,"discussions":[{"author":{"id":1811277,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a3/4d/59390ba9.jpg","nickname":"排骨","note":"","ucode":"A413CF46211E1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570882,"discussion_content":"先写undo log,要先保存数据修改前的状态,给mvcc使用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651981948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158842,"discussion_content":"可结合第8章来看，应该是先前undo吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580633060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330134,"user_name":"Geek_94045a","can_delete":false,"product_type":"c1","uid":2760780,"ip_address":"","ucode":"B8F23BA9D1411B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKghO4kJwQ5ccuBA2Yox1WlZmq0JUICpNAsgYlOHX0wHGv48xVRKSvF9a6Eic5l2UOjFjnvTnsibibiaw/132","comment_is_top":false,"comment_ctime":1641809679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5936776975","product_id":100020801,"comment_content":"老师，我从你的文章里发现了好多用来面试别人的题，而且这些题 不是光靠背八股文而不明原理就能回答的出来的 哈哈","like_count":1},{"had_liked":false,"id":326991,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1639816327,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5934783623","product_id":100020801,"comment_content":"思考题：<br>update t set a=2 where id=1;<br>如果用一个事务来控制这个更新操作，在事务未提交之前，其他进程如果要更新id=1这一行记录，仍然是被锁住的，因此推断，更新时尽管更新后的值没有发生变化，但mysql仍然以自身的方式对记录进行更新，该加锁时仍然加锁，更新后的那个统计值，我的理解是按更新后有多少记录的值发生变化来统计的，并不是mysql发现值一样而没有去执行更新。","like_count":1},{"had_liked":false,"id":323364,"user_name":"克里斯","can_delete":false,"product_type":"c1","uid":1181844,"ip_address":"","ucode":"00B755C10AC1C3","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/94/2c22bd4e.jpg","comment_is_top":false,"comment_ctime":1637855064,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5932822360","product_id":100020801,"comment_content":"Redo Log Commit标识是什么?","like_count":1},{"had_liked":false,"id":268176,"user_name":"周翔在山麓（Xiang Zhou）","can_delete":false,"product_type":"c1","uid":1609289,"ip_address":"","ucode":"E126273356E5B6","user_header":"https://static001.geekbang.org/account/avatar/00/18/8e/49/10ef002d.jpg","comment_is_top":false,"comment_ctime":1608091252,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5903058548","product_id":100020801,"comment_content":"我觉得最后一个问题解决的并不好. 在不改变表结构的情况下, 可以改变业务逻辑:<br><br>当A 去关注 B 的时候:<br>1.在like 表里插入记录;<br>2.commit 事务;<br>3.判断like 表里是否有B对A 的关注;<br>  a)如果有, 在friend 里面插入一条记录;<br>  b)如果没有, 结束;<br>","like_count":1,"discussions":[{"author":{"id":1170486,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dc/36/e63c115f.jpg","nickname":"edgewalk","note":"","ucode":"A576FAEA5A81BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583793,"discussion_content":"如果执行第三步报错了,怎么回滚??","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660386171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258711,"user_name":"ytyee","can_delete":false,"product_type":"c1","uid":2018869,"ip_address":"","ucode":"05079CE049A8FA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/FQQA0icGXUvJZicd7jX1r85MmH2XgpQUlkXNpB2u9OibCc1k3ITJwaqbZm7WQiaT93hWYDRBCJMsThuL62PLTaP5hQ/132","comment_is_top":false,"comment_ctime":1604542066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5899509362","product_id":100020801,"comment_content":"如果在图中时刻 A 的地方，也就是写入 redo log 处于 prepare 阶段之后、写 binlog 之前，发生了崩溃（crash），由于此时 binlog 还没写，redo log 也还没提交，所以崩溃恢复的时候，这个事务会回滚。这时候，binlog 还没写，所以也不会传到备库。到这里，大家都可以理解。<br>这里我还是不太理解，如果按组提交的理解，flush阶段结束，也就是fsync redo log完成了，那么write binlog不也应该完成了吗，那么如果只是数据库挂掉，操作系统还是正常，那么操作系统不就会定时把write page cache这部分binlog刷到磁盘吗，不就没有丢吗？","like_count":1},{"had_liked":false,"id":229412,"user_name":"乖，摸摸头","can_delete":false,"product_type":"c1","uid":1611745,"ip_address":"","ucode":"BD92741A11D3CD","user_header":"https://static001.geekbang.org/account/avatar/00/18/97/e1/0f4d90ff.jpg","comment_is_top":false,"comment_ctime":1592987833,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5887955129","product_id":100020801,"comment_content":"mysql&gt; begin;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; select * from t where id=1;<br>+----+------+<br>| id | a    |<br>+----+------+<br>|  1 |    2 |<br>+----+------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; select * from t where id=1;<br>+----+------+<br>| id | a    |<br>+----+------+<br>|  1 |    2 |<br>+----+------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; update t set a=3 where id=1;<br>Query OK, 0 rows affected (0.00 sec)<br>Rows matched: 1  Changed: 0  Warnings: 0<br><br>mysql&gt; select * from t where id=1;<br>+----+------+<br>| id | a    |<br>+----+------+<br>|  1 |    2 |<br>+----+------+<br>1 row in set (0.00 sec)<br><br>为什么 update 后还是(1,2),死活没想通","like_count":1},{"had_liked":false,"id":208182,"user_name":"thomas","can_delete":false,"product_type":"c1","uid":1016777,"ip_address":"","ucode":"9AB945308F1B50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/c9/5d03981a.jpg","comment_is_top":false,"comment_ctime":1587294779,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5882262075","product_id":100020801,"comment_content":"追问 1：MySQL 怎么知道 binlog 是完整的?回答：一个事务的 binlog 是有完整格式的：statement 格式的 binlog，最后会有 COMMIT；row 格式的 binlog，最后会有一个 XID event。<br>----------------------------------------------------------------------------------<br>在MYSQL5.7.29版本试验， binlog模式为statement或row模式，都会有XID event + COMMIT","like_count":1},{"had_liked":false,"id":161394,"user_name":"suke","can_delete":false,"product_type":"c1","uid":1007753,"ip_address":"","ucode":"C0287C31A4F45B","user_header":"","comment_is_top":false,"comment_ctime":1576201130,"is_pvip":false,"replies":[{"id":"61532","content":"就是他们的id值","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1576213464,"ip_address":"","comment_id":161394,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5871168426","product_id":100020801,"comment_content":"a b大小的比较到底是在比较什么？没有说清楚啊 很迷惑","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477704,"discussion_content":"就是他们的id值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576213464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1007753,"avatar":"","nickname":"suke","note":"","ucode":"C0287C31A4F45B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81062,"discussion_content":"好的 ，明白了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576217066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1614499,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLRXPleVJnXU4gib2Hib5xR7jMmAgVPs1GKuJ39ib8HvnVk79Q3k8STLhOcCcO2rjKSuuMLFRekCyL2A/132","nickname":"Geek_slk","note":"","ucode":"413CDBEF0B7679","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1007753,"avatar":"","nickname":"suke","note":"","ucode":"C0287C31A4F45B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381345,"discussion_content":"哪个表的id值啊 没懂呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625018817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":81062,"ip_address":""},"score":381345,"extra":""}]}]},{"had_liked":false,"id":149479,"user_name":"jian","can_delete":false,"product_type":"c1","uid":1185102,"ip_address":"","ucode":"21CDBBB8000F0C","user_header":"https://static001.geekbang.org/account/avatar/00/12/15/4e/4636a81d.jpg","comment_is_top":false,"comment_ctime":1573229699,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5868196995","product_id":100020801,"comment_content":"请问老师，如何理解“对于 InnoDB 引擎来说，如果 redo log 提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。”其中的“这还允许回滚，就可能覆盖掉别的事务的更新”，具体 什么意思？能否举个例子？<br>麻烦解答一下","like_count":1,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158845,"discussion_content":"事务都提交了，相当于对于对别的事务是可见的，如果还允许回滚，那就会将别的事务基于这个事务提交的数据而算出来的更新进行覆盖，那就有点没有规矩可言了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580633416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92481,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1557280478,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5852247774","product_id":100020801,"comment_content":"看完问题后，我对数据落盘的理解如下：<br>更新内存页和redo log、binlog是分开管理的。写的时候写内存页，写redo log、binlog，内存页变为脏页，内存不足或是负载较低时由后台刷盘。读的时候读内存是最新的数据（有可能还是脏页）。期间如果崩溃，即使脏页没有刷盘，但脏页的修改一定是commit到了redo log，binlog上，恢复时会读出磁盘数据，应用修改（变为脏页，），等待某个刷盘时机。<br>因此，数据落盘和记录redo log、binlog并非强相关，但落盘前，一定是记录过redo log、binlog","like_count":1},{"had_liked":false,"id":64820,"user_name":"刘十一","can_delete":false,"product_type":"c1","uid":1035899,"ip_address":"","ucode":"5927D77D248E30","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ce/7b/fa0f9368.jpg","comment_is_top":false,"comment_ctime":1548918080,"is_pvip":false,"replies":[{"id":"22932","content":"有文化呀，多谢鼓励😆","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548922492,"ip_address":"","comment_id":64820,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5843885376","product_id":100020801,"comment_content":"在堂食客皆乎精彩，精彩～","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438194,"discussion_content":"有文化呀，多谢鼓励😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548922492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63200,"user_name":"念你如昔","can_delete":false,"product_type":"c1","uid":1323531,"ip_address":"","ucode":"FCAD88AB57D084","user_header":"https://static001.geekbang.org/account/avatar/00/14/32/0b/981b4e93.jpg","comment_is_top":false,"comment_ctime":1548297837,"is_pvip":false,"replies":[{"id":"22425","content":"有可能会的，binlog写完了","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548325431,"ip_address":"","comment_id":63200,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5843265133","product_id":100020801,"comment_content":"如果主库在B位置主库挂掉了，很明显innodb还没来的及做commit操作，这个事务会不会同步到从库中呢？","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437500,"discussion_content":"有可能会的，binlog写完了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548325431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57355,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1162714,"ip_address":"","ucode":"88348CCAE81931","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/da/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1546761735,"is_pvip":false,"replies":[{"id":"20673","content":"1. Binlog只能“整行重做”，不能单独做一个数据页的，没有信息<br>2. 不用全部回放。从checkpoint 的位置开始到当前写入位置就可以了。（不过理论上会是整个redo 空间）问题不大，现在硬盘很快的😄","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1546772847,"ip_address":"","comment_id":57355,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5841729031","product_id":100020801,"comment_content":"老师好，因为一些疑惑跳过了几篇先来看了下答疑。对如果只用binlog而不使用redo log无法进行奔溃恢复还是有些疑惑，想请老师解答一下。<br>1.binlog内容的能力不足（没有页面信息）。印象里在第二篇文章里说到binlog记录的是逻辑修改，而redolog记录的是物理修改。那么最终不都是记录的一条数据的修改吗？为什么binlog就能力不足了呢？<br>2.我理解是如果使用binlog进行恢复不确定从哪个时间点进行数据恢复有可能导致数据丢失。但是redolog也可以设置的很大。那么用redo log恢复相当于把redo log回放了一遍吗？<br>困惑了好久，还望老师可以百忙之中抽空解答一下，感激不尽。","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435539,"discussion_content":"1. Binlog只能“整行重做”，不能单独做一个数据页的，没有信息\n2. 不用全部回放。从checkpoint 的位置开始到当前写入位置就可以了。（不过理论上会是整个redo 空间）问题不大，现在硬盘很快的😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546772847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51162,"user_name":"Smile","can_delete":false,"product_type":"c1","uid":1021017,"ip_address":"","ucode":"2002460CB3D869","user_header":"https://static001.geekbang.org/account/avatar/00/0f/94/59/ac2aa72b.jpg","comment_is_top":false,"comment_ctime":1545123230,"is_pvip":true,"replies":[{"id":"18441","content":"是的是的，<br>我从上面拷下来后注释忘记改了，<br><br>你看得好细致👍🏿","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545126211,"ip_address":"","comment_id":51162,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5840090526","product_id":100020801,"comment_content":"如果 A&gt;B，则执行下面的逻辑<br><br>&#47;* 代码中判断返回的 relation_ship.....<br>如果是 1，事务结束，执行 commit<br>----------<br>老师，这里应该为 “如果是2” 吧<br><br>","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433315,"discussion_content":"是的是的，\n我从上面拷下来后注释忘记改了，\n\n你看得好细致👍🏿","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545126211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51141,"user_name":"xmasye","can_delete":false,"product_type":"c1","uid":1067119,"ip_address":"","ucode":"7AB897FE157604","user_header":"https://static001.geekbang.org/account/avatar/00/10/48/6f/cdf34b6b.jpg","comment_is_top":false,"comment_ctime":1545120439,"is_pvip":false,"replies":[{"id":"18517","content":"1. Mariadb支持秒级加列可以了解下<br><br><br>2. 额，这个真得具体问题才能分析","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545158108,"ip_address":"","comment_id":51141,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5840087735","product_id":100020801,"comment_content":"老师，问点课外问题。<br>1.业务不断迭代，表一直加字段，一个是维护问题，一个是会锁表。有什么常用的做法吗？例如用Json字符串（序列化和反序列化的消耗）、例如用纵表来存key&#47;value（额外开发成本）、主属性放一张表比较杂的属性放另一张表，主属性表就不动（垂直拆表，但是还是有维护问题和锁表问题）<br>2.一张表的数据量多大会明显影响性能？明显影响后有什么方案？分库分表（据说很痛苦）、优化sql索引、数据归档等等。<br>谢谢！","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433306,"discussion_content":"1. Mariadb支持秒级加列可以了解下\n\n\n2. 额，这个真得具体问题才能分析","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545158108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51075,"user_name":"明亮","can_delete":false,"product_type":"c1","uid":1303015,"ip_address":"","ucode":"DAFB3424C4C2D7","user_header":"https://static001.geekbang.org/account/avatar/00/13/e1/e7/d1b2e914.jpg","comment_is_top":false,"comment_ctime":1545108912,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5840076208","product_id":100020801,"comment_content":"接上一个提问，如果给redo总体大小设置4G，这时在一个事务中写10G数据是否可成功行呢？","like_count":1},{"had_liked":false,"id":50896,"user_name":"明亮","can_delete":false,"product_type":"c1","uid":1303015,"ip_address":"","ucode":"DAFB3424C4C2D7","user_header":"https://static001.geekbang.org/account/avatar/00/13/e1/e7/d1b2e914.jpg","comment_is_top":false,"comment_ctime":1545062144,"is_pvip":false,"replies":[{"id":"18349","content":"不会呀，中间崩溃的，binlog还在binlog cache里，没发给从库呢","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545101145,"ip_address":"","comment_id":50896,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5840029440","product_id":100020801,"comment_content":"我在运维过程中 思考过一个问题，一个事务特别大，一次写了1G的数据量，这个过程中如果主库崩溃，而redo log必然没有刷盘，主库恢复后，是不是会导致主从不一致而无法同步呢？","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433164,"discussion_content":"不会呀，中间崩溃的，binlog还在binlog cache里，没发给从库呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545101145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50881,"user_name":"Laputa","can_delete":false,"product_type":"c1","uid":1079345,"ip_address":"","ucode":"64C157042CF138","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/31/c7f8d1db.jpg","comment_is_top":false,"comment_ctime":1545060167,"is_pvip":false,"replies":[{"id":"18522","content":"这真是个好问题，第21篇会讲到","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545158559,"ip_address":"","comment_id":50881,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5840027463","product_id":100020801,"comment_content":"老师，间隙锁是如何运行的？<br>实际中遇到一个问题：<br>假如我有一张表 table1，id列为主键<br>事务1：<br>begin;<br>select * from table1 where id = 1 for update;<br>此时开始事务2：<br>begin;<br>select * from table1 where id = 1 for update;<br>事务1继续执行：<br>#若id为1的记录不存在则执行：<br>insert into table1 values(1);<br>此时事务1会阻塞,应该是在获取锁；<br>然后事务2也会执行同样的逻辑，因为id为1的记录不存在，也会执行插入操作：<br>insert into table1 values(1);<br>此时事务2会报死锁，事务1会执行成功：<br>Deadlock found when trying to get lock; try restarting transaction；<br><br>业务上的逻辑是这样的：<br>根据ID查找对应的记录，如果不存在就插入对应的记录，若存在就更新对应的记录，当有两个请求同时执行此逻辑且对应ID不存在的时候，就会报错，老师能不解释下间隙锁和如何避免此种情况的死锁，谢谢","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433156,"discussion_content":"这真是个好问题，第21篇会讲到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545158559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50818,"user_name":"古娜拉黑暗之神·巴啦啦能量·堕落达","can_delete":false,"product_type":"c1","uid":1185642,"ip_address":"","ucode":"080BBCEF7DE985","user_header":"https://static001.geekbang.org/account/avatar/00/12/17/6a/c979163e.jpg","comment_is_top":false,"comment_ctime":1545050438,"is_pvip":false,"replies":[{"id":"18271","content":"1. 就是刷脏页，然后改位置，不是很简单，这个过程挺吃资源的<br><br>2. 会的，我们之前文章算R% 那个图，就是算完以后，作为平时推“推多快”的依据哦<br><br>平时推也是刷脏页。<br><br>而且实际上，一个系统健康的状态就是烤平时推，来避免redo log满了的情况","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545055364,"ip_address":"","comment_id":50818,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5840017734","product_id":100020801,"comment_content":"老师，对于redo log还是有两个疑问，望能解答一下<br>1. 如果 redo log 满了，那么数据库会停止所有更新操作，把 checkpoint 往前推进，为redo log 留出空间可以继续写。那么要把checkpoint往前推进大概需要做哪些操作呢？难道就是简单的刷脏页吗？<br>2. 在平常的时候，checkpoint会不会自动向前推进呢？如果平常的时候也向前推进，那么它和平时刷脏页有没有关系？","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433122,"discussion_content":"1. 就是刷脏页，然后改位置，不是很简单，这个过程挺吃资源的\n\n2. 会的，我们之前文章算R% 那个图，就是算完以后，作为平时推“推多快”的依据哦\n\n平时推也是刷脏页。\n\n而且实际上，一个系统健康的状态就是烤平时推，来避免redo log满了的情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545055364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50720,"user_name":"对方正在输入中…","can_delete":false,"product_type":"c1","uid":1210596,"ip_address":"","ucode":"D40224951C57E1","user_header":"https://static001.geekbang.org/account/avatar/00/12/78/e4/7978869e.jpg","comment_is_top":false,"comment_ctime":1545034556,"is_pvip":false,"replies":[{"id":"18205","content":"1. 大概率都在内存里（内存不够会放磁盘）<br><br>2. 之后","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545041616,"ip_address":"","comment_id":50720,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5840001852","product_id":100020801,"comment_content":"总结一下：<br>redo阶段有两种：redo prepare阶段和redo commit。<br>写binlog有两种情况：未完整写完，完整写完。<br>总体来说mysql确认事务需要执行只认两种情况：<br>情况1：redo commit完成。<br>情况2：完整的redo prepare+完整的binlog(这里指写完)。<br>crash recovery：<br>redo prepare不完整：事务直接回滚。<br>redo prepare完整，未完成redo commit：找binlog是否完整，如果binlog完整，由于主从复制依靠binlog传输和应用，所以从库已接受并应用binlog，主库也应执行该事务。binlog不完整直接回滚。<br>redo prepare完整，redo commit完成：不管binlog是否完整，事务提交。<br>注：redo prepare完整和binlog完整的情况应该是老师说的“两阶段提交就是为了给所有人一个机会，当每个人都说“我 ok”的时候，再一起提交“，只不过在两个人说ok前就挂了。<br>疑问：<br>1、如果auto_commit=0时，在事务未commit之前，redo log和binlog的写入状态是怎么样的？<br>2、binlog是在redo prepare开始时写入还是redo prepare完成后写入的？","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433073,"discussion_content":"1. 大概率都在内存里（内存不够会放磁盘）\n\n2. 之后","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545041616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50656,"user_name":"东青","can_delete":false,"product_type":"c1","uid":1001046,"ip_address":"","ucode":"D7FF3299721F19","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/56/5e83f44b.jpg","comment_is_top":false,"comment_ctime":1545024533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5839991829","product_id":100020801,"comment_content":"老师，我想问一下<br>1. redo log跟binlog都是在commit阶段进行sync磁盘操作的吗（双1）<br>2. master线程每秒也会刷盘redo log跟commit阶段刷盘是不冲突的吧。<br>3. sync_binlog为1时发送binlog是在sync到磁盘之后吗？反之是在flush之后。被发送的binlog是从binlog文件读取出来的。<br>感谢回答","like_count":1},{"had_liked":false,"id":50591,"user_name":"AstonPutting","can_delete":false,"product_type":"c1","uid":1303239,"ip_address":"","ucode":"1DB579A7922964","user_header":"https://static001.geekbang.org/account/avatar/00/13/e2/c7/d6a0927a.jpg","comment_is_top":false,"comment_ctime":1545013393,"is_pvip":false,"replies":[{"id":"18168","content":"听过这个说法，但是感觉怪怪的，<br><br>嗯嗯，不过有用到这个词的地方确实是2(a)的意思","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545015501,"ip_address":"","comment_id":50591,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5839980689","product_id":100020801,"comment_content":"老师，请问前滚的意思是不是指的在 2(a) 的情况下，未提交的事务被提交的过程？","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433033,"discussion_content":"听过这个说法，但是感觉怪怪的，\n\n嗯嗯，不过有用到这个词的地方确实是2(a)的意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545015501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50513,"user_name":"臧天霸","can_delete":false,"product_type":"c1","uid":1302804,"ip_address":"","ucode":"F53FB15E7BD17A","user_header":"https://static001.geekbang.org/account/avatar/00/13/e1/14/006e8b9b.jpg","comment_is_top":false,"comment_ctime":1545005321,"is_pvip":false,"replies":[{"id":"18310","content":"1会的,inplace 执行完成后会自动调用一次重建索引统计","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545075382,"ip_address":"","comment_id":50513,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5839972617","product_id":100020801,"comment_content":"老师，我把前面的问题挪过来，烦请解惑：<br>1.alter table t engine = innodb;后表及索引的统计信息也会跟着自动重建吗？联想到在oracle中迁移完数据，没有及时做统计信息收集所引发的事故了……<br>2.如果表及索引的统计信息没有跟着自动重建，那此时会使用表及索引旧的统计信息?或者是达到统计信息重新收集阈值后再收集？","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433005,"discussion_content":"1会的,inplace 执行完成后会自动调用一次重建索引统计","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545075382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158853,"discussion_content":"普通索引没有重建。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580634131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50487,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1544981732,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5839949028","product_id":100020801,"comment_content":"追问5中，老师说到binlog没有能力恢复数据页，但这和它能不能恢复数据库是两回事呀，本质上都是更新在存储层次上的几种展现吗？一个是记录顶层数据页的变化，一个是行变化。<br><br>业务设计问题，这个问题其实抽象点就是写倾斜问题，类似的问题基本都符合先select读个什么东东出来，作为条件，然后再决定是否写入。老师的解决方法核心是实体化冲突，把原先不能加锁的无记录，人为引入可加锁的对象。当然还有种解决方式就是索引区间锁的方式，当然这是串行化级别下的东东了。这个问题让我好好回顾了一遍隔离，还是很有收获的，也希望老师能够把47个问题种剩下的也发出来，不需要完整的解答，点点就好。<br><br>今日问题：在两个事务中，一个执行更新后（没提交），发现另一个事务就没办法对相同行进行更新了。所以处理方式为3。至于为什么这么做，如果说更新木改变就不加锁，（1）调用方就可能需要确定这个更新有木有加上锁，才进行相关的操作。（2）对代码引入不必要的复杂度。（3）想的头大了，想不出来了。。。。😔","like_count":1},{"had_liked":false,"id":360171,"user_name":"tailender","can_delete":false,"product_type":"c1","uid":1133837,"ip_address":"日本","ucode":"BCF8C43F9039E9","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/0d/f8b8c22e.jpg","comment_is_top":false,"comment_ctime":1666252259,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666252259","product_id":100020801,"comment_content":"半同步 如果一个事务从库没有ack, 主库crash后 先删掉binlog 然后重启库发现这个事务提交了<br>请问老师 这个是为什么","like_count":0},{"had_liked":false,"id":359636,"user_name":"Geek_70a558","can_delete":false,"product_type":"c1","uid":3197432,"ip_address":"江苏","ucode":"D256BF6FC26BFD","user_header":"","comment_is_top":false,"comment_ctime":1665719938,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1665719938","product_id":100020801,"comment_content":"追问5和6, 我理解应该还有一些原因 :<br>5. 为什么不能一次redolog+一次binlog ..  是因为如果单次的话, 每次恢复要把redolog刷盘, 都需要对比所有redolog和对应的binlog,  但是如果是两段commit的话,  只要检测到commit不需要再去binlog再检索一次;<br>6. 为什么不能只用binlog...  因为redolog是可复用的一块空间, 并且有writePos和checkPoint这样的标记可以确定执行的范围, 恢复的时候按照范围恢复即可;  但是binlog是追加写入, 没有办法知道从哪里开始恢复, 例如文中说的从上一个commit开始恢复 ,  但是上一个commit很有可能也没有持久化到data文件中;  ","like_count":0},{"had_liked":false,"id":350945,"user_name":"NeverSeeYouAgainBUG","can_delete":false,"product_type":"c1","uid":2930836,"ip_address":"","ucode":"1B0E8CA284C181","user_header":"https://static001.geekbang.org/account/avatar/00/2c/b8/94/d20583ef.jpg","comment_is_top":false,"comment_ctime":1657374027,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657374027","product_id":100020801,"comment_content":"那个业务上关注与好友的问题，执行当前读可以解决吗？","like_count":0},{"had_liked":false,"id":350602,"user_name":"Unknown element","can_delete":false,"product_type":"c1","uid":2028277,"ip_address":"","ucode":"34A129800D0238","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f2/f5/b82f410d.jpg","comment_is_top":false,"comment_ctime":1657033159,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657033159","product_id":100020801,"comment_content":"问个问题，在文章开头的“日志相关问题”中您说：“图1中用到的这个“commit 步骤”，指的是事务提交过程中的一个小步骤，也是最后一步。当这个步骤执行完成后，这个事务就提交完成了”；在追问9中您又说“真正把日志写到 redo log 文件（文件名是 ib_logfile+ 数字），是在执行 commit 语句的时候做的”，那么是不是说commit语句的执行其实包含一系列步骤，而整个两阶段提交（redo log prepare的落盘、binlog的落盘、bin log commit的落盘）都包含在这一系列步骤中？<br>另外就是用户执行一个增删改事务，它的执行结果什么时候返回呢？只要这个事务对数据库的操作被记录下来（哪怕只是暂时记录在内存里）了就立即返回事务执行成功吗？","like_count":0},{"had_liked":false,"id":348219,"user_name":"小刘","can_delete":false,"product_type":"c1","uid":1625914,"ip_address":"","ucode":"8017FB710CCB09","user_header":"https://static001.geekbang.org/account/avatar/00/18/cf/3a/ba5b4375.jpg","comment_is_top":false,"comment_ctime":1654849862,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654849862","product_id":100020801,"comment_content":"我们知道，更新过程中，commit提交之前，日志被记录在redo log buffer中，如果commit之前，发生crash, 随后进行崩溃恢复， binlog如果没有crash-safe的能力话，在崩溃恢复时，为什么能够使用prepared阶段的redo log + 完整binlog进行崩溃恢复。","like_count":0},{"had_liked":false,"id":348218,"user_name":"小刘","can_delete":false,"product_type":"c1","uid":1625914,"ip_address":"","ucode":"8017FB710CCB09","user_header":"https://static001.geekbang.org/account/avatar/00/18/cf/3a/ba5b4375.jpg","comment_is_top":false,"comment_ctime":1654849838,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654849838","product_id":100020801,"comment_content":"求解答，我已晕在厕所<br>我们知道，更新过程中，commit提交之前，日志被记录在redo log buffer中。<br>如果commit之前且binlog已经写入，发生crash, 随后进行崩溃恢复，因为binlog是完整的，所以该事务需要进行崩溃恢复。<br>但是，binlog如果没有crash-safe的能力话，在崩溃恢复时，为什么能够使用prepared阶段的redo log + 完整binlog进行崩溃恢复。","like_count":0},{"had_liked":false,"id":347646,"user_name":"假装学习","can_delete":false,"product_type":"c1","uid":2811767,"ip_address":"","ucode":"CBF1D121ECFF43","user_header":"https://static001.geekbang.org/account/avatar/00/2a/e7/77/c8c2008f.jpg","comment_is_top":false,"comment_ctime":1654246848,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654246848","product_id":100020801,"comment_content":"有个问题一直想不明白<br>binlog可以n个事务刷一次盘，这样就有可能在crash时候丢失还没有持久化的binlog<br>如果配置redo log设置为每次事务提交fsync到磁盘中，但是binlog设置为100次事务fsync一次，这就有一种可能：在binlog还没有持久化的时候，事务已经提交，redolog完整，此时宕机。但是此时redolog 却是完整的。<br>这种情况还会丢失数据吗？<br>我的理解是不会丢失数据，只是造成了binloog不完整，这样就会造成主从同步失败。<br>但是既然redolog可以恢复数据，是不是能把丢失的binlog 补上呢？如果可以补上，那丢失的binlog是否就无所谓了呢？<br>","like_count":0},{"had_liked":false,"id":345859,"user_name":"Geek_669721","can_delete":false,"product_type":"c1","uid":1308502,"ip_address":"","ucode":"631471460ACFF3","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83erabhkvu3jKSia1Y3l7pvicBy1YibN6GuIxLuZmI9E9icR8zdjP7BZ570PsDXv7ZLlMTU4Xr3Xz6N9bZg/132","comment_is_top":false,"comment_ctime":1652653000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652653000","product_id":100020801,"comment_content":"不知道老师您还在嘛😂我有个问题是，如果binlog和redolog的两阶段提交在binlog写成功之后崩溃，但是还没commit，最后redolog会进行崩溃恢复，让这个事务完成。但是对于执行这个事务的客户端来说这个事务不是没完成吗？对于客户端来说是失败的，那客户端不是会回滚吗？这里客户端和MySQL的状态是不是就不一致了","like_count":0},{"had_liked":false,"id":344155,"user_name":"罗文彬","can_delete":false,"product_type":"c1","uid":1390646,"ip_address":"","ucode":"17AB673A419ED0","user_header":"https://static001.geekbang.org/account/avatar/00/15/38/36/711a66d0.jpg","comment_is_top":false,"comment_ctime":1651308180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651308180","product_id":100020801,"comment_content":"相互关注成好友哪里，不是很理解为啥要这样设计两张表，而且当A和B不重复关注的话那不是成不了好友了","like_count":0},{"had_liked":false,"id":341101,"user_name":"上善若水","can_delete":false,"product_type":"c1","uid":1116397,"ip_address":"","ucode":"F4EC3FA1F27594","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/ed/fe5242fe.jpg","comment_is_top":false,"comment_ctime":1649346312,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1649346312","product_id":100020801,"comment_content":"A&gt;B，insert ignore into friend(friend_1_id, friend_2_id) values(B,A);<br>是不是<br>应该改成 insert ignore into friend(friend_1_id, friend_2_id) values(A,B);<br>不然 friend 只会有一条数据了。不知道我的理解对不对。","like_count":0,"discussions":[{"author":{"id":1324550,"avatar":"https://static001.geekbang.org/account/avatar/00/14/36/06/08c46bcd.jpg","nickname":"聂利","note":"","ucode":"808E064089724D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586465,"discussion_content":"优化后结果是只有一条记录，增加一个字段，用状态来代表关注方向，谁关注谁，A关注B为1,B关注A为2，互相关注一定是3，老师没有详细说明，看代码可以推敲出来，我也理解了很久","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662254669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339656,"user_name":"。。","can_delete":false,"product_type":"c1","uid":2853618,"ip_address":"","ucode":"A52A6043D27D87","user_header":"https://static001.geekbang.org/account/avatar/00/2b/8a/f2/6c6f7886.jpg","comment_is_top":false,"comment_ctime":1648279052,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648279052","product_id":100020801,"comment_content":"追问8里面，如果是 redolog 满了呢，此时就不得不去刷脏页了，这个也是刷内存中的脏页吗？之前的理解就是 redolog 自己写到磁盘，把 fsync 刷到磁盘的都擦拭了，是理解错了吗？","like_count":0},{"had_liked":false,"id":337632,"user_name":"Geek_0cfc2d","can_delete":false,"product_type":"c1","uid":2365133,"ip_address":"","ucode":"4E7A034578A19E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLR2YXdT0AticVATPbtpd1LLOAA0FE1uRJstglZeBs1bAiaPB2PkEnlibIFtUPg1gsseribTib5Oiaw0BBA/132","comment_is_top":false,"comment_ctime":1646924807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646924807","product_id":100020801,"comment_content":"看了评论区和老师说的，使用 redo log 做崩溃恢复而不能使用 binglog 的原因应该是：<br>1、redo log 记录的是页级的改动，刷盘也是按页去刷的（脏页），两者可以对应上；<br>2、binglog 的记录并不对应哪个页的改动，可能一条更新就对应多个页，崩溃了也不知道从哪里开始把原先还未刷盘的数据还原。","like_count":0},{"had_liked":false,"id":337091,"user_name":"FireD","can_delete":false,"product_type":"c1","uid":1614735,"ip_address":"","ucode":"60D2A6057E6924","user_header":"https://static001.geekbang.org/account/avatar/00/18/a3/8f/0501a57a.jpg","comment_is_top":false,"comment_ctime":1646618946,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646618946","product_id":100020801,"comment_content":"只要prepare redolog和写binlog也能做到crash-safe和主从一致吧<br>发现prepare redolog，通过XID找binlog，找到且完整就commit，没找到或者不完整就rollback<br>从库收到binlog就执行同步","like_count":0},{"had_liked":false,"id":337090,"user_name":"FireD","can_delete":false,"product_type":"c1","uid":1614735,"ip_address":"","ucode":"60D2A6057E6924","user_header":"https://static001.geekbang.org/account/avatar/00/18/a3/8f/0501a57a.jpg","comment_is_top":false,"comment_ctime":1646618733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646618733","product_id":100020801,"comment_content":"如果这样设计是不是不要commit redolog？","like_count":0},{"had_liked":false,"id":333017,"user_name":"小妖","can_delete":false,"product_type":"c1","uid":1730626,"ip_address":"","ucode":"49C01DBFADF101","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJvm1JYIDcS74s4cEYxA1PXMqjortVXEjUKyGQcPvibNJ4EAuksIa6uoHgr6G1yRqAM2KtP3yicKgTA/132","comment_is_top":false,"comment_ctime":1643960204,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643960204","product_id":100020801,"comment_content":"文中提到了redo log buffer 同时又说redo log是两阶段提交。我这里有个问题，事务在写redo log buffer 后，没有写入redo log文件（没有最终commit）之前crash了，那么redolog是怎么记录到prepare状态的","like_count":0},{"had_liked":false,"id":330378,"user_name":"佐佐真君","can_delete":false,"product_type":"c1","uid":2761438,"ip_address":"","ucode":"CE6E1A08C30DB1","user_header":"https://static001.geekbang.org/account/avatar/00/2a/22/de/1351551d.jpg","comment_is_top":false,"comment_ctime":1641958244,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1641958244","product_id":100020801,"comment_content":"老师，我的疑惑是两阶段提交里的写binlog这一步骤，是写到binlog cache里还是直接落盘。我印象里binlog的落盘必须是在事务提交后进行的，但是看您的描述感觉commit之前的写binlog这个步骤是落盘。","like_count":0},{"had_liked":false,"id":329980,"user_name":"恐龙","can_delete":false,"product_type":"c1","uid":1323030,"ip_address":"","ucode":"7B85A27E40D261","user_header":"https://static001.geekbang.org/account/avatar/00/14/30/16/4773d604.jpg","comment_is_top":false,"comment_ctime":1641712285,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641712285","product_id":100020801,"comment_content":"文中这一句：&quot;真正把日志写到 redo log 文件（文件名是 ib_logfile+ 数字），是在执行 commit 语句的时候做的&quot;，如果redo log为prepare状态，binlog已写入，但事务还未执行commit步骤，此时数据库所在服务器掉电宕机，是否意味着redo log buffer未写入binlog，最终的结果是binlog有记录，redo log无记录？谢谢","like_count":0},{"had_liked":false,"id":324405,"user_name":"Geek_aa9f6e","can_delete":false,"product_type":"c1","uid":2046557,"ip_address":"","ucode":"D2EAAC7244FA45","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epHrVsJzVH0LUFyMmU77Raj3fF3oXrl8OpD4v1wWhRHjPbs2iaeZE5qtw1ZoZWqq5oAeDkAwa8Nv6g/132","comment_is_top":false,"comment_ctime":1638416893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638416893","product_id":100020801,"comment_content":"在崩溃恢复的时候，InnoDB 如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会在其上应用这个redo log，让它重新成为脏页。<br>InnoDB是如何做到这一点的？崩溃之后，buffer pool是空的，只凭借redo log，如何判断其对应的数据页是不是干净的？","like_count":0},{"had_liked":false,"id":323796,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1638165197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638165197","product_id":100020801,"comment_content":"我验证的方法是通过binlog日志：开启bin-log后，设置为Statement格式，发现有对应的操作日志。<br>因为根据之前文章更新的流程，更新的动作肯定会传递到Innodb层，至于Innodb有没有做，按说应该<br>看redolog, 但是redolog是物理日志，不好查看，并且提交了事务的commit，undo页可能已经会回收。而binlog和redolog的两阶段提交方式，说明从binlog也能看到innodb的行为。<br><br>至于为何这么做，我没想出比较好的答案。评论区通过事务角度切入看这个问题，感觉是正解。","like_count":0},{"had_liked":false,"id":323367,"user_name":"克里斯","can_delete":false,"product_type":"c1","uid":1181844,"ip_address":"","ucode":"00B755C10AC1C3","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/94/2c22bd4e.jpg","comment_is_top":false,"comment_ctime":1637855939,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637855939","product_id":100020801,"comment_content":"Commit阶段，向磁盘中的Redo Log写入Commit标识，表示事务提交,呃呃，云里雾里，Commit标识是什么？为啥最重要的东西不说清楚呢？","like_count":0},{"had_liked":false,"id":322291,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1637291568,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637291568","product_id":100020801,"comment_content":"MySQL 技术内幕有一句：因为重做日志写入磁盘时是按照512字节，也就是一个扇区的大小写入，扇区是写入的最小单位，因此可以保证吸入必定是成功的。 想请教老师，为何以扇区为单位写，就一定是成功的？？一直很疑惑。望解答。","like_count":0},{"had_liked":false,"id":318877,"user_name":"瓜牛","can_delete":false,"product_type":"c1","uid":2273620,"ip_address":"","ucode":"5EB7D2F4400A70","user_header":"https://static001.geekbang.org/account/avatar/00/22/b1/54/6d663b95.jpg","comment_is_top":false,"comment_ctime":1635472342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635472342","product_id":100020801,"comment_content":"第一个问题，binlog提交以后，从库听到这个binlog并执行了，那这个时候主库再commit，那主库不就比从库慢了吗？主从就不一致了？","like_count":0},{"had_liked":false,"id":315716,"user_name":"克克","can_delete":false,"product_type":"c1","uid":2742451,"ip_address":"","ucode":"0FA7CA5AB26A6F","user_header":"https://static001.geekbang.org/account/avatar/00/29/d8/b3/38105dbb.jpg","comment_is_top":false,"comment_ctime":1633952056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633952056","product_id":100020801,"comment_content":"老师，上面说的先写redo log再写binlog的问题，如果redo log可以回滚，为什么可能会覆盖别的记录呀？","like_count":0},{"had_liked":false,"id":314993,"user_name":"582726866","can_delete":false,"product_type":"c1","uid":1368458,"ip_address":"","ucode":"DED4D636F024C0","user_header":"https://static001.geekbang.org/account/avatar/00/14/e1/8a/ec2f38bd.jpg","comment_is_top":false,"comment_ctime":1633647574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633647574","product_id":100020801,"comment_content":"表的字段名建议改一下，user1,user2。当user1 like user2时, relationship为1。当user2 like user1时relationship为2，互相like时relationship为3","like_count":0},{"had_liked":false,"id":314265,"user_name":"思考的技术","can_delete":false,"product_type":"c1","uid":1109283,"ip_address":"","ucode":"4D1CEF299F8349","user_header":"https://static001.geekbang.org/account/avatar/00/10/ed/23/94158691.jpg","comment_is_top":false,"comment_ctime":1632922769,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632922769","product_id":100020801,"comment_content":"高并发场景用表方式记录表总行数，无疑会造成性能低下","like_count":0},{"had_liked":false,"id":313701,"user_name":"不凡","can_delete":false,"product_type":"c1","uid":2031689,"ip_address":"","ucode":"28A3EC4C309C56","user_header":"","comment_is_top":false,"comment_ctime":1632623925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632623925","product_id":100020801,"comment_content":"老师，请教个问题，在主从模式半同步after_sync情况下，二阶段提交中binlog的xid写入时机是在哪一步写入的","like_count":0},{"had_liked":false,"id":312587,"user_name":"Geek_8226bc","can_delete":false,"product_type":"c1","uid":2147472,"ip_address":"","ucode":"9F67898DAC2223","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLbM6ZwjHTUuMNI1gIib8ZQTaljbnh1GxEE7RhffyO3SE5ibhh2fWwG1xkyb1XNnYzUhe5b2zaFYy8g/132","comment_is_top":false,"comment_ctime":1631877941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631877941","product_id":100020801,"comment_content":"redolog的prepare阶段是怎么回滚的","like_count":0},{"had_liked":false,"id":312570,"user_name":"Geek_8226bc","can_delete":false,"product_type":"c1","uid":2147472,"ip_address":"","ucode":"9F67898DAC2223","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLbM6ZwjHTUuMNI1gIib8ZQTaljbnh1GxEE7RhffyO3SE5ibhh2fWwG1xkyb1XNnYzUhe5b2zaFYy8g/132","comment_is_top":false,"comment_ctime":1631869088,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631869088","product_id":100020801,"comment_content":"关于两阶段提交有个问题望解答，感谢！<br>redo log 的 prepare 阶段数据是怎么保留的？<br>1、如果是内存，还没到最后的commit，重启数据丢失<br>2、如果是磁盘（假如就是redo log磁盘，只是状态是prepare），binlog还未写入，重启需要回滚redo log，如何回滚（正如老师所说的redolog是顺序写，不能回滚）","like_count":0},{"had_liked":false,"id":310860,"user_name":"A 拽丫头","can_delete":false,"product_type":"c1","uid":1470434,"ip_address":"","ucode":"F875D99D18DF6E","user_header":"https://static001.geekbang.org/account/avatar/00/16/6f/e2/f3b05833.jpg","comment_is_top":false,"comment_ctime":1630937673,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1630937673","product_id":100020801,"comment_content":"疑问：在奔溃恢复的时候，根据redo log  和 bin log 结合使用，但是怎么知道从那个节点开始恢复数据了？是按照redo log 的数据来恢复的吗？ 恢复redo log 中的所有的记录？  如果是的话，有个疑问，redo log 在被应用到  change  buffer 中之后，刷脏页的时候是以change buffer 的数据页来耍新的，那么 redo log 被当前change buffer 应用的log ，会删除吗？","like_count":0},{"had_liked":false,"id":309669,"user_name":"被钓的鱼","can_delete":false,"product_type":"c1","uid":2748506,"ip_address":"","ucode":"A5AFC5D38B88FC","user_header":"https://static001.geekbang.org/account/avatar/00/29/f0/5a/e5bfa9ac.jpg","comment_is_top":false,"comment_ctime":1630295408,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630295408","product_id":100020801,"comment_content":"分布式一致性真的是个很深入的课题, 不存在完美无缺的一致性, 只有性能与一致性之间的权衡, 极端理论讲, 任何间隙性操作都可能出现宕机, 不管是redo log buffer和os buffer都只是比较一致性和性能的得失后的方案, 所以研究这种问题更多的应该关注平衡点, 而不要过于钻研一致性而掉入牛角尖中","like_count":0},{"had_liked":false,"id":308987,"user_name":"Geek_8cf0a3","can_delete":false,"product_type":"c1","uid":2109366,"ip_address":"","ucode":"D1ACDE82193AA2","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLn1rhQ7nlmQgyEZhgfgH0s9BicusXhTG7J6Tcxib2oDVoKVTbia9CcNIkicj2L2a2xqQRicF4FhPepjqA/132","comment_is_top":false,"comment_ctime":1629882460,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1629882460","product_id":100020801,"comment_content":"大佬还会看评论区吗？有个问题想问下。MySQL会在二阶段提交的什么时候给客户端响应成功呢？我理解应该是在成功commit以后。那如果MySQL在binlog 写完，redo log 还没 commit 前发生 crash，客户端拿到的应该会是一个超时之类的错误响应。如果MySQL重启后才会根据binlog完整程度决定事务是否提交的话，我们的业务代码是不是就没办法确定事务到底是成功了还是失败了？","like_count":0,"discussions":[{"author":{"id":2112092,"avatar":"https://static001.geekbang.org/account/avatar/00/20/3a/5c/60fdf8e2.jpg","nickname":"wtdd","note":"","ucode":"26C64BF9CCA061","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392192,"discussion_content":"binlog完整程度代表着事务就是成功了，虽然实际上事务异常终止了，但是日志文件完整，此时会重新提交事务，将未完成的事务再执行一次。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1630896064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307105,"user_name":"Miroticwillbeforever","can_delete":false,"product_type":"c1","uid":2488913,"ip_address":"","ucode":"1DDD8AECD93EA8","user_header":"https://static001.geekbang.org/account/avatar/00/25/fa/51/5da91010.jpg","comment_is_top":false,"comment_ctime":1628862250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628862250","product_id":100020801,"comment_content":"看了也有七八门课程，这门课程老师的回复确实尽心尽责。<br>前面15讲认真看，认真做笔记，收获还是挺大的，但是我有个小问题，对于只会简单的 SQL语句的人来说，比如那些索引都还傻傻分布清（比如我），老师能否提供一个小板块推荐一些辅助资料。比如书籍或者博客之类的，现在新手很难从这么多的互联网资源中择优或者辨别哪个好，哪个不好了。。","like_count":0},{"had_liked":false,"id":306943,"user_name":"卢本伟","can_delete":false,"product_type":"c1","uid":1941856,"ip_address":"","ucode":"E03B9949016930","user_header":"https://static001.geekbang.org/account/avatar/00/1d/a1/60/98f81f78.jpg","comment_is_top":false,"comment_ctime":1628783701,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1628783701","product_id":100020801,"comment_content":"我就想问，你写出这种半成品好意思吗？就不能写成一个章节，把日志再好好讲讲？","like_count":0,"discussions":[{"author":{"id":2112092,"avatar":"https://static001.geekbang.org/account/avatar/00/20/3a/5c/60fdf8e2.jpg","nickname":"wtdd","note":"","ucode":"26C64BF9CCA061","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392196,"discussion_content":"这只是答疑，前面的已经都讲了，还有不会的自己去查，为啥还要再讲日志？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630896449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306880,"user_name":"赴","can_delete":false,"product_type":"c1","uid":2675954,"ip_address":"","ucode":"D47B3179BE3950","user_header":"https://static001.geekbang.org/account/avatar/00/28/d4/f2/3c0bfa0e.jpg","comment_is_top":false,"comment_ctime":1628760717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628760717","product_id":100020801,"comment_content":"假如没有打开binlog是不是redo-log要么commit，要么不成功","like_count":0},{"had_liked":false,"id":306496,"user_name":"BCool","can_delete":false,"product_type":"c1","uid":2689813,"ip_address":"","ucode":"E6C2B78F379988","user_header":"https://static001.geekbang.org/account/avatar/00/29/0b/15/d2b7d7be.jpg","comment_is_top":false,"comment_ctime":1628585642,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628585642","product_id":100020801,"comment_content":"关于追问5的图2例子，事务1既然已经commit了，为什么之后的崩溃回复会丢失它呢？","like_count":0},{"had_liked":false,"id":305421,"user_name":"cake","can_delete":false,"product_type":"c1","uid":1966533,"ip_address":"","ucode":"55A7FC6CC1204C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/01/c5/b48d25da.jpg","comment_is_top":false,"comment_ctime":1627966331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627966331","product_id":100020801,"comment_content":"有人问先写入redo log buffer然后写binlog,binlog写入磁盘,崩溃了怎么办呢?<br>redo log会记录内存页的修改,如果此时崩溃,redo log buffer没了,数据页没了,binlog还在。崩溃恢复的时候,会按顺序扫描 redo log来恢复,没redo log 那就不用恢复,但事务没有提交, 就会通过undo log会回滚。因为内存数据数据页没有刷新到磁盘,也没什么关系。但是一旦事务提交了,必须通过配置把redo log 同步到磁盘,不仅仅是写入操作系统缓冲区。如果这时候崩溃了,磁盘上的redo log就不是完整的。不用崩溃恢复,因为虽然事务提交但数据没刷到磁盘,所以没影响。","like_count":0},{"had_liked":false,"id":305207,"user_name":"🤩","can_delete":false,"product_type":"c1","uid":2063201,"ip_address":"","ucode":"9F0524A1BA1BE6","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7b/61/b65f1438.jpg","comment_is_top":false,"comment_ctime":1627876882,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627876882","product_id":100020801,"comment_content":"“在崩溃恢复场景中，InnoDB 如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让 redo log 更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。”<br>我对文字这段话有疑问，怎么判断数据页在奔溃恢复的时候丢失了更新呢？因为再次从磁盘将数据读到内存中时一定是干净页(磁盘和内存数据一致)，我记得前面几节讲过在内存不足或其他原因刷脏页的时候是不会对redo log中的数据有任何操作的，所以redo log在刷内存的时候若是干净页则跳过不处理。","like_count":0},{"had_liked":false,"id":305206,"user_name":"🤩","can_delete":false,"product_type":"c1","uid":2063201,"ip_address":"","ucode":"9F0524A1BA1BE6","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7b/61/b65f1438.jpg","comment_is_top":false,"comment_ctime":1627876755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627876755","product_id":100020801,"comment_content":"林老师，你好:文中有一句话“在崩溃恢复场景中，InnoDB 如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让 redo log 更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。”<br>我对文字这段话有疑问，怎么判断数据页在奔溃恢复的时候丢失了更新呢？因为再次从磁盘将数据读到内存中时一定是干净页(磁盘和内存数据一致)，我记得前面几节讲过在内存不足或其他原因刷脏页的时候是不会对redo log中的数据有任何操作的，所以redo log在刷内存的时候若是干净页则跳过不处理。","like_count":0},{"had_liked":false,"id":302789,"user_name":"gsn99939","can_delete":false,"product_type":"c1","uid":2678962,"ip_address":"","ucode":"D32D25832CD47B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLGOW1Crcle750QWghPE0lDQoHJYibh4KXFoMRF7qLhWde1nKaeOaaT4IKtC1urx44via16yntc9YdQ/132","comment_is_top":false,"comment_ctime":1626363968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626363968","product_id":100020801,"comment_content":"老师，我有一个问题。就是在刷脏页的时候redo log日志的checkpoint会跟着推进吗？谢谢老师","like_count":0},{"had_liked":false,"id":302133,"user_name":"熊猫","can_delete":false,"product_type":"c1","uid":1080238,"ip_address":"","ucode":"23C85117A16BEF","user_header":"https://static001.geekbang.org/account/avatar/00/10/7b/ae/66ae403d.jpg","comment_is_top":false,"comment_ctime":1626094722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626094722","product_id":100020801,"comment_content":"老师这句:“压缩”到一个语录里面完成，说的太好了。---好多程序都存在类似的“压缩”，压缩背后的原理显的格外重要","like_count":0},{"had_liked":false,"id":300138,"user_name":"Geek_slk","can_delete":false,"product_type":"c1","uid":1614499,"ip_address":"","ucode":"413CDBEF0B7679","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLRXPleVJnXU4gib2Hib5xR7jMmAgVPs1GKuJ39ib8HvnVk79Q3k8STLhOcCcO2rjKSuuMLFRekCyL2A/132","comment_is_top":false,"comment_ctime":1625019461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625019461","product_id":100020801,"comment_content":"老师 没想明白 为啥要比较A 和B呢 比较两个用户的userId 这是为什么啊 想不明白啊","like_count":0},{"had_liked":false,"id":300133,"user_name":"Geek_slk","can_delete":false,"product_type":"c1","uid":1614499,"ip_address":"","ucode":"413CDBEF0B7679","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLRXPleVJnXU4gib2Hib5xR7jMmAgVPs1GKuJ39ib8HvnVk79Q3k8STLhOcCcO2rjKSuuMLFRekCyL2A/132","comment_is_top":false,"comment_ctime":1625018538,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625018538","product_id":100020801,"comment_content":"老师 没想明白 您说的A&gt;B 是指什么 A怎么大于B是哪个字段么","like_count":0},{"had_liked":false,"id":298802,"user_name":"胡浩🐸","can_delete":false,"product_type":"c1","uid":1157175,"ip_address":"","ucode":"F2184A31258439","user_header":"https://static001.geekbang.org/account/avatar/00/11/a8/37/00ed15af.jpg","comment_is_top":false,"comment_ctime":1624329412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624329412","product_id":100020801,"comment_content":"丁奇老师，请教个问题，不知道你还能看到留言不。<br><br>a 表 353642331 条数据, b 表 462103637 条数据，a 表的 b_id 有索引， b 表的 id 是主键， xxx 上也有索引，<br>为啥下面这条语句跑了 69 个小时还没结束呀？<br><br>update a join b on a.b_id = b.id set a.xxx = b.xxx<br><br>innodb_trx 里看到 trx_rows_locked: 460259156 了，是要等到 462103637 才能结束吗？<br><br>之前 a 表的 b_id 没索引，跑了一晚上没跑完，我回滚了，加了一个 b_id 索引，结果还是跑了两天没跑完，我该怎么做能加速这个 update 语句呢？<br><br>问过一些朋友，大多推荐写脚本分批一万一万的update，我想知道有其它的办法吗？","like_count":0},{"had_liked":false,"id":297478,"user_name":"王康","can_delete":false,"product_type":"c1","uid":1416934,"ip_address":"","ucode":"DDFAA49639927C","user_header":"https://static001.geekbang.org/account/avatar/00/15/9e/e6/f362dad1.jpg","comment_is_top":false,"comment_ctime":1623572103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623572103","product_id":100020801,"comment_content":"“这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没 commit 的时候就直接写到 redo log 文件里。<br>所以，redo log buffer 就是一块内存，用来先存 redo 日志的。也就是说，在执行第一个 insert 的时候，数据的内存被修改了，redo log buffer 也写入了日志。<br>但是，真正把日志写到 redo log 文件（文件名是 ib_logfile+ 数字），是在执行 commit 语句的时候做的。”<br><br>这部分内容有问题，redo并不是commit时才落盘。redo log buffer的作用更多是为了并发","like_count":0},{"had_liked":false,"id":296080,"user_name":"Sie Huai Gan","can_delete":false,"product_type":"c1","uid":1476433,"ip_address":"","ucode":"502BC3E07DA001","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/51/a48f69e7.jpg","comment_is_top":false,"comment_ctime":1622734844,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622734844","product_id":100020801,"comment_content":"丁老师，想请问一下，如果redolog 在commit 阶段失败的话，这个事务会被回滚吗？binlog 还可以回滚吗？<br><br>假设可以回滚的话，如何确保回滚前的binlog记录不会被复制到了备库呢？<br><br>谢谢！","like_count":0},{"had_liked":false,"id":292947,"user_name":"大草原","can_delete":false,"product_type":"c1","uid":1301925,"ip_address":"","ucode":"F2FB4DD3E58694","user_header":"https://static001.geekbang.org/account/avatar/00/13/dd/a5/308c23cb.jpg","comment_is_top":false,"comment_ctime":1621089994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621089994","product_id":100020801,"comment_content":"追问 6：那能不能反过来，只用 redo log，不要 binlog？<br>如果redo log不是循环写，而是像binlog一样顺序写，拥有归档作用。主从复制基于redo log来实现，是不是就可以淘汰binlog。","like_count":0},{"had_liked":false,"id":291919,"user_name":"creasylai19","can_delete":false,"product_type":"c1","uid":1128420,"ip_address":"","ucode":"F9B04060FCFD3F","user_header":"https://static001.geekbang.org/account/avatar/00/11/37/e4/5d7a32c6.jpg","comment_is_top":false,"comment_ctime":1620607602,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1620607602","product_id":100020801,"comment_content":"插入朋友关系也可以通过两个锁来实现，先拿userid小的锁，再拿userid大的锁，或者反过来","like_count":0},{"had_liked":false,"id":291577,"user_name":"初晨","can_delete":false,"product_type":"c1","uid":2557602,"ip_address":"","ucode":"7945DA6C62C741","user_header":"https://static001.geekbang.org/account/avatar/00/27/06/a2/c306c734.jpg","comment_is_top":false,"comment_ctime":1620373126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620373126","product_id":100020801,"comment_content":"老师好，我想请教一个问题 ，mysql error log经常有 Got an error reading communication packets，这个可以怎么处理 谢谢。","like_count":0},{"had_liked":false,"id":290328,"user_name":"新手","can_delete":false,"product_type":"c1","uid":1322121,"ip_address":"","ucode":"1C8007C09B8A5E","user_header":"https://static001.geekbang.org/account/avatar/00/14/2c/89/f64f3919.jpg","comment_is_top":false,"comment_ctime":1619501794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619501794","product_id":100020801,"comment_content":"老师好,有几个问题没理解<br>1、使用on duplicate 好像是锁表了呀... 我在自己测试的时候 开启了3个事务，insert (C,D) 也是会锁住的. 所以这一块不明白为什么使用这个...是想要一行一行来执行吗?<br>2、正常insert 的话 会出现3的情况吗,我试了一下 也不会出现啊....<br>想了好久也没明白.. 举例完结已经很久了..不知道还有没有机会蹲到老师..","like_count":0},{"had_liked":false,"id":286967,"user_name":"Geek_55e386","can_delete":false,"product_type":"c1","uid":1795793,"ip_address":"","ucode":"5A727F1323C2D0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/zxkns28cIAUZIt3WjDb8G26qiccT84d9GMr9ZpbYR60TU1ibqSj9NoYVHlJvGF1kOltkqNDmEfJCqPuYVkue3WHg/132","comment_is_top":false,"comment_ctime":1617708650,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617708650","product_id":100020801,"comment_content":"结合老师的文章,和阿里的polardb.才明白为啥,阿里可以选择快照+redolog完成快速备份了,原来binlog并不是必须的,","like_count":0},{"had_liked":false,"id":283740,"user_name":"依逝往昔","can_delete":false,"product_type":"c1","uid":1336581,"ip_address":"","ucode":"5C62D22DD939D2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJM1M1iboffpY17I2eSJjlcyC4ibCJrNeB1EDMjticKospDeTOvZHdheib1tiadEicxGfyInzvJSn7PPqpA/132","comment_is_top":false,"comment_ctime":1615900318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615900318","product_id":100020801,"comment_content":"业务涉及那个例子，数据不存在，行锁无法生效，这个更准确说，应该是read-committed隔离级别下，在可重复读级别下，是存在间隙锁的，select加上for update是可以锁住的，上述例子中，其中一个事务会死锁回滚，然后加上重试逻辑，,这样在业务不修改表结构的情况下，可以实现上述目的，借文中表结构实验如下(都是空表,格式不好调整，勉强看下)：<br>-----------------------------------------<br>session A                                                                               |  session B<br>set tx_isolation = &quot;repeatable-read&quot;;                                       |  set tx_isolation = &quot;repeatable-read&quot;;<br>begin;                                                                                    |  begin;<br>select * from `like` where user_id = 1 and liker_id = 2 for update;|<br>                                                                                              |  select * from `like` where user_id = 2 and liker_id = 1 for update;<br>                                                                                              |  insert into `like` (user_id, liker_id) values(1,2);<br>insert into `like` (user_id, liker_id) values(2,1);<br>  ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction|    Query OK, 1 row affected(提交成功)  <br>                                                                                             | commit;","like_count":0},{"had_liked":false,"id":283594,"user_name":"Hony","can_delete":false,"product_type":"c1","uid":1061082,"ip_address":"","ucode":"898C8C345A340D","user_header":"https://static001.geekbang.org/account/avatar/00/10/30/da/8ec33b04.jpg","comment_is_top":false,"comment_ctime":1615850355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615850355","product_id":100020801,"comment_content":"只有prepare没有commit的redo log，就拿XID去binlog找对应的事务。那如果是biglog是statement格式下的情况，没有XID怎么关联？","like_count":0},{"had_liked":false,"id":281440,"user_name":"杰sir","can_delete":false,"product_type":"c1","uid":1098505,"ip_address":"","ucode":"80BB56B3BFB71A","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/09/dc368335.jpg","comment_is_top":false,"comment_ctime":1614751356,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614751356","product_id":100020801,"comment_content":"关于redo log buffer的问题我总结下我的看法（如有错误，欢迎指正）：<br>1，mysql 本地事务：begin&#47;commit 包起来sql语句，执行结果慢ACID属性。<br>2，两阶段提交：mysql本地事务更新数据除了要在本地持久化，还在通过binlog同步到其他实例，要保证本地数据和其他实例数据的一致就是保证redo log和binlog一致，这个一致就是通过两阶段提交来保证。而本地事务的持久化就是在本地事务commit时触发的，也就是说两阶段提交是在本地事务commit时触发的。<br><br>图 1 两阶段提交示意图，这个图里真正的两阶段提交其实只有最后3步：<br>prepare阶段（第一阶段）：(1) 写入relolog，处于prepare阶段, (2)写入binlog。<br>commit(也就是第二阶段)：提交事务处于commit阶段。（这了的提交事务可能容易引起误解，本地事务提交后就进入了两阶段提交的第一阶段）<br><br>这里虽然叫两阶段提交，其实整个过程都是在本地事务的commit阶段完成的。<br><br>3，redo log buffer：图 1画的是一个事务里只有一条update语句，如果想象一下一个事务里有多个update语句，在一个事务里每条update语句在内存里完成数据更新后都需要记录redo log，此时数据还没有提交，redo log只能缓存在内存里，也就是redo log buffer,等到本地事务提交,触发两阶段提交时，把redo log buffer里的数据写入redo log file。","like_count":0},{"had_liked":false,"id":279600,"user_name":"sotondolphin","can_delete":false,"product_type":"c1","uid":1307088,"ip_address":"","ucode":"42198CE9B201FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QZBHia4nXtspEaRibpmMIMVcDA2HHkNypfvVJ2IllQC3FeFCt7f9iaHW7z5yQ4lcB79ibJwia6tNtpuFroufntMhc2g/132","comment_is_top":false,"comment_ctime":1613842554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613842554","product_id":100020801,"comment_content":"对于业务涉及的那个场景，用一张表就可以解决问题，不需要分开liker &#47; friends. 如果A 喜欢B，就在friends 表里插入一条数据，如果B喜欢A，也插入一条数据。在每次插入成功后，不管是A还是B，都做一个测试. 比如A关注了B，在插入之后，就会执行 select count(*) from t_friends where user=B and liker = A, 如果结果是0就不会显示互相关注。<br>这个互相关注的状态不需要即时的更新，因为这两个人不需要很及时的知道对方关注了自己。所以就算A,B 在查询时因为某些原因都返回了0， 在下次登录的时候系统都会做一次刷新，也会显示出正确的互观状态。","like_count":0},{"had_liked":false,"id":278066,"user_name":"Geek2014","can_delete":false,"product_type":"c1","uid":2028957,"ip_address":"","ucode":"9EB356D8DF287E","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/9d/104bb8ea.jpg","comment_is_top":false,"comment_ctime":1612749734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612749734","product_id":100020801,"comment_content":"on duplicate key update 会造成死锁的吧","like_count":0},{"had_liked":false,"id":274008,"user_name":"汉江","can_delete":false,"product_type":"c1","uid":1788647,"ip_address":"","ucode":"01622D984B8F9B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","comment_is_top":false,"comment_ctime":1610786677,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610786677","product_id":100020801,"comment_content":"老师 请教几个问题：<br>1.我理解的在begin&#47;commit 的commit之前都不是属于二阶段提交的范围<br>2.那假设在begin 之后，commit 之前做了很多 update ,delete的操作，这个时候内存里面的数据发生了变化，生成了脏页，刚好刚才该动的这些内存里面的脏页刷到了磁盘，此时这些操作的日志还在redologbuffer 里面 还没有落盘，刚好系统崩溃重启，那岂不是这个看起来未提交的事务提交了","like_count":0},{"had_liked":false,"id":270167,"user_name":"mofee888","can_delete":false,"product_type":"c1","uid":2249670,"ip_address":"","ucode":"F1FB6F68DCF802","user_header":"","comment_is_top":false,"comment_ctime":1608965063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608965063","product_id":100020801,"comment_content":"对于这个业务的设计，改变了表的结构，也许会给与这个表相关的其他业务逻辑带来不小的麻烦。<br>所以对于这种实时要求不高的变化，都可以转为后台 task 间隔 N 分钟找出相关数据进行补救，以此简化表结构，业务逻辑。","like_count":0},{"had_liked":false,"id":269593,"user_name":"David.cui","can_delete":false,"product_type":"c1","uid":1302228,"ip_address":"","ucode":"AB46F310403612","user_header":"https://static001.geekbang.org/account/avatar/00/13/de/d4/b83c4185.jpg","comment_is_top":false,"comment_ctime":1608708921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608708921","product_id":100020801,"comment_content":"参考其他数据库，mysql应该可以自动备份redo log，当一个写满之后，自动归档，同时业务继续写入下一个redo log file，在恢复的时候就可以抛弃binlog。但是mysql好像做不了这个，就只能是redo log + binlog一起来完成这个事情。<br>另外binlog其实更像其他数据库的CDC或logminer的，用于数据复制之用。<br>在商业数据库中，数据库的复制技术，更多的是利用redo log来去实现，而很少通过类似binlog这样的技术去实现。","like_count":0},{"had_liked":false,"id":267057,"user_name":"学好习，做好人","can_delete":false,"product_type":"c1","uid":1205294,"ip_address":"","ucode":"C991643DB458E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/2e/e70a317a.jpg","comment_is_top":false,"comment_ctime":1607584443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607584443","product_id":100020801,"comment_content":"请问老师，从redo buffer 写到redo log是在图1的时刻A还是时刻B执行的呢？","like_count":0},{"had_liked":false,"id":265199,"user_name":"杨磊","can_delete":false,"product_type":"c1","uid":2130485,"ip_address":"","ucode":"8C06C02568E41D","user_header":"https://static001.geekbang.org/account/avatar/00/20/82/35/602e8bfc.jpg","comment_is_top":false,"comment_ctime":1606812103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606812103","product_id":100020801,"comment_content":"追问9里面为什么说在commit的时候才会写入redolog？图1两段式提交示意图不是写入内存后就开始写入redolog了吗？然后再commit的啊","like_count":0},{"had_liked":false,"id":265176,"user_name":"张爽","can_delete":false,"product_type":"c1","uid":1021129,"ip_address":"","ucode":"ED2969DA26E8E0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/94/c9/374a69f2.jpg","comment_is_top":false,"comment_ctime":1606805518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606805518","product_id":100020801,"comment_content":"如果redo log &amp; binlog是双1的配置，redo log preapre阶段到底是在磁盘上还是在redo log buffer里，追问 9里说的是在redo log buffer，而图1的案例又说是在磁盘上。还是说当事务commit的时候，先写redo log到磁盘是prepare状态，然后写binlog,最后提交磁盘上的redo log为commit状态，还请老师解答。","like_count":0},{"had_liked":false,"id":263840,"user_name":"陈明","can_delete":false,"product_type":"c1","uid":2183012,"ip_address":"","ucode":"10B28F6F8EEF86","user_header":"https://static001.geekbang.org/account/avatar/00/21/4f/64/93500a26.jpg","comment_is_top":false,"comment_ctime":1606277917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606277917","product_id":100020801,"comment_content":"MySQL表中有article、tag、tag_in_article三张表，新增文章接口，会在一个事务中进行，先将文章插入数据库，再将tag与article建立关联关系时，tag_in_article插入数据会频繁报Error 1062: Duplicate entry &#39;24-78&#39; for key &#39;tau_index&#39;&quot;，tau_index为tag_id与article_id在tag_in_article表中的唯一索引。<br>请问这个问题是什么造成的？代码逻辑层中不存在重试逻辑；","like_count":0},{"had_liked":false,"id":263409,"user_name":"LPF","can_delete":false,"product_type":"c1","uid":2287841,"ip_address":"","ucode":"036C552D7251E9","user_header":"https://static001.geekbang.org/account/avatar/00/22/e8/e1/6045b299.jpg","comment_is_top":false,"comment_ctime":1606126872,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606126872","product_id":100020801,"comment_content":"MySQL 支持用户自定义在commit时如何将log buffer中的日志刷log file中。这种控制通过变量innodb_flush_log_at_trx_commit的值来决定。该变量有 3 种值：0、1、2，默认为 1。但注意，这个变量只是控制commit动作是否刷新log buffer到磁盘。<br><br>当设置为 1 的时候，事务每次提交都会将log buffer中的日志写入os buffer并调用fsync()刷到log file on disk中。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO 的性能较差。<br>当设置为 0 的时候，事务提交时不会将log buffer中日志写入到os buffer，而是每秒写入os buffer并调用fsync()写入到log file on disk中。也就是说设置为 0 时是每秒刷新写入到磁盘中的，当系统崩溃，会丢失 1 秒钟的数据。<br>当设置为 2 的时候，每次提交都仅写入到os buffer，然后是每秒调用fsync()将os buffer中的日志写入到log file on disk。<br>所以即使binlog完整，只要没有commit，MySQL异常重启，redo log buffer都是不会写入redolog，那redo log buffer就会清空，那么redo log处于prepare并且binlog完整就不回滚这种情况不就不存在了！吗？","like_count":0},{"had_liked":false,"id":260578,"user_name":"霍华德斯塔克","can_delete":false,"product_type":"c1","uid":1072223,"ip_address":"","ucode":"4C947E5EA10F6A","user_header":"https://static001.geekbang.org/account/avatar/00/10/5c/5f/75284920.jpg","comment_is_top":false,"comment_ctime":1605064275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605064275","product_id":100020801,"comment_content":"老师，我们的项目有这样一个问题：我们的产品是交付给客户，部署在客户各个单位的。这些单位经常遭遇断电的问题，一旦断电，InnoDB数据库文件经常会损坏，数据库就起不来了，需要手动运维恢复（还有一定概率恢复不了）。按道理说，基于binlog和redo log应该具备崩溃自动恢复的能力。请问老师有没有什么办法，或是一些配置项，能够断电后数据库自动恢复正常呢？目前处于成本考虑，客户一般不愿意配置UPS。","like_count":0},{"had_liked":false,"id":260294,"user_name":"x-ray","can_delete":false,"product_type":"c1","uid":1140175,"ip_address":"","ucode":"8363F0C4D0AC0B","user_header":"https://static001.geekbang.org/account/avatar/00/11/65/cf/326c0eea.jpg","comment_is_top":false,"comment_ctime":1604978209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604978209","product_id":100020801,"comment_content":"总结下目前个人看到的两个问题：<br>1.内存脏页刷盘后，MySQL如何处理redo log中被刷盘的数据？<br>答：根据老师的回答，是不处理，只不过下次redo log 写满了，擦除时发生的刷盘，会对擦除的数据进行判断，判断其是否为脏页，是脏页就刷，是干净页就跳过。<br><br>2.redo log中涉及change buffer的内容，如果发生刷盘，会产生merge行为吗？<br>答：根据老师的回答，不会。无论是内存不足发生的刷盘，还是redo log写满时发生的刷盘，如果涉及change buffer，就把change buffer当做普通的数据刷到磁盘上。前面提到过，这就是change buffer的持久化。而merge的行为始终发生在read时。","like_count":0},{"had_liked":false,"id":257625,"user_name":"123之人","can_delete":false,"product_type":"c1","uid":1417637,"ip_address":"","ucode":"49F5CD8C8587BD","user_header":"https://static001.geekbang.org/account/avatar/00/15/a1/a5/8b01ed90.jpg","comment_is_top":false,"comment_ctime":1604045029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604045029","product_id":100020801,"comment_content":"A&gt;B :<br>insert into `like`(user_id, liker_id, relation_ship) values(A, B, 1) on duplicate key update relation_ship=3<br>B&gt;A:<br>insert into `like`(user_id, liker_id, relation_ship) values(B, A, 2) on duplicate key update relation_ship=3<br>感觉这两个场景第一句DML中on duplicate key update 的relation_ship固定为3页可以诶<br>","like_count":0},{"had_liked":false,"id":254486,"user_name":"Demter","can_delete":false,"product_type":"c1","uid":1158439,"ip_address":"","ucode":"BE3B6F726916CE","user_header":"https://static001.geekbang.org/account/avatar/00/11/ad/27/5556ae50.jpg","comment_is_top":false,"comment_ctime":1603120201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603120201","product_id":100020801,"comment_content":"看了一点，就学到了很多，谢谢林老师！","like_count":0},{"had_liked":false,"id":253981,"user_name":"听雨","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1603001234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603001234","product_id":100020801,"comment_content":"InnoDB 如何判断一个数据页有没有在崩溃恢复的时候丢失了更新呢","like_count":0},{"had_liked":false,"id":253404,"user_name":"hey","can_delete":false,"product_type":"c1","uid":2054357,"ip_address":"","ucode":"ECD6D0EC04E50B","user_header":"https://static001.geekbang.org/account/avatar/00/1f/58/d5/6688e2a0.jpg","comment_is_top":false,"comment_ctime":1602729138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602729138","product_id":100020801,"comment_content":"业务设计举的那个例子，先把关注记录插好，提交，然后再查对面有没有关注自己怎么样？","like_count":0},{"had_liked":false,"id":252156,"user_name":"Fighter","can_delete":false,"product_type":"c1","uid":1282641,"ip_address":"","ucode":"B1925EE400372D","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/51/0505254d.jpg","comment_is_top":false,"comment_ctime":1602150327,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1602150327","product_id":100020801,"comment_content":"redo log buffer那块有点没明白，commit的时候才去真正下redo-log，那在commit前crash岂不是就丢数据了，这与redo log的设计初衷不久矛盾了吗","like_count":0,"discussions":[{"author":{"id":1526355,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","nickname":"moonfox","note":"","ucode":"902BFF40EFA9FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330640,"discussion_content":"都没有执行到提交，丢失是正常的呀。图中说的写redolog的都是执行到提交后的情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606661017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246666,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1599449395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599449395","product_id":100020801,"comment_content":"实践结果表明mysql innodb采用的方式2，即读完后会加锁，但并不更新。这样做的目的还是为了保证更新的一致性，如果不加锁，那么同一时间即允许其他事务更新，这违背了update的语义","like_count":0},{"had_liked":false,"id":243027,"user_name":"清蒸结尾鱼","can_delete":false,"product_type":"c1","uid":2012721,"ip_address":"","ucode":"371AA2E17DB89C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/b6/31/c801c289.jpg","comment_is_top":false,"comment_ctime":1597923495,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597923495","product_id":100020801,"comment_content":"老师，你好！有个问题想不明白：既然binlog没有恢复数据页的能力，没有保存数据页的细节，在备库怎么重放进去的？辛苦老师拨冗解答一下哈","like_count":0},{"had_liked":false,"id":242010,"user_name":"Carter","can_delete":false,"product_type":"c1","uid":1030842,"ip_address":"","ucode":"1FD476D8F2BE27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ba/83de3488.jpg","comment_is_top":false,"comment_ctime":1597560878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597560878","product_id":100020801,"comment_content":"老师好，是不是可以这么理解，binlog可以从头开始恢复完整数据；但binlog不能从已落盘数据恢复到完整数据，因为binlog不知道那些数据已经落盘，数据持久化时只需要写了redo log，不一定落盘。<br>binlog是从0恢复数据（备份恢复、多库同步等），磁盘数据+redo log可以快速恢复完整数据。","like_count":0},{"had_liked":false,"id":240603,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1207056,"ip_address":"","ucode":"5CEF9A1806298D","user_header":"https://static001.geekbang.org/account/avatar/00/12/6b/10/22f93764.jpg","comment_is_top":false,"comment_ctime":1596994820,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596994820","product_id":100020801,"comment_content":"关于两阶段提交，有一个点还是没明白，不知道我这样理解对不对<br>1.prepare阶段时，redolog实际写的是redolog buffer(commit时才会刷盘).<br>2.那么如果在binlog写成功后，commit之前，mysql crash了，我理解这个时候redolog丢失了，但是binlog已经同步到备机做了修改。也就是会出现binlog与redolog得不一致。<br>希望老师和各位大神帮忙解惑，感谢","like_count":0,"discussions":[{"author":{"id":1450778,"avatar":"https://static001.geekbang.org/account/avatar/00/16/23/1a/db7dd0e5.jpg","nickname":"梧桐街灯丶","note":"","ucode":"CC15DDDD933ABF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320306,"discussion_content":"应该即便是使用了redolog buffer，在prepare和commit两阶段都必须提交的。否则在prepare阶段如果没提交，发生宕机，文件中是不可能含有prepare字段的，之前的崩溃恢复判断条件也全是错的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604317227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238249,"user_name":"jjyyun","can_delete":false,"product_type":"c1","uid":1592576,"ip_address":"","ucode":"8824654F673087","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLIzE6JOuXsOamCWiaq8sHHVyCK44bdIOEqnE42veoZPEqxs5IJ8RT1Hicz0ZlPQFcbEFSwjV7icrfEw/132","comment_is_top":false,"comment_ctime":1596102443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596102443","product_id":100020801,"comment_content":"“你可以把 binlog 关掉，这样就没有两阶段提交了，但系统依然是 crash-safe 的”，binlog关了，是不是redolog中只认commit的事务。prepare的事务认为是不完整的直接忽略。但是又一个问题，如果binlog也支持prepare和commit2种状态，是不是也能支持crash-safe了。redolog 和binlog是逻辑日志还是物理日志和crash-safe是不是关系不大","like_count":0},{"had_liked":false,"id":238124,"user_name":"huanghuahh","can_delete":false,"product_type":"c1","uid":1063466,"ip_address":"","ucode":"2341E187E49D91","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK3AuPXcqmo2fydvJLUpgvWZJsk43gvHVoEialia68oeTyJ7GTK0UkrpMv89j4Tg4pCTCjobA5gq86Q/132","comment_is_top":false,"comment_ctime":1596074540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596074540","product_id":100020801,"comment_content":"想问下老师，之前说redo log是基于WAL，顺序写加快速度，之后将结果返回给客户端，但是流程里还有一个写binlog的过程，请问是写完redo log后请求就返回客户端然后异步写binlog吗，但这样感觉无法保证客户端收到的结果是对的，因为可能回滚。如果写完binlog提交后再返回给客户端，感觉性能上又不会快了，所以想了解下这个流程到底是什么样的","like_count":0},{"had_liked":false,"id":237532,"user_name":"whyly","can_delete":false,"product_type":"c1","uid":1798882,"ip_address":"","ucode":"D34D6B7164C982","user_header":"https://static001.geekbang.org/account/avatar/00/1b/72/e2/95b0543c.jpg","comment_is_top":false,"comment_ctime":1595856787,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595856787","product_id":100020801,"comment_content":"老师，上面A、B关注的那个场景，当A&lt;B，比如A=2，B=3，首先A关注B，那么应该是insert into `like`(user_id, liker_id, relation_ship) values(2, 3, 1) on duplicate key update relation_ship=relation_ship | 1;`like`表中user_id，liker_id和relation_ship对应的数据是2，3，1，然后在B关注A，执行语句insert into `like`(user_id, liker_id, relation_ship) values(2, 3, 2) on duplicate key update relation_ship=relation_ship | 1;这时候relation_ship= 1 | 1，结果是1啊，不是3，上面的过程哪里出了问题呢？","like_count":0},{"had_liked":false,"id":234739,"user_name":"Garwen","can_delete":false,"product_type":"c1","uid":1045062,"ip_address":"","ucode":"C76346E1734AB8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f2/46/09c457eb.jpg","comment_is_top":false,"comment_ctime":1594784543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594784543","product_id":100020801,"comment_content":"老师，这个数据页落盘的问题让我更疑惑了，之前文章讲解的由redolog来记录更新，之后抽空再将数据的更新写入磁盘。现在又说从内存更新脏页直接写入磁盘没有redolog什么事。这两个说法就把我搞蒙了。哪位能讲解一下啊。","like_count":0},{"had_liked":false,"id":233056,"user_name":"lleft","can_delete":false,"product_type":"c1","uid":1970443,"ip_address":"","ucode":"D573EB509455AE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIx1V1QAxC4NHaxYZGyuibBN8lcURJWc5nrnO4yic1kxnDemYV2FJGialf47kYX9qtDnZZOfe1SJeLicg/132","comment_is_top":false,"comment_ctime":1594207241,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594207241","product_id":100020801,"comment_content":"redo log在commit的时候从redo log buffer写入到磁盘的redo log文件，binlog也是在commit的时候写，一次commit这两个日志同时写？","like_count":0},{"had_liked":false,"id":233048,"user_name":"Geek_07a5f9","can_delete":false,"product_type":"c1","uid":2058966,"ip_address":"","ucode":"7478945032C139","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKARWSGics4fJG6PNLvZz0Xy0F2UovamAWKAd7YgKaFmPhF2zml13TPWC1ubaLs2GTq2HUDZs5wI7Q/132","comment_is_top":false,"comment_ctime":1594201496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594201496","product_id":100020801,"comment_content":"老师你好：假设已经做了两个事务，T1和T2，T1修改了数据页1，先生存了LSN1，然后事务T2修改了数据页2，生成了LSN2的 redolog， 然后发生了checkpoint，发现需要把脏页2的数据刷到磁盘，这时候由于LSN2是大于LSN1的，那么LSN1对应的脏数据页1也会被动的刷新到磁盘嘛","like_count":0},{"had_liked":false,"id":229251,"user_name":"海鸟","can_delete":false,"product_type":"c1","uid":1028311,"ip_address":"","ucode":"EBAF85D1EFFAAB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b0/d7/22ce0046.jpg","comment_is_top":false,"comment_ctime":1592931787,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592931787","product_id":100020801,"comment_content":"最后的问题中，如果执行 update 语句会返回最终数据更新的行数，比如：<br>Rows matched: 1  Changed: 0  Warnings: 0<br>这里结合前面的知识点有点疑惑了，前面提到更新数据时会使用 chagne buffer ，这样其实数据页不用读取到内存页的，那么怎么会实时反馈客户端 changed 信息的呢？","like_count":0},{"had_liked":false,"id":228383,"user_name":"布尔-极客","can_delete":false,"product_type":"c1","uid":1265214,"ip_address":"","ucode":"FFB20E8632EE24","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKicxChCIAib1Qjo616J02icxDHc0BPFcPu31De1ONvYoXnkicfGJUrsozGBkib1ibbQ5onhhXfbovLlaDg/132","comment_is_top":false,"comment_ctime":1592653403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592653403","product_id":100020801,"comment_content":"老师针对互关的问题的实现方案是否如下的操作，这样的话，查询某人关注的好友的时候会挺麻烦。<br>约定user_id&lt;liker_id,a&lt;b时，a=10,b=20<br><br>sessionA:<br>insert into `like`(user_id, liker_id, relation_ship) values(10, 20, 1) on duplicate key update relation_ship=relation_ship | 1;<br>select relation_ship from `like` where user_id=10 and liker_id=20;<br>#1<br>commit;<br><br>sessionB:<br>insert into `like`(user_id, liker_id, relation_ship) values(10, 20, 2) on duplicate key update relation_ship=relation_ship | 2;<br>select relation_ship from `like` where user_id=10 and liker_id=20;<br>#3<br>insert ignore into friend(friend_1_id, friend_2_id) values(10,20);<br>commit;<br><br>select * from `like`;<br>+----+---------+----------+---------------+<br>| id | user_id | liker_id | relation_ship |<br>+----+---------+----------+---------------+<br>|  1 |      10 |       20 |             3 |<br>+----+---------+----------+---------------+<br><br>select * from `friend`;<br>+----+-------------+-------------+<br>| id | friend_1_id | friend_2_id |<br>+----+-------------+-------------+<br>|  1 |          10 |          20 |<br>+----+-------------+-------------+","like_count":0},{"had_liked":false,"id":227800,"user_name":"creasylai19","can_delete":false,"product_type":"c1","uid":1128420,"ip_address":"","ucode":"F9B04060FCFD3F","user_header":"https://static001.geekbang.org/account/avatar/00/11/37/e4/5d7a32c6.jpg","comment_is_top":false,"comment_ctime":1592484104,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1592484104","product_id":100020801,"comment_content":"业务设计的这个问题，目前是三种状态，位操作设计得很精巧。提供一种思路，分两个事务，先插入，提交事务。然后再查询，如果存在相互关注，就insert朋友表，这样应该也可以。两个并发线程中最后commit的那个总是可以拿到全部数据","like_count":0},{"had_liked":false,"id":227739,"user_name":"鱼","can_delete":false,"product_type":"c1","uid":1487584,"ip_address":"","ucode":"89EC9CE3AD0281","user_header":"https://static001.geekbang.org/account/avatar/00/16/b2/e0/d856f5a4.jpg","comment_is_top":false,"comment_ctime":1592467559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592467559","product_id":100020801,"comment_content":"（开始准备随便写写，但是看老师这么认真回答大家的问题，我也稍微总结一下）<br>“业务设计问题”中的成为好友的问题，实际上就是一种非常典型的写冲突问题：两个并发的写事物，一个事物的写修改了另外一个事物（可能不是同一个数据）执行的先决条件。<br>在这个例子中就是 事物1中需要判断B有没有喜欢A，而根据这个业务上的约束去决定接下来的操作，而事物2却修改了这个前提条件。<br>通常解决这类隔离要求更高的问题问题（隔离级别高于一致性视图，也就是快照级别）有以下几种方式：<br>1. 实际串行执行<br>2. 两阶段加锁（FOR UPDATE 通知数据库对所有返回的行加锁）<br>3. 如果没有加锁的对象，可以实体化冲突<br>4. 业务上控制（锁定开支）<br>5. 可串行化的快照隔离SSI<br>老师实际上采用的是一种变形的实体化冲突的方式，将原来业务定义的冲突逻辑实体化到数据库中的一行记录上去，也就是<br>“值是 1 的时候，表示 user_id 关注 liker_id;值是 2 的时候，表示 liker_id 关注 user_id;值是 3 的时候，表示互相关注。”<br>这部分，值得学习。<br>","like_count":0},{"had_liked":false,"id":227735,"user_name":"鱼","can_delete":false,"product_type":"c1","uid":1487584,"ip_address":"","ucode":"89EC9CE3AD0281","user_header":"https://static001.geekbang.org/account/avatar/00/16/b2/e0/d856f5a4.jpg","comment_is_top":false,"comment_ctime":1592466873,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592466873","product_id":100020801,"comment_content":"“业务设计问题”中的举例，其实就是一个非常典型的写倾斜问题：两个并发的写事物，一个事物的写修改了另外一个事物（可能不是同一个数据）执行的先决条件。","like_count":0},{"had_liked":false,"id":224029,"user_name":"武兴业","can_delete":false,"product_type":"c1","uid":1092637,"ip_address":"","ucode":"9091C8B76AD2F0","user_header":"https://static001.geekbang.org/account/avatar/00/10/ac/1d/c695f03e.jpg","comment_is_top":false,"comment_ctime":1591258898,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1591258898","product_id":100020801,"comment_content":"老师您好，请教一下，mysql-bin.000001什么情况下会从000001重新计数呢<br><br>如果运行了好多年，这个会重新从000001开始吗","like_count":0,"discussions":[{"author":{"id":1970443,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIx1V1QAxC4NHaxYZGyuibBN8lcURJWc5nrnO4yic1kxnDemYV2FJGialf47kYX9qtDnZZOfe1SJeLicg/132","nickname":"lleft","note":"","ucode":"D573EB509455AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372352,"discussion_content":"会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620294197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223106,"user_name":"鲁班大师","can_delete":false,"product_type":"c1","uid":1179156,"ip_address":"","ucode":"4F9615DF87B031","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/14/f1532dec.jpg","comment_is_top":false,"comment_ctime":1591002554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591002554","product_id":100020801,"comment_content":"老师，回过头来重新看，发现undolog没怎么介绍，想到一些问题，undolog和redolog,binlog的写入顺序？undolog何时落盘？我理解undolog也应该在两阶段协议里处理的吧","like_count":0},{"had_liked":false,"id":222021,"user_name":"yonglongk","can_delete":false,"product_type":"c1","uid":1980225,"ip_address":"","ucode":"AE3168B15BA5AF","user_header":"","comment_is_top":false,"comment_ctime":1590657356,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590657356","product_id":100020801,"comment_content":"林老师，您好，请问上面那个“关注”问题里面，like表是不是 A,B量用户相互关注的话1，2,3这三个状态总共有6条呢，包括用A查的，123，用B查的123","like_count":0},{"had_liked":false,"id":221736,"user_name":"陈斌","can_delete":false,"product_type":"c1","uid":1450358,"ip_address":"","ucode":"B3F3A2117F8455","user_header":"https://static001.geekbang.org/account/avatar/00/16/21/76/0e443bcb.jpg","comment_is_top":false,"comment_ctime":1590579346,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590579346","product_id":100020801,"comment_content":"老师，我有个疑惑的地方就是，您文中的这句描述：“此时，binlog 里面并没有记录数据页的更新细节，是补不回来的” ，binlog没有记录数据页的更新细节，但是binlog不是有记录了每一条执行的sql语句吗？可否用记录的每一条sql来恢复数据呢？一点疑惑一样老师可以解答，谢谢","like_count":0},{"had_liked":false,"id":221088,"user_name":"talkyoung","can_delete":false,"product_type":"c1","uid":1613665,"ip_address":"","ucode":"8D231FA9004B64","user_header":"https://static001.geekbang.org/account/avatar/00/18/9f/61/c46b42f4.jpg","comment_is_top":false,"comment_ctime":1590402455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590402455","product_id":100020801,"comment_content":"业务涉及这个小模块实现的真是太巧妙了 哈哈 看两遍才懂这样设计的原因","like_count":0},{"had_liked":false,"id":217854,"user_name":"雪の雫·雨の音","can_delete":false,"product_type":"c1","uid":1997293,"ip_address":"","ucode":"0693DA3939A321","user_header":"https://static001.geekbang.org/account/avatar/00/1e/79/ed/4737a49b.jpg","comment_is_top":false,"comment_ctime":1589630353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589630353","product_id":100020801,"comment_content":"我好像有点明白老师的意思了。。意思是说，binlog的本来目的在于恢复数据，先读取某个时间点的数据库备份，从这个时间点开始按照binlog记录的信息恢复数据是可以正确恢复的；但是对于数据库crash然后重启的情况，实际磁盘里面的数据更新情况是随机的（可能有的更新落盘了有的没落盘），而binlog是没有办法判断这个情况的。而对于redolog，因为数据更新落盘了之后会在redolog有相应记录，所以redolog可以根据实际更新的落盘情况来针对性的恢复数据。是这个意思吗？","like_count":0},{"had_liked":false,"id":213617,"user_name":"雨中漫步","can_delete":false,"product_type":"c1","uid":1130927,"ip_address":"","ucode":"022AFC716E3CAA","user_header":"https://static001.geekbang.org/account/avatar/00/11/41/af/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1588492602,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1588492602","product_id":100020801,"comment_content":"有一点还是不明白，redo log 是在对应事务的脏页数据写入磁盘后可被覆盖，那假如脏页写入到磁盘，然后crash ，没有推进checkpoint ，进行数据恢复的时候是不是又会重新执行那些已经执行过的操作呢？","like_count":0,"discussions":[{"author":{"id":1110149,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f0/85/fca692bf.jpg","nickname":"zhendecai","note":"","ucode":"DD27D314F8177D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260063,"discussion_content":"因为数据是幂等的啊，redolog保存的是当前数据页的信息啊，所以重复多少次问题都不大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588845284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1526355,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","nickname":"moonfox","note":"","ucode":"902BFF40EFA9FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1110149,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f0/85/fca692bf.jpg","nickname":"zhendecai","note":"","ucode":"DD27D314F8177D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330638,"discussion_content":"这里与等幂性无关，没有推进会推进，然后通过lsn判定这个redolog已经执行过了，就直接跳过，不用执行redolog中的内容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606660830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":260063,"ip_address":""},"score":330638,"extra":""}]}]},{"had_liked":false,"id":209473,"user_name":"qwc","can_delete":false,"product_type":"c1","uid":1345393,"ip_address":"","ucode":"FACA3958F322BD","user_header":"","comment_is_top":false,"comment_ctime":1587555498,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587555498","product_id":100020801,"comment_content":"老师您好，有个问题很疑惑，select for update where或者update where ，where条件是通过索引查询。正常情况会有行级锁，如果说查询或更新的行不存在，那是不是应该上表级锁呀？<br>","like_count":0},{"had_liked":false,"id":199643,"user_name":"余向华","can_delete":false,"product_type":"c1","uid":1119778,"ip_address":"","ucode":"263773616D2C83","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/22/2205cf0a.jpg","comment_is_top":false,"comment_ctime":1585493068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585493068","product_id":100020801,"comment_content":"当时很多疑惑都能够解开了。","like_count":0},{"had_liked":false,"id":197146,"user_name":"X丶楓","can_delete":false,"product_type":"c1","uid":1079760,"ip_address":"","ucode":"F5402FBD150BC1","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/d0/63ac112e.jpg","comment_is_top":false,"comment_ctime":1585360246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585360246","product_id":100020801,"comment_content":"答疑文章真棒，前面不懂的一下子清晰了","like_count":0},{"had_liked":false,"id":193727,"user_name":"复兴","can_delete":false,"product_type":"c1","uid":1363230,"ip_address":"","ucode":"C172A87873001A","user_header":"https://static001.geekbang.org/account/avatar/00/14/cd/1e/692c3313.jpg","comment_is_top":false,"comment_ctime":1584955380,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584955380","product_id":100020801,"comment_content":"“但是，真正把日志写到 redo log 文件（文件名是 ib_logfile+ 数字），是在执行 commit 语句的时候做的。“ 第二篇不是说 先写redo log(prepare) 再写binlog，最后commit，这里说commit的时候，才写redo log。","like_count":0},{"had_liked":false,"id":190298,"user_name":"运维老胡","can_delete":false,"product_type":"c1","uid":1227007,"ip_address":"","ucode":"DF398BEE296E11","user_header":"https://static001.geekbang.org/account/avatar/00/12/b8/ff/249da6da.jpg","comment_is_top":false,"comment_ctime":1584627680,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584627680","product_id":100020801,"comment_content":"主键索引带有叶子节点的数据，应该是引擎层发现值与原来相同，不更新，直接返回。","like_count":0},{"had_liked":false,"id":186982,"user_name":"youngButcher","can_delete":false,"product_type":"c1","uid":1563339,"ip_address":"","ucode":"2762D20F1E8D19","user_header":"","comment_is_top":false,"comment_ctime":1583983453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583983453","product_id":100020801,"comment_content":"A和B的大小比较是什么意思啊","like_count":0},{"had_liked":false,"id":186871,"user_name":"先听","can_delete":false,"product_type":"c1","uid":1151409,"ip_address":"","ucode":"82D8DA7A2FEB4B","user_header":"https://static001.geekbang.org/account/avatar/00/11/91/b1/fb117c21.jpg","comment_is_top":false,"comment_ctime":1583942076,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1583942076","product_id":100020801,"comment_content":"互相关注加好友那个例子，老师给出的设计很巧妙。<br>如果扩展一下有这样一个功能：<br>可能会有 “找出某人user_idxxx所关注的所有人”<br><br>可以把user_id和liker_id比较大小后，把大的作为friend_id1,小的作为friend_id2插到friend表里面(和like表反过来). 这样拿着user_idxxx在like表和friend表里面分别查一次然后合并就可以得到想要的结果了。","like_count":0,"discussions":[{"author":{"id":1151409,"avatar":"https://static001.geekbang.org/account/avatar/00/11/91/b1/fb117c21.jpg","nickname":"先听","note":"","ucode":"82D8DA7A2FEB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202866,"discussion_content":"哦，我的这个说法不对。会漏掉id比user_idxxx小，但是没有关注user_idxxx的人","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583972283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183524,"user_name":"williamcai","can_delete":false,"product_type":"c1","uid":1158294,"ip_address":"","ucode":"B158F52C2D39BC","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/96/46b13896.jpg","comment_is_top":false,"comment_ctime":1583058054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583058054","product_id":100020801,"comment_content":"第一种，把表t加一个时间戳字段，值设置为当前时间戳，发现更新操作后，时间没有变化","like_count":0},{"had_liked":false,"id":178852,"user_name":"华融科技","can_delete":false,"product_type":"c1","uid":1808280,"ip_address":"","ucode":"B6BA3C47C05073","user_header":"","comment_is_top":false,"comment_ctime":1581840437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581840437","product_id":100020801,"comment_content":"老师关于本主题的课后作业中，你分析说为什么没法做等值对比分析。因为 “MySQL 在更新前是进行了等值对比的。只是在这个语句里面，MySQL 认为读出来的值，只有一个确定的 (id=1), 而要写的是 (a=3)，只从这两个信息是看不出来“不需要修改”的。”   想问一下，为什么看不出来 不需要修改？ ID 确实了唯一行， a=3确认了要更新的值，完全可以与原表a的值进行等值对比呀？","like_count":0},{"had_liked":false,"id":175697,"user_name":"王盛武","can_delete":false,"product_type":"c1","uid":1182516,"ip_address":"","ucode":"DE7EF246D3DCE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","comment_is_top":false,"comment_ctime":1580801888,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580801888","product_id":100020801,"comment_content":"&quot;InnoDB 如果判断到一个数据页可能在崩溃恢复的时候丢失了更新&quot;<br>崩溃重启后，如何判断识别出一个数据页可能在崩溃恢复的时候丢失了更新？","like_count":0},{"had_liked":false,"id":175689,"user_name":"、落叶为你舞","can_delete":false,"product_type":"c1","uid":1756562,"ip_address":"","ucode":"A196460774A33F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/cd/92/f75a00dd.jpg","comment_is_top":false,"comment_ctime":1580800750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580800750","product_id":100020801,"comment_content":"redo log buffer只有在commit状态才会刷盘，为什么redo log里有prepare状态？","like_count":0},{"had_liked":false,"id":164983,"user_name":"栋能","can_delete":false,"product_type":"c1","uid":1006849,"ip_address":"","ucode":"8BD9C939D3E8E1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5d/01/9cd84003.jpg","comment_is_top":false,"comment_ctime":1577123817,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577123817","product_id":100020801,"comment_content":"引用：“如果图1的写入redo log是写内存，当时刻B发生crash，重启后这部分redo log都丢失了，那么何谈判断redo log是否有完整的prepare还是commit标志呢？” 作者回复：“不是哦，<br>在事务执行期间是在redo log buffer.在图中写binlog之前，就已经都写了盘并且fsync了”. 我理解是commit时，除了把redo buffer log 写入了到了redo log（而文中只讲redo buffer log Commit的部分，并没讲完后续，所以会有在B点crash的困惑），还会把redo log状态设为prepare，继续binlog写入，继续后续操作等，直到最后再commit.","like_count":0},{"had_liked":false,"id":160160,"user_name":"遇见","can_delete":false,"product_type":"c1","uid":1624590,"ip_address":"","ucode":"FAF53CD4C28494","user_header":"https://static001.geekbang.org/account/avatar/00/18/ca/0e/5009c5ff.jpg","comment_is_top":false,"comment_ctime":1575882584,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575882584","product_id":100020801,"comment_content":"由文章中提到的&quot;结果显示，匹配 (rows matched) 了一行，修改 (Changed) 了 0 行。&quot;想到的一点:<br><br>在程序的数据库连接地址中有一个参数, useAffectedRows, 如果这个参数设置成了true, 那么在这个例子中, jdbc api 或者 mybatis框架 的更新语句返回的受影响行数就是0.<br><br>如果这时用程序返回的 jdbc或者mybatis框架返回的 0 来判断是否数据库更新成功, 就会出现明明数据库更新成功了, 但是程序却认为没有成功, 从而抛出异常, 一路反馈到用户端.<br><br>虽然这时要更新的数据和数据库中的数据本身就是一样的, 不影响数据的准确性, 但是在程序的行为上是比较怪异的.<br><br>一般程序在做更新操作的时候, 都会通过判断返回的行数来得知此次更新操作是否成功.<br>而在更新之前一般都不会在代码中判断要更新的值和数据库的当前值是否一样<br><br>如果url中没有设置这个参数或者这个参数设置为false, jdbc则会返回rows matched的值, 这里就是1. 程序可以正常据此判断.<br><br>这儿可能是一个坑.","like_count":0},{"had_liked":false,"id":155979,"user_name":"Geek_e0c36d","can_delete":false,"product_type":"c1","uid":1709425,"ip_address":"","ucode":"5FB004687DB2CB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aM00uMFibmtMG9OcSiaB9HwRuRdRNUuMQibWNmmq7r33p7nibkY1CQbLicNYDufEjickLt82VQBtZ0BibrJ6X4RIer02A/132","comment_is_top":false,"comment_ctime":1574786751,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574786751","product_id":100020801,"comment_content":"额老师，前面的问题请忽略。<br>我的新问题是，一条更新语句执行，使用WAL,只写了内存和redo log就算完成了。两阶段提交体现在哪？纠结啊","like_count":0},{"had_liked":false,"id":152635,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1574054512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574054512","product_id":100020801,"comment_content":"amazing🤩","like_count":0},{"had_liked":false,"id":152491,"user_name":"Ccc","can_delete":false,"product_type":"c1","uid":1691243,"ip_address":"","ucode":"EAEA0284948959","user_header":"https://static001.geekbang.org/account/avatar/00/19/ce/6b/ae7489a0.jpg","comment_is_top":false,"comment_ctime":1574035892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574035892","product_id":100020801,"comment_content":"看到老师用了on duplicate key update，想问一个相关问题：<br>参数innodb_autoinc_lock_mode值为1的时候，每次用on duplicate key update时，不管是插入还是更新，<br>都会更新该表的自增id；如果这个操作比较频繁的话，会导致主键id自增的很快。<br>下面这三种做法合理吗：<br>(1)把参数innodb_autoinc_lock_mode改为0<br>(2)自增id用bigint类型<br>(3)把这条语句拆成select ,insert&#47;update  两条语句<br><br>有没有其他更好的方式吗？","like_count":0},{"had_liked":false,"id":149396,"user_name":"CcczzZ","can_delete":false,"product_type":"c1","uid":1019568,"ip_address":"","ucode":"5F46DA5053D2BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","comment_is_top":false,"comment_ctime":1573210869,"is_pvip":false,"replies":[{"id":"57450","content":"你说得对，<br>赞细致<br>我们勘误下","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1573224673,"ip_address":"","comment_id":149396,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573210869","product_id":100020801,"comment_content":"文章里创建friend表语句id字段少了一个标点哈。「id` int(11) NOT NULL AUTO_INCREMENT」。<br>应该是 `id` int(11) NOT NULL AUTO_INCREMENT","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473848,"discussion_content":"你说得对，\n赞细致\n我们勘误下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573224673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145711,"user_name":"无菇朋友","can_delete":false,"product_type":"c1","uid":1035562,"ip_address":"","ucode":"80482C5F0464A3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/2a/bdbed6ed.jpg","comment_is_top":false,"comment_ctime":1572350451,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1572350451","product_id":100020801,"comment_content":"老师您好，有一个疑问，mysql在对事务进行回滚时，应该是有一些判断逻辑吧（比如根据undo log里数据的更改时序？），不然可能会出现覆盖别的事务的更改？","like_count":0,"discussions":[{"author":{"id":1970443,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIx1V1QAxC4NHaxYZGyuibBN8lcURJWc5nrnO4yic1kxnDemYV2FJGialf47kYX9qtDnZZOfe1SJeLicg/132","nickname":"lleft","note":"","ucode":"D573EB509455AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372351,"discussion_content":"mvcc？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620294100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143194,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1571645452,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1571645452","product_id":100020801,"comment_content":"老师对于“业务设计问题”您给出的答案，为什么要区分A&gt;B和A&lt;B的情况呢？没有明白","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158858,"discussion_content":"因为a<b为1，a>b为2，大于小于只是一种关注关系，但是唯索引是userid_likerid的前后关系，所以这种前后不能变，变的就是关注关系，因为UK的存在，并发解决了，然后剩下的就是当记录中有1或者2时，执行到第二步时就相当于互相关注了，此时改成3，同时向friend表中插入一条记录。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580634374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135638,"user_name":"星星滴蓝天","can_delete":false,"product_type":"c1","uid":1465990,"ip_address":"","ucode":"2F2F56F93AD828","user_header":"https://static001.geekbang.org/account/avatar/00/16/5e/86/40877404.jpg","comment_is_top":false,"comment_ctime":1569232319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569232319","product_id":100020801,"comment_content":"个人感觉“但是如果 A、B 同时关注对方，会出现不会成为好友的情况”这种最好还是在外面用其他分布式锁保证，类似于订单同一时间支付一次的效果。或者搞个定时任务判断下有没有这种异常情况发生，然后处理下。","like_count":0},{"had_liked":false,"id":126455,"user_name":"我家门前有只猪","can_delete":false,"product_type":"c1","uid":1488035,"ip_address":"","ucode":"F8CF618CF4681E","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/a3/a159ca86.jpg","comment_is_top":false,"comment_ctime":1566388080,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1566388080","product_id":100020801,"comment_content":"为什么wal就是顺序写？","like_count":0,"discussions":[{"author":{"id":1022507,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOpANMwDibLmj5IGJh6dTw300sZ1BHM5sG3sZv1A1rvCHOiblPD3jgFOiaMVVujtctWnQbVFoNPpRgw/132","nickname":"alioo","note":"","ucode":"F36A38C1F5FFAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7700,"discussion_content":"wal我理解是写redolog，只是记录日志而已，直接往后插入就行的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567645474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1970443,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIx1V1QAxC4NHaxYZGyuibBN8lcURJWc5nrnO4yic1kxnDemYV2FJGialf47kYX9qtDnZZOfe1SJeLicg/132","nickname":"lleft","note":"","ucode":"D573EB509455AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1022507,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOpANMwDibLmj5IGJh6dTw300sZ1BHM5sG3sZv1A1rvCHOiblPD3jgFOiaMVVujtctWnQbVFoNPpRgw/132","nickname":"alioo","note":"","ucode":"F36A38C1F5FFAB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372349,"discussion_content":"redo log是固定大小的连续的存储空间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620293713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7700,"ip_address":""},"score":372349,"extra":""}]}]},{"had_liked":false,"id":125970,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1566286907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566286907","product_id":100020801,"comment_content":"”但是，真正把日志写到 redo log 文件（文件名是 ib_logfile+ 数字），是在执行 commit 语句的时候做的。”<br><br>我记得老师说过，redo log就是为了减少磁盘的随机写io，提升性能，但是上边的话，每次更新，既然更新一定会提交，提交又都要写盘了(我理解redo log文件一定是落盘了)，这好像和老师说的矛盾了。(先写redo log   redo log会定时的落盘)","like_count":0},{"had_liked":false,"id":122527,"user_name":"nirvana","can_delete":false,"product_type":"c1","uid":1612674,"ip_address":"","ucode":"1DD07B5F2C6E03","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKT7Exm9wh9wtJYvB33mEwcUmNKfkzYjk56GrPUsllwc5iaklMSJ0eaaTbKuAFgQaFLtDSIfUcogGQ/132","comment_is_top":false,"comment_ctime":1565416381,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1565416381","product_id":100020801,"comment_content":"业务上有这样的需求，A、B 两个用户，如果互相关注，则成为好友<br>这个问题能否这样解决：<br>A like B时：<br>begin;<br>insert into like(user_id, like_id) values(A, B);<br>commit;<br>begin;<br>select * from like where user_id = B and like_id = A;<br>如果有记录<br>那么 insert into friend...<br>commit<br><br>此时A，B同时互相like时应当不会出现不能成为friend的情况，要嘛A能读到B插入like的记录，要嘛B能读到A插入到like表的记录","like_count":0,"discussions":[{"author":{"id":1016917,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/55/1e40bd61.jpg","nickname":"shiziwen","note":"","ucode":"ADADC770D82D66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":266252,"discussion_content":"希望老师和同学们能指出这种设计的不足之处，谢谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589481640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016917,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/55/1e40bd61.jpg","nickname":"shiziwen","note":"","ucode":"ADADC770D82D66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":266251,"discussion_content":"看文章的时候，我的第一反应，也是这么设计，不知道有没有隐藏的问题。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589481578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121099,"user_name":"Geek_4e4ec2","can_delete":false,"product_type":"c1","uid":1603078,"ip_address":"","ucode":"6DAD5EE4FFB195","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/zAZv4NyuS21Y1qk45j8JiaoEYdA5Zgc1PqpJsBokz5bZVmdkf6kNWvT4cUAAKAdH6TgN52DWZhiaH6wNFhw14nRg/132","comment_is_top":false,"comment_ctime":1565058014,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1565058014","product_id":100020801,"comment_content":"用户相互关注问题如果id是varchar类型应该怎么办呢，请老师给个思路","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158859,"discussion_content":"varchar也是可以比大小的吧。这个不是重点，重点是靠这种大小来明确一种关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580634434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120150,"user_name":"布衣不舍","can_delete":false,"product_type":"c1","uid":1144495,"ip_address":"","ucode":"7576087DC22F3B","user_header":"https://static001.geekbang.org/account/avatar/00/11/76/af/c4e518ff.jpg","comment_is_top":false,"comment_ctime":1564799541,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1564799541","product_id":100020801,"comment_content":"老师好，请教一下，innodb主键索引的叶子节点分裂时会有数据从旧页面迁移到新的页面，这种情况下是不是也要记录redo？","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158860,"discussion_content":"不用吧，这个有关系吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580634560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119291,"user_name":"thomas","can_delete":false,"product_type":"c1","uid":1016777,"ip_address":"","ucode":"9AB945308F1B50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/c9/5d03981a.jpg","comment_is_top":false,"comment_ctime":1564551955,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1564551955","product_id":100020801,"comment_content":"老师，有什么工具可以查看ib_logfile文件吗","like_count":0},{"had_liked":false,"id":114447,"user_name":"玩命","can_delete":false,"product_type":"c1","uid":1106854,"ip_address":"","ucode":"68FEEA5F541B7E","user_header":"https://static001.geekbang.org/account/avatar/00/10/e3/a6/3f6f0cea.jpg","comment_is_top":false,"comment_ctime":1563319461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563319461","product_id":100020801,"comment_content":"最后一句是不是不会有表锁","like_count":0},{"had_liked":false,"id":114129,"user_name":"Sancho","can_delete":false,"product_type":"c1","uid":1436391,"ip_address":"","ucode":"78849913082622","user_header":"https://static001.geekbang.org/account/avatar/00/15/ea/e7/9ce305ec.jpg","comment_is_top":false,"comment_ctime":1563240562,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563240562","product_id":100020801,"comment_content":"同时关注，加为好友，按老师思路<br>如果A&lt;B时<br>A关注B<br>mysql&gt; begin; &#47;* 启动事务 *&#47;<br>insert into `like`(user_id, liker_id, relation_ship) values(A, B, 1) on duplicate key update relation_ship=relation_ship | 1;<br>select relation_ship from `like` where user_id=A and liker_id=B;<br>&#47;* 代码中判断返回的 relation_ship，<br>  如果是 1，事务结束，执行 commit<br>  如果是 3，则执行下面这两个语句：<br>  *&#47;<br>insert ignore into friend(friend_1_id, friend_2_id) values(A,B);<br>commit;<br><br>如此同时，B关注A（B&gt;A），推演(根据老师文中&quot;如果A&gt;B,xxx&quot;)应该执行如下逻辑：<br>mysql&gt; begin; &#47;* 启动事务 *&#47;<br>insert into `like`(user_id, liker_id, relation_ship) values(A, B, 2) on duplicate key update relation_ship=relation_ship | 2;<br>select relation_ship from `like` where user_id=A and liker_id=B;<br>&#47;* 代码中判断返回的 relation_ship，<br>  如果是 2，事务结束，执行 commit<br>  如果是 3，则执行下面这两个语句：<br>*&#47;<br>insert ignore into friend(friend_1_id, friend_2_id) values(A,B);<br>commit;<br><br>推演结论：<br>由于`like`表中对(`friend_1_id`,`firned_2_id`)加了唯一键索引，根据上面推演出来的insert `like`语句，会有唯一键冲突而失败,然后insert into `like`&quot;降级&quot;为<br>update `like` set relation_ship=relation_ship | 2 where user_id=A and liker_id=B;<br><br>这样同时产生A关注B与B关注A时，就会操作同一行记录，先执行的事务会执行insert into `like`，同时下面的select持有该行的读锁；后到的另一个事务由于唯一键冲突被降级为update后，只有等待该行的行锁被释放。<br><br>PS：本来对老师文中“行锁冲突”有疑问，准备按文中逻辑推演提出问题，结果推着推着“行锁冲突”自己就出来了，引起极度舒适","like_count":0},{"had_liked":false,"id":113501,"user_name":"chenpiing","can_delete":false,"product_type":"c1","uid":1357056,"ip_address":"","ucode":"C847A30B3FDB8F","user_header":"https://static001.geekbang.org/account/avatar/00/14/b5/00/f4e8fbaf.jpg","comment_is_top":false,"comment_ctime":1563035715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563035715","product_id":100020801,"comment_content":"关于两阶段提交中prepare阶段阶段的疑问<br><br>请问prepare阶段是会将一条redo日志写入到redolog中并标记为prepare，然后事务提交成功时再回redolog中找到刚才那条日志把它标记为commit吗？如果在此期间由于其他事务的提交使得redolog的write pos往前推了不少，之前那条标记为prepare状态的redo log怎么找出来并标为commit呢？<br><br>这里不是很理解，希望老师帮忙解惑，谢谢","like_count":0},{"had_liked":false,"id":110336,"user_name":"Geek","can_delete":false,"product_type":"c1","uid":1466335,"ip_address":"","ucode":"1B8EB2C26DE4EC","user_header":"https://static001.geekbang.org/account/avatar/00/16/5f/df/3c4881f0.jpg","comment_is_top":false,"comment_ctime":1562232085,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1562232085","product_id":100020801,"comment_content":"老师，请问下社交关系建立这个案例中，这种可以互相加好友的业务会导致数据量非常大。这种情况下如何设计表结构呢","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158861,"discussion_content":"数据量大也可以按照此种表结构来设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580634627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109247,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1561987504,"is_pvip":false,"replies":[{"id":"39576","content":"淡定~~哈哈","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1562010178,"ip_address":"","comment_id":109247,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1561987504","product_id":100020801,"comment_content":"人与人的差别核心在于认知，同样是人同样是技术人，为什么有人是小白？为什么有人是大神？有人有车有房衣食无忧？有人担心被辞被裁？如果技术实力，如林老师这般还会有这种担忧吗？<br>为什么差距这么大呢？天赋？努力？就是没别人聪明怎么办？就是没别人学习能力强怎么办？同样的专栏内容有人觉得小儿科太过简单要求在深入一些？有人一脸懵逼完全不知所以然？<br>那咋弄？我也不知道，我只知道人和人本来就是有差异的，人无完人，自身更不例外，基础不好补基础，一遍不会第二遍，保持心态平和，多思考多想想郭靖。<br>现在感觉老师就是马钰！","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456320,"discussion_content":"淡定~~哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562010178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022507,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOpANMwDibLmj5IGJh6dTw300sZ1BHM5sG3sZv1A1rvCHOiblPD3jgFOiaMVVujtctWnQbVFoNPpRgw/132","nickname":"alioo","note":"","ucode":"F36A38C1F5FFAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7701,"discussion_content":"为什么差距这么大呢？天赋？努力？—>我比较好奇你最后得出的结论是啥?你觉得天赋和努力哪个更重要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567645682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108423,"user_name":"微笑","can_delete":false,"product_type":"c1","uid":1363834,"ip_address":"","ucode":"6E8E2964D0191F","user_header":"https://static001.geekbang.org/account/avatar/00/14/cf/7a/51951b07.jpg","comment_is_top":false,"comment_ctime":1561769551,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1561769551","product_id":100020801,"comment_content":"想问下老师 写盘和fsync是啥区别  写盘就已经落盘了吧  干嘛还要fsync","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158866,"discussion_content":"落盘是一种概念，fsync是实现的一种方式吧。个人这么理解哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580635005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101854,"user_name":"　　","can_delete":false,"product_type":"c1","uid":1560563,"ip_address":"","ucode":"0D736D44A24C56","user_header":"https://static001.geekbang.org/account/avatar/00/17/cf/f3/48fc6781.jpg","comment_is_top":false,"comment_ctime":1559997826,"is_pvip":false,"replies":[{"id":"36690","content":"文章和问题中的例子实验一下，看看好不好好些，后端开发工程师还是迟早要接触这些的<br>","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1560003500,"ip_address":"","comment_id":101854,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559997826","product_id":100020801,"comment_content":"老师 我是只有一年工作经验的后端开发工程师，看了前面的15节课程 ，给我的感觉十分的复杂，索引和语句的执行过程我能够听懂，但是在关于日志片的课程中，感觉到压力真的好大，基本上都听不懂，所以我想咨询一下老师您，对于我目前的这种情况有必须继续往下听下去吗 ？我再坚持 但是很多地方都很难理解或者说很难在现实的情况下去实现这种事情， ","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453145,"discussion_content":"文章和问题中的例子实验一下，看看好不好好些，后端开发工程师还是迟早要接触这些的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560003500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98642,"user_name":"ZHANG","can_delete":false,"product_type":"c1","uid":1442437,"ip_address":"","ucode":"BAFD110AE33328","user_header":"https://static001.geekbang.org/account/avatar/00/16/02/85/9a81a973.jpg","comment_is_top":false,"comment_ctime":1559047614,"is_pvip":false,"replies":[{"id":"35318","content":"👍快乐最赞","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1559060797,"ip_address":"","comment_id":98642,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559047614","product_id":100020801,"comment_content":"学习的最快乐的一个专栏","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451768,"discussion_content":"👍快乐最赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559060797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96014,"user_name":"Socket","can_delete":false,"product_type":"c1","uid":1313213,"ip_address":"","ucode":"932CF3D692FFB5","user_header":"https://static001.geekbang.org/account/avatar/00/14/09/bd/cc31c95d.jpg","comment_is_top":false,"comment_ctime":1558312818,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558312818","product_id":100020801,"comment_content":"问一个问题mvcc和redolog有什么关系呢？追问9中提到事务还没提交前，插入的数据是不会写入到redolog。那么一个长事务中有许多插入和更新这些数据都写去哪里呢？怎么做到多版本控制？如果不写到redolog怎么做到事务回滚","like_count":0},{"had_liked":false,"id":96000,"user_name":"GLADIATOR","can_delete":false,"product_type":"c1","uid":1448564,"ip_address":"","ucode":"6FE14E0BCD6240","user_header":"https://static001.geekbang.org/account/avatar/00/16/1a/74/8f7f8786.jpg","comment_is_top":false,"comment_ctime":1558309212,"is_pvip":false,"replies":[{"id":"36699","content":"其实也是可以的，只是一开始没这么做","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1560003896,"ip_address":"","comment_id":96000,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1558309212","product_id":100020801,"comment_content":"直接归档redolog不行吗","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450675,"discussion_content":"其实也是可以的，只是一开始没这么做","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560003896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1302064,"avatar":"https://static001.geekbang.org/account/avatar/00/13/de/30/b468b41d.jpg","nickname":"北落狮门","note":"","ucode":"C5A951170001B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12972,"discussion_content":"8.0.17恢复了redolog的归档功能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568622481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93172,"user_name":"　","can_delete":false,"product_type":"c1","uid":1172538,"ip_address":"","ucode":"DBE2DB5CC52C91","user_header":"https://static001.geekbang.org/account/avatar/00/11/e4/3a/16545faf.jpg","comment_is_top":false,"comment_ctime":1557413706,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1557413706","product_id":100020801,"comment_content":"后面的例子中<br><br>这个A、B关注的关系（由用户点击的）在数据库逻辑中为什么跟id大小挂钩了？后面的SQL语句也不是很理解为什么要那样做？","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158867,"discussion_content":"因为a<b为1，a>b为2，大于小于只是一种关注关系，但是唯索引是userid_likerid的前后关系，所以这种前后不能变，变的就是关注关系，因为UK的存在，并发解决了，然后剩下的就是当记录中有1或者2时，执行到第二步时就相当于互相关注了，此时改成3，同时向friend表中插入一条记录。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580635061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92150,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1306334,"ip_address":"","ucode":"B2F2E2F28397BC","user_header":"https://static001.geekbang.org/account/avatar/00/13/ee/de/eb2baece.jpg","comment_is_top":false,"comment_ctime":1557192125,"is_pvip":false,"replies":[{"id":"34320","content":"逻辑就是说，<br>如果允许redo log写完，再写binlog，那意味着，redo log写完以后，就不让回滚了；<br><br><br>那binlog写失败怎么办呢？<br><br>这个意思哈","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1558261577,"ip_address":"","comment_id":92150,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557192125","product_id":100020801,"comment_content":"老师你的追问4并不能自圆其说啊。<br><br>问的是redo log写完，再写binlog，最后才提交事务，为何不可。老师怎么解释成，redo log写完就提交，然后binlog写失败的情况了","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449160,"discussion_content":"逻辑就是说，\n如果允许redo log写完，再写binlog，那意味着，redo log写完以后，就不让回滚了；\n\n\n那binlog写失败怎么办呢？\n\n这个意思哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558261577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89391,"user_name":"~玲玲玲~子~哥~","can_delete":false,"product_type":"c1","uid":1302741,"ip_address":"","ucode":"89379F3A0427EA","user_header":"https://static001.geekbang.org/account/avatar/00/13/e0/d5/7485e51f.jpg","comment_is_top":false,"comment_ctime":1556163002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556163002","product_id":100020801,"comment_content":"老师您好,在跟着做实验时,对好友关注表有疑问<br>建表语句`user_id` 和 `liker_id`都是int(11),但是实例语句是<br>select relation_ship from `like` where user_id=A and liker_id=B;<br>如果like表字段都为int, 假设user_id为1和3的两个用户相互关注模拟如下:<br>##session A<br>mysql&gt; begin;<br>Query OK, 0 rows affected (0.01 sec)<br><br>mysql&gt; insert into `like`(user_id, liker_id, relation_ship) values(1, 3, 1) on duplicate key update relation_ship=relation_ship | 1;<br>Query OK, 1 row affected (0.00 sec)<br><br>mysql&gt; select relation_ship from `like` where user_id=1 and liker_id=3;<br>+---------------+<br>| relation_ship |<br>+---------------+<br>|             1 |<br>+---------------+<br>1 row in set (0.00 sec)<br><br>##在提交前切换到SESSION B<br>mysql&gt; begin;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; insert into `like`(user_id, liker_id, relation_ship) values(3, 1, 2) on duplicate key  update relation_ship=relation_ship | 2;<br>Query OK, 1 row affected (53.42 sec)<br>注:这时由于SESSION A还没有提交进入锁等待, A提交后插入成功(53秒原因是等待session A)<br><br>mysql&gt; select relation_ship from `like` where user_id=3 and liker_id=1;<br>+---------------+<br>| relation_ship |<br>+---------------+<br>|             2 |<br>+---------------+<br>1 row in set (0.00 sec)<br><br>1.这里有老师说的&quot;如果反向的关系已经存在,就会出现行锁冲突&quot;<br>但是on duplicate key却没有生效. 不知道其中缘由<br><br><br>2.insert ignore into friend(friend_1_id, friend_2_id) values(A,B)| values(B,A);<br>设计初就是想通过friend表查看是否是好友, 但是这种插入方式,查看是否是好友时,是不是就地写成:<br>select * from friedn where (friend_1_id=A and  friend_2_id=B) or (friend_1_id=B and  friend_2_id=A);<br>这样反而影响查询效率了. <br><br>3.还有这句&quot;这个设计里,让&#39;like&#39;表里的数据保证user_id&lt;liker_id&quot; 通过什么来保证<br><br>","like_count":0},{"had_liked":false,"id":88818,"user_name":"微微一笑","can_delete":false,"product_type":"c1","uid":1250327,"ip_address":"","ucode":"CFA7ABE81D0B99","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/17/8763dced.jpg","comment_is_top":false,"comment_ctime":1556007716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556007716","product_id":100020801,"comment_content":"老师，有个问题希望你能解答下。当服务异常重启时，redolog的checkpoint会往后扫，将数据页加载到内存中。问题1，checkpoint往后扫到哪里停止呢？还是把所有的redolog都扫完？问题2：在往后扫的过程中，要将数据加载到bufferpool中，如果加载过多，导致内存不够了肿么办呢？停下来进行刷脏页吗？","like_count":0},{"had_liked":false,"id":88353,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1142081,"ip_address":"","ucode":"B77968684C1A51","user_header":"https://static001.geekbang.org/account/avatar/00/11/6d/41/3e1c2485.jpg","comment_is_top":false,"comment_ctime":1555909483,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1555909483","product_id":100020801,"comment_content":"老师 我想问下，如果一张表T有 a,b,c三个字段，唯一索引是（a，b，c）,普通索引是(c),当我select * from T where a = &quot;a&quot; and c=&quot;c&quot;,这个时候，这条语句走的索引是唯一索引，这是为什么呢？","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158870,"discussion_content":"说明c这个索引的扫描行数比唯一索引少。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580635194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83670,"user_name":"dz617","can_delete":false,"product_type":"c1","uid":1221366,"ip_address":"","ucode":"5952846AB16744","user_header":"","comment_is_top":false,"comment_ctime":1554695402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554695402","product_id":100020801,"comment_content":"请问老师，这里说到redo log的落盘，想问下undolog有没有落盘这个概念？如果没有的话，调用undo回滚又是怎么调用呢？5.7以后undolog也有自己的独立物理文件，这个文件里面存的又是什么内容呢？谢谢老师","like_count":0},{"had_liked":false,"id":83439,"user_name":"梦想","can_delete":false,"product_type":"c1","uid":1286059,"ip_address":"","ucode":"71DE16FC85D868","user_header":"https://static001.geekbang.org/account/avatar/00/13/9f/ab/1b0dfa68.jpg","comment_is_top":false,"comment_ctime":1554601042,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1554601042","product_id":100020801,"comment_content":"&quot;数据落盘，这个过程，甚至与 redo log 毫无关系&quot; 老师这怎么理解？redologo不是粉板吗？怎么写数据跟他没关系了？","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158873,"discussion_content":"落盘写数据靠内存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580635239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83419,"user_name":"darwin","can_delete":false,"product_type":"c1","uid":1368090,"ip_address":"","ucode":"2F93C0881AAC7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/1a/3a77856a.jpg","comment_is_top":false,"comment_ctime":1554569057,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1554569057","product_id":100020801,"comment_content":"老师，想问问还有很多公司有异构系统（比如一些数据分析系统），这些异构系统跟mysql是怎么实现数据同步的？","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158874,"discussion_content":"工具解析binlog吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580635273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82428,"user_name":"嘻嘻","can_delete":false,"product_type":"c1","uid":1325931,"ip_address":"","ucode":"E1EB75DD1C05E0","user_header":"","comment_is_top":false,"comment_ctime":1554208138,"is_pvip":false,"replies":[{"id":"30158","content":"prepare的时候就要落盘一次的哈（就是包含了一次写数据到盘）","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1554616535,"ip_address":"","comment_id":82428,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554208138","product_id":100020801,"comment_content":"老师，redo log buffer那段有疑问，如果redo log先写内存，commit才写文件，那么，为什么还存在写了prepare和binlog的场景？binlog也不是直接写磁盘(sync_binlog=1)?","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445585,"discussion_content":"prepare的时候就要落盘一次的哈（就是包含了一次写数据到盘）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554616535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81562,"user_name":"唯她命","can_delete":false,"product_type":"c1","uid":1240398,"ip_address":"","ucode":"8F687E8D306840","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4e/ef406442.jpg","comment_is_top":false,"comment_ctime":1553946978,"is_pvip":false,"replies":[{"id":"29640","content":"👍","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1554047622,"ip_address":"","comment_id":81562,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553946978","product_id":100020801,"comment_content":"看完后面的章节，再回来看这一篇，豁然开朗啊，好多都在后面章节讲到了。","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445254,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554047622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78768,"user_name":"取一个长长长长的名字","can_delete":false,"product_type":"c1","uid":1387521,"ip_address":"","ucode":"8C39641B6EBCA1","user_header":"https://static001.geekbang.org/account/avatar/00/15/2c/01/636452b4.jpg","comment_is_top":false,"comment_ctime":1553236709,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1553236709","product_id":100020801,"comment_content":"业务设计问题，我觉得其实不用那么复杂，其实在业务代码中把insert into `like`(user_id,lile_id) values(A,B)放在前面，select * form `like` where user_id = B and like_id = A放在后面去执行是不是就解决了呢？其实这个问题我觉得还应当要去考虑数据库的主从同步的问题，select如果查询的是从库的也话，也有可能由于主从延迟，导致查询数据不符合逾期。","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158880,"discussion_content":"那如果恰好并发时，select * form `like` where user_id = B and like_id = A没有，返回后，马上进来这种关系的一条数据，岂不是判断不出来了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580635548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78017,"user_name":"cam","can_delete":false,"product_type":"c1","uid":1195618,"ip_address":"","ucode":"5C111E4914E0FA","user_header":"https://static001.geekbang.org/account/avatar/00/12/3e/62/d02d8f86.jpg","comment_is_top":false,"comment_ctime":1553055081,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553055081","product_id":100020801,"comment_content":"赞赞赞","like_count":0},{"had_liked":false,"id":78005,"user_name":"罗飞","can_delete":false,"product_type":"c1","uid":1032310,"ip_address":"","ucode":"DA28B6D24A583E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/76/12203657.jpg","comment_is_top":false,"comment_ctime":1553052705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553052705","product_id":100020801,"comment_content":"这些问题，只要把数据库实现原理及jim gray 的事务处理读一遍，全部通透！ ","like_count":0},{"had_liked":false,"id":77348,"user_name":"悟空WuKong","can_delete":false,"product_type":"c1","uid":1139455,"ip_address":"","ucode":"49AFD2B048C1BA","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/ff/f71034e9.jpg","comment_is_top":false,"comment_ctime":1552910563,"is_pvip":false,"replies":[{"id":"28807","content":"|  是按位或","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1553340125,"ip_address":"","comment_id":77348,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552910563","product_id":100020801,"comment_content":"请问这是什么意思：... on duplicate key update relation_ship=relation_ship | 2;<br><br>","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443692,"discussion_content":"|  是按位或","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553340125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76735,"user_name":"浪迹天涯的蜗牛","can_delete":false,"product_type":"c1","uid":1462230,"ip_address":"","ucode":"ABB3D1C542F777","user_header":"https://static001.geekbang.org/account/avatar/00/16/4f/d6/8371b5c3.jpg","comment_is_top":false,"comment_ctime":1552698336,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1552698336","product_id":100020801,"comment_content":"关于redo日志和binlog的两阶段有点没太明白，如果事务的最后阶段是rollback，但是你的binlog已经写入了，这时不就会不一致吗？","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158885,"discussion_content":"最后rollback说明一是真的要执行回滚，反正不是commit；二是binlog有可能不完整，需要回滚。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580635692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74941,"user_name":"唯她命","can_delete":false,"product_type":"c1","uid":1240398,"ip_address":"","ucode":"8F687E8D306840","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4e/ef406442.jpg","comment_is_top":false,"comment_ctime":1552317322,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1552317322","product_id":100020801,"comment_content":"binlog 不是保存了sql的执行逻辑吗，不应该是想怎么恢复就怎么恢复吗，那为什么一直说 “没有信息”","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158886,"discussion_content":"binlog存的是行信息，redolog是页信息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580635807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74835,"user_name":"唯她命","can_delete":false,"product_type":"c1","uid":1240398,"ip_address":"","ucode":"8F687E8D306840","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4e/ef406442.jpg","comment_is_top":false,"comment_ctime":1552302851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552302851","product_id":100020801,"comment_content":"老师，binlog 里面并没有记录数据页的更新细节   binlog里面不是保存了sql执行逻辑吗，为啥说binlog 里面并没有记录数据页的更新细节？","like_count":0},{"had_liked":false,"id":73300,"user_name":"。","can_delete":false,"product_type":"c1","uid":1222200,"ip_address":"","ucode":"75B163F01F20F3","user_header":"https://static001.geekbang.org/account/avatar/00/12/a6/38/55483b8c.jpg","comment_is_top":false,"comment_ctime":1551854223,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551854223","product_id":100020801,"comment_content":"林老师，关注关系那个例子，也可以用分布式锁的方案解决吧？比如redis","like_count":0},{"had_liked":false,"id":73016,"user_name":"八怪","can_delete":false,"product_type":"c1","uid":1328234,"ip_address":"","ucode":"A9200AC057BDAD","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/6a/49f026af.jpg","comment_is_top":false,"comment_ctime":1551777768,"is_pvip":false,"replies":[{"id":"26576","content":"Row格式的binlog的话，是不调用的","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1551814962,"ip_address":"","comment_id":73016,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551777768","product_id":100020801,"comment_content":"percona 5.7.22版本源码<br>丁奇老师，我简单做了一下debug发现这种情况不会调用table-&gt;file-&gt;ha_update_row进入innodb层进行更新了啊<br>当然扫描数据加锁肯定是要进入innodb层然后获取数据的，mysql层发现两个值是相同的就不调用了。<br>感觉像是innodb层加锁获取数据回mysql层进行比较，mysql层发现相同不再调用ha_update_row接口了不知道对否。<br>我打了断点如下：<br>row_upd_clust_step<br>row_upd<br>row_upd_step<br>row_update_for_mysql<br>ha_innobase::update_row<br>handler::ha_update_row<br>sql_update.cc:811<br><br>发现innodb层的update方法都没调用，其次发现undo 也没有生成。<br><br>debug sql_update.cc:811行开始如下<br><br>(gdb) n<br>828             if (!records_are_comparable(table) || compare_records(table)) &#47;&#47;这里mysql层比较了记录？这里判断是否调用table-&gt;file-&gt;ha_update_row<br>(gdb) n<br>906             if (!error &amp;&amp; table-&gt;triggers &amp;&amp;<br>(gdb) n<br>914             if (!--limit &amp;&amp; using_limit)<br>(gdb) n<br>970           thd-&gt;get_stmt_da()-&gt;inc_current_row_for_condition();<br>(gdb) n<br>971           if (thd-&gt;is_error())<br>(gdb) n<br>809         while (true)<br>(gdb) n<br><br>Breakpoint 17, mysql_update (thd=0x7ffe7c000b70, fields=..., values=..., limit=18446744073709551614, handle_duplicates=DUP_ERROR, found_return=0x7fffec0f4bd8, <br>    updated_return=0x7fffec0f4bd0) at &#47;root&#47;mysqlall&#47;percona-server-locks-detail-5.7.22&#47;sql&#47;sql_update.cc:811<br>811           error= info.read_record(&amp;info);<br>(gdb) p compare_records(table)<br>$4 = false<br>(gdb) p records_are_comparable(table)<br>$5 = true<br>(gdb) <br><br>忘老师看看。谢谢老师","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441878,"discussion_content":"Row格式的binlog的话，是不调用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551814962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69434,"user_name":"不惑ing","can_delete":false,"product_type":"c1","uid":1207079,"ip_address":"","ucode":"AF04E417D38027","user_header":"https://static001.geekbang.org/account/avatar/00/12/6b/27/8c964e52.jpg","comment_is_top":false,"comment_ctime":1550742614,"is_pvip":false,"replies":[{"id":"24987","content":"1.  redolog 加commit标识 &gt; binlog 加commit标识 ， 这两个顺序调换一下<br><br>2. 追问5的回答的意思是，如果没有两阶段，redo log先提交完成再写binlog的话，就会导致binlog写入过程如果发生错误，无法回滚<br><br>3. 是的","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550996477,"ip_address":"","comment_id":69434,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550742614","product_id":100020801,"comment_content":"您好，看完后还有3个疑问不能确定，如果看到留言希望帮忙确认一下，非常感谢<br><br>1.图一：最后commit之后还给redolog binlog增加‘commit’标识，完整流程是 ：<br>开始commit &gt; redolog prepare &gt; binlog prepare &gt; 返回事物提交成功 &gt; redolog 加commit标识 &gt; binlog 加commit标识。<br>所以对应到文章中的2(a)的情况，这个理解有问题么？<br><br>2.追问5：binlog1丢失的原因是因为数据还在内存没刷到磁盘？如果设置innodb_flush_log_at_trx_commit=1 每次commit都刷到磁盘是不是就不会丢失了？这个两个理解有问题么？<br><br>3.追问5：根据‘历史原因’那段描述理解，redolog是在InnerDB引擎实现的  binlog是在Server层实现的？这个理解有问题么？<br>","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440120,"discussion_content":"1.  redolog 加commit标识 &amp;gt; binlog 加commit标识 ， 这两个顺序调换一下\n\n2. 追问5的回答的意思是，如果没有两阶段，redo log先提交完成再写binlog的话，就会导致binlog写入过程如果发生错误，无法回滚\n\n3. 是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550996477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69170,"user_name":"Jefitar","can_delete":false,"product_type":"c1","uid":1370659,"ip_address":"","ucode":"D7ED9F32ADA5B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/ea/23/508f71e3.jpg","comment_is_top":false,"comment_ctime":1550672682,"is_pvip":false,"replies":[{"id":"24559","content":"都要是insert into `like`(user_id, liker_id, relation_ship) values(A, B, 1) on duplicate key update relation_ship=relation_ship | 1; 这么写才行哦<br><br>你改了语句可就不保证了😆","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550679709,"ip_address":"","comment_id":69170,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550672682","product_id":100020801,"comment_content":"感谢老师辛苦地讲解！每篇文章都有收获！<br>关于“重复调用时幂等性”，我没搞懂。以A&lt;B为例，下面的的两条语句是如何保证幂等性的？<br><br>insert into `like`(user_id, liker_id, relation_ship) values(A, B, 1) on duplicate key update relation_ship=relation_ship | 1;<br>insert ignore into friend(friend_1_id, friend_2_id) values(A,B); ","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439980,"discussion_content":"都要是insert into `like`(user_id, liker_id, relation_ship) values(A, B, 1) on duplicate key update relation_ship=relation_ship | 1; 这么写才行哦\n\n你改了语句可就不保证了😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550679709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67886,"user_name":"immortalCockroach","can_delete":false,"product_type":"c1","uid":1157912,"ip_address":"","ucode":"9A4F497BEA7DFB","user_header":"https://static001.geekbang.org/account/avatar/00/11/ab/18/b01e71d1.jpg","comment_is_top":false,"comment_ctime":1550310230,"is_pvip":false,"replies":[{"id":"24022","content":"对，就是在崩溃的瞬间，磁盘上那个数据页","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550321349,"ip_address":"","comment_id":67886,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550310230","product_id":100020801,"comment_content":"追问8：在崩溃恢复场景中，InnoDB 如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让 redo log 更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。<br><br>这个&quot;将它读到内存&quot;中的它是原始的表记录信息吗？<br>","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439411,"discussion_content":"对，就是在崩溃的瞬间，磁盘上那个数据页","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550321349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67725,"user_name":"书豪","can_delete":false,"product_type":"c1","uid":1068091,"ip_address":"","ucode":"212FBDE59E8457","user_header":"https://static001.geekbang.org/account/avatar/00/10/4c/3b/2780fc51.jpg","comment_is_top":false,"comment_ctime":1550232917,"is_pvip":false,"replies":[{"id":"24013","content":"不是，这个relation_ship，就是字段名哦，不用代入参数。","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550299537,"ip_address":"","comment_id":67725,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550232917","product_id":100020801,"comment_content":"老师，在业务设计问题中的关注问题中，比如A小于B的情况<br>mysql&gt; begin; &#47;* 启动事务 *&#47;<br>insert into `like`(user_id, liker_id, relation_ship) values(A, B, 1) on duplicate key update relation_ship=relation_ship | 1;<br>select relation_ship from `like` where user_id=A and liker_id=B;<br>这里的relation_ship=relation_ship | 1的relation_ship的值是从哪里取得的，是下边select语句检索得到的吗？如果是的话，那应该就是插入的值1吧？就是对这个执行逻辑有点不清晰，还希望老师能梳理一下。<br><br>","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439346,"discussion_content":"不是，这个relation_ship，就是字段名哦，不用代入参数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550299537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66199,"user_name":"窗外","can_delete":false,"product_type":"c1","uid":1311172,"ip_address":"","ucode":"1E8F2D9439E7F3","user_header":"https://static001.geekbang.org/account/avatar/00/14/01/c4/21c2cde4.jpg","comment_is_top":false,"comment_ctime":1549891473,"is_pvip":false,"replies":[{"id":"25270","content":"新年好（虽然其实已经元宵都过了，不好意思，这个问题回太晚啦）<br><br>1. 是状态改变，同时写redo log文件的，写512字节。<br>2. 多个redo 刷同一个的话，第一个redo先刷，变成干净页。然后之后如果没有再对这个页面的更新，那从第二个redo log位置开始，发现这是一个干净页，就跳过了。<br>3. 第一个问题的commit位<br>4. 不能<br>5. 看下23篇<br>6. “不能恢复数据页”，这个还是内容导致的。binlog里面记录的是逻辑操作<br>7. 没事，在这个阶段如果出问题，比如宕机重启，那事务还没有到提交阶段呢，事务本来就可以丢掉<br>8. 目前还没有这个参数选项。考虑主备一致性，还是得提交","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1551187361,"ip_address":"","comment_id":66199,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1549891473","product_id":100020801,"comment_content":"老师，新年快乐啊，过年期间攒了好些问题，不想打扰您，现在问下，还请解惑，<br><br>1. redo log 在 prepare 与 commit 两处有什么区别呢，仅仅是一个状态的改变吗？<br>2. 刷新 redo log 时，如果多个 redo log 对应的是同一个脏页，此时是合并 redo log 再刷新还是单条刷新，如果是单条 redo log 刷新，那脏页中的其它脏数据怎么处理呢？如果是合并刷新那这些 redo log 不连贯时怎么处理，是否会涉及到随机 io 的消耗？且合并到什么程度呢？<br>3. 怎么判断 redo log 是完整的？在判断 binlog 完整性时，是判断单个 binlog 文件的完整性还是 binlog 中每个事务的完整性？<br>4. 能否用 binlog 恢复 redo log？如果能，redo log 中包含页的信息，而 binlog 中不包含，这些信息怎么获取的？<br>5. 如果刷新脏页与 redo log 无关，那脏页落盘，redo log 没落盘时（假设 innodb_flush_log_at_trx_commit != 1，事务提交，脏页落盘，但 redo log 没落盘），此时崩溃，数据为什么可能会丢失&#47;不一致，即该参数为 1 的重要性？<br>6. 不能只用 binlog 恢复数据，是因为 1. 时机不好控制，那这在 redo log 是怎么解决的？lsn 吗? 2. 不能恢复数据页，我的理解是可以通过 binlog 恢复数据，为什么不能用于崩溃后的恢复呢？为什么此时不需要相关页的信息？<br>7. 更新内存的同时写 redo log buffer，此时是怎么保障两者皆写成功呢，毕竟一旦一个写失败就会出问题？<br>8. 当崩溃后，3 步提交中的前 2 步均已完成，理论上会自动提交该事务，此时能否设置该事务不自动提交？","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438748,"discussion_content":"新年好（虽然其实已经元宵都过了，不好意思，这个问题回太晚啦）\n\n1. 是状态改变，同时写redo log文件的，写512字节。\n2. 多个redo 刷同一个的话，第一个redo先刷，变成干净页。然后之后如果没有再对这个页面的更新，那从第二个redo log位置开始，发现这是一个干净页，就跳过了。\n3. 第一个问题的commit位\n4. 不能\n5. 看下23篇\n6. “不能恢复数据页”，这个还是内容导致的。binlog里面记录的是逻辑操作\n7. 没事，在这个阶段如果出问题，比如宕机重启，那事务还没有到提交阶段呢，事务本来就可以丢掉\n8. 目前还没有这个参数选项。考虑主备一致性，还是得提交","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551187361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65521,"user_name":"devil","can_delete":false,"product_type":"c1","uid":1259625,"ip_address":"","ucode":"BB6090411BAA23","user_header":"https://static001.geekbang.org/account/avatar/00/13/38/69/864569a4.jpg","comment_is_top":false,"comment_ctime":1549427930,"is_pvip":false,"replies":[{"id":"23214","content":"不同的数据插入的行不同，行锁不同。<br>但是更新是用一行哈","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1549441584,"ip_address":"","comment_id":65521,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1549427930","product_id":100020801,"comment_content":"如果表中有自增字段，insert 的时候也会拿到一个锁吧，先插入再更新也有锁等待吧。","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438487,"discussion_content":"不同的数据插入的行不同，行锁不同。\n但是更新是用一行哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549441584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63407,"user_name":"LIU","can_delete":false,"product_type":"c1","uid":1324845,"ip_address":"","ucode":"CB8BAB022F5B9F","user_header":"","comment_is_top":false,"comment_ctime":1548343894,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548343894","product_id":100020801,"comment_content":"用了很多年    才入门啊  ","like_count":0},{"had_liked":false,"id":62508,"user_name":"chitanda","can_delete":false,"product_type":"c1","uid":1235077,"ip_address":"","ucode":"B3E28E1C8E410B","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/85/21fd42fa.jpg","comment_is_top":false,"comment_ctime":1548077642,"is_pvip":false,"replies":[{"id":"22092","content":"多谢鼓励！！！ 😆","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548077973,"ip_address":"","comment_id":62508,"utype":1}],"discussion_count":1,"race_medal":2,"score":"1548077642","product_id":100020801,"comment_content":"这个关注、喜欢表的讲解相当精妙，简直如醍醐灌顶，mysql还有我没用到的这许多操作，同时也再次确认了自己的局限和不足。<br>多谢款待！！！","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437244,"discussion_content":"多谢鼓励！！！ 😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548077973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":61397,"user_name":"Snake","can_delete":false,"product_type":"c1","uid":1034894,"ip_address":"","ucode":"C3E80DE87EACD1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ca/8e/5768649e.jpg","comment_is_top":false,"comment_ctime":1547690034,"is_pvip":false,"replies":[{"id":"21833","content":"如果where条件多，尽量用上索引，到数据库直接查吧，应用复杂性也小很多，<br>是在没辙也只能这样了","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547694126,"ip_address":"","comment_id":61397,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547690034","product_id":100020801,"comment_content":"关于count单表的总记录数，用独立的业务记数表去记录确实可以提速。但是，我们业务中经常出现包含各种join和where的复杂查询，我能想到的一个不太好的方法是根据sql查询语句做结果缓存，但是这个缓存的命中率可能就不见得有多高了。老师有什么好的方法推荐吗？","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436863,"discussion_content":"如果where条件多，尽量用上索引，到数据库直接查吧，应用复杂性也小很多，\n是在没辙也只能这样了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547694126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":60760,"user_name":"杰之7","can_delete":false,"product_type":"c1","uid":1297232,"ip_address":"","ucode":"F7DA2E21085332","user_header":"https://static001.geekbang.org/account/avatar/00/13/cb/50/66d0bd7f.jpg","comment_is_top":false,"comment_ctime":1547544295,"is_pvip":false,"replies":[{"id":"21674","content":"赞，一起进步~<br>","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547552107,"ip_address":"","comment_id":60760,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547544295","product_id":100020801,"comment_content":"通过这一节答疑文章的阅读，老师带我们回顾了过去关于日志和锁的相关问题。阅读完之后给我的一个体会是熟悉Mysql的原理是非常重要的，许多的细节都可以通Mysql的设计原理和Innodb寻求答案。<br><br>在第一个问题中，关于两阶段提交，关键是看binlog是否存在完整性。在这个问题基础之上，又为我们延伸了9个问题，(1)binlog完整的标志，(2)redo log与binlog的关联,(3)redo log加上完binlog重启就能恢复,(4)两阶段提交的意义,(5)(6),单独的binlog或redo log是否可行,(7)redo log的大小设置,(8)redo log 还是buffer pool最终落盘,(9) redo log buffer是什么.我读老师的回答，我对上述的问题能理解。<br><br>第二个问题关于索引同时关注的问题，老师给的解决方案就是解答3的这种情况。<br><br>看到老师专门记录我们的问题，我就觉得有一种幸福的感觉，因为有这么好的老师一同前行，持续下去必会接出好的果实。<br><br><br><br><br><br><br>","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436613,"discussion_content":"赞，一起进步~\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547552107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58594,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1162714,"ip_address":"","ucode":"88348CCAE81931","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/da/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1547128698,"is_pvip":false,"replies":[{"id":"21187","content":"你说得对，redo log其实还可以的，它只是没有保存整页数据，但是可以记录页面级别的变更。<br>","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547140812,"ip_address":"","comment_id":58594,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547128698","product_id":100020801,"comment_content":"看完追问8，我的理解是，Innodb对于数据的查询及存储都是基于整个数据页的而非单条数据。<br>在看评论的时候看到老师有回复说：binlog一来时机控制不好（就是你说的这个），二来内容的能力不足（没有页面信息。那么按照追问8的说法，redo log实际上能力也应当是不足的。但是redo log由于记录的是页上的物理修改，自己自身大小有限，所以便于崩溃时的回放。<br>不知上面两点理解是否准确。还请老师指点迷津。","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436129,"discussion_content":"你说得对，redo log其实还可以的，它只是没有保存整页数据，但是可以记录页面级别的变更。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547140812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58292,"user_name":"道","can_delete":false,"product_type":"c1","uid":1100869,"ip_address":"","ucode":"B17CA7372C21C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/cc/45/73a0f7f8.jpg","comment_is_top":false,"comment_ctime":1547028052,"is_pvip":false,"replies":[{"id":"21009","content":"对啊，双1才能保证不丢而且一致，你都设置成0了…","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547042925,"ip_address":"","comment_id":58292,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547028052","product_id":100020801,"comment_content":"懵逼了，按23节的意思，如果把innodb_flush_log_at_trx_commit 值设为0（只有后台线程定期写盘redo log） ，那么两阶段提交在时刻b，有可能redo log事务没写硬盘，而binlog事务写硬盘上了，而此时机器挂了，重启后恢复到事务前的状态，此时binlog就不一致了啊","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435991,"discussion_content":"对啊，双1才能保证不丢而且一致，你都设置成0了…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547042925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57392,"user_name":"信信","can_delete":false,"product_type":"c1","uid":1303865,"ip_address":"","ucode":"8DF0EC045579FD","user_header":"https://static001.geekbang.org/account/avatar/00/13/e5/39/951f89c8.jpg","comment_is_top":false,"comment_ctime":1546778664,"is_pvip":false,"replies":[{"id":"20675","content":"因为binlog可能已经发给备库了","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1546782152,"ip_address":"","comment_id":57392,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546778664","product_id":100020801,"comment_content":"老师您好，图2下方说：重启后，引擎内部事务 2 会回滚，然后应用 binlog2 可以补回来。可是未提交的事务在回滚之后，为啥还要重做呢？反过来说，如果判定这个事务满足已提交的条件，那就不会回滚才对啊。请老师指正。","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435557,"discussion_content":"因为binlog可能已经发给备库了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546782152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56633,"user_name":"crazyone","can_delete":false,"product_type":"c1","uid":1115042,"ip_address":"","ucode":"705E34642E41F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/a2/ceb37046.jpg","comment_is_top":false,"comment_ctime":1546512063,"is_pvip":false,"replies":[{"id":"20418","content":"是得客户端自己再去查数据判断的","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1546514751,"ip_address":"","comment_id":56633,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546512063","product_id":100020801,"comment_content":"一直不是很清楚mysql是什么时候返回响应给客户端的？对应事务的提交，是最后的commit完成之后?那如果发生 写binlog后，commit事务前 的crash，客户端的提交响应是一个异常断链吧，这时数据库恢复会把事务恢复完全，客户端如何得知之前的提交是ok的呢？","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435161,"discussion_content":"是得客户端自己再去查数据判断的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546514751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56520,"user_name":"运斤成风","can_delete":false,"product_type":"c1","uid":1350812,"ip_address":"","ucode":"BAFF69C29FDFA5","user_header":"https://static001.geekbang.org/account/avatar/00/14/9c/9c/e02a0daf.jpg","comment_is_top":false,"comment_ctime":1546481387,"is_pvip":false,"replies":[{"id":"20387","content":"这个算是“设计内”的，不算bug ","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1546486343,"ip_address":"","comment_id":56520,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546481387","product_id":100020801,"comment_content":"老师好，update t set a=2 where Id=2 万，真实的做了更新，那执行成功后结果显示，匹配 (rows matched) 了一行，修改 (Changed) 了 0 行，0行被影响，是客户端显示问题？谢谢","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435089,"discussion_content":"这个算是“设计内”的，不算bug ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546486343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55756,"user_name":"Long","can_delete":false,"product_type":"c1","uid":1318970,"ip_address":"","ucode":"2417242560360A","user_header":"https://static001.geekbang.org/account/avatar/00/14/20/3a/90db6a24.jpg","comment_is_top":false,"comment_ctime":1546297290,"is_pvip":false,"replies":[{"id":"20096","content":"对没写完整的事务就回滚","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1546303514,"ip_address":"","comment_id":55756,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546297290","product_id":100020801,"comment_content":"老师，你好。  跑到老课程下问个问题。  如果把session 或者global 的binlog关闭了，那么如果执行事务期间MySQL 崩溃了，那么是不是在崩溃恢复的时候就会直接把redo里面处于prepare状态的回滚掉？因为binlog找不到记录？  多谢答复","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434840,"discussion_content":"对没写完整的事务就回滚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546303514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55737,"user_name":"alias cd=rm -rf","can_delete":false,"product_type":"c1","uid":1318325,"ip_address":"","ucode":"E7B27D76305B75","user_header":"https://static001.geekbang.org/account/avatar/00/14/1d/b5/971261fd.jpg","comment_is_top":false,"comment_ctime":1546273944,"is_pvip":false,"replies":[{"id":"20094","content":"可能是1或3，<br>看下一篇哈<br><br>新年快乐","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1546275132,"ip_address":"","comment_id":55737,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546273944","product_id":100020801,"comment_content":"思考题答案<br>应该是：1<br>原因：<br>1、mysqlserver层的直接返回，减少了引擎层不必要的运算，例如：innodb需要些redolog，undolog,并且刷脏页。<br>2、为什么这步操作不放在引擎层也就是2的原因是：引擎层的实现server无法控制，不能保证引擎看到值相等直接返回。<br>验证方式：<br>在myIsam的表中执行逻辑返现结果和innodb一样","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434836,"discussion_content":"可能是1或3，\n看下一篇哈\n\n新年快乐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546275132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55166,"user_name":"互联网牛仔","can_delete":false,"product_type":"c1","uid":1013536,"ip_address":"","ucode":"B866B0E497AD27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/20/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1546054983,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546054983","product_id":100020801,"comment_content":"关于这个问题：“业务上有这样的需求，A、B 两个用户，如果互相关注，则成为好友。”<br>是否可以分成两个事务,并把insert into like，提前到select from like之前,如下：<br>SessionA，<br>begin<br>insert into like;<br>end<br><br>begin<br>select from like<br>判断是否 B关注A，如果B已关注A，则：<br>insert into friends<br>commit<br><br>Session B类似的操作。","like_count":0},{"had_liked":false,"id":54602,"user_name":"小李子","can_delete":false,"product_type":"c1","uid":1196293,"ip_address":"","ucode":"C5593E33CA6F4C","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/05/5ba603f2.jpg","comment_is_top":false,"comment_ctime":1545912230,"is_pvip":false,"replies":[{"id":"19816","content":"只能分成多个语句，每个语句都这么来一下，然后取id的交集了…","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545917681,"ip_address":"","comment_id":54602,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545912230","product_id":100020801,"comment_content":"老师，我的意思是 ，例如下面语句 需要全模糊匹配<br>select * from people where name like &#39;%张三丰%&#39; <br>应该可以加多一个字段 name_反序  存储  name 的内容的反序字符串，然后<br>把它改写成 后模糊<br>select * from people where name like &#39;张三丰%&#39;  <br>union all <br>select * from people where name_反序 like &#39;丰三张%&#39;  ，<br><br>我的问题是，如果不止 name 这个字段，还有其他的字段也需要全模糊，有没有办法做到如上类似的取巧？<br>","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434507,"discussion_content":"只能分成多个语句，每个语句都这么来一下，然后取id的交集了…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545917681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54496,"user_name":"小李子","can_delete":false,"product_type":"c1","uid":1196293,"ip_address":"","ucode":"C5593E33CA6F4C","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/05/5ba603f2.jpg","comment_is_top":false,"comment_ctime":1545882367,"is_pvip":false,"replies":[{"id":"19798","content":"其实第一个也不能吧，有%在最前面，得用全文检索索引<br><br>如果要用各自取id来join的话，需要单独写成几个子查询","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545903096,"ip_address":"","comment_id":54496,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545882367","product_id":100020801,"comment_content":"老师，想问一下，一个表有多个字段，需要支持模糊索引，例如 select * from people where name like &#39;%张三%&#39; and address like &#39;%广东省广州市天河区%&#39;  ，我首先想到加多几个冗余字段存储反序的待模糊匹配字符，将全模糊转换成多个后模糊，但是多个条件之间的and，导致只有第一个后模糊才能走到索引，后面的都走不到，请问类似这种问题，应该用什么方案提高性能比较好","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434476,"discussion_content":"其实第一个也不能吧，有%在最前面，得用全文检索索引\n\n如果要用各自取id来join的话，需要单独写成几个子查询","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545903096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":53589,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1545698441,"is_pvip":true,"replies":[{"id":"19482","content":"后面文章会说到哈","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545702729,"ip_address":"","comment_id":53589,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545698441","product_id":100020801,"comment_content":"追问 8：正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？<br>回答：这个问题其实问得非常好。这里涉及到了，“redo log 里面到底是什么”的问题。<br><br>实际上，redo log 并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就不存在“数据最终落盘，是由 redo log 更新过去”的情况。<br><br>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与 redo log 毫无关系。<br><br> 请问老师这个“数据落盘”是如果进行的？","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434193,"discussion_content":"后面文章会说到哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545702729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":53586,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1545698377,"is_pvip":true,"replies":[{"id":"19481","content":"没有办法，会丢","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545702705,"ip_address":"","comment_id":53586,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545698377","product_id":100020801,"comment_content":"追问 5：不引入两个日志，也就没有两阶段提交的必要了。只用 binlog 来支持崩溃恢复，又能支持归档，不就可以了？<br>回答：这位同学的意思是，只保留 binlog，然后可以把提交流程改成这样：… -&gt; “数据更新到内存” -&gt; “写 binlog” -&gt; “提交事务”，是不是也可以提供崩溃恢复的能力？<br><br>答案是不可以。<br><br>如果说历史原因的话，那就是 InnoDB 并不是 MySQL 的原生存储引擎。MySQL 的原生引擎是 MyISAM，设计之初就有没有支持崩溃恢复。<br><br><br><br>那么请问老师MyISam 如何恢复数据？","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434192,"discussion_content":"没有办法，会丢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545702705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":53322,"user_name":"产品助理","can_delete":false,"product_type":"c1","uid":1019821,"ip_address":"","ucode":"39A76D346A96E9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/ad/6e3e9e15.jpg","comment_is_top":false,"comment_ctime":1545626294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545626294","product_id":100020801,"comment_content":"https:&#47;&#47;blog.csdn.net&#47;pml18710973036&#47;article&#47;details&#47;78452688<br><br>insert ... on duplicate 会导致死锁的问题，怎么避免呢？","like_count":0},{"had_liked":false,"id":52436,"user_name":"肖鹏","can_delete":false,"product_type":"c1","uid":1302602,"ip_address":"","ucode":"BE1B8BD7053B9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/e0/4a/c0a3cb3f.jpg","comment_is_top":false,"comment_ctime":1545382096,"is_pvip":false,"replies":[{"id":"19129","content":"Binlog写盘的最后一步。<br><br>不会不合理我觉得。因为两阶段提交本来就要先有一个人提交的呀，只不过binlog先了","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545401805,"ip_address":"","comment_id":52436,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545382096","product_id":100020801,"comment_content":"请教一个xa事务的问题。<br>XA事务的过程<br>阶段1：InnoDB 事务进入 prepare 状态,InnoDB redo log 写盘。<br>阶段2：binlog 写盘，InooDB 事务进入 commit 状态<br>每个事务binlog的末尾，会记录一个 XID event，标志着事务是否提交成功。<br>我的问题是，这个xid event是什么时间写入的呢？如果binlog写盘的时候吗？这个时间点 innodb commit还未执行，这样做是不是不太合理？","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433872,"discussion_content":"Binlog写盘的最后一步。\n\n不会不合理我觉得。因为两阶段提交本来就要先有一个人提交的呀，只不过binlog先了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545401805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51503,"user_name":"tzgsuccess","can_delete":false,"product_type":"c1","uid":1214837,"ip_address":"","ucode":"65CB561BF8B06D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJeHXNIicCRGMibkmSkr9tiaHpbCjS2MGaLrCIhIVjlicAdNusOAfMMDRosU4NRm2XKA2uetZR7xaSoWQ/132","comment_is_top":false,"comment_ctime":1545190531,"is_pvip":false,"replies":[{"id":"18616","content":"是的","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545191139,"ip_address":"","comment_id":51503,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545190531","product_id":100020801,"comment_content":"最终写入磁盘，磁盘也有缓冲区，数据库最终调用的是flush这种最终落盘的硬写吧。","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433483,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545191139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51156,"user_name":"Smile","can_delete":false,"product_type":"c1","uid":1021017,"ip_address":"","ucode":"2002460CB3D869","user_header":"https://static001.geekbang.org/account/avatar/00/0f/94/59/ac2aa72b.jpg","comment_is_top":false,"comment_ctime":1545122033,"is_pvip":true,"replies":[{"id":"18440","content":"嗯，你说的对的，我发现这块我讲的有歧义。加了说明，原来是计划在后面的文章展开的，这里就简要说明了下😓","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545126039,"ip_address":"","comment_id":51156,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545122033","product_id":100020801,"comment_content":"老师，您好，关于redo log 有一个疑惑：<br>-----------------<br>这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没 commit 的时候就直接写到 redo log 文件里。<br>-----------------<br>1. 比如事物比较大，但是redo log buffer 满了，如果不写到redo log 文件，不就尴尬了么<br>2.  我之前的理解，是在事物begin以后，会逐步写redo log 到 文件的（binlog 是会在commit的一瞬间才写），或者 master 线程也会每秒刷一次redo log buffer到redo文件。 --- 不知道是不是其他资料有误，望老师指正。<br><br><br>","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433312,"discussion_content":"嗯，你说的对的，我发现这块我讲的有歧义。加了说明，原来是计划在后面的文章展开的，这里就简要说明了下😓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545126039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51130,"user_name":"leohuachao","can_delete":false,"product_type":"c1","uid":1148284,"ip_address":"","ucode":"02FC4FCB6CE775","user_header":"https://static001.geekbang.org/account/avatar/00/11/85/7c/03a268fe.jpg","comment_is_top":false,"comment_ctime":1545118787,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1545118787","product_id":100020801,"comment_content":"为什么sql也要考虑“幂等性”呢，sql里放业务逻辑不好吧？","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158901,"discussion_content":"当然不好，不过这里应该是为了说明问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580637327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51112,"user_name":"☞","can_delete":false,"product_type":"c1","uid":1302793,"ip_address":"","ucode":"6FAEF05F234D2A","user_header":"https://static001.geekbang.org/account/avatar/00/13/e1/09/9483f537.jpg","comment_is_top":false,"comment_ctime":1545116089,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1545116089","product_id":100020801,"comment_content":"老师您好：<br>        redo buffer往redo log里面写入是有机制的吧，并不只是等待commit才会写入吧，还有一些其他场景也会触发从buffer中写入到redo file中才对","like_count":0,"discussions":[{"author":{"id":1099170,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c5/a2/4ece341b.jpg","nickname":"Ivan.Qi","note":"","ucode":"36F46A4D1F0EAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179854,"discussion_content":"https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html#auto_id_6\n1.6 日志刷盘的规则","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582256812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158902,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580637356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51106,"user_name":"结冰的水滴","can_delete":false,"product_type":"c1","uid":1350505,"ip_address":"","ucode":"088108D4848353","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/69/b844df30.jpg","comment_is_top":false,"comment_ctime":1545114866,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1545114866","product_id":100020801,"comment_content":"redo log buffer 的内容只有在 commit的时候才会写到ib_log文件么？，如果事务比较大，redo log buffer 满了 怎么办","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158903,"discussion_content":"会有相应的机制向redo log写的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580637388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51003,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1082187,"ip_address":"","ucode":"FC323371453C97","user_header":"https://static001.geekbang.org/account/avatar/00/10/83/4b/0e96fcae.jpg","comment_is_top":false,"comment_ctime":1545098073,"is_pvip":false,"replies":[{"id":"18519","content":"触发器不行，可以考虑存储过程。<br>你这个业务逻辑感觉存储过程更直观呀","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545158277,"ip_address":"","comment_id":51003,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545098073","product_id":100020801,"comment_content":"老师好！<br>有这样一个需求：A、B两张一样的表，其中一个表更新或者插入时都能够让对方感知到并且也做相应的更新或者插入，更新则以主键ID为条件。<br>主要是想在MySQL层去实现，所以想到了触发器，但触发器会有这样的问题，即：不能让两个触发器触发两个表，并使之循环。<br>如：触发器a触发b表的insert操作，并往d表insert数据；触发器c触发d表的insert操作，并往表b insert数据；这时会报如下错误：（方案一）<br>Can&#39;t update table &#39;b&#39; in stored function&#47;trigger because it is already used by statement which invoked this stored function&#47;trigger.<br>于是想能不能在实际插入之前做个判断，如果存在就不做insert，否则做insert。但好像这个判断语句在被执行之前就报上面的错误了。（方案二）<br><br>问题：<br>1.MySQL层面这个需求是真实现不了吗，还是说需要做什么配置呢<br>2.如果能实现的话，会对MySQL本身带来什么样的影响吗<br>3.如果不能实现的话，可否借用第三方插件去实现呢 <br><br>希望老师能帮忙解答下问题，谢谢！<br><br>方案一：<br>----------------------------------------------------<br>drop trigger if exists t_afterinsert_on_a$<br>create trigger t_afterinsert_on_a<br>after insert on a<br>for each row<br>begin<br>\tinsert into b values (new.id, new.name, new.city_id);<br>end$<br><br>drop trigger if exists t_afterinsert_on_b$<br>create trigger t_afterinsert_on_b<br>after insert on b<br>for each row<br>begin<br>\tinsert into a values (new.id, new.name, new.city_id);<br>end$<br>----------------------------------------------------<br>方案二：<br>----------------------------------------------------<br>drop trigger if exists t_before_insert_on_a$<br>create trigger t_before_insert_on_a<br>before insert on a<br>for each row<br>begin<br>declare c_id int default 0;<br>select max(id)+1 into c_id from a;<br>if not exists (select id from b where id = c_id) then<br>\tinsert into b values (c_id, new.name, new.city_id);<br>end if;<br>end$<br><br>drop trigger if exists t_before_insert_on_b$<br>create trigger t_before_insert_on_b<br>before insert on b<br>for each row<br>begin<br>declare c_id int default 0;<br>select max(id)+1 into c_id from b;<br>if not exists (select id from a where id = c_id) then<br>\tinsert into a values (c_id, new.name, new.city_id);<br>end if;<br>end$<br>----------------------------------------------------","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433225,"discussion_content":"触发器不行，可以考虑存储过程。\n你这个业务逻辑感觉存储过程更直观呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545158277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50951,"user_name":"峰哥","can_delete":false,"product_type":"c1","uid":1301870,"ip_address":"","ucode":"CB0652D3EF49A1","user_header":"https://static001.geekbang.org/account/avatar/00/13/dd/6e/f3cfebc5.jpg","comment_is_top":false,"comment_ctime":1545093079,"is_pvip":false,"replies":[{"id":"18345","content":"如果敢关闭binlog,一定是已经能够用redo log来恢复数据了吧","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545100721,"ip_address":"","comment_id":50951,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545093079","product_id":100020801,"comment_content":"阿里云的polarDB官方说明：由于是基于redolog的物理复制构建复制关系，所以默认关闭binlog。<br>我的理解是主要还是为了提升性能所以关闭，那么就无法做到”恢复到任意一秒”了吧;另外如果是物理复制redolog，如果redo文件损坏,还是会有数据丢失，不知道polarDB有哪些机制来避免？","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433198,"discussion_content":"如果敢关闭binlog,一定是已经能够用redo log来恢复数据了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545100721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50870,"user_name":"郭江伟","can_delete":false,"product_type":"c1","uid":1313994,"ip_address":"","ucode":"613D638619B5A2","user_header":"https://static001.geekbang.org/account/avatar/00/14/0c/ca/6173350b.jpg","comment_is_top":false,"comment_ctime":1545058276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545058276","product_id":100020801,"comment_content":"无法追加评论 ，我之前的留言老师问到运行hexdump时有没有关闭MySQL 。 没关闭<br>但是我在update后紧接着插入一条数据 hexdump可以看到新插入的数据","like_count":0},{"had_liked":false,"id":50861,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1545056252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545056252","product_id":100020801,"comment_content":"redo log(重做日志)作用，事务回滚或者数据库崩溃。bin log(归档日志)作用，主从复制。具体的提交顺序，1 先写入到redo log，处于prepare阶段，再写入到bin log，再提交 redo log打上commit标记，进行提交。如果redo log处于prepare阶段，需要看下bin log是否完整，完整则提交，不完整则回滚。","like_count":0},{"had_liked":false,"id":50855,"user_name":"undifined","can_delete":false,"product_type":"c1","uid":1068920,"ip_address":"","ucode":"449CB4CD2DC089","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/78/c3d8ecb0.jpg","comment_is_top":false,"comment_ctime":1545055196,"is_pvip":false,"replies":[{"id":"18283","content":"我的解决建议里就是有这个唯一性约束呀","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545056386,"ip_address":"","comment_id":50855,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545055196","product_id":100020801,"comment_content":"老师 后面那个案例，在业务中该怎么设计避免；如果我给like 表里的 user_id 和 like_id 一起加 unique 约束，在业务中如果报唯一约束的错就再次查询更新是不是也可以","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433143,"discussion_content":"我的解决建议里就是有这个唯一性约束呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545056386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50847,"user_name":"包包up","can_delete":false,"product_type":"c1","uid":1073495,"ip_address":"","ucode":"A6F51A62A8B362","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/57/6f3c81dd.jpg","comment_is_top":false,"comment_ctime":1545054260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545054260","product_id":100020801,"comment_content":"通过构造两个事务，先后去提交update语句，发现后提交的事务在等待锁。得出mysql选择的策略是3.InnoDB 认真执行了“把这个值修改成 (1,2)&quot;这个操作，该加锁的加锁，该更新的更新。<br><br>原因的话我想到了一个，在可重复读模式下，如果不加锁，就有可能导致更新丢失。","like_count":0},{"had_liked":false,"id":50839,"user_name":"王子瑞Aliloke有事电联","can_delete":false,"product_type":"c1","uid":1249400,"ip_address":"","ucode":"9ABE8E475E336B","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/78/29bd3f1e.jpg","comment_is_top":false,"comment_ctime":1545053306,"is_pvip":false,"replies":[{"id":"18269","content":"下周就来啦<br><br>锁我们还没讲完，还没到总结的时候😄","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545055161,"ip_address":"","comment_id":50839,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545053306","product_id":100020801,"comment_content":"老师，期待您出一篇:mysql锁的总结，mysql索引的总结~上周被问到聚簇索引和非聚簇索引，间隙锁，😂惭愧，没答好，想很多人会遇到，期待您的解读。","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433136,"discussion_content":"下周就来啦\n\n锁我们还没讲完，还没到总结的时候😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545055161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50836,"user_name":"王子瑞Aliloke有事电联","can_delete":false,"product_type":"c1","uid":1249400,"ip_address":"","ucode":"9ABE8E475E336B","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/78/29bd3f1e.jpg","comment_is_top":false,"comment_ctime":1545053075,"is_pvip":false,"replies":[{"id":"18270","content":"👍🏿<br><br>大家有收获我特别开心","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545055200,"ip_address":"","comment_id":50836,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545053075","product_id":100020801,"comment_content":"老师，真是由衷地佩服:<br>1.技术牛，作为一名java开发，常用mysql，但不知其原理。老师的讲授为我将mysql破开了，呈现其脉络，并详细讲解！<br>2.用心授课:不辞辛劳的答疑，还特意整理了答疑内容。虽然现在还是有些知识觉得比较深，难懂，相信跟着老师，能精通mysql。","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433133,"discussion_content":"👍🏿\n\n大家有收获我特别开心","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545055200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50811,"user_name":"慧鑫coming","can_delete":false,"product_type":"c1","uid":1324385,"ip_address":"","ucode":"7BAC9CA255630E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLE4LYb3jrH63ZV98Zpc8DompwDgb1O3nffMoZCmiaibauRyEFv6NDNsST9RWxZExvMLMWb50zaanoQ/132","comment_is_top":false,"comment_ctime":1545049282,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1545049282","product_id":100020801,"comment_content":"@信 信，同问<br>如果图1的“写入redo log”是写内存，当时刻B发生crash，重启后这部分redo log都丢失了，那么何谈判断redo log是否有完整的prepare还是commit标志呢？","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158906,"discussion_content":"prepare也是要将页变更落盘到redo log中吧，不会在内存里的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580637649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50809,"user_name":"鹏","can_delete":false,"product_type":"c1","uid":1209661,"ip_address":"","ucode":"B514BA450CB317","user_header":"","comment_is_top":false,"comment_ctime":1545049041,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1545049041","product_id":100020801,"comment_content":"更新记录都是先写到内存页上的，但是怎么定位到写到哪一个内存页呢？","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158908,"discussion_content":"redo log应该记了吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580637672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50808,"user_name":"卫江","can_delete":false,"product_type":"c1","uid":1101226,"ip_address":"","ucode":"DE2F7A6916F1A9","user_header":"https://static001.geekbang.org/account/avatar/00/10/cd/aa/33d48789.jpg","comment_is_top":false,"comment_ctime":1545049003,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545049003","product_id":100020801,"comment_content":"思考题，我感觉是第三种，因为写都是当前读，这样才不会覆盖其他事务的修改，所以，在可重复读的事务隔离下，只有第三种才能保证，同一个事务中，接下来的语句可以看到最新的值。","like_count":0},{"had_liked":false,"id":50803,"user_name":"Ryoma","can_delete":false,"product_type":"c1","uid":1130590,"ip_address":"","ucode":"7F692369239692","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","comment_is_top":false,"comment_ctime":1545048801,"is_pvip":true,"replies":[{"id":"18275","content":"分布式锁看上去更复杂，不错来分享一下你的解决方案吧😄","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545055498,"ip_address":"","comment_id":50803,"utype":1}],"discussion_count":1,"race_medal":2,"score":"1545048801","product_id":100020801,"comment_content":"关系业务设计问题，我倒是有一个想法，个人觉得由MySQL做这种复杂的操作不太合适，也不太好理解。这个问题本质其实是并发问题，这种先check再update的场景其实有很多，比如使用一个分布式锁来解决更简单一点，保证在select、update 的过程中不会有并发问题。","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433114,"discussion_content":"分布式锁看上去更复杂，不错来分享一下你的解决方案吧😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545055498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50766,"user_name":"峰哥","can_delete":false,"product_type":"c1","uid":1301870,"ip_address":"","ucode":"CB0652D3EF49A1","user_header":"https://static001.geekbang.org/account/avatar/00/13/dd/6e/f3cfebc5.jpg","comment_is_top":false,"comment_ctime":1545041704,"is_pvip":false,"replies":[{"id":"18217","content":"没有吧？<br><br>而且像我文中说的，关闭binlog其实崩溃恢复没问题的，<br>如果已经实现了“用redo log来归档和恢复历史数据”， 备份问题也解决了, 安全级别没降低。不过要解决下游消费问题。<br><br>Archive 指的是什么？","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545047131,"ip_address":"","comment_id":50766,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1545041704","product_id":100020801,"comment_content":"现在一些云计算厂商开发的基于mysql的云数据库，为了性能，默认关闭了binlog,那么在安全级别上是否降低了？archive又是怎么处理的？","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433090,"discussion_content":"没有吧？\n\n而且像我文中说的，关闭binlog其实崩溃恢复没问题的，\n如果已经实现了“用redo log来归档和恢复历史数据”， 备份问题也解决了, 安全级别没降低。不过要解决下游消费问题。\n\nArchive 指的是什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545047131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158911,"discussion_content":"archive应该是想问redo log如何做到归档吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580637901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50741,"user_name":"斜面镜子 Bill","can_delete":false,"product_type":"c1","uid":1305242,"ip_address":"","ucode":"B5505F94540D52","user_header":"https://static001.geekbang.org/account/avatar/00/13/ea/9a/02d589f9.jpg","comment_is_top":false,"comment_ctime":1545037442,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545037442","product_id":100020801,"comment_content":"会选择第二种，更新虽然是先读后写的，但是基于“当前读”和“快照读”的理解，读和更新是完全不同的路径，更新需要持锁操作，一定需要进入到引擎层，至于是否重复更新我理解 redo纪录的是物理页的变更信息，如果变更前后值不改变，redo其实是没有内容需要纪录的，所以binlog也没有内容，所以就直接返回了！","like_count":0},{"had_liked":false,"id":50717,"user_name":"Jadic","can_delete":false,"product_type":"c1","uid":1005121,"ip_address":"","ucode":"C6DE22C449B911","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/41/050144c7.jpg","comment_is_top":false,"comment_ctime":1545034346,"is_pvip":false,"replies":[{"id":"18276","content":"嗯，能保持简单最好了。<br><br>不过确实这个例子里，要避免出现这个bug, 是需要一些复杂化修改。<br><br>方案肯定不止一个😄","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545055583,"ip_address":"","comment_id":50717,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545034346","product_id":100020801,"comment_content":"接前面留言遗漏部分。<br>相互关注需求在实际业务场景中综合读业务的需求，是不是将原题主的诉求在应用层解决，保持DB表结构的简单化，这样更加合理点，谢谢。","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433072,"discussion_content":"嗯，能保持简单最好了。\n\n不过确实这个例子里，要避免出现这个bug, 是需要一些复杂化修改。\n\n方案肯定不止一个😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545055583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50713,"user_name":"Jadic","can_delete":false,"product_type":"c1","uid":1005121,"ip_address":"","ucode":"C6DE22C449B911","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/41/050144c7.jpg","comment_is_top":false,"comment_ctime":1545033658,"is_pvip":false,"replies":[{"id":"18207","content":"嗯，你这个问题问得好，<br><br>嗯，这样最好就是把or的条件分成两个语句，<br>或者用union all 的写法，<br><br>User_id和liker_id分别单独建索引。<br><br><br><br>","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545042074,"ip_address":"","comment_id":50713,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1545033658","product_id":100020801,"comment_content":"老师你好，关于用户相互关注的这个业务设计方案很巧妙，解决了冲突的问题。但我想到另一个问题，在正常业务中应该会有查询的需求，比如查询某人关注的用户或关注了某人的用户或者关注数等高频场景的时候，这样的查询条件中是不是有组合的情况，不知道如下的查询效率怎么样:<br><br>-- 用户1所关注的用户<br>select *<br>from like<br>where (user_id=1 and relation_ship &amp; 1=1)<br>       or (liker_id=1 and relation_ship &amp; 2=2)","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433070,"discussion_content":"嗯，你这个问题问得好，\n\n嗯，这样最好就是把or的条件分成两个语句，\n或者用union all 的写法，\n\nUser_id和liker_id分别单独建索引。\n\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545042074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158912,"discussion_content":"userid就不用建索引了吧，可以直接用UK的前缀索引。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580638051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50638,"user_name":"信信","can_delete":false,"product_type":"c1","uid":1303865,"ip_address":"","ucode":"8DF0EC045579FD","user_header":"https://static001.geekbang.org/account/avatar/00/13/e5/39/951f89c8.jpg","comment_is_top":false,"comment_ctime":1545020944,"is_pvip":false,"replies":[{"id":"18281","content":"对的","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545056201,"ip_address":"","comment_id":50638,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545020944","product_id":100020801,"comment_content":"追问4思考：为啥不能先刷盘redo，然后根据redo修复binlog呢？我想原因有两点：1、这是遵循“等两者都ok”理念，前面redo已经prepare了，那接下来binlog先刷盘，出错的概率就会小一点；2、修复binlog之前已经同步给从服务器了，会造成数据不一致。不知我想的是否正确。","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433047,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545056201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50636,"user_name":"信信","can_delete":false,"product_type":"c1","uid":1303865,"ip_address":"","ucode":"8DF0EC045579FD","user_header":"https://static001.geekbang.org/account/avatar/00/13/e5/39/951f89c8.jpg","comment_is_top":false,"comment_ctime":1545020078,"is_pvip":false,"replies":[{"id":"18280","content":"对，图1里面是写盘","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1545056176,"ip_address":"","comment_id":50636,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545020078","product_id":100020801,"comment_content":"请问老师，图1的写入redo log和写binlog指的是刷盘，不是写内存吗？隐约记得binlog是先一步刷盘的。","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433046,"discussion_content":"对，图1里面是写盘","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545056176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50616,"user_name":"铁皮","can_delete":false,"product_type":"c1","uid":1013200,"ip_address":"","ucode":"E20FB02D9ABD20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/d0/0053c9ba.jpg","comment_is_top":false,"comment_ctime":1545016804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545016804","product_id":100020801,"comment_content":"课后解答：<br>   update t set a = 2 where id = 1;<br>个人认为应该是第二种。<br><br>构造实验方式：<br>1. 先执行事务A<br>   start transaction;<br>   update t set a = a + 1 where id = 1;<br>2. 然后执行事务B<br>    update t set a = 2 where id = 1;<br>当事务A不执行commit;时，事务B执行update语句将被锁住。那证明需要加锁的，那么第一种选择是错误的。它需要调用引擎提供的接口来保证数据的安全。<br><br>为什么不是第三种？<br>我是在执行update t set a = 2 where id = 1;语句时发现结果的0 rows affected的话，binlong并没有产生新的数据。那么我猜想的是：MySQL调用引擎提供的接口返回的结果就是0 rows affected。那么Mysql就不会写入到binlog中，那么redo log也应该不会写。所以并没有更新。<br><br>以上只是个人见解。还请老师给出意见哈。<br><br>","like_count":0},{"had_liked":false,"id":50613,"user_name":"蠢蠢欲动的腹肌","can_delete":false,"product_type":"c1","uid":1007326,"ip_address":"","ucode":"B10550BF463017","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/de/4e7ec66d.jpg","comment_is_top":false,"comment_ctime":1545016487,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1545016487","product_id":100020801,"comment_content":"老师，你好<br>在业务设计问题的实现措施中，A关注B的时候，逻辑改成如下所示的样子这句话后边没有跟着图或者示例，是我这边显示的问题吗。。<br><br>还有就是没get到解决同时插入问题的点，什么时候变成3的状态，又怎么保证userid小于likerid，望老师解答","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158916,"discussion_content":"如果并发会UK阻塞。如果先有2，然后1来了就可以将记录更为3。反之也是可以更为3，然后向friend表插入一条记录。如果没有这种情况就无非是插入一条1或者2的记录。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580638355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50590,"user_name":"Bin","can_delete":false,"product_type":"c1","uid":1304406,"ip_address":"","ucode":"26BA010D2990C4","user_header":"https://static001.geekbang.org/account/avatar/00/13/e7/56/87f45704.jpg","comment_is_top":false,"comment_ctime":1545013388,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545013388","product_id":100020801,"comment_content":"答: 第一种。<br>构造实验如下:<br>mysql&gt; show master status\\G;<br>\tExecuted_Gtid_Set: b453f45b-ba9f-11e8-a29c-080027eb50c1:1-433437<br>\t1 row in set (0.00 sec)<br><br>mysql&gt; select a from t where id=1;<br>+------+<br>| a    |<br>+------+<br>| 2 |<br>+------+<br>1 row in set (0.00 sec)<br>\t<br>mysql&gt; update t set a=2 where id=1;<br>\tQuery OK, 0 rows affected (0.00 sec)<br>\tRows matched: 1  Changed: 0  Warnings: 0<br>       （Changed 不等于0才是真正做了修改）<br>mysql&gt; show master status\\G;<br>\tExecuted_Gtid_Set: b453f45b-ba9f-11e8-a29c-080027eb50c1:1-433437<br>\t1 row in set (0.00 sec)<br><br>可以看到, 当执行完成  &quot;update t set a=2 where id=1;&quot; 之后, 通过 &quot;show master status\\G;&quot; 发现没有产生新的GTID。<br><br>为什么这样设计:<br>\t设计的思路就类似结果存在就不做更新操作,这样可以节省开销，提高性能。<br><br> 希望老师指正.谢谢","like_count":0},{"had_liked":false,"id":50522,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1545006867,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545006867","product_id":100020801,"comment_content":"我认为是第一种。第二种如果出现了脏页，内存中的数据和和磁盘中数据不一致，最后还是会被磁盘中的数据页覆盖。第三种，内存中的数据页flush到磁盘，是有机制的，更新内存里，再统一把内存刷到磁盘上，性能更好，第三种性能不好。所以选择第一种","like_count":0},{"had_liked":false,"id":50521,"user_name":"amazon1011","can_delete":false,"product_type":"c1","uid":1001032,"ip_address":"","ucode":"BD745BDCBD7059","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/48/e959b1e0.jpg","comment_is_top":false,"comment_ctime":1545006353,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1545006353","product_id":100020801,"comment_content":"&quot;这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没 commit 的时候就直接写到 redo log 文件里。&quot;老师，如果是一个长事务占用了redo log buffer 的1&#47;2的时候且事务还没有完成，后台线程就直接刷到redo log file 吧。","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158917,"discussion_content":"应该是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580638381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}