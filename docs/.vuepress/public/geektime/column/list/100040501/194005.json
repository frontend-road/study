{"id":194005,"title":"28 | Concepts：如何对模板进行约束?","content":"<p>你好，我是吴咏炜。</p><p>从这一讲开始，我们进入了未来篇，展望一下即将在 C++20 出现的新功能。我们第一个要讨论的，是 concepts（概念）——一个难产了很多年才终于进入 C++ 的新功能。</p><h2>一个小例子</h2><p>老规矩，要讲“概念”，我们先看例子。</p><p>我们知道 C++ 里有重载，可以根据参数的类型来选择合适的函数。比如，我们可以定义 <code>half</code> 对于 <code>int</code> 和 <code>string</code> 有不同的作用：</p><pre><code class=\"language-c++\">int half(int n)\n{\n  return n / 2;\n}\n\nstring half(string s)\n{\n  s.resize(s.size() / 2);\n  return s;\n}\n</code></pre><p>初看，似乎重载可以解决问题，但细想，不对啊：除了 <code>int</code>，我们还有差不多的 <code>short</code>、<code>long</code> 等类型，甚至还有 <code>boost::multiprecision::cpp_int</code>；除了 <code>string</code>，我们也还有 <code>wstring</code>、<code>u16string</code>、<code>u32string</code> 等等。上面的每个函数，实际上都适用于一族类型，而不是单个类型。重载在这方面并帮不了什么忙。</p><p>也许你现在已经反应过来了，我们有 SFINAE 啊！回答部分正确。可是，你告诉我你有没有想到一种很简单的方式能让 SFINAE 对整数类型可以工作？Type traits？嗯嗯，总是可以解决的是吧，但这会不会是一条把初学者劝退的道路呢？……</p><!-- [[[read_end]]] --><p>C++ 的概念就是用来解决这个问题的。对于上面的例子，我们只需要事先定义了 <code>Integer</code> 和 <code>String</code> 的概念（如何定义一个概念我们后面会说），我们就可以写出下面这样的代码：</p><pre><code class=\"language-c++\">template &lt;Integer N&gt;\nN half(N n)\n{\n  return n / 2;\n}\n\ntemplate &lt;String S&gt;\nS half(S s)\n{\n  s.resize(s.size() / 2);\n  return s;\n}\n</code></pre><p>我们应当了解一下，从概念上讲，上面这种形式的含义和下面的代码实质相同（以上面的第一个函数为例）：</p><pre><code class=\"language-c++\">template &lt;typename N&gt;\n  requires Integer&lt;N&gt;\nN half(N n)\n{\n  return n / 2;\n}\n</code></pre><p>即，这个 <code>half</code> 是一个函数模板，有一个模板参数，启用这个模板的前提条件是这个参数满足 <code>Integer</code> 这个约束。</p><h2>Concepts 简史</h2><p>2019 年 11 月，上海，当在 C++ 峰会上被问起他最喜欢的 C++ 特性有哪些时，Bjarne 的回答里就有 concepts。这丝毫不让我感到惊讶。虽然 C++ 的“概念”看起来是个挺简单的概念，但它的历史并不短——Bjarne 想把它加入 C++ 已经有好多年了 <span class=\"orange\">[1]</span>。</p><p>从基本概念上来讲，“概念”就是一组对模板参数的约束条件。我们讨论过模板就是 C++ 里的鸭子类型，但我们没有提过，Bjarne 对模板的接口实际上是相当不满意的：他自己的用词直接就是 lousy，并认为这一糟糕的接口设计是后面导致了恐怖的模板编译错误信息的根源。</p><p>从另一方面讲，Alex Stepanov 设计的 STL 一开始就包含了“概念”的概念，如我们在<a href=\"https://time.geekbang.org/column/article/176842\">[第 7 讲]</a> 中提到的各种不同类型的迭代器：</p><ul>\n<li>Output Iterator</li>\n<li>Input Iterator</li>\n<li>Forward Iterator</li>\n<li>Bidirectional Iterator</li>\n<li>Random Access Iterator</li>\n<li>…</li>\n</ul><p>这些概念出现在了 STL 的文档中，有详细的定义；但它们只是落在纸面上，而没有在 C++ 语言中有真正的体现。后来，他还进一步把很多概念的形式描述写进了他于 2009 年（和 Paul McJones 一起）出版的“神作” <em>Elements of Programming</em> <span class=\"orange\">[2]</span> 中，并给出了假想的实现代码——其中就有关键字 <code>requires</code>——即使那时没有任何编译器能够编译这样的代码。</p><p>在 C++ 第一次标准化（1998）之后，Bjarne 多次试图把“概念”引入 C++（根据我看到的文献，他在 03 到 09 年直接有至少九篇单独或合著的论文跟“概念”有关），但一直没有成功——魔鬼在细节，一旦进入细节，人们对一个看起来很美的点子的分歧就非常大了。一直到 C++11 标准化，“概念” 还是因为草案复杂、争议多、无成熟实现而没有进入 C++ 标准。</p><p>目前 C++20 里的“概念”的基础是 2009 年重新启动的 Concepts Lite，并在 2015 年出版成为技术规格书 Concepts TS（正式的 TS 文档需要花钱购买，我们需要进一步了解可以查看正式出版前的草案 <span class=\"orange\">[3]</span>）。很多人参与了相关工作，其中就包括了 Andrew Sutton、Bjarne Stroustrup 和 Alex Stepanov。这回，实现简化了，有了一个实现（GCC），争议也少多了。然而，“概念”还是没有进入 C++17，主要由于下面这些原因：</p><ul>\n<li>从 Concepts TS 出版到标准定稿只有不到四个⽉的时间（C++20 的内容也同样是在 2019 年就全部冻结了，到正式出版前的时间留个修正小问题和走批准流程）</li>\n<li>“概念”只有一个实现（GCC）</li>\n<li>Concepts TS 规格书的作者和 GCC 中的概念实现者是同⼀个⼈，没有⼈独⽴地从规格书出发实现概念</li>\n<li>Concepts TS ⾥没有实际定义概念，标准库也没有把概念用起来</li>\n</ul><p>当然，大家还是认可“概念”是个好功能，到了 2017 年 7 月，“概念”就正式并入 C++20 草案了。之后，小修订还是不少的（所以“概念”没有进入 C++20 也不完全是件坏事）。从用户的角度，最大的一个改变是“概念”的名字：目前，所有标准“概念”从全部由大写字母打头改成了“标准大小写”——即全部小写字母加下划线 <span class=\"orange\">[4]</span>。比如，允许相等比较这个概念，原先写作 <code>EqualityComparable</code>，现在要写成 <code>equality_comparable</code>。</p><h2>基本的 Concepts</h2><p>下图中给出了 C++ 里对象相关的部分标准概念（不完整）：</p><p><img src=\"https://static001.geekbang.org/resource/image/fc/21/fc99fa3b010ab1e84741eea004933f21.png?wh=1084*828\" alt=\"\"></p><p>我们从下往上快速看一下：</p><ul>\n<li><code>move_constructible</code>：可移动构造</li>\n<li><code>swappable</code>：可交换</li>\n<li><code>movable</code>：可移动构造、可交换，合在一起就是可移动了</li>\n<li><code>copy_constructible</code>：可拷贝构造</li>\n<li><code>copyable</code>：可拷贝构造、可移动，合在一起就是可复制了（注：这儿“拷贝”和“复制”只是我在翻译中做的一点小区分，英文中没有区别）</li>\n<li><code>default_initializable</code>：可默认初始化（名字不叫 <code>default_constructible</code> 是因为目前的 type traits 中有 <code>is_default_constructible</code>，且意义和 <code>default_initializable</code> 有点微妙的区别；详见<a href=\"https://timsong-cpp.github.io/lwg-issues/3338\">问题报告 3338</a>）</li>\n<li><code>semiregular</code>：可复制、可默认初始化，合在一起就是半正则了</li>\n<li><code>equality_comparable</code>：可相等比较，即对象之间可以使用 <code>==</code> 运算符</li>\n<li><code>regular</code>：半正则、可相等比较，合在一起就是正则了</li>\n</ul><p>这些“概念”现在不只是文字描述，绝大部分是可以真正在代码中定义的。现在，准标准的定义已经可以在 cppreference.com 上找到 <span class=\"orange\">[5]</span>。从实际的角度，下面我们列举部分概念在 CMCSTL2 <span class=\"orange\">[6]</span>——一个 Ranges（我们下一讲讨论）的参考实现——中的定义。</p><p>从简单性的角度，我们自上往下看，首先是 <code>regular</code>：</p><pre><code class=\"language-c++\">template &lt;class T&gt;\nconcept regular =\n  semiregular&lt;T&gt; &amp;&amp;\n  equality_comparable&lt;T&gt;;\n</code></pre><p>很简单吧，定义一个 concept 此处只是一些针对类型的条件而已。可以看出，每个概念测试表达式（如 <code>semiregular&lt;T&gt;</code>）的结果是一个布尔值（编译期常量）。</p><p>然后是 <code>semiregular</code>：</p><pre><code class=\"language-c++\">template &lt;class T&gt;\nconcept semiregular =\n  copyable&lt;T&gt; &amp;&amp;\n  default_initializable&lt;T&gt;;\n</code></pre><p>再看一眼 <code>equality_comparable</code>：</p><pre><code class=\"language-c++\">template &lt;class T, class U&gt;\nconcept WeaklyEqualityComparable =\n  requires(\n      const remove_reference_t&lt;T&gt;&amp; t,\n      const remove_reference_t&lt;U&gt;&amp; u) {\n    { t == u } -&gt; boolean;\n    { t != u } -&gt; boolean;\n    { u == t } -&gt; boolean;\n    { u != t } -&gt; boolean;\n  };\n\ntemplate &lt;class T&gt;\nconcept equality_comparable =\n  WeaklyEqualityComparable&lt;T, T&gt;;\n</code></pre><p>这个稍复杂点，用到了 <code>requires</code> <span class=\"orange\">[7]</span>，但不需要我讲解，你也能看出来 <code>equality_comparable</code> 的要求就是类型的常左值引用之间允许进行 <code>==</code> 和 <code>!=</code> 的比较，且返回类型为布尔类型吧。</p><p>注意上面的定义里写的是 <code>boolean</code> 而不是 <code>bool</code>。这个概念定义不要求比较运算符的结果类型是 <code>bool</code>，而是可以用在需要布尔值的上下文中。自然，<code>boolean</code> 也是有定义的，但这个定义可能比你想象的复杂，我这儿就不写出来了😜。</p><p>我们之前已经讲过了各种迭代器，每个迭代器也自然地满足一个“概念”——概念名称基本上就是之前给的，只是大小写要变化一下而已。最底下的 <code>iterator</code> 是个例外：因为这个名字在标准里已经被占用啦。所以现在它的名字是 <code>input_or_output_iterator</code>。</p><p>迭代器本身需要满足哪些概念呢？我们看下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/6a/0c/6ade3581f8f2da22c92987e81974210c.png?wh=1142*512\" alt=\"\"></p><p>注意这张跟上面那张图不一样，概念之间不是简单的“合取”关系，而是一种“继承”关系：上面的概念比它指向的下面的概念有更多的要求。具体到代码：</p><pre><code class=\"language-c++\">template &lt;class I&gt;\nconcept weakly_incrementable =\n  semiregular&lt;I&gt; &amp;&amp; requires(I i) {\n    typename iter_difference_t&lt;I&gt;;\n    requires signed_integral&lt;\n      iter_difference_t&lt;I&gt;&gt;;\n    { ++i } -&gt; same_as&lt;I&amp;&gt;;\n    i++;\n  };\n</code></pre><p>也就是说，<code>weakly_incrementable</code> 是 <code>semiregular</code> 再加一些额外的要求：</p><ul>\n<li><code>iter_difference_t&lt;I&gt;</code> 是一个类型</li>\n<li><code>iter_difference_t&lt;I&gt;</code> 是一个有符号的整数类型</li>\n<li><code>++i</code> 的结果跟 <code>I&amp;</code> 是完全相同的类型</li>\n<li>能够执行 <code>i++</code> 操作（不检查结果的类型）</li>\n</ul><p><code>input_or_output_iterator</code> 也很简单：</p><pre><code class=\"language-c++\">template &lt;class I&gt;\nconcept input_or_output_iterator =\n  __dereferenceable&lt;I&amp;&gt; &amp;&amp;\n  weakly_incrementable&lt;I&gt;;\n</code></pre><p>就是要求可以解引用、可以执行 <code>++</code>、可以使用 <code>iter_difference_t</code> 提取迭代器的 <code>difference_type</code> 而已。</p><p>剩下的概念的定义也不复杂，我这儿就不一一讲解了。感兴趣的话你可以自己去看 CMCSTL2 的源代码。</p><h3>简单的概念测试</h3><p>为了让你再简单感受一下标准的概念，我写了下面这个简单的测试程序，展示一些标准概念的测试结果：</p><pre><code class=\"language-c++\">#include &lt;armadillo&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;type_traits&gt;\n\nusing namespace std;\n\n#if defined(__cpp_concepts)\n\n#if __cpp_concepts &lt; 201811\n\n#include &lt;experimental/ranges/concepts&gt;\nusing namespace experimental::ranges;\n\n#else\n\n#include &lt;concepts&gt;\n\n#endif\n\n#else // defined(__cpp_concepts)\n\n#error \"No support for concepts!\"\n\n#endif\n\n#define TEST_CONCEPT(Concept,      \\\n                     Type)         \\\n  cout &lt;&lt; #Concept &lt;&lt; '&lt;' &lt;&lt; #Type \\\n       &lt;&lt; \"&gt;: \"                    \\\n       &lt;&lt; Concept&lt;Type&gt; &lt;&lt; endl\n\n#define TEST_CONCEPT2(             \\\n  Concept, Type1, Type2)           \\\n  cout &lt;&lt; #Concept &lt;&lt; '&lt;'          \\\n       &lt;&lt; #Type1 &lt;&lt; \", \" &lt;&lt; #Type2 \\\n       &lt;&lt; \"&gt;: \"                    \\\n       &lt;&lt; Concept&lt;Type1,           \\\n                  Type2&gt; &lt;&lt; endl\n\nint main()\n{\n  cout &lt;&lt; boolalpha;\n  cout &lt;&lt; \"__cpp_concepts is \"\n       &lt;&lt; __cpp_concepts &lt;&lt; endl;\n  TEST_CONCEPT(regular, int);\n  TEST_CONCEPT(regular, char);\n  TEST_CONCEPT(integral, int);\n  TEST_CONCEPT(integral, char);\n  TEST_CONCEPT(readable, int);\n  TEST_CONCEPT(readable,\n               unique_ptr&lt;int&gt;);\n  TEST_CONCEPT2(\n    writable, unique_ptr&lt;int&gt;, int);\n  TEST_CONCEPT2(writable,\n                unique_ptr&lt;int&gt;,\n                double);\n  TEST_CONCEPT2(writable,\n                unique_ptr&lt;int&gt;,\n                int*);\n  TEST_CONCEPT(semiregular,\n               unique_ptr&lt;int&gt;);\n  TEST_CONCEPT(semiregular,\n               shared_ptr&lt;int&gt;);\n  TEST_CONCEPT(equality_comparable,\n               unique_ptr&lt;int&gt;);\n  TEST_CONCEPT(semiregular,\n               arma::imat);\n  TEST_CONCEPT2(assignable_from,\n                arma::imat&amp;,\n                arma::imat&amp;);\n  TEST_CONCEPT(semiregular,\n               arma::imat22);\n  TEST_CONCEPT2(assignable_from,\n                arma::imat22&amp;,\n                arma::imat22&amp;);\n}\n</code></pre><p>代码照顾了两种可能的环境：</p><ul>\n<li>最新的 MSVC（需要使用 <code>/std:c++latest</code>；我用的是 Visual Studio 2019 16.4.4）</li>\n<li>GCC（需要使用 <code>-fconcepts</code>；我测试了 7、8、9 三个版本都可以）和 CMCSTL2（需要将其 include 目录用 <code>-I</code> 选项加到命令行上）</li>\n</ul><p>程序在 MSVC 下的结果如下所示：</p><blockquote>\n<p><code>__cpp_concepts is 201811</code><br>\n<code>regular&lt;int&gt;: true</code><br>\n<code>regular&lt;char&gt;: true</code><br>\n<code>integral&lt;int&gt;: true</code><br>\n<code>integral&lt;char&gt;: true</code><br>\n<code>readable&lt;int&gt;: false</code><br>\n<code>readable&lt;unique_ptr&lt;int&gt;&gt;: true</code><br>\n<code>writable&lt;unique_ptr&lt;int&gt;, int&gt;: true</code><br>\n<code>writable&lt;unique_ptr&lt;int&gt;, double&gt;: true</code><br>\n<code>writable&lt;unique_ptr&lt;int&gt;, int*&gt;: false</code><br>\n<code>semiregular&lt;unique_ptr&lt;int&gt;&gt;: false</code><br>\n<code>semiregular&lt;shared_ptr&lt;int&gt;&gt;: true</code><br>\n<code>equality_comparable&lt;unique_ptr&lt;int&gt;&gt;: true</code><br>\n<code>semiregular&lt;arma::imat&gt;: true</code><br>\n<code>assignable_from&lt;arma::imat&amp;, arma::imat&amp;&gt;: true</code><br>\n<code>semiregular&lt;arma::imat22&gt;: false</code><br>\n<code>assignable_from&lt;arma::imat22&amp;, arma::imat22&amp;&gt;: false</code></p>\n</blockquote><p>除了第一行 <code>__cpp_concepts</code> 的输出，GCC 的结果也是完全一致的。大部分的结果应当没有意外，但也需要注意，某些用起来没问题的类（如 <code>arma::imat22</code>），却因为一些实现上的特殊技术，不能满足 <code>semiregular</code>。——概念要比鸭子类型更为严格。</p><h2>概念、出错信息和 SFINAE</h2><p>显然，对于上面出现的这个例子：</p><pre><code class=\"language-c++\">template &lt;Integer N&gt;\nN half(N n)\n{\n  return n / 2;\n}\n</code></pre><p>我们用 <code>enable_if</code> 也是能写出来的：</p><pre><code class=\"language-c++\">template &lt;typename N&gt;\nenable_if_t&lt;Integer&lt;N&gt;, N&gt;\nhalf(N n)\n{\n  return n / 2;\n}\n</code></pre><p>不过，你不会觉得这种方式更好吧？而且，对于没有返回值的情况，要用对 <code>enable_if</code> 还是非常麻烦的（参见 <span class=\"orange\">[8]</span> 里的 Notes /注解部分）。</p><p>更重要的是，“概念”可以提供更为友好可读的代码，以及潜在更为友好的出错信息。拿 Andrew Sutton 的一个例子 <span class=\"orange\">[9]</span>（根据我们上节说的编译环境做了改编）：</p><pre><code class=\"language-c++\">#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n#if defined(__cpp_concepts)\n\n#if __cpp_concepts &lt; 201811\n\n#include &lt;experimental/ranges/concepts&gt;\nusing namespace experimental::ranges;\n\n#else\n\n#include &lt;concepts&gt;\n#include &lt;ranges&gt;\nusing namespace ranges;\n\n#endif\n\n#define REQUIRES(x) requires x\n\n#else // defined(__cpp_concepts)\n\n#define REQUIRES(x)\n\n#endif\n\ntemplate &lt;typename R, typename T&gt;\n  REQUIRES(\n    (range&lt;R&gt; &amp;&amp;\n     equality_comparable_with&lt;\n       T, typename R::value_type&gt;))\nbool in(R const&amp; r, T const&amp; value)\n{\n  for (auto const&amp; x : r)\n    if (x == value)\n      return true;\n  return false;\n}\n\nint main()\n{\n  vector&lt;string&gt; v{\"Hello\",\n                   \"World\"};\n  in(v, \"Hello\");\n  in(v, 0);\n}\n</code></pre><p>以 GCC 8 为例，如果不使用概念约束，<code>in(v, 0)</code> 这行会产生 166 行出错信息；而启用了概念约束后，出错信息缩减到了 8 行。MSVC 上对于这个例子不使用概念错误信息也较短，但启用了概念后仍然能产生更短、更明确的出错信息：</p><blockquote>\n<p><code>test.cpp(47): error C2672: 'in': no matching overloaded function found</code><br>\n<code>test.cpp(47): error C7602: 'in': the associated constraints are not satisfied</code><br>\n<code>test.cpp(34): note: see declaration of 'in'</code></p>\n</blockquote><p>随着编译器的改进，概念在出错信息上的优势在消减，但在代码表达上的优势仍然是实实在在的。记得<a href=\"https://time.geekbang.org/column/article/181636\">[第 14 讲]</a> 里我们费了好大的劲、用了几种不同的方法来定义 <code>has_reserve</code> 吗？在概念面前，那些就成了“回”字有几种写法了。我们可以飞快地定义下面的概念：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nconcept has_reserve =\n  requires(T&amp; dest) {\n    dest.reserve(1U);\n  };\n</code></pre><p>这个概念用在编译期条件语句里，效果和之前的完全相同……哦，错了，不用再写 <code>::value</code> 或 <code>{}</code> 了😂。</p><p>在<a href=\"https://time.geekbang.org/column/article/181608\">[第 13 讲]</a> 我给出过的 <code>fmap</code>，在实际代码中我也是用了 SFINAE 来进行约束的（略简化）：</p><pre><code class=\"language-c++\">template &lt;\n  template &lt;typename, typename&gt;\n  class OutContainer = vector,\n  typename F, class R&gt;\nauto fmap(F&amp;&amp; f, R&amp;&amp; inputs)\n  -&gt; decltype(begin(inputs),\n              end(inputs),\n              OutContainer&lt;\n                decay_t&lt;decltype(f(\n                  *begin(inputs)))&gt;,\n                allocator&lt;decay_t&lt;\n                  decltype(f(*begin(\n                    inputs)))&gt;&gt;&gt;());\n</code></pre><p>我费了老大的劲，要把返回值写出来，实际上就是为了利用 SFINAE 而已。如果使用“概念”，那代码可以简化成：</p><pre><code class=\"language-c++\">template &lt;\n  template &lt;typename, typename&gt;\n  class OutContainer = vector,\n  typename F, class R&gt;\n  requires requires(R&amp;&amp; r) {\n    begin(r);\n    end(r);\n  }\nauto fmap(F&amp;&amp; f, R&amp;&amp; inputs);\n</code></pre><p>上面的 <code>requires requires</code> 不是错误，正如 <code>noexcept(noexcept(…))</code> 不是错误一样。第一个 <code>requires</code> 开始一个 <strong>requires 子句</strong>，后面跟一个常量表达式，结果的真假表示是否满足了模板的约束条件。第二个 <code>requires</code> 则开始了一个 <strong>requires 表达式</strong>：如果类型 <code>R</code> 满足约束——可以使用 <code>begin</code> 和 <code>end</code> 对 <code>R&amp;&amp;</code> 类型的变量进行调用——则返回真，否则返回假。</p><p>不过，在 C++20 里，上面这个条件我是不需要这么写出来的。有一个现成的概念可用，这么写就行了：</p><pre><code class=\"language-c++\">template &lt;\n  template &lt;typename, typename&gt;\n  class OutContainer = vector,\n  typename F, class R&gt;\n  requires range&lt;R&gt;\nauto fmap(F&amp;&amp; f, R&amp;&amp; inputs);\n</code></pre><p>如你所见，我今天第二次用了 <code>range</code> 这个概念。究竟什么是 range？我们留到下一讲再说。</p><h2>内容小结</h2><p>今天我们讨论了 C++20 里可以说是最重要的新功能——概念。概念可以用来对模板参数进行约束，能取代 SFINAE，产生更好、更可读的代码。</p><p>注意本讲的内容并非一个形式化的描述，请你在阅读了本讲的内容之后，再对照参考资料 [6] 的内容看一下更严格的描述，然后再回过头来读一下例子，来加深你对本讲内容的理解。</p><h2>课后思考</h2><p>请结合自己的 C++ 项目，考虑一下，“概念”可以为开发具体带来哪些好处？反过来，负面的影响又可能会是什么？</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Bjarne Stroustrup, “Concepts: the future of generic programming, or how to design good concepts and use them well”. <a href=\"http://www.stroustrup.com/good_concepts.pdf\">http://www.stroustrup.com/good_concepts.pdf</a> </span></p><p><span class=\"reference\">[2] Alexander Stepanov and Paul McJones, <em>Elements of Programming</em>. Addison-Wesley, 2009. 有中文版（裘宗燕译《编程原本》，人民邮电出版社，2019 年） </span></p><p><span class=\"reference\">[3] ISO/IEC JTC1 SC22 WG21, N4549, “Programming languages — C++ extensions for concepts”. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4549.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4549.pdf</a> </span></p><p><span class=\"reference\">[4] Herb Sutter et al., “Rename concepts to standard_case for C++20, while we still can”. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1754r1.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1754r1.pdf</a> </span></p><p><span class=\"reference\">[5] cppreference.com, “Standard library header &lt;concepts&gt;”. <a href=\"https://en.cppreference.com/w/cpp/header/concepts\">https://en.cppreference.com/w/cpp/header/concepts</a>. </span></p><p><span class=\"reference\">[5a] cppreference.com, “标准库头文件 &lt;concepts&gt;”. <a href=\"https://zh.cppreference.com/w/cpp/header/concepts\">https://zh.cppreference.com/w/cpp/header/concepts</a>. </span></p><p><span class=\"reference\">[6] Casey Carter et al., cmcstl2. <a href=\"https://github.com/CaseyCarter/cmcstl2\">https://github.com/CaseyCarter/cmcstl2</a> </span></p><p><span class=\"reference\">[7] cppreference.com, “Constraints and concepts”. <a href=\"https://en.cppreference.com/w/cpp/language/constraints\">https://en.cppreference.com/w/cpp/language/constraints</a> </span></p><p><span class=\"reference\">[7a] cppreference.com, “约束与概念”. <a href=\"https://zh.cppreference.com/w/cpp/language/constraints\">https://zh.cppreference.com/w/cpp/language/constraints</a> </span></p><p><span class=\"reference\">[8] cppreference.com, “std::enable_if”. <a href=\"https://en.cppreference.com/w/cpp/types/enable_if\">https://en.cppreference.com/w/cpp/types/enable_if</a> </span></p><p><span class=\"reference\">[8a] cppreference.com, “std::enable_if”. <a href=\"https://zh.cppreference.com/w/cpp/types/enable_if\">https://zh.cppreference.com/w/cpp/types/enable_if</a> </span></p><p><span class=\"reference\">[9] Andrew Sutton, “Introducing concepts”. <a href=\"https://accu.org/index.php/journals/2157\">https://accu.org/index.php/journals/2157</a> </span></p>","neighbors":{"left":{"article_title":"27 | C++ REST SDK：使用现代C++开发网络应用","id":193523},"right":{"article_title":"29 | Ranges：无迭代器的迭代和更方便的组合","id":195553}},"comments":[{"had_liked":false,"id":383498,"user_name":"李云龙","can_delete":false,"product_type":"c1","uid":3201926,"ip_address":"北京","ucode":"785924B16BE788","user_header":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","comment_is_top":false,"comment_ctime":1699169000,"is_pvip":false,"replies":[{"id":140089,"content":"是错了。谢谢。正文已更新。","user_name":"作者回复","user_name_real":"作者","uid":1645639,"ctime":1700005440,"ip_address":"广东","comment_id":383498,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，您的这段代码，OutContainer是需要2个模板参数的，但是特化的时候只提供了一个类型作为模板参数，是不是漏写了一个模板参数？我回到13讲，是不是应该加上 allocator&lt;decay_t&lt;decltype(f(*begin(inputs)))&gt;&gt;&gt;?还是编译期会帮我们自动推断第二个类型？\ntemplate &lt;\n  template &lt;typename, typename&gt;\n  class OutContainer = vector,\n  typename F, class R&gt;\nauto fmap(F&amp;&amp; f, R&amp;&amp; inputs)\n  -&gt; decltype(\n    begin(inputs),\n    end(inputs),\n    OutContainer&lt;decay_t&lt;\n      decltype(f(*begin(\n        inputs)))&gt;&gt;());","like_count":1},{"had_liked":false,"id":306120,"user_name":"Geek_QiDian","can_delete":false,"product_type":"c1","uid":1760241,"ip_address":"","ucode":"048B4D7E07E2E2","user_header":"https://static001.geekbang.org/account/avatar/00/1a/db/f1/1015328a.jpg","comment_is_top":false,"comment_ctime":1628390769,"is_pvip":false,"replies":[{"id":110945,"content":"有支持 ranges 的版本 output_range（URL 里相应改一下就行），没有去做概念实现版本过。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1628564977,"ip_address":"","comment_id":306120,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"请问老师的 output_container 的概念实现版本有吗？想研究一下","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631809,"discussion_content":"是错了。谢谢。正文已更新。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700005440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177124,"user_name":"廖熊猫","can_delete":false,"product_type":"c1","uid":1141444,"ip_address":"","ucode":"8E8C475CD11FBC","user_header":"https://static001.geekbang.org/account/avatar/00/11/6a/c4/8679ca8a.jpg","comment_is_top":false,"comment_ctime":1581297462,"is_pvip":false,"replies":[{"id":68818,"content":"Java和C#的泛型约束都太弱了，只能是你需要做什么，而不能说你不可以做什么。另外，这种基于继承的约束是 跟 C++ 的鸭子类型方式背道而驰的：概念仍然是基于鸭子类型的，虽然是更形式化的鸭子类型——但它仍然是不使用继承体系的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581332140,"ip_address":"","comment_id":177124,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"c++里的泛型约束和java或者c#中的泛型约束很像，但是复杂了好多...不像后者只能约束泛型参数实现某一接口，c++可以通过很小的约束组合成需要的约束，感觉这就是函数式里面经常提的组合的力量吧","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524639,"discussion_content":"有支持 ranges 的版本 output_range（URL 里相应改一下就行），没有去做概念实现版本过。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628564977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228645,"user_name":"易轻尘","can_delete":false,"product_type":"c1","uid":1136684,"ip_address":"","ucode":"0D0CB9D6D45A70","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/2c/92c7ce3b.jpg","comment_is_top":false,"comment_ctime":1592770055,"is_pvip":false,"replies":[{"id":84389,"content":"有答案的。学到这么后面了，就去看一下答案吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1592833305,"ip_address":"","comment_id":228645,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"个人认为好处就是1. 代码量减少，2. 代码变得更加易读，和老师说的3. 出错信息变得更友善了。\n\n我对模板编程不是很熟练，所以之前很少通过SFINAE来直接规制函数的模板参数类型，反而是通过模仿java的做法，写模板类作为接口，包装实际的类型。如果需要的约束简单这样写也不麻烦，但是无法像concepts的写法那样随意的组合各种约束，要实现这节图中那种类似树状的结构麻烦得就不是一点半点了。\n\n至于缺点，暂时没有想到，希望老师能提示提示","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483313,"discussion_content":"Java和C#的泛型约束都太弱了，只能是你需要做什么，而不能说你不可以做什么。另外，这种基于继承的约束是 跟 C++ 的鸭子类型方式背道而驰的：概念仍然是基于鸭子类型的，虽然是更形式化的鸭子类型——但它仍然是不使用继承体系的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581332140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203594,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1586238277,"is_pvip":false,"replies":[{"id":76164,"content":"对于思维严谨的人来说，是抽象，是好事，不是困难。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1586274156,"ip_address":"","comment_id":203594,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"如果是引入概念的话\n1.从当前的标准库里可以抽取更多近似概念的操作（类似于itrerator），直接调用即可。\n2.在class的设计上直接标记概念相关关键字就可以检查class的设计是不是符合原则\n\n缺点:理解起来比较困难","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499124,"discussion_content":"有答案的。学到这么后面了，就去看一下答案吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592833305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184772,"user_name":"李亮亮","can_delete":false,"product_type":"c1","uid":1116508,"ip_address":"","ucode":"290907F930B261","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","comment_is_top":false,"comment_ctime":1583398588,"is_pvip":false,"replies":[{"id":71451,"content":"代码前面要有：\n\n#include &lt;vector&gt;\nusing namespace std;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583450877,"ip_address":"","comment_id":184772,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"vs2019  c++17\ntemplate &lt;typename, typename&gt;\n    class OutContainer = vector,\n这里提示错误：\tC2065\t“vector”: 未声明的标识符\t\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486126,"discussion_content":"代码前面要有：\n\n#include &amp;lt;vector&amp;gt;\nusing namespace std;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583450877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116508,"avatar":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","nickname":"李亮亮","note":"","ucode":"290907F930B261","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198001,"discussion_content":"谢谢老师，我刚发现了。太久没用C++，傻了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583461028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175831,"user_name":"始之源稳于心","can_delete":false,"product_type":"c1","uid":1326578,"ip_address":"","ucode":"E0721C63557ACD","user_header":"https://static001.geekbang.org/account/avatar/00/14/3d/f2/912c9f9d.jpg","comment_is_top":false,"comment_ctime":1580865672,"is_pvip":false,"replies":[{"id":68372,"content":"没遇到类似问题，不熟悉。建议到 Stack Overflow 上去问，最好描述清楚环境，并且有一个最小的测试程序。\n\n一般而言，网络程序和多线程程序要做好单元测试，也只有单元测试可以在调试器里顺利进行。完整系统的调试多靠记日志和分析。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580874286,"ip_address":"","comment_id":175831,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，你好，我问一个与此文章无关的，一个GDB调试的问题：\n一个网络多线程服务，一个socket一个线程。有一个共享变量用boost的unordered_map，同步也用boost的unique_lock\n程序在运行时基本正常，但在gdb调试时只要打印共享变量(即使里面没有数据)，就会收到SIGSEG，调试其它变量或用下面的步骤就没事\n1   handle SIGPIPE nostop noprint\n2   set print elements 0\n3   将共享的变量的类型变为 stl的map\n问题：\n  这种情况产生的主要原因是什么，用了boost的 hash map吗，和屏蔽管道关系有多大？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482920,"discussion_content":"没遇到类似问题，不熟悉。建议到 Stack Overflow 上去问，最好描述清楚环境，并且有一个最小的测试程序。\n\n一般而言，网络程序和多线程程序要做好单元测试，也只有单元测试可以在调试器里顺利进行。完整系统的调试多靠记日志和分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580874286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1326578,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3d/f2/912c9f9d.jpg","nickname":"始之源稳于心","note":"","ucode":"E0721C63557ACD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161203,"discussion_content":"好的，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580875700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383498,"user_name":"李云龙","can_delete":false,"product_type":"c1","uid":3201926,"ip_address":"北京","ucode":"785924B16BE788","user_header":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","comment_is_top":false,"comment_ctime":1699169000,"is_pvip":false,"replies":[{"id":140089,"content":"是错了。谢谢。正文已更新。","user_name":"作者回复","user_name_real":"作者","uid":1645639,"ctime":1700005440,"ip_address":"广东","comment_id":383498,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，您的这段代码，OutContainer是需要2个模板参数的，但是特化的时候只提供了一个类型作为模板参数，是不是漏写了一个模板参数？我回到13讲，是不是应该加上 allocator&lt;decay_t&lt;decltype(f(*begin(inputs)))&gt;&gt;&gt;?还是编译期会帮我们自动推断第二个类型？\ntemplate &lt;\n  template &lt;typename, typename&gt;\n  class OutContainer = vector,\n  typename F, class R&gt;\nauto fmap(F&amp;&amp; f, R&amp;&amp; inputs)\n  -&gt; decltype(\n    begin(inputs),\n    end(inputs),\n    OutContainer&lt;decay_t&lt;\n      decltype(f(*begin(\n        inputs)))&gt;&gt;());","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631809,"discussion_content":"是错了。谢谢。正文已更新。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700005440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306120,"user_name":"Geek_QiDian","can_delete":false,"product_type":"c1","uid":1760241,"ip_address":"","ucode":"048B4D7E07E2E2","user_header":"https://static001.geekbang.org/account/avatar/00/1a/db/f1/1015328a.jpg","comment_is_top":false,"comment_ctime":1628390769,"is_pvip":false,"replies":[{"id":110945,"content":"有支持 ranges 的版本 output_range（URL 里相应改一下就行），没有去做概念实现版本过。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1628564977,"ip_address":"","comment_id":306120,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"请问老师的 output_container 的概念实现版本有吗？想研究一下","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524639,"discussion_content":"有支持 ranges 的版本 output_range（URL 里相应改一下就行），没有去做概念实现版本过。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628564977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177124,"user_name":"廖熊猫","can_delete":false,"product_type":"c1","uid":1141444,"ip_address":"","ucode":"8E8C475CD11FBC","user_header":"https://static001.geekbang.org/account/avatar/00/11/6a/c4/8679ca8a.jpg","comment_is_top":false,"comment_ctime":1581297462,"is_pvip":false,"replies":[{"id":68818,"content":"Java和C#的泛型约束都太弱了，只能是你需要做什么，而不能说你不可以做什么。另外，这种基于继承的约束是 跟 C++ 的鸭子类型方式背道而驰的：概念仍然是基于鸭子类型的，虽然是更形式化的鸭子类型——但它仍然是不使用继承体系的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581332140,"ip_address":"","comment_id":177124,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"c++里的泛型约束和java或者c#中的泛型约束很像，但是复杂了好多...不像后者只能约束泛型参数实现某一接口，c++可以通过很小的约束组合成需要的约束，感觉这就是函数式里面经常提的组合的力量吧","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483313,"discussion_content":"Java和C#的泛型约束都太弱了，只能是你需要做什么，而不能说你不可以做什么。另外，这种基于继承的约束是 跟 C++ 的鸭子类型方式背道而驰的：概念仍然是基于鸭子类型的，虽然是更形式化的鸭子类型——但它仍然是不使用继承体系的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581332140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228645,"user_name":"易轻尘","can_delete":false,"product_type":"c1","uid":1136684,"ip_address":"","ucode":"0D0CB9D6D45A70","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/2c/92c7ce3b.jpg","comment_is_top":false,"comment_ctime":1592770055,"is_pvip":false,"replies":[{"id":84389,"content":"有答案的。学到这么后面了，就去看一下答案吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1592833305,"ip_address":"","comment_id":228645,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"个人认为好处就是1. 代码量减少，2. 代码变得更加易读，和老师说的3. 出错信息变得更友善了。\n\n我对模板编程不是很熟练，所以之前很少通过SFINAE来直接规制函数的模板参数类型，反而是通过模仿java的做法，写模板类作为接口，包装实际的类型。如果需要的约束简单这样写也不麻烦，但是无法像concepts的写法那样随意的组合各种约束，要实现这节图中那种类似树状的结构麻烦得就不是一点半点了。\n\n至于缺点，暂时没有想到，希望老师能提示提示","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499124,"discussion_content":"有答案的。学到这么后面了，就去看一下答案吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592833305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203594,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1586238277,"is_pvip":false,"replies":[{"id":76164,"content":"对于思维严谨的人来说，是抽象，是好事，不是困难。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1586274156,"ip_address":"","comment_id":203594,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"如果是引入概念的话\n1.从当前的标准库里可以抽取更多近似概念的操作（类似于itrerator），直接调用即可。\n2.在class的设计上直接标记概念相关关键字就可以检查class的设计是不是符合原则\n\n缺点:理解起来比较困难","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490903,"discussion_content":"对于思维严谨的人来说，是抽象，是好事，不是困难。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586274156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184772,"user_name":"李亮亮","can_delete":false,"product_type":"c1","uid":1116508,"ip_address":"","ucode":"290907F930B261","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","comment_is_top":false,"comment_ctime":1583398588,"is_pvip":false,"replies":[{"id":71451,"content":"代码前面要有：\n\n#include &lt;vector&gt;\nusing namespace std;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583450877,"ip_address":"","comment_id":184772,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"vs2019  c++17\ntemplate &lt;typename, typename&gt;\n    class OutContainer = vector,\n这里提示错误：\tC2065\t“vector”: 未声明的标识符\t\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490903,"discussion_content":"对于思维严谨的人来说，是抽象，是好事，不是困难。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586274156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175831,"user_name":"始之源稳于心","can_delete":false,"product_type":"c1","uid":1326578,"ip_address":"","ucode":"E0721C63557ACD","user_header":"https://static001.geekbang.org/account/avatar/00/14/3d/f2/912c9f9d.jpg","comment_is_top":false,"comment_ctime":1580865672,"is_pvip":false,"replies":[{"id":68372,"content":"没遇到类似问题，不熟悉。建议到 Stack Overflow 上去问，最好描述清楚环境，并且有一个最小的测试程序。\n\n一般而言，网络程序和多线程程序要做好单元测试，也只有单元测试可以在调试器里顺利进行。完整系统的调试多靠记日志和分析。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580874286,"ip_address":"","comment_id":175831,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，你好，我问一个与此文章无关的，一个GDB调试的问题：\n一个网络多线程服务，一个socket一个线程。有一个共享变量用boost的unordered_map，同步也用boost的unique_lock\n程序在运行时基本正常，但在gdb调试时只要打印共享变量(即使里面没有数据)，就会收到SIGSEG，调试其它变量或用下面的步骤就没事\n1   handle SIGPIPE nostop noprint\n2   set print elements 0\n3   将共享的变量的类型变为 stl的map\n问题：\n  这种情况产生的主要原因是什么，用了boost的 hash map吗，和屏蔽管道关系有多大？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486126,"discussion_content":"代码前面要有：\n\n#include &amp;lt;vector&amp;gt;\nusing namespace std;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583450877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116508,"avatar":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","nickname":"李亮亮","note":"","ucode":"290907F930B261","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198001,"discussion_content":"谢谢老师，我刚发现了。太久没用C++，傻了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583461028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}