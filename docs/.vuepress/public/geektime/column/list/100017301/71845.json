{"id":71845,"title":"34 | 字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法？","content":"<p>上一节我们讲了BM算法，尽管它很复杂，也不好理解，但却是工程中非常常用的一种高效字符串匹配算法。有统计说，它是最高效、最常用的字符串匹配算法。不过，在所有的字符串匹配算法里，要说最知名的一种的话，那就非KMP算法莫属。很多时候，提到字符串匹配，我们首先想到的就是KMP算法。</p><p>尽管在实际的开发中，我们几乎不大可能自己亲手实现一个KMP算法。但是，学习这个算法的思想，作为让你开拓眼界、锻炼下逻辑思维，也是极好的，所以我觉得有必要拿出来给你讲一讲。不过，KMP算法是出了名的不好懂。我会尽力把它讲清楚，但是你自己也要多动动脑子。</p><p>实际上，KMP算法跟BM算法的本质是一样的。上一节，我们讲了好后缀和坏字符规则，今天，我们就看下，如何借助上一节BM算法的讲解思路，让你能更好地理解KMP算法？</p><h2>KMP算法基本原理</h2><p>KMP算法是根据三位作者（D.E.Knuth，J.H.Morris和V.R.Pratt）的名字来命名的，算法的全称是Knuth Morris Pratt算法，简称为KMP算法。</p><p>KMP算法的核心思想，跟上一节讲的BM算法非常相近。我们假设主串是a，模式串是b。在模式串与主串匹配的过程中，当遇到不可匹配的字符的时候，我们希望找到一些规律，可以将模式串往后多滑动几位，跳过那些肯定不会匹配的情况。</p><!-- [[[read_end]]] --><p>还记得我们上一节讲到的好后缀和坏字符吗？\b这里我们可以类比一下，在模式串和主串匹配的过程中，把不能匹配的那个字符仍然叫作<strong>坏字符</strong>，把已经匹配的那段字符串叫作<strong>好前缀</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/17/be/17ae3d55cf140285d1f34481e173aebe.jpg?wh=1142*489\" alt=\"\"></p><p>当遇到坏字符的时候，我们就要把模式串往后滑动，在滑动的过程中，只要模式串和好前缀有上下重合，前面几个字符的比较，就相当于拿好前缀的后缀子串，跟模式串的前缀子串在比较。这个比较的过程能否更高效了呢？可以不用一个字符一个字符地比较了吗？</p><p><img src=\"https://static001.geekbang.org/resource/image/f4/69/f4ef2c1e6ce5915e1c6460c2e26c9469.jpg?wh=1142*838\" alt=\"\"></p><p>KMP算法就是在试图寻找一种规律：在模式串和主串匹配的过程中，当遇到坏字符后，对于已经比对过的好前缀，能否找到一种规律，将模式串一次性滑动很多位？</p><p>我们只需要拿好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的。假设最长的可匹配的那部分前缀子串是{v}，长度是k。我们把模式串一次性往后滑动j-k位，相当于，每次遇到坏字符的时候，我们就把j更新为k，i不变，然后继续比较。</p><p><img src=\"https://static001.geekbang.org/resource/image/da/8f/da99c0349f8fac27e193af8d801dbb8f.jpg?wh=1142*856\" alt=\"\"></p><p>为了表述起来方便，我把好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫作<strong>最长可匹配后缀子串</strong>；对应的前缀子串，叫作<strong>最长可匹配前缀子串</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/9e/ad/9e59c0973ffb965abdd3be5eafb492ad.jpg?wh=1142*800\" alt=\"\"></p><p>如何来求好前缀的最长可匹配前缀和后缀子串呢？我发现，这个问题其实不涉及主串，只需要通过模式串本身就能求解。所以，我就在想，能不能事先预处理计算好，在模式串和主串匹配的过程中，直接拿过来就用呢？</p><p>类似BM算法中的bc、suffix、prefix数组，KMP算法也可以提前构建一个数组，用来存储模式串中每个前缀（这些前缀都有可能是好前缀）的最长可匹配前缀子串的结尾字符下标。我们把这个数组定义为<strong>next数组</strong>，很多书中还给这个数组起了一个名字，叫<strong>失效函数</strong>（failure function）。</p><p>数组的下标是每个前缀结尾字符下标，数组的值是这个前缀的最长可以匹配前缀子串的结尾字符下标。这句话有点拗口，我举了一个例子，你一看应该就懂了。</p><p><img src=\"https://static001.geekbang.org/resource/image/16/a8/1661d37cb190cb83d713749ff9feaea8.jpg?wh=1142*743\" alt=\"\"></p><p>有了next数组，我们很容易就可以实现KMP算法了。我先假设next数组已经计算好了，先给出KMP算法的框架代码。</p><pre><code>// a, b分别是主串和模式串；n, m分别是主串和模式串的长度。\npublic static int kmp(char[] a, int n, char[] b, int m) {\n  int[] next = getNexts(b, m);\n  int j = 0;\n  for (int i = 0; i &lt; n; ++i) {\n    while (j &gt; 0 &amp;&amp; a[i] != b[j]) { // 一直找到a[i]和b[j]\n      j = next[j - 1] + 1;\n    }\n    if (a[i] == b[j]) {\n      ++j;\n    }\n    if (j == m) { // 找到匹配模式串的了\n      return i - m + 1;\n    }\n  }\n  return -1;\n}\n</code></pre><h2>失效函数计算方法</h2><p>KMP算法的基本原理讲完了，我们现在来看最复杂的部分，也就是next数组是如何计算出来的？</p><p>当然，我们可以用非常笨的方法，比如要计算下面这个模式串b的next[4]，我们就把b[0, 4]的所有后缀子串，从长到短找出来，依次看看，是否能跟模式串的前缀子串匹配。很显然，这个方法也可以计算得到next数组，但是效率非常低。有没有更加高效的方法呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/1e/ec/1ee5bea573abd033a6aa35d15ef0baec.jpg?wh=1142*689\" alt=\"\"></p><p>这里的处理非常有技巧，类似于动态规划。不过，动态规划我们在后面才会讲到，所以，我这里换种方法解释，也能让你听懂。</p><p>我们按照下标从小到大，依次计算next数组的值。当我们要计算next[i]的时候，前面的next[0]，next[1]，……，next[i-1]应该已经计算出来了。利用已经计算出来的next值，我们是否可以快速推导出next[i]的值呢？</p><p>如果next[i-1]=k-1，也就是说，子串b[0, k-1]是b[0, i-1]的最长可匹配前缀子串。如果子串b[0, k-1]的下一个字符b[k]，与b[0, i-1]的下一个字符b[i]匹配，那子串b[0, k]就是b[0, i]的最长可匹配前缀子串。所以，next[i]等于k。但是，如果b[0, k-1]的下一字符b[k]跟b[0, i-1]的下一个字符b[i]不相等呢？这个时候就不能简单地通过next[i-1]得到next[i]了。这个时候该怎么办呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/4c/19/4caa532d03d3b455ca834245935e2819.jpg?wh=1142*351\" alt=\"\"></p><p>我们假设b[0, i]的最长可匹配后缀子串是b[r, i]。如果我们把最后一个字符去掉，那b[r, i-1]肯定是b[0, i-1]的可匹配后缀子串，但不一定是最长可匹配后缀子串。所以，既然b[0, i-1]最长可匹配后缀子串对应的模式串的前缀子串的下一个字符并不等于b[i]，那么我们就可以考察b[0, i-1]的次长可匹配后缀子串b[x, i-1]对应的可匹配前缀子串b[0, i-1-x]的下一个字符b[i-x]是否等于b[i]。如果等于，那b[x, i]就是b[0, i]的最长可匹配后缀子串。</p><p><img src=\"https://static001.geekbang.org/resource/image/2a/e1/2a1845b494127c7244c82c7c59f2bfe1.jpg?wh=1142*351\" alt=\"\"></p><p>可是，如何求得b[0, i-1]的次长可匹配后缀子串呢？次长可匹配后缀子串肯定被包含在最长可匹配后缀子串中，而最长可匹配后缀子串又对应最长可匹配前缀子串b[0, y]。于是，查找b[0, i-1]的次长可匹配后缀子串，这个问题就变成，查找b[0, y]的最长匹配后缀子串的问题了。</p><p><img src=\"https://static001.geekbang.org/resource/image/13/13/1311d9026cb6e0fd51b7afa47255b813.jpg?wh=1142*531\" alt=\"\"></p><p>按照这个思路，我们可以考察完所有的b[0, i-1]的可匹配后缀子串b[y, i-1]，直到找到一个可匹配的后缀子串，它对应的前缀子串的下一个字符等于b[i]，那这个b[y, i]就是b[0, i]的最长可匹配后缀子串。</p><p>前面我已经给出KMP算法的框架代码了，现在我把这部分的代码也写出来了。这两部分代码合在一起，就是整个KMP算法的代码实现。</p><pre><code>// b表示模式串，m表示模式串的长度\nprivate static int[] getNexts(char[] b, int m) {\n  int[] next = new int[m];\n  next[0] = -1;\n  int k = -1;\n  for (int i = 1; i &lt; m; ++i) {\n    while (k != -1 &amp;&amp; b[k + 1] != b[i]) {\n      k = next[k];\n    }\n    if (b[k + 1] == b[i]) {\n      ++k;\n    }\n    next[i] = k;\n  }\n  return next;\n}\n</code></pre><h2>KMP算法复杂度分析</h2><p>KMP算法的原理和实现我们就讲完了，我们现在来分析一下KMP算法的时间、空间复杂度是多少？</p><p>空间复杂度很容易分析，KMP算法只需要一个额外的next数组，数组的大小跟模式串相同。所以空间复杂度是O(m)，m表示模式串的长度。</p><p>KMP算法包含两部分，第一部分是构建next数组，第二部分才是借助next数组匹配。所以，关于时间复杂度，我们要分别从这两部分来分析。</p><p>我们先来分析第一部分的时间复杂度。</p><p>计算next数组的代码中，第一层for循环中i从1到m-1，也就是说，内部的代码被执行了m-1次。for循环内部代码有一个while循环，如果我们能知道每次for循环、while循环平均执行的次数，假设是k，那时间复杂度就是O(k*m)。但是，while循环执行的次数不怎么好统计，所以我们放弃这种分析方法。</p><p>我们可以找一些参照变量，i和k。i从1开始一直增加到m，而k并不是每次for循环都会增加，所以，k累积增加的值肯定小于m。而while循环里k=next[k]，实际上是在减小k的值，k累积都没有增加超过m，所以while循环里面k=next[k]总的执行次数也不可能超过m。因此，next数组计算的时间复杂度是O(m)。</p><p>我们再来分析第二部分的时间复杂度。分析的方法是类似的。</p><p>i从0循环增长到n-1，j的增长量不可能超过i，所以肯定小于n。而while循环中的那条语句j=next[j-1]+1，不会让j增长的，那有没有可能让j不变呢？也没有可能。因为next[j-1]的值肯定小于j-1，所以while循环中的这条语句实际上也是在让j的值减少。而j总共增长的量都不会超过n，那减少的量也不可能超过n，所以while循环中的这条语句总的执行次数也不会超过n，所以这部分的时间复杂度是O(n)。</p><p>所以，综合两部分的时间复杂度，KMP算法的时间复杂度就是O(m+n)。</p><h2>解答开篇&amp;内容小结</h2><p>KMP算法讲完了，不知道你理解了没有？如果没有，建议多看几遍，自己多思考思考。KMP算法和上一节讲的BM算法的本质非常类似，都是根据规律在遇到坏字符的时候，把模式串往后多滑动几位。</p><p>BM算法有两个规则，坏字符和好后缀。KMP算法借鉴BM算法的思想，可以总结成好前缀规则。这里面最难懂的就是next数组的计算。如果用最笨的方法来计算，确实不难，但是效率会比较低。所以，我讲了一种类似动态规划的方法，按照下标i从小到大，依次计算next[i]，并且next[i]的计算通过前面已经计算出来的next[0]，next[1]，……，next[i-1]来推导。</p><p>KMP算法的时间复杂度是O(n+m)，不过它的分析过程稍微需要一点技巧，不那么直观，你只要看懂就好了，并不需要掌握，在我们平常的开发中，很少会有这么难分析的代码。</p><h2>课后思考</h2><p>至此，我们把经典的单模式串匹配算法全部讲完了，它们分别是BF算法、RK算法、BM算法和KMP算法，关于这些算法，你觉得什么地方最难理解呢？</p><p>欢迎留言和我分享，也欢迎点击“<span class=\"orange\">请朋友读</span>”，把今天的内容分享给你的好友，和他一起讨论、学习。</p>","neighbors":{"left":{"article_title":"33 | 字符串匹配基础（中）：如何实现文本编辑器中的查找功能？","id":71525},"right":{"article_title":"35 | Trie树：如何实现搜索引擎的搜索关键词提示功能？","id":72414}},"comments":[{"had_liked":false,"id":50412,"user_name":"ZX","can_delete":false,"product_type":"c1","uid":1235583,"ip_address":"","ucode":"0D2622FE6D1774","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/7f/8069035d.jpg","comment_is_top":false,"comment_ctime":1544968664,"is_pvip":false,"replies":[{"id":"18145","content":"你掌握了精髓","user_name":"作者回复","comment_id":50412,"uid":"1190123","ip_address":"","utype":1,"ctime":1545009261,"user_name_real":"gg"}],"discussion_count":16,"race_medal":0,"score":"1131121367512","product_id":100017301,"comment_content":"最难理解的地方是<br>k = next[k]<br>因为前一个的最长串的下一个字符不与最后一个相等，需要找前一个的次长串，问题就变成了求0到next(k)的最长串，如果下个字符与最后一个不等，继续求次长串，也就是下一个next(k)，直到找到，或者完全没有<br>","like_count":263,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432976,"discussion_content":"你掌握了精髓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545009261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1162286,"avatar":"https://static001.geekbang.org/account/avatar/00/11/bc/2e/08079c3c.jpg","nickname":"Simon","note":"","ucode":"80146B97EB5CDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298496,"discussion_content":"k一直记录的都是最长可匹配前缀的结尾下标\n","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1597311678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1461246,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4b/fe/048ad222.jpg","nickname":"猪猪男孩","note":"","ucode":"E853E29182C6B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1501,"discussion_content":"问题就变成了求0到next(k)的最长串，这块比较难理解，记住前缀的首尾，和前后缀的首尾是等效的也就理解了","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1562665834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1162286,"avatar":"https://static001.geekbang.org/account/avatar/00/11/bc/2e/08079c3c.jpg","nickname":"Simon","note":"","ucode":"80146B97EB5CDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298495,"discussion_content":"问题就变成了求0到next(k)的最长串说的有问题，应该是问题变成了0到k的最长串，next[k]即为0到k的最长前缀匹配串的结尾下标","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597311610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1972505,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/19/19/d82e24fb.jpg","nickname":"李润东","note":"","ucode":"65CFEA3C8B27C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263049,"discussion_content":"这行代码实现了这句话：这个问题就变成，查找 b[0, y]的最长匹配后缀子串的问题了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589167057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1151854,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/THkFNC52F0kYs2XI1fwxOvCck0Pibwnia4z6fzCPMRg2qYQLlt57qW4caJZ6uj9lWROc7t1OHFmIdKmiaEIP2GXpg/132","nickname":"isaac","note":"","ucode":"62ACA5B9A44D1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229398,"discussion_content":"在b[0,i]有最长可匹配后缀子串，且长度大于1的情况下，去掉b[i]后的子串一定是b[0,i-1]的后缀匹配子串，所以我们可以通过遍历b[0,i-1]的后缀匹配子串来找b[0,i]的最长后缀匹配子串。b[0,i-1]的最长后缀匹配子串等于其最长前缀子串b[0,y]，且后缀匹配子串包含在最长后缀匹配子串中，相当于包含在了b[0,y]中。所以可以通过遍历b[0,y]的后缀匹配子串来寻找，之后就是一层一层循环了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586627443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2706487,"avatar":"https://static001.geekbang.org/account/avatar/00/29/4c/37/b6626a2d.jpg","nickname":"w","note":"","ucode":"CE4230DB2C4398","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578056,"discussion_content":"其实不难理解，但王老师写的真的是太绕了，一堆无关信息，核心就是次长匹配前缀就是 最长匹配前缀的 最长匹配前缀，b[0,i-1]的最长匹配前缀是b[0,y],即next[i-1]=y,次长匹配前缀就是是b[0,y]的最长匹配前缀即next[y]，递归找到k=-1就完事了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656489903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2267052,"avatar":"","nickname":"Bonnie","note":"","ucode":"ADB73E28A870AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386719,"discussion_content":"思考了好久，终于get到了。如果不匹配，应该找0-K中的值就行匹配。比如ababc当i=4,k=1时，你拿a与c比较，你发现不相等，则应该拿b与c比，为什么是 k = next[k].因为前面也进行了匹配，它能拿到最前面那个数。即 第二个b.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627742245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1559321,"avatar":"https://static001.geekbang.org/account/avatar/00/17/cb/19/23cd0c2e.jpg","nickname":"cdjoke","note":"","ucode":"17B57376DE3636","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2267052,"avatar":"","nickname":"Bonnie","note":"","ucode":"ADB73E28A870AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387790,"discussion_content":"i等于1，k等于4，不是应该拿b和c比较吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628415334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":386719,"ip_address":""},"score":387790,"extra":""}]},{"author":{"id":2164554,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLc8iay7SThjDaND4WNn4jlK2L7fyPaFibzxUyS6UiaypQsMibIjhxONeChTuTHZEdjXk0CHEgRRjJKbA/132","nickname":"Geek_636e46","note":"","ucode":"E27F2B037B4C41","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317334,"discussion_content":"比如：ababac -> ababa -> ...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603534779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1530295,"avatar":"https://static001.geekbang.org/account/avatar/00/17/59/b7/9db9c657.jpg","nickname":"渊จุ๊บ","note":"","ucode":"E3A2C1E89EB576","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296283,"discussion_content":"是的，我结合前边最长可匹配前缀的原理，来理解，该次前缀的次长可匹配前缀一定是可以匹配该次前缀的最长可匹配前缀，并且也是该次前缀最长可匹配前缀的最长可匹配前缀。感觉这样理解相对于老师后边用x y等更容易理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596502871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2047980,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/3f/ec/00904faa.jpg","nickname":"连长","note":"","ucode":"555BD3DE57887F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295122,"discussion_content":"懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596096096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062864,"avatar":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","nickname":"aof","note":"","ucode":"5815D63C4926BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274507,"discussion_content":"主要还是动态规划的那段思路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590588794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1203576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5d/78/f011d586.jpg","nickname":"遇见阳光","note":"","ucode":"378E5D37B3CD0E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":131533,"discussion_content":"深有感触","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578841673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1168851,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d5/d3/4b0e8142.jpg","nickname":"Rolle","note":"","ucode":"6BC3DD2BFD9726","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42646,"discussion_content":"我咋一直觉得，前一个最长串的下一个字符与最后一个(标记为i)不等时，应该用次长串的最长匹配前缀，从后往前逐个遍历，找到与最后一个i相等时，最长子串的i相等字符前面的这些为0~i的最长相等前缀呢？求解答，一直困扰在这一点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572740922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1233125,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d0/e5/883438d2.jpg","nickname":"brook8023","note":"","ucode":"22E358D12439C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8107,"discussion_content":"明白了，多谢指点，脑子转不过来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567782013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50046,"user_name":"他在她城断了弦","can_delete":false,"product_type":"c1","uid":1242521,"ip_address":"","ucode":"3D91CA87B64C8B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/99/454b17c1.jpg","comment_is_top":false,"comment_ctime":1544848434,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"439631512626","product_id":100017301,"comment_content":"关于求next数组这部分写的太不好懂了，建议作者别用太多长句，切换成短句，方便大家理解。。","like_count":102,"discussions":[{"author":{"id":2037714,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/17/d2/68cdbd75.jpg","nickname":"海狮","note":"","ucode":"18FDDF5841F282","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311821,"discussion_content":"1、次长子串是模版串的一个前缀子串\n2、最长子串也是模版串的一个前缀子串\n3、次长子串是最长子串的一个部分\n得出：次长子串也是最长子串的一个前缀子串。。。\n\n刚好可以借助之前填充的next数组找到（最长子串之前也作为好前缀候选，放到next数组里过）\n\n因此 k = next[k]","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1602494290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1911235,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKIRSxInCiclMszZ21FptlHSHBB2icQSdIbRX2BYdiaEfdicsWxLzqB7h01jhibpLOAu9Hd8SfbZxHBaQg/132","nickname":"渣渣辉","note":"","ucode":"730838D9161579","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221500,"discussion_content":"看晕了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586011707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1238166,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/96/a5d775e9.jpg","nickname":"牧凉","note":"","ucode":"1F57A16E37C668","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1911235,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKIRSxInCiclMszZ21FptlHSHBB2icQSdIbRX2BYdiaEfdicsWxLzqB7h01jhibpLOAu9Hd8SfbZxHBaQg/132","nickname":"渣渣辉","note":"","ucode":"730838D9161579","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382834,"discussion_content":"很晕","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625735723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":221500,"ip_address":""},"score":382834,"extra":""}]},{"author":{"id":1309592,"avatar":"https://static001.geekbang.org/account/avatar/00/13/fb/98/6f238b8e.jpg","nickname":"半个柚子","note":"","ucode":"CF5D1190D970A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181043,"discussion_content":"大话数据结构书中的这部分讲的比较易懂","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582334678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2136414,"avatar":"https://static001.geekbang.org/account/avatar/00/20/99/5e/33481a74.jpg","nickname":"Lemon","note":"","ucode":"E52BB361B69825","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369272,"discussion_content":"看文字看晕了，放弃文字看代码马上就懂了😂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618993831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2703237,"avatar":"","nickname":"sean","note":"","ucode":"B517C6A09A4F07","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552835,"discussion_content":"直接看麻了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645607420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2065943,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/86/17/0afc84df.jpg","nickname":"jackfan","note":"","ucode":"B61A63A2215A49","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310070,"discussion_content":"主要是求当前的不等于前一个最长子串的下一个，就求前一个最长子串的最长子串，因为前一个最长次子串，肯定被前一个最长子串包含，那么次子串就是前一个最长子串的最长子串，而前一个最长子串就是最长前缀，所求的次子串就是前一个最长前缀的最长子串","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601603675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":61932,"user_name":"algo","can_delete":false,"product_type":"c1","uid":1177817,"ip_address":"","ucode":"31E898AE80B47B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/d9/db957e30.jpg","comment_is_top":false,"comment_ctime":1547861058,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"323670408258","product_id":100017301,"comment_content":"推荐读者先去看下这篇文章，然后再来看看，理解next会比较有帮助。<br>https:&#47;&#47;www.zhihu.com&#47;question&#47;21923021，逍遥行 的回答","like_count":75,"discussions":[{"author":{"id":1058331,"avatar":"https://static001.geekbang.org/account/avatar/00/10/26/1b/4caf36bd.jpg","nickname":"coldpark","note":"","ucode":"D1B0F343B384F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24374,"discussion_content":"“咸鱼白”五月份写的答案更好懂，反而是王老师这次讲的不那么深入浅出","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1570105855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1514305,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","nickname":"xk_","note":"","ucode":"DFE1AC38EA78A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1058331,"avatar":"https://static001.geekbang.org/account/avatar/00/10/26/1b/4caf36bd.jpg","nickname":"coldpark","note":"","ucode":"D1B0F343B384F8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255714,"discussion_content":"王老师的代码跟“咸鱼白”有点不一样，思路有点区别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588424535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":24374,"ip_address":""},"score":255714,"extra":""}]},{"author":{"id":1200867,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/e3/594f7e34.jpg","nickname":"杨超越","note":"","ucode":"D115EDC04B6E1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201981,"discussion_content":"给力啊，看了这个回答才搞懂👍","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583852838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110662,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/86/d689f77e.jpg","nickname":"Hank_Yan","note":"","ucode":"86899B561C502B","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301294,"discussion_content":"知乎答主，排名第一的回答的很好，懂了。其实就是精选留言  ZX 说的， k=next(k) 比较难懂，其他地方 ok 的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598485560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104611,"avatar":"https://static001.geekbang.org/account/avatar/00/10/da/e3/51295241.jpg","nickname":"熊熊","note":"","ucode":"D4E5B5C4FCF059","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586882,"discussion_content":"nice\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662553531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2870321,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLE9hv64CEabxt76tQQcWDicx0sucpAApFvYoM8eXBViaJgz06EjcfJjiamSFWY9aAuxjILaPoiaa0lNw/132","nickname":"Soil","note":"","ucode":"3B353BC858B5AE","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576581,"discussion_content":"完美","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655686072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49950,"user_name":"李","can_delete":false,"product_type":"c1","uid":1119312,"ip_address":"","ucode":"5C0FAA211F2E26","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg","comment_is_top":false,"comment_ctime":1544796800,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"323667344000","product_id":100017301,"comment_content":"终于看明白了，感觉设置了很多干扰项。其实用迭代思想解释就能理解了。<br>这个算法本质是找相等的最长匹配前缀和最长匹配后缀。<br>有两种情况，<br>（1）如果b[i-1]的最长前缀下一个字符与b[i]相等，则next[i]=next[i-1]+1.<br>（2）如果不相等，则我们假设找到b[i-1]的最长前缀里有b[0,y]与后缀的子串b[z,i-1]相等，然后只要b[y+1]与b[i]相等，那么b[0,y+1]就是最长匹配前缀。这个y可以不断的通过迭代缩小就可以找到<br>","like_count":75,"discussions":[{"author":{"id":1138792,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/68/540a9004.jpg","nickname":"戒修","note":"","ucode":"EAECD493E06B66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286587,"discussion_content":"感谢大佬留言帮我解惑，困住2天了。根据您的思路我理解了next数组的构造过程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593236923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202531,"discussion_content":"是这个意思！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583930224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199414,"discussion_content":"感谢你的留言让我豁然开朗，卡了好几天。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583589285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51741,"user_name":"slvher","can_delete":false,"product_type":"c1","uid":1018964,"ip_address":"","ucode":"F4ED6980C8248B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/54/deb19880.jpg","comment_is_top":false,"comment_ctime":1545230753,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"242063399329","product_id":100017301,"comment_content":"「我们假设 b[0, i] 的最长可匹配后缀子串是 b[r, i]。如果我们把最后一个字符去掉，那 b[r, i-1] 肯定是 b[0, i-1] 的可匹配后缀子串，但不一定是最长可匹配后缀子串。」<br><br>========= 手动分割线 ========<br><br>对文中这句话，我的理解如下：<br><br>因为 b[i] 的约束可能导致 r 靠近 i，故去掉 b[i] 字符后，b[r, i-1] 虽然肯定是 b[0, i-1] 的可匹配后缀子串，但不一定是其中最长的。<br><br>例如：设模式串好前缀为 &quot;abxabcabxabx&quot;，其最长可匹配后缀子串为 &quot;abx&quot;，去掉最后的字符 &#39;x&#39; 后，虽然 &quot;ab&quot; 还是好前缀的可匹配后缀子串，但 &quot;abxab&quot; 才是最长可匹配后缀子串。<br><br>这句话虽然本身逻辑上是正确的，与上下文逻辑衔接性不强，感觉去掉这句更有利于对 next 数组第二种情况的理解。","like_count":56,"discussions":[{"author":{"id":1237284,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/24/b2a680f2.jpg","nickname":"六便士","note":"","ucode":"E4778247F2F1CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":266293,"discussion_content":"感谢讲解，在这句话上磕了好久 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589501117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1800886,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/7a/b6/f54bbfaa.jpg","nickname":"花郎世纪","note":"","ucode":"301DF9B6375E08","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":172433,"discussion_content":"谢老哥，我卡这里半天，唉···","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581777996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1972505,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/19/19/d82e24fb.jpg","nickname":"李润东","note":"","ucode":"65CFEA3C8B27C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263034,"discussion_content":"其实是有逻辑关联的，要细品，我大概明白，但是自己讲不出来😅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589165448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1046893,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f9/6d/b623562a.jpg","nickname":"霹雳大仙pp","note":"","ucode":"F654FD9AEC1D56","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":1972505,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/19/19/d82e24fb.jpg","nickname":"李润东","note":"","ucode":"65CFEA3C8B27C4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265850,"discussion_content":"\n假设b[0, i] “abc......abc”，最长可匹配后缀子串为abc，\nb[0, i-1] “abc......ab“, 其中ab是b[0, i-1]可匹配后缀子串，但不一定是最长的。\n即证明存在长度大于ab的可匹配后缀子串，\n即存在： abc? = ??ab （不满足，继续增加位数）\nabc?? = ???ab，其中ab(cab)=(abc)ab\n即存在b[0,i-1] = “abcab...abcab“的可匹配后缀子串为abcab，长度>ab。\n\n\n","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1589447100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":263034,"ip_address":""},"score":265850,"extra":""}]},{"author":{"id":1045568,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f4/40/36f794fc.jpg","nickname":"张红升","note":"","ucode":"EB85C4E2BBBC0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":238976,"discussion_content":"是的，我读到这的时候也很纳闷，感觉这句话跟上下文没有什么关联","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587263903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133611,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cV1oTzslJ6YicADRAjib982gDAIGNiaiaibdOnXofZlJ2Q2kgG7z9wrT9LYNHEhFLia8EnibfEPy4HIxxDcBy0Loljp2Q/132","nickname":"strider","note":"","ucode":"D6B197C263A24F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44232,"discussion_content":"是的，这一句非常没头没脑..","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572940432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49681,"user_name":"李","can_delete":false,"product_type":"c1","uid":1119312,"ip_address":"","ucode":"5C0FAA211F2E26","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg","comment_is_top":false,"comment_ctime":1544752002,"is_pvip":true,"replies":[{"id":"17891","content":"👍","user_name":"作者回复","comment_id":49681,"uid":"1190123","ip_address":"","utype":1,"ctime":1544753658,"user_name_real":"gg"}],"discussion_count":5,"race_medal":0,"score":"164753509250","product_id":100017301,"comment_content":"百度了下，终于搞明白了，回答自己前面一个问题。<br>关键是要搞明白k值是啥东西。<br>比如求aba  每个前缀最长可匹配前缀子串的结尾字符下标<br>这句话很容易引起歧义。<br>aba的前缀有a,ab,   后缀有ba,a    只有a与a匹配。 所以匹配的结尾下标是0.<br>abab     显然ab和ab可以匹配，所以匹配的结尾下标是1<br>abaaba   下标是2<br>ababa    下标是2<br>aaaa  下标是2<br><br><br><br><br>","like_count":38,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432718,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544753658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1615539,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI6LXcIqb5K48nia8d4zmdsD1M9AZeyXoGrLzX5xvqfN0fqXOsYKUWLbZvZ8TtJCXWmYbCkCXg93dQ/132","nickname":"漏脚脖","note":"","ucode":"214AE52EC201E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4936,"discussion_content":"看你的终于看明白了！！！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565845293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1078191,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKjbB3e9vSSgOageuq1uyVJwNTxQHzXLQiaHlTIDBHXUsQAKODbuYWa1yK2yEfcvUsrbLyrG7dicSmg/132","nickname":"修立","note":"","ucode":"99B31848D358E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292196,"discussion_content":"那句话确实歧义，看你的解释才明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595135290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178283,"avatar":"","nickname":"钟狼","note":"","ucode":"EBDED251153164","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":147576,"discussion_content":"必需点个赞 [like]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579660357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1737805,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/84/4d/84371716.jpg","nickname":"何雷","note":"","ucode":"FA9BCE7DD9C8C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86794,"discussion_content":"也是看你的解释才看懂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576626835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50350,"user_name":"niulixin","can_delete":false,"product_type":"c1","uid":1248873,"ip_address":"","ucode":"E61FB492DADE7B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/69/6c085caf.jpg","comment_is_top":false,"comment_ctime":1544959456,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"151868814816","product_id":100017301,"comment_content":"我觉得bm算法倒是好理解但是kmp的算法的next数组我感觉不太好理解啊","like_count":35,"discussions":[{"author":{"id":1800886,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/7a/b6/f54bbfaa.jpg","nickname":"花郎世纪","note":"","ucode":"301DF9B6375E08","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":172626,"discussion_content":"这两个算法花了我一天时间，唉···","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581781002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2292598,"avatar":"https://static001.geekbang.org/account/avatar/00/22/fb/76/71877cfc.jpg","nickname":"Geek_cec571","note":"","ucode":"19727B27AD904F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1800886,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/7a/b6/f54bbfaa.jpg","nickname":"花郎世纪","note":"","ucode":"301DF9B6375E08","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385427,"discussion_content":"强呀，大佬！一天就看完加实现了；光bm的学习和实现我就花了一天多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627034010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":172626,"ip_address":""},"score":385427,"extra":""}]}]},{"had_liked":false,"id":67860,"user_name":"Flash","can_delete":false,"product_type":"c1","uid":1236163,"ip_address":"","ucode":"E285075C9E0B02","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/c3/e4ba51d5.jpg","comment_is_top":false,"comment_ctime":1550302610,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"100334550418","product_id":100017301,"comment_content":"<br>最难理解的是KMP算法了。<br>总体上，KMP算法是借鉴了BM算法本质思想的，都是遇到坏字符的时候，把模式串往后多滑动几位。<br>1.但是这里要注意一个细节，不然容易被前面学的BM算法给误导，导致难以理解。<br>BM算法是对模式串从后往前比较，每次是将主串的下标 ”i“ 往后移动多位。(这符合我们正常的思维，所以好理解)<br>KMP虽然也是往后移动多位，但是比较时，是对模式串从前往后比较；<br>对于主串已经比较过的部分，保持主串的 ”i“ 指针(即下标)不回溯。<br>而是通过修改模式串的”j“指针，变相地让模式串移动到有效的位置。(这里修改&quot;j&quot;，是让&quot;j&quot;变小了，我们说的还是将模式串往后移动，所以不太好理解)<br><br>2.KMP算法中不好难理解的，构建next数组，其实很简单，要多下自己的脑筋，不要被带偏了，就好理解了。就是求next[i](动态规划的思想，根据前面已经计算好的结果next[0]...next[i-1]来得到next[i])，前一个的最长串的下一个字符与最后一个相等，那next[i]就=next[i-1]+1；否则就需要找前一个的次长串，递归这个过程，直到找到或没有。","like_count":23,"discussions":[{"author":{"id":2962599,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/34/a7/52c4ea60.jpg","nickname":"年少挽滑稽世无双","note":"","ucode":"793DCBDE25A07B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574913,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654435132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49626,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1105431,"ip_address":"","ucode":"B1F8AE3AD82C51","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg","comment_is_top":false,"comment_ctime":1544748038,"is_pvip":false,"replies":[{"id":"17898","content":"我写的时候也绕了好久","user_name":"作者回复","comment_id":49626,"uid":"1190123","ip_address":"","utype":1,"ctime":1544754342,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"100328995846","product_id":100017301,"comment_content":"一个双休，加上好几个早上的时间，这两篇关于字符串匹配，弄明白了，代码我自己也实现了一遍，就论代码实现来说，KMP算法比BM算法要简单一点，这个BM算法，一个双休送给了他，慢慢的一点点理解规则，然后再一点点的，按照自己所理解的思想来实现，虽然觉得这样子慢，但能学到的会更多，要论最难理解的地方，这个ＢＭ的算法的计算next数组，这脑子绕了好久！","like_count":23,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432690,"discussion_content":"我写的时候也绕了好久","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544754342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":48620,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1544498573,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"83148877197","product_id":100017301,"comment_content":"「那 b[r, i-1] 肯定是 b[0, i-1] 的可匹配后缀子串，但并不一定是最长可匹配后缀子串。」后半句不是很理解，如果模式串是 b[0, i-1]，i-1 已经是最后一个字符了，那么为什么 b[r, i-1] 不一定是 b[0, i-1] 的最长可匹配后缀子串呢？<br>","like_count":19,"discussions":[{"author":{"id":1114093,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/ed/b2fc0e7c.jpg","nickname":"7","note":"","ucode":"10A6E57A027D42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261560,"discussion_content":"abab e abab a\n现在最长是aba，把最后一个a去掉，则abab才是最长的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588984051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":70464,"user_name":"饺子","can_delete":false,"product_type":"c1","uid":1251229,"ip_address":"","ucode":"88FEB4B0D68975","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/9d/a3706e4f.jpg","comment_is_top":false,"comment_ctime":1551102577,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"74565546609","product_id":100017301,"comment_content":"😂😂😂讲移动那幅图是不是写错了 j=j-k<br>不应该是j=k嘛","like_count":17,"discussions":[{"author":{"id":1027285,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ac/d5/abb7bfe3.jpg","nickname":"veyron","note":"","ucode":"428803B6A52293","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52335,"discussion_content":"我也觉得写错了\nj=j-k是移动位数。j=k是改变的下标","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574040496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78196,"discussion_content":"应该是 滑动了 j-k ，之后 j = j - ( j-k)  =  k\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575983168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1060126,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2d/1e/c6359873.jpg","nickname":"qx","note":"","ucode":"5681418A3D99CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348589,"discussion_content":"我也觉得是，j应该等于k，k就是下一个主串与模式串对齐的位置","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612659890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045078,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/56/c39046c0.jpg","nickname":"Jie","note":"","ucode":"AB94041E548FEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274371,"discussion_content":"同感","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590576004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1972505,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/19/19/d82e24fb.jpg","nickname":"李润东","note":"","ucode":"65CFEA3C8B27C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262989,"discussion_content":"确实，可能是笔误吧，李姐李姐🤣","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589160653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1295609,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","nickname":"老大不小","note":"","ucode":"35BCDD3CB13467","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1972505,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/19/19/d82e24fb.jpg","nickname":"李润东","note":"","ucode":"65CFEA3C8B27C4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582997,"discussion_content":"不李姐，害我纠结半天，知错不改，恶莫大焉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659866907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":262989,"ip_address":"广东"},"score":582997,"extra":""}]}]},{"had_liked":false,"id":58533,"user_name":"luo","can_delete":false,"product_type":"c1","uid":1148742,"ip_address":"","ucode":"00FBDC12101419","user_header":"https://static001.geekbang.org/account/avatar/00/11/87/46/2850b4a9.jpg","comment_is_top":false,"comment_ctime":1547105571,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48791745827","product_id":100017301,"comment_content":"3遍才理解了差不多，还有一句话之前留言的还是木有理解，BM是去滑动主串，KMP是利用模式串的好前缀规则去跳过模式串（相当于滑动模式串）主串递增的形式。最难理解的就是next数组中的求解，如果b[0,i-1]的最长前缀是k-1 那b[0,k-1]就是最长的前缀 这里开始分两种情况，<br>第一种情况：b[0,k-1]的下一个字符b[k]=b[i],则最长前缀子串就变成b[0,k]，最长后缀就变成b[i-k,i]。next[i]=next[i-1]+1<br>第二种情况：b[0,k-1]的下一个字符b[k]≠b[i]，这时候我们要去寻找的就是b[0,i-1]中的最长前缀子串（最长匹配前后缀子串b[0,y] 和b[i-y-1,i-1]这两本身就是一一匹配的，而next数组记录的只有前缀我们仍然利用现有条件做推断）的最长可匹配前缀子串（必然跟后缀子串一致），就是b[0,i-1]的次长可匹配子串（划重点）（因为b[0,i-1]的最长可匹配子串c因为c这个串接下来一个字符跟b[i]不等，求取c它的最长可匹配子串一直到下个字符b[x+1]与b[i]相等递归求取）。<br>可能我说的跟理解的有点问题，举个例子： abeabfabeabe(主串) abeabfabeabc（模型串） 到e处不能匹配，最长可匹配子串就是 abeab接下来发现f与e不一致然后再求取abeab的最长可匹配子串 ， 为ab接下去的e刚好跟e匹配。","like_count":11},{"had_liked":false,"id":48299,"user_name":"P@tricK","can_delete":false,"product_type":"c1","uid":1233716,"ip_address":"","ucode":"293B2B3261A793","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/34/5dee4f70.jpg","comment_is_top":false,"comment_ctime":1544414049,"is_pvip":false,"replies":[{"id":"17388","content":"👍 人才啊 不过时间复杂度就高了 后缀字串是模式串前缀的后缀子串 并不是模式串的后缀子串","user_name":"作者回复","comment_id":48299,"uid":"1190123","ip_address":"","utype":1,"ctime":1544493775,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"48789054305","product_id":100017301,"comment_content":"最难理解的就是kmp的next数组的这个求法了，思路本身就难，几个边界情况靠自己理清写出来没BUG更是难。<br>自己想到的一个简单点的解法，就是先将所有模式串的前缀子串全列出来，然后用哈希表存储，key是串，value是串长度，求解next数组值的时候将后缀子串从长到短去哈希表里找。","like_count":11,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432113,"discussion_content":"👍 人才啊 不过时间复杂度就高了 后缀字串是模式串前缀的后缀子串 并不是模式串的后缀子串","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544493775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78203,"discussion_content":"老师的意思是，动态的临时去遍历 好前缀的这些后缀子串比较麻烦。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575983510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":48499,"user_name":"不上进的码农","can_delete":false,"product_type":"c1","uid":1248890,"ip_address":"","ucode":"D0594DDDD1C5AE","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/7a/31328704.jpg","comment_is_top":false,"comment_ctime":1544453991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35904192359","product_id":100017301,"comment_content":"厉害厉害，这个算法的精髓是不是就是求next数组啊，还有BM算法中的应该也是求那两个数组。我觉着应该理一理这两种求数组的过程，这求数组的过程是不是也是一个特别好的算法呀！","like_count":8},{"had_liked":false,"id":158876,"user_name":"AlexS","can_delete":false,"product_type":"c1","uid":1472051,"ip_address":"","ucode":"3DA81A613CE645","user_header":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","comment_is_top":false,"comment_ctime":1575468729,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"31640239801","product_id":100017301,"comment_content":"来来来，KMP框架代码都没看懂的同学看这里看这里。<br>i：始终是主串的下标。<br>j：始终是模式串的下标。<br>关键点是，在匹配过程中的任何时候，主串下标为 i 的字符永远和模式串下标为 j 的字符对齐。<br>例如，从初始状态开始，i 一直在增加，而 j 保持为0 （没有任何字符匹配上），那么它的含义就是模式串向后移动了 i 位。同时因为j=0，所以此时模式串首和主串 i 下标对齐。","like_count":7,"discussions":[{"author":{"id":2962599,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/34/a7/52c4ea60.jpg","nickname":"年少挽滑稽世无双","note":"","ucode":"793DCBDE25A07B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574915,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654435431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":197422,"discussion_content":"感谢老哥。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583419803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49273,"user_name":"Stephen","can_delete":false,"product_type":"c1","uid":1208572,"ip_address":"","ucode":"CB08E34AB48D99","user_header":"https://static001.geekbang.org/account/avatar/00/12/70/fc/77f60338.jpg","comment_is_top":false,"comment_ctime":1544659062,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31609430134","product_id":100017301,"comment_content":"看了好几天，终于搞懂了","like_count":7},{"had_liked":false,"id":54405,"user_name":"Kevin","can_delete":false,"product_type":"c1","uid":1221259,"ip_address":"","ucode":"EE227364D6FEFB","user_header":"https://static001.geekbang.org/account/avatar/00/12/a2/8b/c3a78b52.jpg","comment_is_top":false,"comment_ctime":1545845940,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27315649716","product_id":100017301,"comment_content":"时间复杂度那个while增长量是怎么推敲出整体小于m或者n的，有点不大理解","like_count":6},{"had_liked":false,"id":135715,"user_name":"徐亮","can_delete":false,"product_type":"c1","uid":1646323,"ip_address":"","ucode":"1EE4C515C4F319","user_header":"https://static001.geekbang.org/account/avatar/00/19/1e/f3/fe4273fe.jpg","comment_is_top":false,"comment_ctime":1569245628,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"23044082108","product_id":100017301,"comment_content":"这两节课难啃啊","like_count":5,"discussions":[{"author":{"id":1292349,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b8/3d/a3e290b0.jpg","nickname":"Nucky","note":"","ucode":"62783A339C61B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309130,"discussion_content":"我直接放弃了，我目前到白银就知足了，不去星耀和王者了。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601193779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2215110,"avatar":"","nickname":"Geek_e8a328","note":"","ucode":"3E17DFDC505EA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1292349,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b8/3d/a3e290b0.jpg","nickname":"Nucky","note":"","ucode":"62783A339C61B7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328659,"discussion_content":"哈哈哈,我也是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606205788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309130,"ip_address":""},"score":328659,"extra":""},{"author":{"id":1238166,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/96/a5d775e9.jpg","nickname":"牧凉","note":"","ucode":"1F57A16E37C668","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1292349,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b8/3d/a3e290b0.jpg","nickname":"Nucky","note":"","ucode":"62783A339C61B7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382842,"discussion_content":"哈哈哈哈哈，我要死磕到底","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625737724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309130,"ip_address":""},"score":382842,"extra":""}]}]},{"had_liked":false,"id":82476,"user_name":"suke","can_delete":false,"product_type":"c1","uid":1007753,"ip_address":"","ucode":"C0287C31A4F45B","user_header":"","comment_is_top":false,"comment_ctime":1554219758,"is_pvip":false,"replies":[{"id":"29875","content":"求你退订 感激","user_name":"作者回复","comment_id":82476,"uid":"1190123","ip_address":"","utype":1,"ctime":1554249222,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"23029056238","product_id":100017301,"comment_content":"这些对什么最长前缀后缀字符串变量的描述能不能不要加那么多形容词？用一个字符变量不就描述了么，整那么多形容词不把人搞晕才怪，自己百度一下，全明白了，相比之下，你这个描述真的是徒然增加读者的阅读障碍","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445606,"discussion_content":"求你退订 感激","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554249222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2760780,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKghO4kJwQ5ccuBA2Yox1WlZmq0JUICpNAsgYlOHX0wHGv48xVRKSvF9a6Eic5l2UOjFjnvTnsibibiaw/132","nickname":"Geek_94045a","note":"","ucode":"B8F23BA9D1411B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407604,"discussion_content":"作者这个逻辑是比较优化之后的 我以前学过kmp 当时是看网上比较简单一些的思路 但是就是复杂度会变高  很多地方是不好用语言来形容的 你应该看到的是作者绞尽脑汁想出这些叫法来表示数据范围 也是花了不少功夫的  而不是看到啥不顺你心意就反驳 你自己试着描述一下 让别人能看懂  你就知道难度了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635071334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":48327,"user_name":"煦暖","can_delete":false,"product_type":"c1","uid":1245418,"ip_address":"","ucode":"96D0B236C4148A","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/ea/6ad346c1.jpg","comment_is_top":false,"comment_ctime":1544422142,"is_pvip":false,"replies":[{"id":"17387","content":"嗯嗯 多谢指正","user_name":"作者回复","comment_id":48327,"uid":"1190123","ip_address":"","utype":1,"ctime":1544493606,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"23019258622","product_id":100017301,"comment_content":"老师你好，第二幅图的上半部分的模式串前缀子串画错了，应该从a开始，abab，而不是baba。","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432131,"discussion_content":"嗯嗯 多谢指正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544493606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":48225,"user_name":"P@tricK","can_delete":false,"product_type":"c1","uid":1233716,"ip_address":"","ucode":"293B2B3261A793","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/34/5dee4f70.jpg","comment_is_top":false,"comment_ctime":1544404091,"is_pvip":false,"replies":[{"id":"17165","content":"嗯嗯 多谢指正","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544406826,"ip_address":"","comment_id":48225,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23019240571","product_id":100017301,"comment_content":"如果 next[i-1]=k-1，也就是说，子串 b[0, k-1] 是 b[0, i-1] 的最长可匹配前缀子串。如果子串 b[0, k-1] 的下一个字符 b[k]，与 b[0, i-1] 的下一个字符 b[i] 匹配，那子串 b[0, k] 就是 b[0, i] 的最长可匹配前缀子串。所以，next[i-1] 等于 k。<br><br>---------------<br><br>末尾应该是 next[i] 等于 k","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432077,"discussion_content":"嗯嗯 多谢指正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544406826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219184,"user_name":"筑梦","can_delete":false,"product_type":"c1","uid":1108832,"ip_address":"","ucode":"702137FB9EF79B","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/60/17f279cc.jpg","comment_is_top":false,"comment_ctime":1589963007,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18769832191","product_id":100017301,"comment_content":"感觉KMP算法核心是k=next[k]，这部分我在看老师的讲解时，没太理解。而且每次试图去理解的时候，总有越想越乱的感觉。下面是我个人的理解，不知道对不对，仅供参考。<br>本来遍历到i时，最长可匹配前缀子串是string[0，k]，也就是string[0, k]=string[x, i].<br>那现在第i+1和第k+1不等了，就需要从string[x, i]中找到最长可匹配前缀子串，也就是从string[0，k]中找到最长可匹配前缀子串，这不就是next[k]了吗","like_count":4},{"had_liked":false,"id":138208,"user_name":"coldpark","can_delete":false,"product_type":"c1","uid":1058331,"ip_address":"","ucode":"D1B0F343B384F8","user_header":"https://static001.geekbang.org/account/avatar/00/10/26/1b/4caf36bd.jpg","comment_is_top":false,"comment_ctime":1570096988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18749966172","product_id":100017301,"comment_content":"next这个解释的不好，更通俗易懂的说法应该是：该子串中，找到能匹配上的最长的前缀和后缀的配对，并记录该前缀的结尾下标。","like_count":4},{"had_liked":false,"id":48290,"user_name":"NeverMore","can_delete":false,"product_type":"c1","uid":1228498,"ip_address":"","ucode":"582698D772810D","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/d2/3d88cb8e.jpg","comment_is_top":false,"comment_ctime":1544411798,"is_pvip":false,"replies":[{"id":"17389","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544493802,"ip_address":"","comment_id":48290,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14429313686","product_id":100017301,"comment_content":"学习啦，next数组一开始没明白，看了几次终于看懂啦。<br>思考了下字符串匹配，最重点的就是多移动几位，但是又不要移动过多，同时记录历史数据，以空间换时间！","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432107,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544493802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176150,"user_name":"发霉的宅大人","can_delete":false,"product_type":"c1","uid":1738243,"ip_address":"","ucode":"6757E30FE5E48D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/03/95004954.jpg","comment_is_top":false,"comment_ctime":1580973100,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10170907692","product_id":100017301,"comment_content":"总结一下，KMP算法——主串下标不动，模串下标尽可能的少后退<br>先举个例子<br>a b a b a c<br>a b a b a d<br>坏字下标为5 = 4+1，即前缀最长的下标为4，我们求得next[4]，值为2；<br>那么模式串中 下标 0，1，2就是匹配的，我们从下标3（2+1）的字符开始匹配<br>即<br>a b a b a c<br>      a b a b a d<br>第二：如何求得next数组<br>private static int[] getNexts(char[] b, int m) {<br>  int[] next = new int[m];<br>  next[0] = -1;<br>  int k = -1;<br>  for (int i = 1; i &lt; m; ++i) {<br>    while (k != -1 &amp;&amp; b[k + 1] != b[i]) {<br>      k = next[k];<br>    }<br>    if (b[k + 1] == b[i]) {<br>      ++k;<br>    }<br>    next[i] = k;<br>  }<br>  return next;<br>}<br>匹配最长匹配子串的时候，你需要匹配的字符会随着字符串的增长而移动<br>举例<br>a b a<br>需要匹配的是 下标 0 和下标 2<br>a b a b<br>因为 0 和 2 依旧匹配过了，所以我们只需要比较下标1和下标3。<br>最难理解的地方是<br>k=next[k];是回退的意思；<br>a b a b c a<br>k==2,i==5;代码比较b[2+1]==b[5]的时候，k=next[2];<br>k表示的是已经匹配的前缀子串的末尾坐标，此时回退的意思就是回退到上一段已经匹配的字符串中的最长匹配串的最长坐标<br>举例<br>模串a b a b a c d<br>前缀a b a b<br>后缀a b a c <br>此时就后退回了abab的最长匹配，也就是前一个上一个长串。因为按照上一个长串去移动肯定是对的，因为已经匹配过了。","like_count":2},{"had_liked":false,"id":163985,"user_name":"北方有盛筵","can_delete":false,"product_type":"c1","uid":1339712,"ip_address":"","ucode":"CFA8ADA67B30CB","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/40/46e1e8b5.jpg","comment_is_top":false,"comment_ctime":1576839383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10166773975","product_id":100017301,"comment_content":"&#47;&#47; 求解 next 数组的简化版C++代码<br>&#47;&#47; P 代表模式串 pattern，Next 是一个数组指针<br>&#47;&#47; P[i,j] 表示模式串中下标从 i 到 j 的字符形成的子串<br>void getNext(int *Next,string P)<br>{<br>  Next[0] = -1;                        &#47;&#47; 明显恒成立<br>  for (int i = 1; i &lt; P.length(); i++) &#47;&#47; 求解 Next[1]~Next[P.length-1]<br>  {<br>    int k = Next[i - 1];  &#47;&#47; P[0,k] 是 P[0,i-1] 的最长可匹配前缀<br>    if (P[k + 1] == P[i]) &#47;&#47; P[k+1]=P[i]，这种情况下最简单，说明 P[0,i] 的最长可匹配前缀为 P[0,k+1]<br>    {<br>      Next[i] = k + 1;<br>    }<br>    else &#47;&#47; P[k+1]!=P[i]，说明 P[0,i] 的最长可匹配前缀不是 P[0,k+1]，此时寻找 P[0,i-1] 的次长可匹配前缀<br>    {<br>      while (k != -1 &amp;&amp; P[i] != P[k + 1])<br>      {<br>        k = Next[k]; &#47;&#47; 不断寻找 P[0,i-1] 的次长可匹配前缀<br>      }<br>      if (P[i] == P[k + 1])<br>      {<br>        Next[i] = k + 1;<br>      }<br>      else if (k == -1)<br>      {<br>        Next[i] = -1;<br>      }<br>    }<br>  }<br>}","like_count":2},{"had_liked":false,"id":125015,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1566044953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10155979545","product_id":100017301,"comment_content":"我觉得我对失效函数的解释会更好：要找前一个的次长串（因为最长串的下一个字符和当前字符不等等），次长串存在于最长串中，最长串也就是最长前缀b[0,k]，所以就是在b[0,k]中找最长串了，当然就是next[k]了。","like_count":2},{"had_liked":false,"id":124338,"user_name":"the geek","can_delete":false,"product_type":"c1","uid":1506723,"ip_address":"","ucode":"71DECBC814A539","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLz3icr3mGs5ib8FbSPQZ2ic3ib90mHkd1btQrmGacZjJxfYXrerIdaTxglKyCicFzLcEAb6deC2cWjE5Q/132","comment_is_top":false,"comment_ctime":1565862424,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10155797016","product_id":100017301,"comment_content":"我觉得可以分段来理解next方法:<br>1.先知道next[i]的值一定等于next[n]的值+1<br>2. 改成求n的值,只要n的最长可匹配前缀的后一个字符等于模式串当前下标为i的字符时,就找到了n的值<br><br>基本方法，从i-1一直找到0;谁的最长可匹配前缀的后一个字符等于模式串当前下标为i的字符,谁就是n<br>高级方法：理解每个next[0~n]的最长可匹配前缀都是next[n]最长可匹配前缀的子串<br>所以不需要每次递减1的方式从i-1一直遍历到0，而是可以递减next[n]-next[next[n]]<br>","like_count":2,"discussions":[{"author":{"id":1311315,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLW8JDURuH8rWWd4kibR9ibsehbiaERqBJIP20GDJfZjaRlGQQVqw6780NTxrfxBujrzQvBnIcrmfkCg/132","nickname":"gibson1112","note":"","ucode":"51CF21A78A35C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360740,"discussion_content":"通俗易懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616510579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113818,"user_name":"雨幕下的稻田","can_delete":false,"product_type":"c1","uid":1388799,"ip_address":"","ucode":"1FBFF3187AE9C4","user_header":"https://static001.geekbang.org/account/avatar/00/15/30/ff/b3e54147.jpg","comment_is_top":false,"comment_ctime":1563161558,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10153096150","product_id":100017301,"comment_content":"个人理解是<br>针对模式串的每个前缀子串<br>比如x={a,b,c,a,b,d}<br>其前缀子串是<br>a<br>ab<br>abc<br>abca<br>abcab<br>所以next[k]<br>就是<br>a           next[0]=-1 前面没有，所以直接-1<br>ab         next[1]=-1  上一个是{a}，后缀b！=前缀a，还是-1<br>abc       next[2]=-1  上一个是{a, b},没有相等的，所部不需要考虑后缀bc，只考虑c，所以还是-1<br>abca      next[3]=0  同理{a,b,c}是-1，所以只需要考虑后缀a的情况，相等，所以是0<br>abcab    next[4]=1   {a,b,c,a}，存在有相等的后缀，直接取出next[3]来比较后面的字符，得出ab=ab，所以是1<br>所以求next[k]数组是，只有两种情况，<br>1、前一个前缀子串有匹配关系，则当前子串的最后一位与匹配传后的一位直接对比即可，x[next[k-1]+1]=x[k],如果相等，next[k-1]+1就是当前前缀子串的匹配位置<br>2、需要考虑当前子串的最后一位是否与第一个字符相等即可x[k]=x[0]<br>不知道这么理解对不对<br>abcab next[4]=1","like_count":2},{"had_liked":false,"id":99280,"user_name":"Tom","can_delete":false,"product_type":"c1","uid":1074968,"ip_address":"","ucode":"5940DF3B4782DC","user_header":"https://static001.geekbang.org/account/avatar/00/10/67/18/79167fa2.jpg","comment_is_top":false,"comment_ctime":1559185999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10149120591","product_id":100017301,"comment_content":"1. 最难理解的next计算部分， 大概来讲就是模式串自身进行对比， 求出模式串每个前缀的最长前缀结尾下标。<br>2. kmp方法的主串与模式串对比思路其实是一样的。<br><br>这片文章看了好几遍， 在next那部分被绕晕。 最后结合https:&#47;&#47;www.zhihu.com&#47;question&#47;21923021?utm_source=wechat_search&amp;utm_medium=organic这篇文章结合一起终于啃下来了。 <br><br>总结：<br>1. 一定要仔细阅读作者文章描述kmp算法的思路， 不然盲目看的话只是一堆索引在数组中变来变去。 一脸懵逼<br>2. 实在攻不下来的时候， 换个脑子，或者去google一下其他人解答思路。 ","like_count":2},{"had_liked":false,"id":77435,"user_name":"文祥","can_delete":false,"product_type":"c1","uid":1396893,"ip_address":"","ucode":"D38B0CD7926894","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/9d/b1305f4d.jpg","comment_is_top":false,"comment_ctime":1552924057,"is_pvip":false,"replies":[{"id":"28298","content":"不可以呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552958804,"ip_address":"","comment_id":77435,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10142858649","product_id":100017301,"comment_content":"第一个程序里面的 while (j &gt; 0 &amp;&amp; a[i] != b[j]) 可以改成if吧<br>","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443721,"discussion_content":"不可以呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552958804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49938,"user_name":"李","can_delete":false,"product_type":"c1","uid":1119312,"ip_address":"","ucode":"5C0FAA211F2E26","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg","comment_is_top":false,"comment_ctime":1544793574,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10134728166","product_id":100017301,"comment_content":"那 b[r, i-1] 肯定是 b[0, i-1] 的可匹配后缀子串，但并不一定是最长可匹配后缀子串。<br>我研究了一会，这句话有误，建议更正。这里应该说一定就是最长可匹配字符串。<br>假设不是最长的，那b[r-1]就应该有匹配相等的，这显然矛盾","like_count":2},{"had_liked":false,"id":49003,"user_name":"牧民牛仔","can_delete":false,"product_type":"c1","uid":1247561,"ip_address":"","ucode":"1CC29B7129B207","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/49/8bc5e315.jpg","comment_is_top":false,"comment_ctime":1544587208,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10134521800","product_id":100017301,"comment_content":"反复看了好多遍才把整体思路和代码的思路整明白，哎","like_count":2},{"had_liked":false,"id":48372,"user_name":"walor","can_delete":false,"product_type":"c1","uid":1003066,"ip_address":"","ucode":"F349FF0591E598","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/3a/fc019528.jpg","comment_is_top":false,"comment_ctime":1544430227,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10134364819","product_id":100017301,"comment_content":"可是，如何求得 b[0, i-1] 的次长可匹配后缀子串呢？次长可匹配后缀子串肯定被包含在最长可匹配后缀子串中，而最长可匹配后缀子串又对应最长可匹配前缀子串 b[0, y]。于是，查找 b[0, i-1] 的次长可匹配后缀子串，这个问题就变成，查找 b[0, y] 的最长匹配后缀子串的问题了。<br><br>@争哥 怎么就转换为 b[0, y] 的最长匹配后缀子串了？","like_count":2,"discussions":[{"author":{"id":1661456,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epYAmnyHBCVY7YicTF3IXa39mvVTuyum9yicPyFG5amXuo6R2QOTicX0iaXLicH8CTktC7XHruv81ichgkg/132","nickname":"Geek_b25f99","note":"","ucode":"6F7BEAB2C31528","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37980,"discussion_content":"next数组的值是这个前缀的最长可以匹配前缀子串的结尾字符下标。这表述很不容易理解，其实就是子字符串的前缀集合与后缀集合的交集中最长元素的长度。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571708387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1393004,"avatar":"https://static001.geekbang.org/account/avatar/00/15/41/6c/687c5dfb.jpg","nickname":"叶子。","note":"","ucode":"3EF2CC36F0D09A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218415,"discussion_content":"好吧懂了(￣∀￣)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585656545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1393004,"avatar":"https://static001.geekbang.org/account/avatar/00/15/41/6c/687c5dfb.jpg","nickname":"叶子。","note":"","ucode":"3EF2CC36F0D09A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218063,"discussion_content":"俺也没懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585616855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260330,"user_name":"追梦","can_delete":false,"product_type":"c1","uid":1197685,"ip_address":"","ucode":"634A19055525B3","user_header":"https://static001.geekbang.org/account/avatar/00/12/46/75/9f80409f.jpg","comment_is_top":false,"comment_ctime":1604986194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5899953490","product_id":100017301,"comment_content":"终于搞懂了，理解next数组生成过程的关键在于：next数组的下标是前缀的尾字符下标；next数组的元素是最长可匹配前缀的尾字符下标；k+1是当前需要与i进行比较的最长可匹配前缀的尾字符后面字符的下标。","like_count":1},{"had_liked":false,"id":219231,"user_name":"筑梦","can_delete":false,"product_type":"c1","uid":1108832,"ip_address":"","ucode":"702137FB9EF79B","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/60/17f279cc.jpg","comment_is_top":false,"comment_ctime":1589969175,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884936471","product_id":100017301,"comment_content":"我认为KMP算法的时间复杂度可以用老师前面讲过的摊还分析。过程如下：<br>当next[k]=x时，第k个字符和第x个字符一定相等，第k-1和第x-1个一定相等...第k-x和第0个一定相等。<br>反过来，正向遍历的时候，next[k-x]=0, next[k-x+1]=1，..., next[k] = x，那么k-x到k这x+1个字符一定没有进入过while循环，时间复杂度是O(1)。<br>第k+1个字符需要从next[k]=x回退到next[z]=-1，中间的计算次数一定不超过x+2，那么多出来的x+1次计算可以均摊到前面x+1个字符上。<br>均摊之后，每一个字符的平均时间复杂度是O(1)，计算next数组的总时间复杂度就是模式串的字符个数，也就是O(m)<br>不知道上述分析过程对不对，麻烦老师批评指正~","like_count":1},{"had_liked":false,"id":215564,"user_name":"kaiser","can_delete":false,"product_type":"c1","uid":1390375,"ip_address":"","ucode":"F9438786E9A57B","user_header":"https://static001.geekbang.org/account/avatar/00/15/37/27/b023ada7.jpg","comment_is_top":false,"comment_ctime":1589017209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883984505","product_id":100017301,"comment_content":"感觉构建 next 数组，可以直接通过判断模式串的所有前缀子串的末尾字符，最后一次出现在它的前缀子串的前缀子串中的位置就可以了。<br><br>  &#47;**<br>   * 构建失效函数<br>   *<br>   * 描述：b 的所有前缀子串的末尾字符在它的前缀子串的前缀子串中出现的最后一个位置<br>   * @param b 模式串<br>   * @param m 模式串长度<br>   * @return 数组<br>   *&#47;<br>  private static int[] generateNexts2(char[] b, int m) {<br>    int[] next = new int[m];<br>    next[0] = -1;<br>    &#47;&#47; 前缀子串中出现的最长可匹配前缀子串的位置<br><br>    for (int i = 1; i &lt; m; i++) {<br>      int k = -1;<br>      &#47;&#47; 子串的最后一个字符<br>      char last = b[i];<br>      &#47;&#47; 最后一个字符在前缀子串的前缀子串中最后出现得位置<br>      for (int j = i-1; j &gt;=0 ; j--) {<br>        if(last == b[j]){<br>          k = j;<br>          break;<br>        }<br>      }<br>      next[i] = k;<br>    }<br><br>    return next;<br>  }<br>}","like_count":1},{"had_liked":false,"id":195385,"user_name":"不知","can_delete":false,"product_type":"c1","uid":1803488,"ip_address":"","ucode":"A2ECBFE43ACDAB","user_header":"https://static001.geekbang.org/account/avatar/00/1b/84/e0/cdb6de57.jpg","comment_is_top":false,"comment_ctime":1585184679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880151975","product_id":100017301,"comment_content":"部分匹配值”是指字符串前缀和后缀所共有元素的长度。前缀是指除最后一个字符外，一个字符串全部头部组合；后缀是指除第一个字符外，一个字符串全部尾部组合。以”ABCDABD”为例： <br>“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0； <br>“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0； <br>“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0； <br>“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1； <br>“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2； <br>“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。 ","like_count":1},{"had_liked":false,"id":127428,"user_name":"张三说","can_delete":false,"product_type":"c1","uid":1065988,"ip_address":"","ucode":"F1BE933F314D6C","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/04/7904829d.jpg","comment_is_top":false,"comment_ctime":1566706710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5861674006","product_id":100017301,"comment_content":"next数组真的反复看了好多遍，又去看了网上其他的贴子终于明白。。。最后发现置顶留言早就道出了真谛，早知道先看一眼留言","like_count":1},{"had_liked":false,"id":117647,"user_name":"CathyLin","can_delete":false,"product_type":"c1","uid":1240546,"ip_address":"","ucode":"F7CDFF5E1A235F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/e2/0e1c6c5a.jpg","comment_is_top":false,"comment_ctime":1564104961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859072257","product_id":100017301,"comment_content":"😁花了两个早上+晚上，终于啃下来了，开心！<br>我觉得的难点是：<br>1) 一开始没有看明白 next 数组的含义，在想为什么表中的 next[0]=-1 这样的，后来发现我们是要把其中的每个模式串前缀去找它的最长可匹配前缀子串结尾字符下标，所以把它当成一个串把所有的情况写出来就好啦<br><br>2) 在第二部分求失效函数那里，一开始没明白为啥 ”如果我们把最后一个字符去掉，那么 b[r,i-1] 肯定是 b[0,i-1] 的可匹配后缀子串，但不一定是最长可匹配后缀子串。“ 后来看了 @slvher 的例子然后明白啦！<br><br>3) 在求 b[0,i-1] 的次长可匹配后缀子串那里一开始没有看懂文章写的，后来多读了几遍，然后手模了一下样例最终搞明白啦！嘻嘻！（感觉自己在变聪明hhh","like_count":1},{"had_liked":false,"id":61833,"user_name":"return","can_delete":false,"product_type":"c1","uid":1135528,"ip_address":"","ucode":"42B8A3380DF04B","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","comment_is_top":false,"comment_ctime":1547813077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5842780373","product_id":100017301,"comment_content":"感觉不难理解，如果只看图的话真的好理解，文字概念太绕了😂","like_count":1},{"had_liked":false,"id":52854,"user_name":"小情绪","can_delete":false,"product_type":"c1","uid":1020311,"ip_address":"","ucode":"92D8081DB8DB45","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/97/3762ca10.jpg","comment_is_top":false,"comment_ctime":1545542295,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5840509591","product_id":100017301,"comment_content":"王老师，kmp时间复杂度分析有点疑惑，以getNexts为例，虽然说while循环内实际是对k做递减，并且在i的每次循环中，while的总执行次数一定不会超过m，但是也是有执行次数的，并且随着i的不断遍历，while的累积执行总次数是有可能超过m的，为什么直接会被忽略，最终成O（m）了？望解答，不甚感激。","like_count":1,"discussions":[{"author":{"id":1114093,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/ed/b2fc0e7c.jpg","nickname":"7","note":"","ucode":"10A6E57A027D42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261591,"discussion_content":"为什么不超过m，他是在next数组（子串）中倒着找，而next数组被每一次被遍历的次数不会超过m，不知道这是不是你疑惑的地方，他有那么多次循环，为什么就不会超过m；\n我开始也是这样想的，但你仔细想一下，当需要进入while循环的时候，每次i都是固定，next的遍历到-1或者找到了与b[i]相等的就会停下，而-1就代表了没有可匹配的前缀子串，加入找到了可匹配的，此时next在回溯的时候遍历了k次，此时next当前位置存下的值又减小了（为前面那个结尾字符串下标的值，比如2），下一次发生不匹配的时候又会倒着遍历，假如能遍历到这里，这时候读取的值是2，会去读取next[2]的值，如果没有找到，那么当前这里就会变为-1，如果找到，那么假设-1之后变为0，所以总的来说不会超过m次是对的；不知道我这样说你了解没有\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588985564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52427,"user_name":"程序员大天地","can_delete":false,"product_type":"c1","uid":1249001,"ip_address":"","ucode":"7A21F15FEE2D5B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg","comment_is_top":false,"comment_ctime":1545380304,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5840347600","product_id":100017301,"comment_content":"看懂了，是比较复杂啊！求next数组比较难！","like_count":1},{"had_liked":false,"id":51168,"user_name":"Pan^yu","can_delete":false,"product_type":"c1","uid":1235771,"ip_address":"","ucode":"28F983B58A9EC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/3b/e56ff0a9.jpg","comment_is_top":false,"comment_ctime":1545124408,"is_pvip":false,"replies":[{"id":"18554","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545184924,"ip_address":"","comment_id":51168,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5840091704","product_id":100017301,"comment_content":"看了三遍总算看懂了，靠@ZX的留言，然后回去在梳理才看懂","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433321,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545184924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49276,"user_name":"narcos","can_delete":false,"product_type":"c1","uid":1244286,"ip_address":"","ucode":"725A8944BAA993","user_header":"https://static001.geekbang.org/account/avatar/00/12/fc/7e/0cc5a187.jpg","comment_is_top":false,"comment_ctime":1544659629,"is_pvip":false,"replies":[{"id":"17726","content":"前面交代了 i是坏字符 j是坏字符对应模式串字符的下标","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544665953,"ip_address":"","comment_id":49276,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5839626925","product_id":100017301,"comment_content":"&quot;我们只需要拿好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的。假设最长的可匹配的那部分前缀子串是{v}，长度是 k。我们把模式串一次性往后滑动 j-k 位，相当于，每次遇到坏字符的时候，我们就把 j 更新为 k，i 不变，然后继续比较。&quot;<br>老师，这里的 j 和 i 分别是什么，没有交代","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432555,"discussion_content":"前面交代了 i是坏字符 j是坏字符对应模式串字符的下标","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544665953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":48779,"user_name":"景页","can_delete":false,"product_type":"c1","uid":1188798,"ip_address":"","ucode":"DC9C2AD52A9E4A","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/be/9a083ea1.jpg","comment_is_top":false,"comment_ctime":1544535435,"is_pvip":false,"replies":[{"id":"17739","content":"嗯嗯 跟文字描述有点不一样","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544667095,"ip_address":"","comment_id":48779,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5839502731","product_id":100017301,"comment_content":"getNexts函数的while循环两行代码很妙，还没理解，虽然文字部分看懂了。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432346,"discussion_content":"嗯嗯 跟文字描述有点不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544667095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":48649,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1544506443,"is_pvip":true,"replies":[{"id":"17741","content":"可以的 更高级 更难懂 就没写","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544667307,"ip_address":"","comment_id":48649,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5839473739","product_id":100017301,"comment_content":"上一节课计算suffix数组与prefix数组也可以使用动态规划么？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432293,"discussion_content":"可以的 更高级 更难懂 就没写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544667307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":48343,"user_name":"Tenderness","can_delete":false,"product_type":"c1","uid":1124304,"ip_address":"","ucode":"840A6104972502","user_header":"https://static001.geekbang.org/account/avatar/00/11/27/d0/7e18e9a2.jpg","comment_is_top":false,"comment_ctime":1544425102,"is_pvip":false,"replies":[{"id":"17386","content":"都一样的 我也是 你让我默写 我也写不出来 ","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544493581,"ip_address":"","comment_id":48343,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5839392398","product_id":100017301,"comment_content":"分开看是差不多看懂了，看了这篇后，貌似前面的代码实现也ok了。估计明天又不会写了，😂","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432139,"discussion_content":"都一样的 我也是 你让我默写 我也写不出来 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544493581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":48282,"user_name":"煦暖","can_delete":false,"product_type":"c1","uid":1245418,"ip_address":"","ucode":"96D0B236C4148A","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/ea/6ad346c1.jpg","comment_is_top":false,"comment_ctime":1544410741,"is_pvip":false,"replies":[{"id":"17393","content":"应该是j-k 你找个例子看看<br>","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544494184,"ip_address":"","comment_id":48282,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5839378037","product_id":100017301,"comment_content":"老师你好，文中“假设最长的可匹配的那部分前缀子串是{v}，长度是 k。我们把模式串一次性往后滑动 j-k位...”这个地方结合下面图看，应该是往后移动j-k+1位吧？？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432102,"discussion_content":"应该是j-k 你找个例子看看\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544494184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359236,"user_name":"111","can_delete":false,"product_type":"c1","uid":3109487,"ip_address":"北京","ucode":"D6E8E83A118A3E","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/6f/44c10658.jpg","comment_is_top":false,"comment_ctime":1665367711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665367711","product_id":100017301,"comment_content":"next数组的建立比较难理解，个人认为不要过多看文字，去看代码，着重注意next数组的含义。<br>在最长前缀的下一位不等于b[i]时，（这里复习一下next数组特点，指向最长相等前缀的下标。所以next[next[i]]指向的内容也是可以作为前缀的),取next[next[i]]下一位来进行比较，依次递归直到符合条件或者下标指向-1.<br>","like_count":0},{"had_liked":false,"id":345248,"user_name":"ERex_Wu","can_delete":false,"product_type":"c1","uid":1039353,"ip_address":"","ucode":"80CD85C77BD33E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/f9/36f332a1.jpg","comment_is_top":false,"comment_ctime":1652156215,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652156215","product_id":100017301,"comment_content":"关于部分匹配表 http:&#47;&#47;jakeboxer.com&#47;blog&#47;2009&#47;12&#47;13&#47;the-knuth-morris-pratt-algorithm-in-my-own-words&#47; 这个说的是人话","like_count":0},{"had_liked":false,"id":338061,"user_name":"Today","can_delete":false,"product_type":"c1","uid":1235000,"ip_address":"","ucode":"4FA397F0BD8C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/38/41027bda.jpg","comment_is_top":false,"comment_ctime":1647261763,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647261763","product_id":100017301,"comment_content":"BF 算法感觉更符合我的思维惯性， 每次倒着比较，移动主串的指针，难点是 “好后缀” 的预处理（核心是找末尾字符的匹配位置）<br>KMP 算法思维绕了一圈，每次顺着比较，移动模式串的指针， 难点是 “好前缀” 的预处理 （核心是找首位字符的匹配位置）<br>还是要结合画图继续多练习下，不然手写不出来","like_count":0},{"had_liked":false,"id":329359,"user_name":"文进","can_delete":false,"product_type":"c1","uid":2257439,"ip_address":"","ucode":"CD1B6196EBC448","user_header":"https://static001.geekbang.org/account/avatar/00/22/72/1f/9ddfeff7.jpg","comment_is_top":false,"comment_ctime":1641300472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641300472","product_id":100017301,"comment_content":"最难的地方k=next[k]。<br>首先，如果k为-1表示之前就没有相同的，直接比较当前就行。<br>如果k不为-1，那就是比较第k+1，即下一个值是否和i相同。<br>如果都不满足，则表示已经有相同的k+1（长度为下标k再+1)个字符，但是现在第i又不相同。这时，继续比较k+1、k-1已经没有意义，只能重新开始算。但是已知前k+1个元素和最后k+1个元素是相同的，所以可以看看前k+1个字符是否在next中已经有值，如果有值next[k]，则表示存在次子串，必然这个next中的次子串的后缀与a中已经匹配完的～i-1相同，则尝试直接比较之前已经匹配到的位数b[next[k]]的下一位，是否与a[i]相同。","like_count":0},{"had_liked":false,"id":326952,"user_name":"谢志新","can_delete":false,"product_type":"c1","uid":2804240,"ip_address":"","ucode":"823F29398BB8F7","user_header":"https://static001.geekbang.org/account/avatar/00/2a/ca/10/ecd75c38.jpg","comment_is_top":false,"comment_ctime":1639795699,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639795699","product_id":100017301,"comment_content":"public static int[] getNexts(char[] b, int m) {<br>        int[] next = new int[m];<br>        next[0] = -1;<br>        int k = -1;<br>        for (int i = 1; i &lt; m; i++) {<br>            &#47;&#47; 这段<br>            &#47;&#47; 前提是 b[k] 为b[i - 1]的最长可匹配前缀子串，如果b[k+1] == b[i] 则 b[k + 1] 为b[i]的最长可匹配前缀，<br>            &#47;&#47; 如果不是 则需要求 b[k]的最长可匹配前缀子串，再与b[i]进行处理，直至得到 b[k+1] == b[i] 或者 k == -1为止<br>            while (k != -1 &amp;&amp; b[k + 1] != b[i]) {<br>                k = next[k];<br>            }<br>            &#47;&#47; 同样经过上面得到的k值 进行判断，如果b[k + 1] == b[i] 则 b[i]的最长可匹配前缀即为b[k+1]，<br>            &#47;&#47; 因为这是在b[i - 1]的最长可匹配前缀为b[k]的基础上计算而来的<br>            if (b[k + 1] == b[i]) {<br>                ++k;<br>            }<br>            next[i] = k;<br>        }<br>        return next;<br>    }<br><br>这个是对于失效函数的理解，得到next","like_count":0},{"had_liked":false,"id":323960,"user_name":"阿仁","can_delete":false,"product_type":"c1","uid":1101024,"ip_address":"","ucode":"972237E993F738","user_header":"https://static001.geekbang.org/account/avatar/00/10/cc/e0/5d85f93c.jpg","comment_is_top":false,"comment_ctime":1638241003,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638241003","product_id":100017301,"comment_content":"BM和KMP连着一起看的，看完人快没了。","like_count":0},{"had_liked":false,"id":321663,"user_name":"爱只只","can_delete":false,"product_type":"c1","uid":2660914,"ip_address":"","ucode":"E115F4D6F14D08","user_header":"https://static001.geekbang.org/account/avatar/00/28/9a/32/692859f2.jpg","comment_is_top":false,"comment_ctime":1636983020,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636983020","product_id":100017301,"comment_content":"我蒙了，不行我要去看看书了。","like_count":0},{"had_liked":false,"id":311658,"user_name":"EveryDayIsNew","can_delete":false,"product_type":"c1","uid":1316926,"ip_address":"","ucode":"776B81EF6830FA","user_header":"https://static001.geekbang.org/account/avatar/00/14/18/3e/f8632713.jpg","comment_is_top":false,"comment_ctime":1631369171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631369171","product_id":100017301,"comment_content":"烧脑，慢慢理解","like_count":0},{"had_liked":false,"id":311347,"user_name":"库博","can_delete":false,"product_type":"c1","uid":1221604,"ip_address":"","ucode":"0D5DD558C9EB25","user_header":"https://static001.geekbang.org/account/avatar/00/12/a3/e4/50266292.jpg","comment_is_top":false,"comment_ctime":1631181545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631181545","product_id":100017301,"comment_content":"就一个判断，应该理解起来简单一点<br>def getNextList(pattern):<br>    length = len(pattern)<br>    next = [-1] * length<br>    i = 1<br>    while i &lt; length:<br>        if pattern[next[i - 1] + 1] == pattern[i]:<br>            next[i] = next[i - 1] + 1<br>        else:<br>            next[i] = next[next[i - 1]]<br>        i += 1<br>    return next","like_count":0},{"had_liked":false,"id":308216,"user_name":"Vvin","can_delete":false,"product_type":"c1","uid":1459341,"ip_address":"","ucode":"664901060BDA33","user_header":"","comment_is_top":false,"comment_ctime":1629454299,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629454299","product_id":100017301,"comment_content":"第三张图有问题吧，j=k, 而不是j=j-k ","like_count":0},{"had_liked":false,"id":306480,"user_name":"ppyh","can_delete":false,"product_type":"c1","uid":1351148,"ip_address":"","ucode":"14022ADEC9B53F","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/ec/235b74c0.jpg","comment_is_top":false,"comment_ctime":1628579470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628579470","product_id":100017301,"comment_content":"这思想用文字来描述确实不太好表述","like_count":0},{"had_liked":false,"id":306479,"user_name":"ppyh","can_delete":false,"product_type":"c1","uid":1351148,"ip_address":"","ucode":"14022ADEC9B53F","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/ec/235b74c0.jpg","comment_is_top":false,"comment_ctime":1628579375,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628579375","product_id":100017301,"comment_content":"next[k]明白了，其实次长串的意思就是求最长串的最长串","like_count":0},{"had_liked":false,"id":306408,"user_name":"ppyh","can_delete":false,"product_type":"c1","uid":1351148,"ip_address":"","ucode":"14022ADEC9B53F","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/ec/235b74c0.jpg","comment_is_top":false,"comment_ctime":1628533616,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628533616","product_id":100017301,"comment_content":"我凎👿👿","like_count":0},{"had_liked":false,"id":303420,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1626780611,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1626780611","product_id":100017301,"comment_content":"“数组的下标是每个前缀结尾字符下标，数组的值是这个前缀的最长可以匹配前缀子串的结尾字符下标。这句话有点拗口，我举了一个例子，你一看应该就懂了。”看到这里卡住了死活看不懂这个图，最后网上搜了一篇文章http:&#47;&#47;www.ruanyifeng.com&#47;blog&#47;2013&#47;05&#47;Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html。算是搞明白了，就是选出前缀，然后这个前缀的字符串再进行前后缀的对比出最长的公共部分，然后记录公共部分的最后一个字符下标位置，比如：aba，前缀：a，ab 后缀：a,ba 。那么公共部分a，那么a的下标是0.","like_count":0,"discussions":[{"author":{"id":1545647,"avatar":"https://static001.geekbang.org/account/avatar/00/17/95/af/b7f8dc43.jpg","nickname":"拓山","note":"","ucode":"11FE9CF3821898","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401522,"discussion_content":"太赞了，这篇文章更好理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633686940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291898,"user_name":"张广旭","can_delete":false,"product_type":"c1","uid":1742887,"ip_address":"","ucode":"ABF0066FE148EF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep1J5W23Gsdufo7l3c6F6NmJaaqxRMxeZb3IQXJEHHHDbOYuVwicSW8nicNYNN18oSTzVjW2ia1P8pIg/132","comment_is_top":false,"comment_ctime":1620576660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620576660","product_id":100017301,"comment_content":"花了两天时间才搞懂KMP。","like_count":0},{"had_liked":false,"id":290181,"user_name":"韩楚楚","can_delete":false,"product_type":"c1","uid":1983444,"ip_address":"","ucode":"0579BB8B66CEBA","user_header":"https://static001.geekbang.org/account/avatar/00/1e/43/d4/06314c00.jpg","comment_is_top":false,"comment_ctime":1619420816,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619420816","product_id":100017301,"comment_content":"结合 https:&#47;&#47;www.zhihu.com&#47;question&#47;21923021&#47;answer&#47;281346746 更容易理解","like_count":0},{"had_liked":false,"id":281896,"user_name":"海无语","can_delete":false,"product_type":"c1","uid":1308200,"ip_address":"","ucode":"0BCBDC09283C0F","user_header":"https://static001.geekbang.org/account/avatar/00/13/f6/28/96e030aa.jpg","comment_is_top":false,"comment_ctime":1614938072,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1614938072","product_id":100017301,"comment_content":"阮老师写的简单易懂，推荐一下：http:&#47;&#47;www.ruanyifeng.com&#47;blog&#47;2013&#47;05&#47;Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html","like_count":0,"discussions":[{"author":{"id":1545647,"avatar":"https://static001.geekbang.org/account/avatar/00/17/95/af/b7f8dc43.jpg","nickname":"拓山","note":"","ucode":"11FE9CF3821898","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401523,"discussion_content":"赞，果然更清晰容易","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633686956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280906,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1614477124,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1614477124","product_id":100017301,"comment_content":"茶艺师学学编程<br><br>思考题<br>最难的地方莫过于那些“前缀”“后缀”，知道老师已经把他所知道都说了，但我就是没能理解。","like_count":0},{"had_liked":false,"id":279204,"user_name":"Geek_676ef6","can_delete":false,"product_type":"c1","uid":1237182,"ip_address":"","ucode":"4DF557B0818E21","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/be/09173bc8.jpg","comment_is_top":false,"comment_ctime":1613656637,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1613656637","product_id":100017301,"comment_content":"next代码写得妙啊，语言难以描述东西，代码非常清晰","like_count":0},{"had_liked":false,"id":278429,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1612940125,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612940125","product_id":100017301,"comment_content":"后半部分求next数组的确是难点，代码很简单，但是如果想不明白其中的原理，那个代码根本想不出来在干啥，为啥这么写。https:&#47;&#47;www.bilibili.com&#47;video&#47;BV1iJ411a7Kb?p=5可以看看这个视频，可以只看最后一个视频，就明白了。","like_count":0},{"had_liked":false,"id":276213,"user_name":"吃鱼","can_delete":false,"product_type":"c1","uid":1812912,"ip_address":"","ucode":"848835584F6099","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/b0/0c701ef3.jpg","comment_is_top":false,"comment_ctime":1611834775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611834775","product_id":100017301,"comment_content":"老师，对于对于最后一个图我看了半天没能理解，<br>我能举出例子跟您都对不上<br>例如a b a a b 最长可匹配前缀后缀都是ab<br>那么按照图上的分隔方法 a|b|  a  |a|b 那么次长可匹配前缀为a ,次长可匹配后缀为b。<br>但是这明显对不上啊，我实在是想不出思路哪里出了问题，希望老师能解答一下","like_count":0},{"had_liked":false,"id":266341,"user_name":"UrgentSimpleSlow","can_delete":false,"product_type":"c1","uid":1520407,"ip_address":"","ucode":"7E3A0631B4C436","user_header":"https://static001.geekbang.org/account/avatar/00/17/33/17/7a43716f.jpg","comment_is_top":false,"comment_ctime":1607307517,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607307517","product_id":100017301,"comment_content":"看完后结合评论和这篇文章思路瞬间打开 https:&#47;&#47;blog.csdn.net&#47;buppt&#47;article&#47;details&#47;78531384","like_count":0},{"had_liked":false,"id":258872,"user_name":"邓海涛","can_delete":false,"product_type":"c1","uid":2188321,"ip_address":"","ucode":"A3504EA1E7A9C4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL8nR7kBpJIFTNkyYfpz5zOr8bVWlfywfT3xRswUDgrDraicNj7TBJoC2fFAUibk7vx8fsPnUfuKmwA/132","comment_is_top":false,"comment_ctime":1604571412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604571412","product_id":100017301,"comment_content":"请问下老师，你这个图是自己在纸上画的，还是用电脑软件画的。如果是软件，请问下是什么软件呢，谢谢了。","like_count":0},{"had_liked":false,"id":258535,"user_name":"奔越","can_delete":false,"product_type":"c1","uid":2280010,"ip_address":"","ucode":"448EBFCEA3C2A8","user_header":"https://static001.geekbang.org/account/avatar/00/22/ca/4a/baae6a93.jpg","comment_is_top":false,"comment_ctime":1604476130,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604476130","product_id":100017301,"comment_content":"假如已经求出next[0] next[1]...next[k-1]，令a=next[k-1]，此时模式串中，A[0].....A[a]  和A[N-a-1].....A[N-1]之间可以画等号。。。","like_count":0},{"had_liked":false,"id":257885,"user_name":"冬风向左吹","can_delete":false,"product_type":"c1","uid":1066928,"ip_address":"","ucode":"376C45C5134F93","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/b0/a9b77a1e.jpg","comment_is_top":false,"comment_ctime":1604193068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604193068","product_id":100017301,"comment_content":"B站上有个视频讲解比较清楚：https:&#47;&#47;www.bilibili.com&#47;video&#47;BV1jb411V78H?from=search&amp;seid=789489790236522154","like_count":0},{"had_liked":false,"id":256131,"user_name":"Geek_636e46","can_delete":false,"product_type":"c1","uid":2164554,"ip_address":"","ucode":"E27F2B037B4C41","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLc8iay7SThjDaND4WNn4jlK2L7fyPaFibzxUyS6UiaypQsMibIjhxONeChTuTHZEdjXk0CHEgRRjJKbA/132","comment_is_top":false,"comment_ctime":1603534112,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603534112","product_id":100017301,"comment_content":"这篇文章对 next数组 定义为“以 j位 结尾的字串中 最长可匹配前缀的 下标”，感觉有点绕<br>有的文章（如https:&#47;&#47;blog.csdn.net&#47;v_JULY_v&#47;article&#47;details&#47;7041827）对 next 的定义是“j 之前的字符串中 最长可匹配前缀||后缀 的最长匹配 长度”，这也意味着更新时直接有 j=next[j]，而不是 j = next[j-1] +1<br>虽然两者的思想都是一致的，我觉得后者更好理解，也更能体现 next数组 的含义为“在某个字符不匹配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置”。","like_count":0},{"had_liked":false,"id":254270,"user_name":"youyou.L","can_delete":false,"product_type":"c1","uid":1796438,"ip_address":"","ucode":"B3DB0D0700EEAC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/zlWt0lPDicdib5BTUbuwA3wLLUuejtZ5icGu3DHMBPd6PicXOdhZ3zYFts8VkXjjyQuxzUJas2w5OTmx3icWKiaZM1Vg/132","comment_is_top":false,"comment_ctime":1603094535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603094535","product_id":100017301,"comment_content":"kmp算法其实很简单，就是描述起来很难说清楚，如果有动态图展示估计好很多","like_count":0},{"had_liked":false,"id":252821,"user_name":"海狮","can_delete":false,"product_type":"c1","uid":2037714,"ip_address":"","ucode":"18FDDF5841F282","user_header":"https://static001.geekbang.org/account/avatar/00/1f/17/d2/68cdbd75.jpg","comment_is_top":false,"comment_ctime":1602494264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602494264","product_id":100017301,"comment_content":"1、次长子串是模版串的一个前缀子串<br>2、最长子串也是模版串的一个前缀子串<br>3、次长子串是最长子串的一个部分<br>得出：次长子串也是最长子串的一个前缀子串。。。<br><br>刚好可以借助之前填充的next数组找到（最长子串之前也作为好前缀候选，放到next数组里过）<br><br>因此 k = next[k]","like_count":0},{"had_liked":false,"id":252325,"user_name":"Mr.Z","can_delete":false,"product_type":"c1","uid":1691496,"ip_address":"","ucode":"DCBAB7628A8992","user_header":"https://static001.geekbang.org/account/avatar/00/19/cf/68/eb862eb5.jpg","comment_is_top":false,"comment_ctime":1602236527,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602236527","product_id":100017301,"comment_content":"想了很久为什么代码写成<br>k = next[k]<br>后来发现自己忽略了一个问题，之前一直在想，当前一个的最长串的下一个字符和当前i指向的字符不同的时候，前后都要回撤，相当于已配对的框左右缩小。但是，左右两个框实际上是相等的，也就是说，不需要一点一点地缩小，直接根据以求的next就可以得到其中一个框中的最长串。再判断最长串的下一位是不是等于i指向的字符即可。非常绕，想了好久……","like_count":0},{"had_liked":false,"id":243660,"user_name":"Lin","can_delete":false,"product_type":"c1","uid":1694787,"ip_address":"","ucode":"41C78E2D9FAB1E","user_header":"https://static001.geekbang.org/account/avatar/00/19/dc/43/544785e3.jpg","comment_is_top":false,"comment_ctime":1598242465,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598242465","product_id":100017301,"comment_content":"可否加上动态规划的解释next数组呢","like_count":0},{"had_liked":false,"id":237540,"user_name":"ɴɪᴋᴇʀ","can_delete":false,"product_type":"c1","uid":1616622,"ip_address":"","ucode":"DB7D92CBB5FD15","user_header":"https://static001.geekbang.org/account/avatar/00/18/aa/ee/15c328ca.jpg","comment_is_top":false,"comment_ctime":1595858388,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595858388","product_id":100017301,"comment_content":"没有理解的同学，我觉得可以借助双指针，把模式串的每个前缀子串想象成一个衔尾蛇，或是两个相同的前缀子串一个在前，一个在后缓慢相交，如果重合的部分完全相等，取最大相等的长度-1就是next[k]的值。","like_count":0},{"had_liked":false,"id":231835,"user_name":"豆豆","can_delete":false,"product_type":"c1","uid":1275407,"ip_address":"","ucode":"97788B134C3212","user_header":"https://static001.geekbang.org/account/avatar/00/13/76/0f/c7c8021d.jpg","comment_is_top":false,"comment_ctime":1593782861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593782861","product_id":100017301,"comment_content":"kmp算法，先看程序员小灰，就比较容易懂了","like_count":0},{"had_liked":false,"id":231250,"user_name":"Smile @ Life","can_delete":false,"product_type":"c1","uid":1293907,"ip_address":"","ucode":"320EDAD5A8BE56","user_header":"https://static001.geekbang.org/account/avatar/00/13/be/53/eda4b622.jpg","comment_is_top":false,"comment_ctime":1593614537,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593614537","product_id":100017301,"comment_content":"请问模式字符串的最后一个字符参与next数组计算吗","like_count":0},{"had_liked":false,"id":225788,"user_name":"lxiongchang","can_delete":false,"product_type":"c1","uid":1603858,"ip_address":"","ucode":"94F322CF8C996E","user_header":"https://static001.geekbang.org/account/avatar/00/18/79/12/ac2af040.jpg","comment_is_top":false,"comment_ctime":1591857799,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591857799","product_id":100017301,"comment_content":"看到 k = next[k]; 深深感到这算法之美。","like_count":0},{"had_liked":false,"id":224115,"user_name":"Sudouble","can_delete":false,"product_type":"c1","uid":1365574,"ip_address":"","ucode":"B369B09DAF8D20","user_header":"https://static001.geekbang.org/account/avatar/00/14/d6/46/5eb5261b.jpg","comment_is_top":false,"comment_ctime":1591277683,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1591277683","product_id":100017301,"comment_content":"主要的还是对于假设的验证，即存在一个最小移动量，使失配的部分再一次匹配。其他计算next数组都是技巧在于技巧性。<br>啃了论文关于KMP的介绍，看了作者提出这个问题的来龙去脉，写了篇博客：https:&#47;&#47;blog.csdn.net&#47;VVBBBBB&#47;article&#47;details&#47;105032799","like_count":0},{"had_liked":false,"id":223934,"user_name":"www","can_delete":false,"product_type":"c1","uid":1898338,"ip_address":"","ucode":"ADC9BC655EA16C","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f7/62/947004d0.jpg","comment_is_top":false,"comment_ctime":1591235413,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591235413","product_id":100017301,"comment_content":"B站上有个视频讲解形象些，有需要的可以看看 https:&#47;&#47;www.bilibili.com&#47;video&#47;BV1jb411V78H?from=search&amp;seid=5262116903755933028","like_count":0},{"had_liked":false,"id":221897,"user_name":"cool","can_delete":false,"product_type":"c1","uid":1383620,"ip_address":"","ucode":"254220D6E2DAE8","user_header":"https://static001.geekbang.org/account/avatar/00/15/1c/c4/3e593863.jpg","comment_is_top":false,"comment_ctime":1590629943,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590629943","product_id":100017301,"comment_content":"看作者的f分析说明文字没看懂，看代码看懂了，分析说明写的太绕了，句子太长了。","like_count":0},{"had_liked":false,"id":221485,"user_name":"宁悦","can_delete":false,"product_type":"c1","uid":1901403,"ip_address":"","ucode":"68844C314FEEF8","user_header":"https://static001.geekbang.org/account/avatar/00/1d/03/5b/3cdbc9fa.jpg","comment_is_top":false,"comment_ctime":1590506988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590506988","product_id":100017301,"comment_content":"看了一个晚上，加上评论的链接，和文中的图片，才大致的能看懂next数组到底是怎么工作的，真不容易。","like_count":0},{"had_liked":false,"id":219417,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1590024094,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1590024094","product_id":100017301,"comment_content":"有了昨天的经历，对早就有所耳闻的 KMP 算法也有了心理准备，作者讲的还是听清楚的，虽然“好前缀的后缀子串”和“模式串的前缀子串”有点绕，“最长可匹配后缀子串”和“最长可匹配前缀子串”令人发指，不过，在大量配图的帮助下，总算能够大概明白意思。<br><br>同样卡在了代码实现的部分，特别是求 next 数组的 getNexts 部分。<br><br>再次去求助 algsr，结果这次得到了一个可怕的结果：<br><br>public KMP(String pat) {<br>    this.R = 256;<br>    this.m = pat.length();<br><br>    &#47;&#47; build DFA from pattern<br>    dfa = new int[R][m];<br>    dfa[pat.charAt(0)][0] = 1;<br>    for (int x= 0, j = 1; j &lt; m; j++) {<br>        for (int c = 0; c &lt; R; c++) {<br>            &#47;&#47; Copy mismatch cases.<br>            dfa[c][j] = dfa[c][x];<br>        }<br>        &#47;&#47; Set match case.<br>        dfa[pat.charAt(j)][j] = j + 1;<br>        x = dfa[pat.charAt(j)][x];<br>    }<br>}<br><br>它居然用了一个二维数组，思路和之前的 BM 算法有点像。<br><br>这个只有等我下次有空的时候再想办法搞明白了。<br><br>可什么时候有空呢？","like_count":0},{"had_liked":false,"id":217157,"user_name":"Geek_ac7784","can_delete":false,"product_type":"c1","uid":1981613,"ip_address":"","ucode":"62F0E5E6D6F4BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","comment_is_top":false,"comment_ctime":1589428061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589428061","product_id":100017301,"comment_content":"学习笔记:<br>bm 算法 km 算法采用了相同的思路来优化。<br><br>1. bf朴素匹配算法好理解<br><br>2. rk算法加入了哈希表，比较模式串和主串所有子字符串的哈希值就可以了。缺点是哈希冲突和遍历每个子字符串以求得子字符串哈希值的消耗。这两个问题通过设计哈希函数来解决，但是结果是不能适用所有的字符集。<br><br>3. BM算法 采用两种规则，坏字符和好后缀规则。两种准则都是好理解不好实现型的<br><br>   坏字符：为实现快速在m中查找坏字符，需要建立坏字符哈希表<br><br>   好后缀：两种情况<br><br>   <br><br>          1. m中间能找到好后缀  suffix列表<br>          2. m中找不到但是前缀，但是后缀与前缀部分能匹配。prefix列表  <br><br>4. kmp算法  类似好前缀和坏字符来理解。同样不好实现，尤其是预处理得到next数组不好实现。<br><br>   主串一直向前遍历，通过坏字符位置(坏字符前面是好前缀)，在next数组中查询m下一个该匹配的位置。所以有个next数组。<br><br>应用与复杂度分析:<br>BM算法最高效，用于文本编辑器中的字符串查询替换算法。时间复杂度为小于O(3n)空间复杂度跟字符集大小和m的长度有关。如果对空间要求苛刻，可以只使用好后缀规则<br>kmp算法最出名：时间复杂度为O(n+m)。空间复杂度O(m) 用于next数组","like_count":0},{"had_liked":false,"id":216613,"user_name":"        ","can_delete":false,"product_type":"c1","uid":1255918,"ip_address":"","ucode":"21028A49D81B06","user_header":"https://static001.geekbang.org/account/avatar/00/13/29/ee/fba11edf.jpg","comment_is_top":false,"comment_ctime":1589295891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589295891","product_id":100017301,"comment_content":"关键在于理解 b[0, i-1]的次长可匹配后缀子串（简称【次长后串】）正好是 b[0, y]的最长可匹配后缀子串(简称【最长后串】)，其中y = next[i-1]， 其实就是文章文章最后一张图。<br>这里有两个点需要思考，一个是 &quot;可匹配后串&quot;，一个是&quot;最长&quot;。<br>&quot;可匹配&quot;这点，从图上就可以看出来。<br>&quot;最长&quot;这点，是因为次长后串 仅次于 最长后串，如果b[0, y]中有更长， 在b[0, i-1]里就不是次长","like_count":0},{"had_liked":false,"id":216001,"user_name":"李润东","can_delete":false,"product_type":"c1","uid":1972505,"ip_address":"","ucode":"65CFEA3C8B27C4","user_header":"https://static001.geekbang.org/account/avatar/00/1e/19/19/d82e24fb.jpg","comment_is_top":false,"comment_ctime":1589165707,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589165707","product_id":100017301,"comment_content":"&gt; 可以考察完所有的 b[0, i-1]的可匹配后缀子串 b[y, i-1]<br>这里，如果和图中保持一致的话，y 应该表示一个可匹配前缀子串最后一个字符的下标，即b[0, y]，那么它对应的后缀子串就应该是 b[i-1-y, i-1]吧？","like_count":0},{"had_liked":false,"id":215179,"user_name":"默默","can_delete":false,"product_type":"c1","uid":1006635,"ip_address":"","ucode":"AF798B9D327F24","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/2b/8b771383.jpg","comment_is_top":false,"comment_ctime":1588922689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588922689","product_id":100017301,"comment_content":"跟着老师看懂算法已经没有问题了。最难的是，各种优化点的考虑。怎么样能让模式串匹配的过程中，多跳过字符，省去不比较的比较。为了多跳过一些字符，而设计的好前缀、好后缀等概念。以及计算这些概念时，构造辅助变量，提前构造这些变量等优化手段。","like_count":0},{"had_liked":false,"id":214855,"user_name":"201201177","can_delete":false,"product_type":"c1","uid":1901015,"ip_address":"","ucode":"8E2C0DB7A4D3D4","user_header":"","comment_is_top":false,"comment_ctime":1588833517,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588833517","product_id":100017301,"comment_content":"算法框架的主循环的终止条件可以优化下，当 n - i &lt; m - j 的时候就可以结束循环返回了。","like_count":0},{"had_liked":false,"id":212587,"user_name":"Typing...","can_delete":false,"product_type":"c1","uid":1903641,"ip_address":"","ucode":"5F8E60E5D55E3A","user_header":"https://static001.geekbang.org/account/avatar/00/1d/0c/19/01f075fe.jpg","comment_is_top":false,"comment_ctime":1588156905,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588156905","product_id":100017301,"comment_content":"数组的值是这个前缀的最长可以匹配前缀子串的结尾字符下标<br>数组的值是这个前缀的前缀子串中最长能与该前缀的后缀子串匹配的结尾下标","like_count":0},{"had_liked":false,"id":207683,"user_name":"天","can_delete":false,"product_type":"c1","uid":1310629,"ip_address":"","ucode":"664E42100DE272","user_header":"https://static001.geekbang.org/account/avatar/00/13/ff/a5/02953912.jpg","comment_is_top":false,"comment_ctime":1587136319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587136319","product_id":100017301,"comment_content":"就是论证k=next[k]的时候，采取的是一种逻辑上的收缩，如果存在，必然是会找到这样一个次长串，感觉很像是做了一道数学题，但是证明过程里只能口述，难以纯粹用数学公式来推导。","like_count":0},{"had_liked":false,"id":207164,"user_name":"陈君豪","can_delete":false,"product_type":"c1","uid":1759924,"ip_address":"","ucode":"1685F79A69DEA3","user_header":"https://static001.geekbang.org/account/avatar/00/1a/da/b4/880f2fac.jpg","comment_is_top":false,"comment_ctime":1587019260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587019260","product_id":100017301,"comment_content":"举一个例子吧            e.g.（abaaba）+b<br>i-1为abaaba，第i个字符为b；<br>显然，对于i-1，aba是最长可匹配前缀，此时加入一个b，b不匹配aba前缀的下一个字符a（abaa中的第四个），此时，我们考虑次长可匹配前缀，显然，次长可匹配前缀为a，下标为0，对比新加入的b与a之后的字符b，发现两者相同，得到新字符串abaabab的最长可匹配前缀子串ab；如果发现新加入的字符与a之后的字符不等，则继续找次次长~直到没有","like_count":0},{"had_liked":false,"id":205476,"user_name":"isaac","can_delete":false,"product_type":"c1","uid":1151854,"ip_address":"","ucode":"62ACA5B9A44D1D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/THkFNC52F0kYs2XI1fwxOvCck0Pibwnia4z6fzCPMRg2qYQLlt57qW4caJZ6uj9lWROc7t1OHFmIdKmiaEIP2GXpg/132","comment_is_top":false,"comment_ctime":1586626413,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586626413","product_id":100017301,"comment_content":"「我们假设 b[0, i] 的最长可匹配后缀子串是 b[r, i]。如果我们把最后一个字符去掉，那 b[r, i-1] 肯定是 b[0, i-1] 的可匹配后缀子串，但不一定是最长可匹配后缀子串。」<br><br><br>这段其实逆过来看比较好，如果[0,i]有最长匹配子串，且长度&gt;1，那么[0,i-1]肯定也有匹配子串。注意，这个子串不一定是[0,i-1]的最长匹配子串，所以[0,i]的最长匹配子串可以通过[0,i-1]的匹配子串来找","like_count":0},{"had_liked":false,"id":201138,"user_name":"Simple life","can_delete":false,"product_type":"c1","uid":1571460,"ip_address":"","ucode":"1902D7F72FB43F","user_header":"https://static001.geekbang.org/account/avatar/00/17/fa/84/f01d203a.jpg","comment_is_top":false,"comment_ctime":1585722361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585722361","product_id":100017301,"comment_content":"看能看懂，但是就觉得这代码很巧妙","like_count":0},{"had_liked":false,"id":199300,"user_name":"Wisdom","can_delete":false,"product_type":"c1","uid":1098980,"ip_address":"","ucode":"0787F954B66E93","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/e4/81ee2d8f.jpg","comment_is_top":false,"comment_ctime":1585486111,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585486111","product_id":100017301,"comment_content":"又学习了一遍，发现这几个匹配算法还是有点难，next很难理解","like_count":0},{"had_liked":false,"id":191497,"user_name":"獨自去遠方","can_delete":false,"product_type":"c1","uid":1503941,"ip_address":"","ucode":"E246B33F397441","user_header":"https://static001.geekbang.org/account/avatar/00/16/f2/c5/2a441c27.jpg","comment_is_top":false,"comment_ctime":1584777850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584777850","product_id":100017301,"comment_content":"字符串匹配基础（3）<br>\tKMP算法<br>\t\t核心思想和BM算法相近，找到一些规则，将模式串向后多滑动几位<br>\t\t试图寻找一种规律：<br>\t\t\t在模式串和主串匹配的过程中，当遇到坏字符后，对于已经比对过的好前缀，能否找到一种规律，将模式串一次性滑动很多位？<br><br><br>\t\t从前往后比较：<br>\t\t\t基本概念：坏字符\t好前缀<br><br>\t失效函数计算方法:next数组<br>\t\thttps:&#47;&#47;www.bilibili.com&#47;video&#47;av76521950?p=2<br><br>\tKMP算法复杂度分析<br>\t\t1.额外的next数组<br>\t\t\t空间复杂度O(m)<br>\t\t2.空间复杂度:O(m+n)<br>\t\t\t构建next数组：O(m)<br>\t\t\t借助next数组匹配:O(n)<br><br>\t总结<br>\t\t步骤：<br>\t\t\t1.计算next数组<br>\t\t\t2.主串和模式串对照，遇到坏字符，坏字符的next数组值对应的模式串位置，滑动到主串发生坏字符的位置<br>\t\t\t3.重复第二步，主串和模式串完全匹配，或者模式串长度大于主串剩余长度","like_count":0},{"had_liked":false,"id":186854,"user_name":"LeeTanko","can_delete":false,"product_type":"c1","uid":1276574,"ip_address":"","ucode":"5F1886BC74B814","user_header":"https://static001.geekbang.org/account/avatar/00/13/7a/9e/e5fa04b9.jpg","comment_is_top":false,"comment_ctime":1583938934,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583938934","product_id":100017301,"comment_content":"”按照这个思路，我们可以考察完所有的 b[0, i-1]的可匹配后缀子串 b[y, i-1]，直到找到一个可匹配的后缀子串，它对应的前缀子串的下一个字符等于 b[i]，那这个 b[y, i]就是 b[0, i]的最长可匹配后缀子串。“<br><br>请问老师，此处的y是不是应该写作i-1-y，即b[i-1-y,i-1]与b[i-1-y,i]?","like_count":0},{"had_liked":false,"id":185711,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1583668723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583668723","product_id":100017301,"comment_content":"k = next[k]<br>第一次这里的k为b[0, i-1]的最长可匹配前缀子串下标，next[k]的值就是b[0, k]的最长可匹配前缀子串下标，也就是b[0, i-1]的次长可匹配前缀子串下标。<br>后面反复循环，直到找到，或者完全没有。","like_count":0},{"had_liked":false,"id":184657,"user_name":"追风者","can_delete":false,"product_type":"c1","uid":1055092,"ip_address":"","ucode":"879BC372A6B605","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjUDIRQ0gRiciax3Wo78c5rVjuWDiaw4ibcCiby8xiaMXJh5ibjU5242vfCGOK4ehibe1IKyxex2A4IX4XSA/132","comment_is_top":false,"comment_ctime":1583378311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583378311","product_id":100017301,"comment_content":"推荐B站一个非常通俗易懂的讲解KMP视频，https:&#47;&#47;www.bilibili.com&#47;video&#47;av81151415#reply2470426880","like_count":0},{"had_liked":false,"id":184183,"user_name":"马建伟","can_delete":false,"product_type":"c1","uid":1745775,"ip_address":"","ucode":"EC4F32B8E3A2D2","user_header":"https://static001.geekbang.org/account/avatar/00/1a/a3/6f/250520f2.jpg","comment_is_top":false,"comment_ctime":1583244126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583244126","product_id":100017301,"comment_content":"“可是，如何求得 b[0, i-1]的次长可匹配后缀子串呢？次长可匹配后缀子串肯定被包含在最长可匹配后缀子串中，而最长可匹配后缀子串又对应最长可匹配前缀子串 b[0, y]。于是，查找 b[0, i-1]的次长可匹配后缀子串，这个问题就变成，查找 b[0, y]的最长匹配后缀子串的问题了。”","like_count":0},{"had_liked":false,"id":183952,"user_name":"科科","can_delete":false,"product_type":"c1","uid":1647304,"ip_address":"","ucode":"7DAE6FE781172E","user_header":"https://static001.geekbang.org/account/avatar/00/19/22/c8/f2892022.jpg","comment_is_top":false,"comment_ctime":1583167543,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1583167543","product_id":100017301,"comment_content":"总算是看懂KMP里面求解next数组的方法了。<br>１．当好前缀候选的长度为k的时候，首先看k-1长度前缀的next值，如果存在匹配前缀，就判断前缀的后一位和当前的K位是否一样，如果一样next等于k , over<br>2. 如果前面的判断出现不相等的情况，我们可以试试k-1长度前缀子串的次长前缀。<br>３. 如何找到次长前缀？<br>可以观察到的是，最长子串肯定包含次长子串，求出次长子串的方法是找到k-1最长前缀子串的最长前缀子串。<br>由于我们在next里面得到了k-1好前缀候选的最长子串的位置，所以问题化为在[0 , next[k-1]]里面寻找最长前缀子串，其实就是next[next[k-1]] (迭代)","like_count":0},{"had_liked":false,"id":180930,"user_name":"hill","can_delete":false,"product_type":"c1","uid":1159287,"ip_address":"","ucode":"86BF2F4CD440F9","user_header":"https://static001.geekbang.org/account/avatar/00/11/b0/77/cb933f6c.jpg","comment_is_top":false,"comment_ctime":1582445651,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582445651","product_id":100017301,"comment_content":"k = next(k)的关键在于：下一个字符不等，就找前缀的前子串和后缀的后子串的最长匹配，因为前缀和后缀一样，所以就是找前缀的最长匹配next(k)，下一个字符不等就依次迭代，直到下个字符相等<br><br>这个算法让我深刻体会到智商的重要性。所以学算法不只是掌握算法本身，更重要的是思维和智商的磨练","like_count":0},{"had_liked":false,"id":174864,"user_name":"抱小星","can_delete":false,"product_type":"c1","uid":1504652,"ip_address":"","ucode":"BA7B0DAFDA4AF5","user_header":"https://static001.geekbang.org/account/avatar/00/16/f5/8c/82fb5890.jpg","comment_is_top":false,"comment_ctime":1580441834,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1580441834","product_id":100017301,"comment_content":"一个晚上终于把kmp学懂了，里面有一些错误，就是画图时j=j-k这里应该是j=k。<br>再就是次长子串可能不好理解，应该说成是&quot;下一组最长匹配子串&quot;比较符合算法的意思。","like_count":0},{"had_liked":false,"id":174600,"user_name":"🐒王子 ♡桃桃。","can_delete":false,"product_type":"c1","uid":1350615,"ip_address":"","ucode":"1FD9BCD3459DC4","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/d7/3e4eb062.jpg","comment_is_top":false,"comment_ctime":1580291164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580291164","product_id":100017301,"comment_content":"确实好难理解","like_count":0},{"had_liked":false,"id":172084,"user_name":"曙光","can_delete":false,"product_type":"c1","uid":1476450,"ip_address":"","ucode":"04D65BF7F19845","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/62/f99b5b05.jpg","comment_is_top":false,"comment_ctime":1579084607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579084607","product_id":100017301,"comment_content":"1 长句（如“b[0, i-1] 最长可匹配后缀子串对应的模式串的前缀子串的下一个字符并不等于 b[i]”）前几次看，会懵圈，但多看几次，慢慢理解还是可以消化的<br>2 要多理解，多写几个字符串abdababdabdx，abababac去套老师的公式，有助于理解<br>3 while (k != -1 &amp;&amp; b[k + 1] != b[i]) { k = next[k]; } 需要理解b[k+1]是什么，k= next[k]是什么；<br>b[k + 1] 是最大前缀子串结尾字符，b[i]是最大后缀子串结尾字符，next[k]是次长前缀子串的结尾字符。<br>4  慢慢消化，我看了两天才理解代码。如果老师手把手，配合字符串例子，我应该理解更快。","like_count":0},{"had_liked":false,"id":171703,"user_name":"楊_宵夜","can_delete":false,"product_type":"c1","uid":1019302,"ip_address":"","ucode":"7BA0CADC5F23BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/a6/22c37c91.jpg","comment_is_top":false,"comment_ctime":1578993602,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578993602","product_id":100017301,"comment_content":"不算是掌握, 但总算找到入口了..... <br>为什么 k = next[k] ?<br>就看倒数第一幅图, 因为<br>最长可匹配前缀 == 最长可匹配后缀<br>次长可匹配前缀 == 最长可匹配后缀[的前缀]<br>又<br>次长可匹配前缀 == 次长可匹配后缀<br><br>所以, 如果存在次长可匹配后缀的情况下, 则最长可匹配后缀中, 必定包含 [次长可匹配前缀与次长可匹配后缀]<br>所以, 这最终就扯到递归的坑上去了...<br>脑子已爆炸<br>","like_count":0},{"had_liked":false,"id":170861,"user_name":"敲键盘的人","can_delete":false,"product_type":"c1","uid":1232210,"ip_address":"","ucode":"59AFFFE9DA5B4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/cd/52/a2478536.jpg","comment_is_top":false,"comment_ctime":1578742297,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578742297","product_id":100017301,"comment_content":"前缀、后缀、模式串主串我已经迷糊了","like_count":0},{"had_liked":false,"id":170450,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1578616841,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1578616841","product_id":100017301,"comment_content":"1，KMP算法的核心思想，与BM算法非常相近。假设注册是a，模式串是b。再模式串与主串匹配的过程中，当遇到不可匹配的字符的时候，找到一些规律，将模式串往后多滑动几位，跳过肯定不会匹配的情况。<br>2，当遇到坏字符的时候，我们就要把模式串往后滑动，在滑动的过程中，只要模式串和好前缀有上下重合，前面几个字符的比较，就相当于拿好前缀的后缀子串，跟模式串的前缀子串在比较。<br> <br>3，KMP算法就是试图寻找一种规律：在模式串和主串匹配的过程中，当遇到坏字符后，对于已经对过的好前缀，将模式串一次性滑动很多位？<br>4，我们只需要拿好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的。假设最长的可匹配的那部分前缀子串是{v}，长度是k。我们把模式串一次性往后滑动j-k位，相当于，每次遇到坏字符的时候，我们就把j更新为k，i不变，然后继续比较。<br><br>5，KMP算法也可以提前构建一个数组，用来存储模式串中每个前缀（这些前缀都有可能是好前缀）的最长可匹配子串的结尾字符下标。将这个数组定义为next数组，很多书中将这个数组起名为失效函数（failure function）。<br>6，数组的下标是每个前缀结尾字符下标，数组的值是这个前缀的最长可以匹配的前缀子串的结尾字符下标。<br> <br>7，失效函数计算方法<br>\t\t①：按照下标从小到大，依次计算next数组的值。当我们要计算next[i]时，前面的next[0]，next[1]，……，next[i-1]应该已经计算出来了。利用已经计算出来的next值，可以快速推导出next[i]的值。<br>\t\t②：如果next[i-1] = k-1，即子串b[0,k-1]是b[0,i-1]的最长可匹配前缀子串。如果子串b[0,k-1]的下一个字符b[k]，与b[0,i-1]的下一个字符b[i]匹配，那子串b[0,k]就是b[0,i]的最长可匹配前缀子串。所以，next[i]等于k。但是，如果b[0,k-1]的下一个字符b[k]跟b[0,i-1]的下一个字符不相等，则需要进一步处理。<br> <br>\t\t③：假设b[0,i]的最长可匹配后缀子串是b[r，i]。如果把最后一个字符去掉，那b[r,i-1]肯定是b[0,i-1]的可匹配后缀子串，但不一定是最长可匹配后缀子串。所以，既然b[0,i-1]最长可匹配后缀子串对应的模式串的前缀子串的下一个字符并不等于b[i]，那么我们就可以考察b[0，i-1]的次长可匹配后缀子串b[x,i-1]对应的可匹配前缀子串b[0，i-1-x]的下一个字符b[i-x]是否等于b[i]。如果等于，那[x，i]就是b[0，i]的最长可匹配后缀子串。<br> <br>\t\t④：求b[0，i-1]的次长可匹配后缀子串，次长可匹配后缀子串肯定被包含在最长可匹配后缀子串中，而最长可匹配后缀子串又对应最长可匹配前缀子串b[0,y]。于是，查找b[0，i-1]的次长可匹配后缀子串，这个问题就变成，查找b[0,y]的最长匹配后缀子串的问题。<br>\t\t⑤：按照这个思路，可以考察完所有的b[0,i-1]的可匹配后缀子串b[y,i-1]，直到找到一个可匹配的后缀子串，他对应的前缀子串的下一个字符等于b[i]，那这个b[y，i]就是b[0,i]<br>的最长可匹配后缀子串。<br>\t\t<br>8KMP算法复杂度分析<br>\tKMP算法包含两部分，第一部分是构建next数组，第二部分是借助next数组匹配。所以时间复杂度分析要分别从这两部分来分析。<br>\t<br>\t关于第一部分的时间复杂度：<br>\t计算next数组得代码中，第一层for循环中i从1到m-1，即内部的代码被执行了m-1次，for循环内部代码有一个while循环，如果我们能知道每次for循环，while循环平均执行的次数，假设是k，那时间复杂度就是O(k*m)。但是，while循环执行的次数不好统计，所以放弃这种方式。<br><br>\t可以找一些参照变量，i和k。i从1开始一直增加到m，而k并不是每次for循环都会增加，所以，k累积增加的值肯定小于m。而while循环里k=next[k]。实际上是在减小k的值，k累积都没有增加超过m，所以while循环里面k=next[k]总的执行次数也不可能超过m。因此next数组计算的时间复杂度是O(m)。<br>\t<br>\t关于第二部分的时间复杂度<br>\tI从0循环增长到n-1,j的增量不可能超过i，所以肯定小于n。而while循环中的那条语句j=next[j-1]+1，不会让j增长的。因为next[j-1]的值肯定小于j-1，所以while循环中的这条语句实际上也是让j的值减少。而j总共增长的量都会超过n，那减少的量也不可能超过n，所以while循环中的这条语句总的执行次数也不会超过n，所以这部分的时间复杂度是O(n)。<br>\t<br>\t所以综合两部分的时间复杂度，KMP算法的时间复杂度就是O(m+n)。<br>","like_count":0},{"had_liked":false,"id":170076,"user_name":"草裡菌","can_delete":false,"product_type":"c1","uid":1241514,"ip_address":"","ucode":"E11C630ABA4370","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/aa/c29def94.jpg","comment_is_top":false,"comment_ctime":1578508831,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1578508831","product_id":100017301,"comment_content":"最难想明白得就是：k=next[k]; 这一句。<br>换一种思路去理解，处理到ababac时，求nexts[5]实际上就是：<br>主串=abac，模式串=abab，他们在最后一位失配了，自然要使用nexts[2]，后移2-0=2位，继续匹配。<br>最终匹配失败 ，返回-1。<br>","like_count":0,"discussions":[{"author":{"id":1241514,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f1/aa/c29def94.jpg","nickname":"草裡菌","note":"","ucode":"E11C630ABA4370","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":126448,"discussion_content":"不太准确，但是有点那意思。\n主串和模式串写反了。\n主串abab，模式串abac。\n第一次失配后，主串变ab，模式串变ac。\n最终匹配失败，返回-1。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578509552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170074,"user_name":"小夏","can_delete":false,"product_type":"c1","uid":1110755,"ip_address":"","ucode":"D87444ADC28C6A","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/e3/c1a88a64.jpg","comment_is_top":false,"comment_ctime":1578503342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578503342","product_id":100017301,"comment_content":"老师我这里在构建模式串的最长前缀后缀的地方有一点不懂。<br>我的理解，构建next数组分为两步<br>1.寻找最长前缀后缀，通过这个作为依据来滑动模式串<br>2.滑动模式串，滑动的依据就是最长前缀后缀。先对齐最长前缀后缀的小串，然后标记新串在旧串的相对偏移量，匹配到最后一个冲突串为止，如若冲突，小串跳过此冲突字符继续向后对齐，进而进一步标记<br><br>我有一点不明白的是，最长前缀后缀字符串是否是需要前缀和后缀重合才算。这个点还是不太懂。","like_count":0},{"had_liked":false,"id":169763,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1578444032,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1578444032","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":169260,"user_name":"zzh","can_delete":false,"product_type":"c1","uid":1174510,"ip_address":"","ucode":"0FC6BD729E5801","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJmcPTvjtSbhBNic4wb61Pj77nIHcLG64MnAXicsHBrMWvjCQPoiaHTtYmbnlVSkSWZEnN2QlicekqLhg/132","comment_is_top":false,"comment_ctime":1578302183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578302183","product_id":100017301,"comment_content":"看了三天，终于凑合勉强看懂一遍了","like_count":0},{"had_liked":false,"id":167765,"user_name":"SteveYang","can_delete":false,"product_type":"c1","uid":1754829,"ip_address":"","ucode":"C42BCA4F40A9EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCbnOvEatUN4ysE2cl6zJNoAJVXXuQVhicQ1jxh6Z2Towrmmc1I6PndaicuQQ0RyyJPyJQicv4tSib9Q/132","comment_is_top":false,"comment_ctime":1577930571,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577930571","product_id":100017301,"comment_content":"字符串匹配算法最难理解的是：BM 算法中的 bc、suffix、prefix 数组，KMP 算法中的next数组。","like_count":0},{"had_liked":false,"id":167090,"user_name":"奔跑的小孩","can_delete":false,"product_type":"c1","uid":1304259,"ip_address":"","ucode":"0053193F7A9870","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/21uTMWr7bx5qMibp2hwmGvLbYuj5Aic2dqD3futlNo25eDGDt4t7zzN9cdnj7cVGwTot1U4AyADfWUpqjq1SicgWQ/132","comment_is_top":false,"comment_ctime":1577689251,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577689251","product_id":100017301,"comment_content":"模式匹配算法：通过一个字符串模式串A 去寻找其在字符串B中的字符串位置，在匹配过程中，会出现A已经匹配到第五个字符串了，然后匹配不下去，需要重头来，很麻烦，如果在模式串中做一次筛选，每个字符对应他失败了跳转到前面字符的位置（连续字符的位置），这样就可以直接跳转，不需要重头匹配，例如：ababc(A)  ababdababcd(B)  当a走到b的第五个位置时，失败，如果a再从B的第二 三.......位置开始就很麻烦，我们用模式匹配算法，算出 A中第四个位置对应的是b且b对应的模式匹配算法的值为1表示在A中的第二个位置元素，这样就直接跳转到这来继续进行匹配，提高效率 ","like_count":0},{"had_liked":false,"id":164960,"user_name":"book尾汁","can_delete":false,"product_type":"c1","uid":1446375,"ip_address":"","ucode":"AE2B8DFC643ACC","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg","comment_is_top":false,"comment_ctime":1577116691,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577116691","product_id":100017301,"comment_content":"第五天<br> KMP算法：KMP算法与KM算法有点类似，都是当遇到不匹配的字符即坏字符的时候，筛去肯定不会匹配的那些情况，提高滑动效率。<br> 不同点，KMP算法是通过好前缀来进行判断滑动的，类似的思路，当模式串中没有与好前缀完全匹配的子串时，找出最长前缀子串与最长后缀子串相等时前缀子串的下标。在KM算法中我们找出最长前缀子串是通过一个一个字符的比较，效率比较低，KMP算法采用了更高效的方式来找出最长前缀子串。<br> 模式串的不同长度的好前缀的最长前缀子串与主串无关，因此我们可以事先通过预处理找出各长度的好前缀对应的最长子串末尾元素下标，并将其存在数组里<br> 假设我们已知[0,i-1]好前缀的最长后缀子串为[r,i-1],那么如果好前缀[0,i]的第i个字符与好前缀的最长子串的下一个字符相等，那么好前缀[0,i]的最长后缀子串为[r,i],如果不相等，我们就要比较好前缀[0,i-1]的次长前缀子串的下一个字符与下标为i的字符是否相等，直到找到一个相等的前缀子串，假如其对应的后缀子串下标为k，那么[0,i-1]好前缀对应的最长后缀子串为[k,i]，如果找不到的话，【0，i-1】的最长子串下标记为-1。<br> 这里比较难理解的就是【0，i-1】如果最长前缀子串的下一个字符与i处的字符不相等时，为什么之前的最长子串不是【0,i】的最长子串，这是因为我们比较的是前缀子串与后缀子串的是否相等，假如第i个字符与[0,i-1]的最长子串的下一个字符不相等，我们下一布是应该比较最长子串与[r+1,i]是否相等，最长后缀子串的首坐标依次增加，最长前缀子串的尾标依次减小，理解了这其他就好理解了。","like_count":0},{"had_liked":false,"id":162616,"user_name":"boss_pi","can_delete":false,"product_type":"c1","uid":1713744,"ip_address":"","ucode":"5EED6D9BA7F061","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/htzC3ImxibzOia06PkhxmHib8aXnFXqOSjbHiaveNkh26EtFDFxlAoXzyBdibDtGIIlmZhqumnAAaSGYGTPopY0kZicw/132","comment_is_top":false,"comment_ctime":1576566627,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576566627","product_id":100017301,"comment_content":"时间复杂度为O(m+n)不对吧，n应该是恒大于m，就应该是O(n)啊","like_count":0},{"had_liked":false,"id":156799,"user_name":"常文龙","can_delete":false,"product_type":"c1","uid":1204525,"ip_address":"","ucode":"4A126159D24766","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/2d/5ca0a3da.jpg","comment_is_top":false,"comment_ctime":1574959569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574959569","product_id":100017301,"comment_content":"BM算法和KMP算法整整花了两个小时才看明白","like_count":0},{"had_liked":false,"id":155308,"user_name":"Mew151","can_delete":false,"product_type":"c1","uid":1002201,"ip_address":"","ucode":"D4793F5874F345","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/d9/75dd7cf9.jpg","comment_is_top":false,"comment_ctime":1574676939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574676939","product_id":100017301,"comment_content":"========================================<br>假设最长的可匹配的那部分前缀子串是{v}，长度是 k。<br>========================================<br><br><br>========================================<br>如果 next[i-1]=k-1，也就是说，子串 b[0, k-1] 是 b[0, i-1] 的最长可匹配前缀子串。如果子串 b[0, k-1] 的下一个字符 b[k]，与 b[0, i-1] 的下一个字符 b[i] 匹配，那子串 b[0, k] 就是 b[0, i] 的最长可匹配前缀子串。所以，next[i] 等于 k。但是，如果 b[0, k-1] 的下一字符 b[k] 跟 b[0, i-1] 的下一个字符 b[i] 不相等呢？这个时候就不能简单地通过 next[i-1] 得到 next[i] 了。这个时候该怎么办呢？<br>========================================<br><br>想问一下，以上两段文字中k不是同一个含义吧？第2段文字中的k指的是最长可匹配前缀子串的最后一个字符的下标吧？","like_count":0},{"had_liked":false,"id":152143,"user_name":"杨涛,..","can_delete":false,"product_type":"c1","uid":1592128,"ip_address":"","ucode":"D6DA068C067F39","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/40/9c8b9027.jpg","comment_is_top":false,"comment_ctime":1573890933,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573890933","product_id":100017301,"comment_content":"原文中：<br>可是，如何求得 b[0, i-1] 的次长可匹配后缀子串呢？次长可匹配后缀子串肯定被包含在最长可匹配后缀子串中，而最长可匹配后缀子串又对应最长可匹配前缀子串 b[0, y]。于是，查找 b[0, i-1] 的次长可匹配后缀子串，这个问题就变成，查找 b[0, y] 的最长匹配后缀子串的问题了。<br>这里为什么 b[0, i-1] 的次长可匹配后缀子串 等于  b[0, y] 的最长匹配后缀子串？ 看了好久才理解。<br>","like_count":0},{"had_liked":false,"id":150407,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1573529258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573529258","product_id":100017301,"comment_content":"最难理解的就是next函数, 不过整体思路是明白了","like_count":0},{"had_liked":false,"id":148701,"user_name":"ack","can_delete":false,"product_type":"c1","uid":1440912,"ip_address":"","ucode":"69CA1233EEA8E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/fc/90/c9df0459.jpg","comment_is_top":false,"comment_ctime":1573051361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573051361","product_id":100017301,"comment_content":"看了几遍，感觉终于懂了。个人对于next数组求解的整理，不足之处望指正：<br>https:&#47;&#47;www.jianshu.com&#47;p&#47;35aa47eea2d8","like_count":0},{"had_liked":false,"id":146636,"user_name":"过千帆","can_delete":false,"product_type":"c1","uid":1183100,"ip_address":"","ucode":"D12DB39C7E8B66","user_header":"https://static001.geekbang.org/account/avatar/00/12/0d/7c/6f96fca0.jpg","comment_is_top":false,"comment_ctime":1572590458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572590458","product_id":100017301,"comment_content":"while (j &gt; 0 &amp;&amp; a[i] != b[j]) { &#47;&#47; 一直找到a[i]和b[j]      j = next[j - 1] + 1;    }<br>这里第一次传入的j==1，那么next[-1]这个索引的未知不太对吧？","like_count":0},{"had_liked":false,"id":146624,"user_name":"Knuth","can_delete":false,"product_type":"c1","uid":1083616,"ip_address":"","ucode":"21298EF9BBB91A","user_header":"https://static001.geekbang.org/account/avatar/00/10/88/e0/292508a4.jpg","comment_is_top":false,"comment_ctime":1572586506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572586506","product_id":100017301,"comment_content":"next那里算错了啊","like_count":0},{"had_liked":false,"id":144223,"user_name":"teddytyy","can_delete":false,"product_type":"c1","uid":1268738,"ip_address":"","ucode":"E1569D81A4154E","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/02/e7af1750.jpg","comment_is_top":false,"comment_ctime":1571880478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571880478","product_id":100017301,"comment_content":"\ri的最长子串的最长子串=i的次长子串？","like_count":0},{"had_liked":false,"id":142516,"user_name":"刘楠","can_delete":false,"product_type":"c1","uid":1120773,"ip_address":"","ucode":"9F19D44CBEE039","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/05/f154d134.jpg","comment_is_top":false,"comment_ctime":1571385101,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571385101","product_id":100017301,"comment_content":"next 看，k是不是匹配元素的个数，next中每个元素，都是对应下标与之前的元素比较后匹配的个数","like_count":0},{"had_liked":false,"id":137961,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1569939214,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569939214","product_id":100017301,"comment_content":"变量贼多，小糊涂神了！","like_count":0},{"had_liked":false,"id":136004,"user_name":"junjun","can_delete":false,"product_type":"c1","uid":1547322,"ip_address":"","ucode":"1F7EE146B9BE04","user_header":"https://static001.geekbang.org/account/avatar/00/17/9c/3a/bfd73920.jpg","comment_is_top":false,"comment_ctime":1569325941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569325941","product_id":100017301,"comment_content":"其实就是一个迭代的过程，，当模式串中最长可匹配前缀子串的下一位字符和主串中的下一位不相等的时候，迭代查找模式串中次长的可匹配前缀子串的下一位和主串中的下一位字符进行比较，如果还不相等，继续迭代，","like_count":0},{"had_liked":false,"id":135430,"user_name":"方晓斌","can_delete":false,"product_type":"c1","uid":1042367,"ip_address":"","ucode":"A26FA55F05FE9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/bf/b6dd86f4.jpg","comment_is_top":false,"comment_ctime":1569159565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569159565","product_id":100017301,"comment_content":"KMP框架代码里for循环i的跳出条件可以优化为i&lt;n-m+1吗","like_count":0},{"had_liked":false,"id":134661,"user_name":"feihui","can_delete":false,"product_type":"c1","uid":1007294,"ip_address":"","ucode":"13F1D4A82BC650","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/be/9ea55f46.jpg","comment_is_top":false,"comment_ctime":1568887888,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1568887888","product_id":100017301,"comment_content":"文多图少，好难懂 🤦‍♂️","like_count":0},{"had_liked":false,"id":133548,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1568602440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568602440","product_id":100017301,"comment_content":"怎么都喜欢用作者的名字命名啊，<br>KMP好前缀规则，下一次再细看加实现，只能说我还会回来的！","like_count":0},{"had_liked":false,"id":132039,"user_name":"一个工匠","can_delete":false,"product_type":"c1","uid":1038449,"ip_address":"","ucode":"2168BA6F926074","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/71/d6f79534.jpg","comment_is_top":false,"comment_ctime":1568011338,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1568011338","product_id":100017301,"comment_content":"前面看的都好，终于这里折沙了。后面章节也迷迷糊糊了。过两天再回头从这里看。没有过不去的坎，多走两遍都是路。","like_count":0,"discussions":[{"author":{"id":1038449,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d8/71/d6f79534.jpg","nickname":"一个工匠","note":"","ucode":"2168BA6F926074","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8800,"discussion_content":"就说嘛，重头在看几次，就理解了，没有过不去的坎在时间面前。现在看到动态规划了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568054317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131418,"user_name":"Viator","can_delete":false,"product_type":"c1","uid":1019722,"ip_address":"","ucode":"FA0C9321D946E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/4a/a6b222c5.jpg","comment_is_top":false,"comment_ctime":1567744290,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1567744290","product_id":100017301,"comment_content":"但“不一定”是最长可匹配后缀子串。所以，既然 b[0, i-1]...的下一个字符“并不等于”b[i]。<br>“不一定”是不是和“并不等于”有矛盾？<br>","like_count":0},{"had_liked":false,"id":126382,"user_name":"李冲","can_delete":false,"product_type":"c1","uid":1254530,"ip_address":"","ucode":"C8C12308B0FDDA","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/82/b5808a60.jpg","comment_is_top":false,"comment_ctime":1566376790,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566376790","product_id":100017301,"comment_content":"没有严格按照讲述的过程来写KMP，就是理解意思之后自己用go写了一次。感觉并不太绕，有点怀疑是不是自己的理解有问题。简单测了两个用例也可以用<br><br>package main<br><br>import (<br>\t&quot;fmt&quot;<br>)<br><br>func GetNext(source string) []int {<br>\tsourceLen := len(source)<br>\tnext := make([]int, sourceLen)<br><br>\tfor i := 0; i &lt; sourceLen; i++ {<br>\t\tif i == 0 {<br>\t\t\tnext[i] = 0<br>\t\t} else {<br>\t\t\tif source[i] == source[next[i-1]] {<br>\t\t\t\tnext[i] = next[i-1] + 1<br>\t\t\t} else {<br>\t\t\t\tnext[i] = 0<br>\t\t\t}<br>\t\t}<br>\t}<br><br>\treturn next<br>}<br><br>func KMPSearch(source string, search string) (int, bool) {<br>\tsourceIndex, searchIndex := 0, 0<br>\tsourceLen := len(source)<br>\tsearchLen := len(search)<br>\tif searchLen &gt; sourceLen {<br>\t\treturn -1, false<br>\t}<br><br>\tnext := GetNext(source)<br>\tfmt.Println(&quot;Assistant array:&quot;, next)<br>\tfor sourceIndex &lt; sourceLen {<br>\t\tif source[sourceIndex] == search[searchIndex] {<br>\t\t\tfmt.Println(&quot;Debug match index:&quot;, sourceIndex, searchIndex)<br>\t\t\tif searchIndex == searchLen-1 {<br>\t\t\t\treturn sourceIndex + 1 - searchLen, true<br>\t\t\t}<br>\t\t\tsourceIndex++<br>\t\t\tsearchIndex++<br>\t\t} else {<br>\t\t\tfmt.Println(&quot;Debug mismatch index:&quot;, sourceIndex, searchIndex)<br>\t\t\tif searchIndex &gt; next[sourceIndex-1] {<br>\t\t\t\tsearchIndex = next[sourceIndex-1]<br>\t\t\t} else {<br>\t\t\t\tsearchIndex = next[sourceIndex]<br>\t\t\t\tsourceIndex++<br>\t\t\t}<br>\t\t}<br>\t}<br><br>\treturn -1, false<br>}<br><br>func main() {<br>\tfmt.Println(&quot;Welcome to the playground!&quot;)<br>\tsourceString := &quot;abcdeabcdefgabcd&quot;<br>\tsearchString := &quot;abcdefg&quot;<br>\tsearchString2 := &quot;abcdefgh&quot;<br><br>\tindex, ok := KMPSearch(sourceString, searchString)<br>\tfmt.Println(&quot;Find sub string&quot;, ok, &quot;with index:&quot;, index)<br><br>\tindex, ok = KMPSearch(sourceString, searchString2)<br>\tfmt.Println(&quot;Find sub string&quot;, ok, &quot;with index:&quot;, index)<br>}<br>","like_count":0},{"had_liked":false,"id":126228,"user_name":"范特西","can_delete":false,"product_type":"c1","uid":1213367,"ip_address":"","ucode":"E16372285CB6BB","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/b7/971a00c7.jpg","comment_is_top":false,"comment_ctime":1566351450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566351450","product_id":100017301,"comment_content":"最难的是k=next[k]。<br>个人觉得代码看的比图好理解。（｡ò ∀ ó｡）","like_count":0},{"had_liked":false,"id":125602,"user_name":"歌德如果","can_delete":false,"product_type":"c1","uid":1257726,"ip_address":"","ucode":"95352A39AE917D","user_header":"https://static001.geekbang.org/account/avatar/00/13/30/fe/a1314e65.jpg","comment_is_top":false,"comment_ctime":1566210122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566210122","product_id":100017301,"comment_content":"这个实在太难懂了,哭了","like_count":0},{"had_liked":false,"id":124422,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1565880984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565880984","product_id":100017301,"comment_content":"老师，失效函数的具体实现还没明白，不过，kmp的整体实现明白了。外层循环里边的几个顺序换一下就好理解多了，把&quot;a[i]==b[j] ;j++;&quot; 和 &quot;j == m; return i-m+1&quot; 放到 while循环前面就好理解多了，符合人类的思维习惯；while循环部分，其实就是循环计算坏字符在模式串中的下标j，当然就是最长前缀的下标再往后1位了。我的理解应该没错吧？","like_count":0},{"had_liked":false,"id":124314,"user_name":"布衣","can_delete":false,"product_type":"c1","uid":1207038,"ip_address":"","ucode":"BFAD9049508330","user_header":"https://static001.geekbang.org/account/avatar/00/12/6a/fe/7566542f.jpg","comment_is_top":false,"comment_ctime":1565859042,"is_pvip":false,"replies":[{"id":"45680","content":"多画几张你这样的该看不懂也看不懂的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565906976,"ip_address":"","comment_id":124314,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565859042","product_id":100017301,"comment_content":"有点太惜笔墨了, 最难的地方讲的不透彻, 需要看半天才搞明白,多画几张图不好吗?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463112,"discussion_content":"多画几张你这样的该看不懂也看不懂的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565906976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123177,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1565620915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565620915","product_id":100017301,"comment_content":"字符串匹配算法<br>一般情况下，感觉 BF 算法就够用了，效率也不低，如 Java 的 String.indexOf。因为预处理 BM &#47; KMP 时，BF 可能已经匹配完了。<br><br>最难理解<br>计算 KMP 的 next[] 数组，理解起来简直绝望。除了看老师的课程 N 遍，也 Google 了 N 遍。最后我是看着一个样例，ababac**ababab**，差不多几个小时吧，终于领悟了，解释起来也难以言语，佩服老师的数学式说明。对于我这种小白，通过较多的样例进行说明感觉会更好理解。PS: 花了我一周理解，今天晚上能够理解到实在开心。<br><br>对于自己写的代码可以通过 leetcode No.28 进行验证（有足够多的 testcases）","like_count":0},{"had_liked":false,"id":121103,"user_name":"青青子衿","can_delete":false,"product_type":"c1","uid":1438102,"ip_address":"","ucode":"4A388A3BA70C29","user_header":"https://static001.geekbang.org/account/avatar/00/15/f1/96/9571fa3d.jpg","comment_is_top":false,"comment_ctime":1565059054,"is_pvip":false,"replies":[{"id":"44729","content":"我不觉得绕啊，写的简单我也会啊，有些人根本看不到文章的亮点的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565219051,"ip_address":"","comment_id":121103,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565059054","product_id":100017301,"comment_content":"作者写的确实有点绕，结合这篇确实更好理解，https:&#47;&#47;www.zhihu.com&#47;question&#47;21923021?utm_source=wechat_search&amp;utm_medium=organic","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461627,"discussion_content":"我不觉得绕啊，写的简单我也会啊，有些人根本看不到文章的亮点的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565219051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120538,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1564925637,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1564925637","product_id":100017301,"comment_content":"看了@ZX的留言，一语惊醒梦中人，老师的推导没看懂，看你这句话瞬间明白了，可以这么理解求next数组<br>1、如果当前最长串的下一个字符b[K+1]和最后一个字符串相等，那么next[i]=k，也就是最长可匹配子串的位置可以后移一位。<br>2、如果当前最长串的下一个字符b[K+1]不等于最后一个字符串，那么最笨的办法是k=k-1，然后继续寻找。但是这里可以用到一个优化：从k-1到b[0,k]的最长可匹配前缀d的位置next[k]我们都不会找到合适的可匹配前缀，因为b[0,k]的最长可匹配前缀是b[0,k]。所以这里我们就可以直接将k移到next[k]的位置开始寻找b[0,i]的最长可匹配前缀。<br>最后，关于内层循环的理解，应该固定i，不然理起来会很绕人的。","like_count":0},{"had_liked":false,"id":120408,"user_name":"oh..","can_delete":false,"product_type":"c1","uid":1210187,"ip_address":"","ucode":"DB1398EA83A1A9","user_header":"https://static001.geekbang.org/account/avatar/00/12/77/4b/99d67d3d.jpg","comment_is_top":false,"comment_ctime":1564885969,"is_pvip":false,"replies":[{"id":"44223","content":"自己研究下吧。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1564959921,"ip_address":"","comment_id":120408,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564885969","product_id":100017301,"comment_content":"老师，我想问下像svn、git这些版本管理工具的代码校验比对是怎么实现的？想了解具体操作是怎样实现的","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461325,"discussion_content":"自己研究下吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564959921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119075,"user_name":"漏网之渔","can_delete":false,"product_type":"c1","uid":1092258,"ip_address":"","ucode":"8D7896E99E784C","user_header":"https://static001.geekbang.org/account/avatar/00/10/aa/a2/c7a3758d.jpg","comment_is_top":false,"comment_ctime":1564498484,"is_pvip":true,"replies":[{"id":"43660","content":"他描述的貌似不全面啊 你照着实现了吗","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1564526833,"ip_address":"","comment_id":119075,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564498484","product_id":100017301,"comment_content":"个人认为这一章节图和文字描述KMP过于抽象了，沿用BM算法来讲述KMP过于繁琐，推荐阅读：http:&#47;&#47;www.ruanyifeng.com&#47;blog&#47;2013&#47;05&#47;Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460738,"discussion_content":"他描述的貌似不全面啊 你照着实现了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564526833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118984,"user_name":"达生","can_delete":false,"product_type":"c1","uid":1372576,"ip_address":"","ucode":"98474B2BB03579","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/uEO3jibbiaWwYLQAIxV9icKGibe4B18D4j2fmCquLELeKnatj8UpW27x83KEmSESshC4rg4HqJpmNh0qBFiaZdqLUsw/132","comment_is_top":false,"comment_ctime":1564479680,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564479680","product_id":100017301,"comment_content":"关于次长串为什么是最长串的最长可匹配子串：A----C---------D-----B--------E----G---------H-----F，<br>AB和EF是最长可匹配串，AD和GF是次长可匹配串，现在要只要证明AD等于CB就行了，因为AD=GF，CB=GF(AB=EF，CB和GF分别是AB、EF的后半段，也相等)，所以AD=CB，所以次长串是最长串的最长可匹配子串","like_count":0},{"had_liked":false,"id":117482,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1564057674,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564057674","product_id":100017301,"comment_content":"表示没看懂，不过我还会回来的。","like_count":0},{"had_liked":false,"id":116572,"user_name":"Peng","can_delete":false,"product_type":"c1","uid":1108103,"ip_address":"","ucode":"D15A78DD1AC18C","user_header":"https://static001.geekbang.org/account/avatar/00/10/e8/87/89561ed0.jpg","comment_is_top":false,"comment_ctime":1563872816,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563872816","product_id":100017301,"comment_content":"参考一下： https:&#47;&#47;mp.weixin.qq.com&#47;s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247485939&amp;idx=1&amp;sn=b25f39b5644da92c4047bbbd9936f73c&amp;chksm=fa0e6672cd79ef64dda0a21e23c2817edf4a64cbb75b9bed328d6519c6cd4fef36d03a4cb309&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1563860553845&amp;sharer_shareid=6473c050943a0d877ef99f6fa8d6a8e8&amp;pass_ticket=tUuUysa4YqWIx8j%2FsLMocLxGmEHHq%2Feb6WxpS1uaaXvFP6N3J6qAVQavS79HCUJn#rd","like_count":0},{"had_liked":false,"id":114480,"user_name":"Geek_18b741","can_delete":false,"product_type":"c1","uid":1368496,"ip_address":"","ucode":"097BA0C2F44150","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLlztvlBgajZMEph8AvkP2pfoqNCGtYSalIKgrCbCg0MWDZJgJwqVRfWA6cgIoZicL6dKibfK0zjsWg/132","comment_is_top":false,"comment_ctime":1563323901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563323901","product_id":100017301,"comment_content":"老师在有一段突然提出b[0,y]有点奇怪。前后都没有y。我的理解是这样的：为了 求b[0, i-1] 的次长可匹配后缀子串，次长可匹配后缀子串一定包含在 最长可匹配后缀子串b[i-1-k,i-1]中(我们假设next[i-1]=k，文中写的是next[i-1]=k-1，为了理解方便更改假设)。b[i-1-k,i-1]对应的最长可匹配前缀子串是b[0,k]。那就是要在b[0,k]中求最长可匹配前缀子串。这个已经在前面的步骤中求得了，就是next[k]。所以才有了代码中的k=next[k]。这也是参考了第一条留言明白的。如果下个字符与b[i]不相等，就继续查找。","like_count":0},{"had_liked":false,"id":112378,"user_name":"罗洪州 IT","can_delete":false,"product_type":"c1","uid":1234281,"ip_address":"","ucode":"3688313E7D010A","user_header":"https://static001.geekbang.org/account/avatar/00/12/d5/69/d1f2f7c8.jpg","comment_is_top":false,"comment_ctime":1562725188,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562725188","product_id":100017301,"comment_content":"讲解的时候过于抽象，应该用具体数据讲解。","like_count":0},{"had_liked":false,"id":111972,"user_name":"猪猪男孩","can_delete":false,"product_type":"c1","uid":1461246,"ip_address":"","ucode":"E853E29182C6B5","user_header":"https://static001.geekbang.org/account/avatar/00/16/4b/fe/048ad222.jpg","comment_is_top":false,"comment_ctime":1562645326,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562645326","product_id":100017301,"comment_content":"        while j&gt;0 and a[i]!=b[j]: #精华的部分，很巧妙的模式串进行了移动。<br>            j = next[j-1]+1 #比较前缀之后，+1是为了接着比较后一位的，也是比较的前缀，很巧妙","like_count":0},{"had_liked":false,"id":110843,"user_name":"静水流深","can_delete":false,"product_type":"c1","uid":1339724,"ip_address":"","ucode":"644F05EFBD2E7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","comment_is_top":false,"comment_ctime":1562373333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562373333","product_id":100017301,"comment_content":"看代码可以理解，看图居然懵了好几天","like_count":0},{"had_liked":false,"id":104613,"user_name":"lzh","can_delete":false,"product_type":"c1","uid":1336951,"ip_address":"","ucode":"C3D83DF4230109","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","comment_is_top":false,"comment_ctime":1560785086,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560785086","product_id":100017301,"comment_content":"KMP基本思想仍是失配后，向右移动模式串到最近匹配前缀，并重新比对模式串。假设匹配完第i点后失配（i&lt;L-1，L为模式串长度），即S[0,i]都是匹配的，此时模式串应该向右移动到某j点（next[i]=j），该j点使得S[0,j]=S[i-j-1,i]（模式串最近的前缀与后缀相匹配处）。<br><br>此时有两种求next方法：<br><br>1.暴力求解，模式串每次向右移动一位，若满足S[0,j]=S[i-j,i]，next[i]=j，否则j-1重复。一般不推荐暴力法。<br><br>2.由next[x]（x&lt;i）求出next[i]，因为next[i-1]已知，假设next[i-1]=k，即已知S[0,k]==S[i-1-k,i-1]。<br>若C[k+1]==C[i]，可得S[0,k+1]==S[i-1-k,i]（S[i-(k+1),i]），说明k+1就是i的最近匹配前缀，即next[i]=k+1；<br>若C[k+1]!=C[i]，尽管S[i-1-k,i-1]==S[0,k]，但没用因为k+1与i失配（无法达到由next[x]求出next[i]的需求），需继续右移到下一个与S[0,i-1]的后缀相匹配的前缀处，即k=next[k]，并考察C[k+1]与C[k]，重复直到找到一个k使C[k+1]==C[k]或k=-1。<br>由next[x]求出next[i]关键在于总是先保证S[0,i-1]满足后缀匹配前缀，再考察C[k+1]与C[i]让S[0,i]满足后缀匹配前缀，即符合next的定义","like_count":0},{"had_liked":false,"id":99475,"user_name":"蛛菲娅","can_delete":false,"product_type":"c1","uid":1516740,"ip_address":"","ucode":"DB192DE3A1E41F","user_header":"https://static001.geekbang.org/account/avatar/00/17/24/c4/f10e15f4.jpg","comment_is_top":false,"comment_ctime":1559225974,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559225974","product_id":100017301,"comment_content":"复杂度需要想一下才能理解，发现一个trick: <br><br>1. 第二步匹配过程<br>每次比较，如果相等则主串下标右滑。不等则模式串整个右滑。总之每次比较必有右滑。<br><br>而主串下标右滑不会超过n，模式串整个右滑也不会超过n（因为超过n意味着匹配结束）所以总体比较次数不会超过2n。<br><br>2. 第一步求next其实和第二步是相同的过程，只是主串是模式串，且next数组动态计算。因此总体比较次数不超过2m。<br><br>3.两步相加不超过2m+2n，因此认为复杂度为O（n+m）<br>","like_count":0},{"had_liked":false,"id":99283,"user_name":"寻路人","can_delete":false,"product_type":"c1","uid":1195917,"ip_address":"","ucode":"1711F740D4D60A","user_header":"https://static001.geekbang.org/account/avatar/00/12/3f/8d/a89be8f9.jpg","comment_is_top":false,"comment_ctime":1559186116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559186116","product_id":100017301,"comment_content":"假设b[0,i]的最大可匹配后缀子串为b[r,i]，如果去掉最后一个字符，那b[r,i-1]一定是b[0,i-1]可匹配的后缀子串，但不一定是最大的可匹配后缀子串。这句话没有理解，我觉得b[r,i-1]就是b[0,i-1]的最大可匹配后缀子串，有没有例子可以证明一下这句话的正确性？","like_count":0},{"had_liked":false,"id":98971,"user_name":"mrlay","can_delete":false,"product_type":"c1","uid":1041640,"ip_address":"","ucode":"385A1954ED3317","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e4/e8/a1703783.jpg","comment_is_top":false,"comment_ctime":1559121950,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559121950","product_id":100017301,"comment_content":"最难理解的地方就是 k = next[k] 迭代的问题 ; 我花费了3天的 时间，因为一直觉得这种等价转换不合理；刚刚才恍然大悟我忽略了一个细节  “最长后缀字串的内容是与最长前缀字串的内容是相等的” 。 ","like_count":0},{"had_liked":false,"id":98594,"user_name":"Shawn","can_delete":false,"product_type":"c1","uid":1014729,"ip_address":"","ucode":"B95D7B54465DE4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/c9/75c9002e.jpg","comment_is_top":false,"comment_ctime":1559036682,"is_pvip":false,"replies":[{"id":"35336","content":"你可以参考下github上的代码实现：<br>https:&#47;&#47;github.com&#47;wangzheng0822&#47;algo","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559088192,"ip_address":"","comment_id":98594,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559036682","product_id":100017301,"comment_content":"理解了原理和写出完美的代码还差了一个宇宙，哈哈。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451746,"discussion_content":"你可以参考下github上的代码实现：\nhttps://github.com/wangzheng0822/algo","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559088192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97093,"user_name":"雍鹏亮","can_delete":false,"product_type":"c1","uid":1179992,"ip_address":"","ucode":"A7E394043295B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/01/58/98719136.jpg","comment_is_top":false,"comment_ctime":1558586419,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558586419","product_id":100017301,"comment_content":"汉语不适合表述这种复杂的语句，读的时候容易咬到舌头，建议用英语。","like_count":0},{"had_liked":false,"id":94725,"user_name":"露秋","can_delete":false,"product_type":"c1","uid":1155296,"ip_address":"","ucode":"016531841C413F","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/e0/8df38d08.jpg","comment_is_top":false,"comment_ctime":1557885304,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557885304","product_id":100017301,"comment_content":"https:&#47;&#47;zhuanlan.zhihu.com&#47;p&#47;24649304","like_count":0},{"had_liked":false,"id":93199,"user_name":"笙南","can_delete":false,"product_type":"c1","uid":1218163,"ip_address":"","ucode":"39F2B7F155EAEF","user_header":"https://static001.geekbang.org/account/avatar/00/12/96/73/b5158f6c.jpg","comment_is_top":false,"comment_ctime":1557420185,"is_pvip":false,"replies":[{"id":"33865","content":"对的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557882425,"ip_address":"","comment_id":93199,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557420185","product_id":100017301,"comment_content":"王争老师你好，您上边的例子中 e 是坏字符，按照 KMP 的匹配规则，模式串需要移动 3 次，走到最后；但是如果是 BM 的坏字符规则，发现 e 是坏字符，并且不再模式串中出现，模式串应该直接移动 5 + 1 位，越过坏字符，移动 1 次，走到最后；这样 BM 的模式串移动次数比 KMP 的少。请问老师，我上面的理解对吗 ？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449520,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557882425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91863,"user_name":"GL","can_delete":false,"product_type":"c1","uid":1125950,"ip_address":"","ucode":"EB14AF83184E85","user_header":"https://static001.geekbang.org/account/avatar/00/11/2e/3e/5ae876fd.jpg","comment_is_top":false,"comment_ctime":1557121742,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557121742","product_id":100017301,"comment_content":"终于看懂了next数组的填充！","like_count":0},{"had_liked":false,"id":89785,"user_name":"mrlay","can_delete":false,"product_type":"c1","uid":1041640,"ip_address":"","ucode":"385A1954ED3317","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e4/e8/a1703783.jpg","comment_is_top":false,"comment_ctime":1556264664,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556264664","product_id":100017301,"comment_content":"我最直观的感受是 变量 i 的迭代弄得不好 ，可以有优化的","like_count":0},{"had_liked":false,"id":89190,"user_name":"JUN","can_delete":false,"product_type":"c1","uid":1227219,"ip_address":"","ucode":"CAED3BEC181EE5","user_header":"https://static001.geekbang.org/account/avatar/00/12/b9/d3/a198d2ed.jpg","comment_is_top":false,"comment_ctime":1556100890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556100890","product_id":100017301,"comment_content":"按照这个思路，我们可以考察完所有的 b[0, i-1] 的可匹配后缀子串 b[y, i-1]，直到找到一个可匹配的后缀子串，它对应的前缀子串的下一个字符等于 b[i]，那这个 b[y, i] 就是 b[0, i] 的最长可匹配后缀子串。<br>前面看懂了，但是这段话看了n边，真心懵。b[0, i-1] 的可匹配后缀子串怎么会是 b[y, i-1]呢？","like_count":0},{"had_liked":false,"id":85613,"user_name":"小新村小学扛霸子","can_delete":false,"product_type":"c1","uid":1250309,"ip_address":"","ucode":"BECFAB70A68C9F","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/05/5f46ffa6.jpg","comment_is_top":false,"comment_ctime":1555143183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555143183","product_id":100017301,"comment_content":"头要爆炸了，k = next[k]想了半天","like_count":0},{"had_liked":false,"id":85509,"user_name":"L.Messi","can_delete":false,"product_type":"c1","uid":1204364,"ip_address":"","ucode":"617C37A23380B1","user_header":"https://static001.geekbang.org/account/avatar/00/12/60/8c/742cd162.jpg","comment_is_top":false,"comment_ctime":1555083298,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555083298","product_id":100017301,"comment_content":"求next数组的讲解跟代码实现真的都不太好，讲解太绕了，代码实现也不够简洁，看半天没看明白，后来看了评论里的一个网友留言的知乎帖子，一下就看懂了","like_count":0},{"had_liked":false,"id":83933,"user_name":"赵捌玖","can_delete":false,"product_type":"c1","uid":1149424,"ip_address":"","ucode":"2DFD73F90609C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/89/f0/678e6643.jpg","comment_is_top":false,"comment_ctime":1554735610,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554735610","product_id":100017301,"comment_content":"妈妈的，看了好几遍终于明白了！！😭","like_count":0},{"had_liked":false,"id":82432,"user_name":"多格","can_delete":false,"product_type":"c1","uid":1222021,"ip_address":"","ucode":"122195F3D90EA1","user_header":"https://static001.geekbang.org/account/avatar/00/12/a5/85/eeb5b42f.jpg","comment_is_top":false,"comment_ctime":1554209992,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554209992","product_id":100017301,"comment_content":"&quot;部分匹配值&quot;就是&quot;前缀&quot;和&quot;后缀&quot;的最长的共有元素的长度。以&quot;ABCDABD&quot;为例，<br><br>　　－　&quot;A&quot;的前缀和后缀都为空集，共有元素的长度为0；<br><br>　　－　&quot;AB&quot;的前缀为[A]，后缀为[B]，共有元素的长度为0；<br><br>　　－　&quot;ABC&quot;的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；<br><br>　　－　&quot;ABCD&quot;的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；<br><br>　　－　&quot;ABCDA&quot;的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为&quot;A&quot;，长度为1；<br><br>　　－　&quot;ABCDAB&quot;的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为&quot;AB&quot;，长度为2；<br><br>　　－　&quot;ABCDABD&quot;的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。","like_count":0},{"had_liked":false,"id":80160,"user_name":"JKnight","can_delete":false,"product_type":"c1","uid":1330419,"ip_address":"","ucode":"709D7A51135EDE","user_header":"https://static001.geekbang.org/account/avatar/00/14/4c/f3/6f18cdae.jpg","comment_is_top":false,"comment_ctime":1553611420,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553611420","product_id":100017301,"comment_content":"发现如果看不懂的时候，自己闲下来思考就思考，回想老师的图，找解决的规律，总是能想通的。<br>想通怎么处理后再看文字描述就简单了（今早在地铁上想通的","like_count":0},{"had_liked":false,"id":78477,"user_name":"精霊剣舞祭","can_delete":false,"product_type":"c1","uid":1237665,"ip_address":"","ucode":"3F012FC569FB58","user_header":"","comment_is_top":false,"comment_ctime":1553156335,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553156335","product_id":100017301,"comment_content":"KMP算法（最常用，时间O(n+m)，空间o(m)）<br>最大可匹配前缀子串：<br>例：模式串：ababacd   其中一个前缀子串：abab 该前缀子串的前缀子串{a,ab,aba}；后缀子串{b,ab,bab}  则其最大可匹配前缀子串为ab。<br>失效函数：<br>数组下标：模式串前缀子串的末尾的下标。<br>值：（默认为-1）模式串的前缀子串X中——X的最大可匹配前缀子串的末尾下标。<br>失效函数构造思路：<br>求模式串长度为[0,K]的前缀子串的最大可匹配前缀子串，已知[0,K-1]的前缀子串的最大可匹配前缀子串为[0,M]。<br>1、若M+1处的字符 ==  K处的字符，则其最大可匹配前缀子串为[0,M+1]。<br>2、否则求模式串的前缀子串[0,M]（长度为M+1）的最大可匹配前缀子串[0,N]。跳到1（将N代入M）。直到其相等。<br>KMP算法思路：<br>失效函数为next[]<br>1、从下表0开始，找到坏字符在模式串中的位置。<br>2、若坏字符的下标为0，直接将模式串向右移动1位。<br>3、否则，根据坏字符位置求出好前缀长度并通过next[]获取最大可匹配前缀子串的末尾。<br>4、若没有最大可匹配前缀子串，则直接将模式串向右移动 好前缀长度 位。<br>5、否则，将模式串移动 最大可匹配前缀子串的长度 位。","like_count":0},{"had_liked":false,"id":78399,"user_name":"水户洋平","can_delete":false,"product_type":"c1","uid":1009140,"ip_address":"","ucode":"806545270EB6C0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/f4/bb81f857.jpg","comment_is_top":false,"comment_ctime":1553140102,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553140102","product_id":100017301,"comment_content":"<br>  for (int i = 0; i &lt; n; ++i) {<br>    while (j &gt; 0 &amp;&amp; a[i] != b[j]) { &#47;&#47; 一直找到 a[i] 和 b[j]<br>    &#47;&#47;这个while循环不能用if替代的原因是不是 此时i是最坏字符串的位置， 循环体内j跟新为最长可匹配前缀子川的下一个下标(或者0的位置)，此时跳出循环体的条件必须是这个j下标对应的模式串字符必须与坏字符一样，否则下一次for循环时就会跳过主串中怀字符的位置去跟模式串比较。<br>      j = next[j - 1] + 1;<br>    }<br>   }","like_count":0},{"had_liked":false,"id":78080,"user_name":"乐凡","can_delete":false,"product_type":"c1","uid":1239260,"ip_address":"","ucode":"918C9997EB6537","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/dc/32e78f02.jpg","comment_is_top":false,"comment_ctime":1553067671,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553067671","product_id":100017301,"comment_content":"看了累计看了有半天有余，主要卡在填充next[]数组了，","like_count":0},{"had_liked":false,"id":77350,"user_name":"Believer(入陣)","can_delete":false,"product_type":"c1","uid":1127667,"ip_address":"","ucode":"A57EFA4E534019","user_header":"https://static001.geekbang.org/account/avatar/00/11/34/f3/465e90d0.jpg","comment_is_top":false,"comment_ctime":1552910754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552910754","product_id":100017301,"comment_content":"是不是可以理解为，把next[]考虑为一种状态，每一次增量匹配，就跳动到++k状态，每次增量匹配失败，就跳动到前一个成功匹配状态","like_count":0},{"had_liked":false,"id":70760,"user_name":"lppklm","can_delete":false,"product_type":"c1","uid":1240668,"ip_address":"","ucode":"6E205A64FE11F3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLw0NCZFvhXdib2JIbuBsdVSIiaQ19D7TryyiaLlyDHAD5THbd8oI6ZmLaMt3FSbunibXF5WPItGibkdNQ/132","comment_is_top":false,"comment_ctime":1551176573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551176573","product_id":100017301,"comment_content":"标注:最长后缀=最长前缀<br>推导:如果最长前缀的下一个字符不等于b[i] 那么应该判断最长后缀的最长后缀即最长前缀的最长前缀的下一个字符是否等于b[i]","like_count":0},{"had_liked":false,"id":70463,"user_name":"吴昊","can_delete":false,"product_type":"c1","uid":1248635,"ip_address":"","ucode":"CB4F6A46930873","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/7b/e574577a.jpg","comment_is_top":false,"comment_ctime":1551102511,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551102511","product_id":100017301,"comment_content":"我最难理解的和大家一样也是k = next[k]，自己提明白了给大家 分享一下。<br>step1、先摆出老师的图，当k+1 != i时要找[0,i-1]的次长匹配前缀。<br>0....... .......k,k+1...................kk..................i-1,i<br>step2、假设次长匹配前缀为z，[0,z]==[ zz,i-1]<br>0.......z......k,k+1...................kk......zz........i-1,i<br>step3、由于对称性，[0,k]==[kk,i-1], [0,z] ==[zz,i-1]所以[0,z]也是[0,k]的匹配前缀。<br>证明了评论区第一老哥的想法<br>","like_count":0},{"had_liked":false,"id":69370,"user_name":"ideastone","can_delete":false,"product_type":"c1","uid":1079666,"ip_address":"","ucode":"D3BA2E4560617A","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/72/bbcaa9b2.jpg","comment_is_top":false,"comment_ctime":1550729417,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550729417","product_id":100017301,"comment_content":"知乎上一篇关于 KMP 算法的描述<br>https:&#47;&#47;www.zhihu.com&#47;question&#47;21923021&#47;answer&#47;281346746<br>","like_count":0},{"had_liked":false,"id":67611,"user_name":"beyondkmp","can_delete":false,"product_type":"c1","uid":1003503,"ip_address":"","ucode":"28D16CEFF6E5BE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4f/ef/57847b72.jpg","comment_is_top":false,"comment_ctime":1550209825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550209825","product_id":100017301,"comment_content":"看完居然懂了kmp 算法。比我大学的老师讲的清晰多了，哈哈哈","like_count":0},{"had_liked":false,"id":65549,"user_name":"zzz","can_delete":false,"product_type":"c1","uid":1194253,"ip_address":"","ucode":"6A5752C924D917","user_header":"https://static001.geekbang.org/account/avatar/00/12/39/0d/80ae66d7.jpg","comment_is_top":false,"comment_ctime":1549445259,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549445259","product_id":100017301,"comment_content":"假设最长的可匹配的那部分前缀子串是{v}，长度是 k。我们把模式串一次性往后滑动 j-k 位，相当于，每次遇到坏字符的时候，我们就把 j 更新为 k，i 不变，然后继续比较。<br><br>这段后面的配图，j=j-k错了，应该是j=k","like_count":0},{"had_liked":false,"id":61592,"user_name":"San","can_delete":false,"product_type":"c1","uid":1333186,"ip_address":"","ucode":"FC14488D3EA074","user_header":"https://static001.geekbang.org/account/avatar/00/14/57/c2/feb6b75b.jpg","comment_is_top":false,"comment_ctime":1547731953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547731953","product_id":100017301,"comment_content":"感觉内容不是很难，只是一些名词的命名方式太长，导致难看懂。<br><br>就和写复杂逻辑代码一样，有些变量命名真不知怎么命名好。<br>写长了看得头疼，写短了就失去了和上下文的关联性。<br>我的经验是：<br>       逐层逐层地写，写第二层时变量的命名，就不用包含第一层的内容。<br><br>比如&quot;最长可匹配后缀子串&quot;，可以改为“最长后缀子串”。<br>因为讨论的都是可匹配的，可以省去这三个字。<br><br><br>","like_count":0},{"had_liked":false,"id":59663,"user_name":"__qms","can_delete":false,"product_type":"c1","uid":1271438,"ip_address":"","ucode":"E220BFD272A54B","user_header":"https://static001.geekbang.org/account/avatar/00/13/66/8e/99c0c5a3.jpg","comment_is_top":false,"comment_ctime":1547397478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547397478","product_id":100017301,"comment_content":"next数组算法用aabaaa这个串捋一遍就明白了","like_count":0},{"had_liked":false,"id":59154,"user_name":"Mr.M","can_delete":false,"product_type":"c1","uid":1243730,"ip_address":"","ucode":"C32AE0A9CD6EEF","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/52/4781da3f.jpg","comment_is_top":false,"comment_ctime":1547308403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547308403","product_id":100017301,"comment_content":"这里的j = next[j - 1] + 1;能不能直接替换成j=0呢？","like_count":0},{"had_liked":false,"id":59074,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1547294446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547294446","product_id":100017301,"comment_content":"说说对求 next 数组那段代码对理解：<br><br>&#47;&#47; b 表示模式串，m 表示模式串的长度<br>private static int[] getNexts(char b, int m){<br>    int[] next = new int[m];<br>    next[0] = -1;<br>    int k = -1;<br><br>    for(int i=1; i&lt;m; ++i){ &#47;&#47; 模式串长度 m<br>        while(k!=-1 &amp;&amp; b[k+1]!=b[i]){<br>            k = next[k];<br>&#47;&#47;next[k]是b[0, k]的最长可匹配前缀子串的结尾字符的下标；b[0,k]的最长可匹配前缀子串必定对应一个最长可匹配后缀子串; 利用这个最长可匹配后缀子串的下一个字符b[k+1]与b[i]继续比较是否相等，求next[i]，也就是求b[0, i]的最长可匹配后缀子串；如果不等，则 k = next[k]，继续取次长可匹配后缀子串的下一个字符b[k+1]与b[i]比较。<br>        }<br><br>        if(b[k+1] == b[i]){<br>            ++k;<br>        }<br><br>        next[i] = k; &#47;&#47; next 数组<br>    }<br>    return next;<br>}","like_count":0},{"had_liked":false,"id":58819,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1547200633,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547200633","product_id":100017301,"comment_content":"只能理解了前缀子串的后缀子串和模式串的前缀子串做对比，剩下来的都好理解","like_count":0},{"had_liked":false,"id":58627,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1547151310,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547151310","product_id":100017301,"comment_content":"文中「数组的下标是每个前缀结尾字符串下标，数组的值是这个前缀的最长可匹配前缀子串的结尾字符下标」：<br>模式串前缀是候选的好前缀，结合图例，其前缀子串与后缀子串比较，得出 next 数组的下标及其存储值的含义。","like_count":0},{"had_liked":false,"id":58626,"user_name":"Alexis何春光","can_delete":false,"product_type":"c1","uid":1181149,"ip_address":"","ucode":"614570FAE3B56A","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/dd/b201cf13.jpg","comment_is_top":false,"comment_ctime":1547149824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547149824","product_id":100017301,"comment_content":"关于时间复杂度分析，wiki上看到一个比较容易理解的角度：Here is another way to think about the runtime: Let us say we begin to match W and S at position i and p. If W exists as a substring of S at p, then W[0..m] = S[p..p+m]. Upon success, that is, the word and the text matched at the positions (W[i] = S[p+i]), we increase i by 1. Upon failure, that is, the word and the text do not match at the positions (W[i] ≠ S[p+i]), the text pointer is kept still, while the word pointer is rolled back a certain amount (i = T[i], where T is the jump table), and we attempt to match W[T[i]] with S[p+i]. The maximum number of roll-back of i is bounded by i, that is to say, for any failure, we can only roll back as much as we have progressed up to the failure. Then it is clear the runtime is 2n. ","like_count":0},{"had_liked":false,"id":58623,"user_name":"Alexis何春光","can_delete":false,"product_type":"c1","uid":1181149,"ip_address":"","ucode":"614570FAE3B56A","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/dd/b201cf13.jpg","comment_is_top":false,"comment_ctime":1547144228,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547144228","product_id":100017301,"comment_content":"KMP 算法的框架代码那一部分没太看懂，感觉j是在一直循环往复？那么模式串“滑动”的部分在哪里体现的呢？","like_count":0},{"had_liked":false,"id":58370,"user_name":"luo","can_delete":false,"product_type":"c1","uid":1148742,"ip_address":"","ucode":"00FBDC12101419","user_header":"https://static001.geekbang.org/account/avatar/00/11/87/46/2850b4a9.jpg","comment_is_top":false,"comment_ctime":1547045972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547045972","product_id":100017301,"comment_content":"我们假设 b[0, i] 的最长可匹配后缀子串是 b[r, i]。如果我们把最后一个字符去掉，那 b[r, i-1] 肯定是 b[0, i-1] 的可匹配后缀子串，但不一定是最长可匹配后缀子串。这个理解不了啊  后缀子串这个时候最后的字符肯定是从r-1往前的啊 如果这个结论不成立那b[r-i]怎么能是最长后缀子串呢","like_count":0},{"had_liked":false,"id":57958,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1546951076,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546951076","product_id":100017301,"comment_content":"这一节建议看wiki，那个很清晰","like_count":0},{"had_liked":false,"id":57583,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1546841278,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546841278","product_id":100017301,"comment_content":"自从搞懂了BM算法原理过后 今天再来理解kmp算法 瞬间就恍然大悟了","like_count":0},{"had_liked":false,"id":53452,"user_name":"唯她命","can_delete":false,"product_type":"c1","uid":1240398,"ip_address":"","ucode":"8F687E8D306840","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4e/ef406442.jpg","comment_is_top":false,"comment_ctime":1545647990,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545647990","product_id":100017301,"comment_content":"当<br>a b a b a e a b a c<br>           a b ab a c d<br>模式串 已经超出了 字符串，可以优化，直接退出了","like_count":0},{"had_liked":false,"id":52598,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1545449901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545449901","product_id":100017301,"comment_content":"王哥，请问这篇我能跳过吗","like_count":0},{"had_liked":false,"id":52464,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1060892,"ip_address":"","ucode":"B29CA98AC45F88","user_header":"https://static001.geekbang.org/account/avatar/00/10/30/1c/e160955d.jpg","comment_is_top":false,"comment_ctime":1545386905,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545386905","product_id":100017301,"comment_content":"之前看了无数kmp算法的讲解，都是记住了规则，稀里糊涂，这次是真的理解了思路，敲开心","like_count":0},{"had_liked":false,"id":52013,"user_name":"Pluto","can_delete":false,"product_type":"c1","uid":1038251,"ip_address":"","ucode":"E292AFAD428135","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d7/ab/15c9b94e.jpg","comment_is_top":false,"comment_ctime":1545293492,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1545293492","product_id":100017301,"comment_content":"个人感觉 BM 算法还是要难一点，KMP 的 next 数组计算居然这么简单，不过讲得真好","like_count":0},{"had_liked":false,"id":51601,"user_name":"猫头鹰爱拿铁","can_delete":false,"product_type":"c1","uid":1105958,"ip_address":"","ucode":"24266B58968428","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/26/4942a09e.jpg","comment_is_top":false,"comment_ctime":1545206572,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1545206572","product_id":100017301,"comment_content":"评论中的问题：那 b[r, i-1] 肯定是 b[0, i-1] 的可匹配后缀子串，但并不一定是最长可匹配后缀子串。」后半句不是很理解，如果模式串是 b[0, i-1]，i-1 已经是最后一个字符了，那么为什么 b[r, i-1] 不一定是 b[0, i-1] 的最长可匹配后缀子串呢？<br>我理解这个问题是这样的，前提条件是next[i-1]=k-1,但是b[i]!=b[k]。所以又假设了已经找到next[i]=i-r,可知r&gt;k的。因为对于相邻的i-1和i，如果求得了i-1的最长可匹配后缀子串b[k,i-1],那么对于i来说最长的可配后缀子串就是b[k,i]。这个可以反证。所以再求得了i的最长匹配后缀子串b[r,i]并不能推导出i-1的最长可匹配后缀子串，b[r, i-1] 肯定是 b[0, i-1] 的可匹配后缀子串，但并不一定是最长可匹配后缀子串。<br>求next数组都是在已知前面索引k的next[k]的情况下去求next[k+1]的。如果b[i]!=b[k+1],那么就找次长匹配前缀子串，只要次长匹配子串的下一个索引k+1对应的value等于b[i]即可。而次长的匹配前缀子串肯定在b[0,next[k]], 而次长的匹配前缀子串肯定是b[0,next[k]]的最长可匹配前缀子串。不理解的看老师画的那个图就清楚了。一直迭代计算出来。<br>kmp理解了好多天，感觉很绕。自己练习的时候也想了好久，感觉比bm难理解多了。<br>我理解kmp和bm的核心思想就是不像rk和bf一样一个个比较，而是利用模式串存在匹配的子串的特性，减少与主串比较的长度。<br>bm的难点在于好前缀中计算后缀子串和后缀子串匹配的前缀子串，想清楚bm的匹配方式是从模式串最后一个字符开始比较就很好理解了。后缀子串和前缀子串的索引为模式串与后缀匹配的长度。值为匹配到的模式串字符索引。那寻找后缀子串的算法就是从模式串的前面和最后索引开始比较。rk和bf相对来说比较容易。都是从模式串的开始索引一个一个的与主串比较。rk稍微难的地方在于计算哈希值。换算成26进制推导主串中相邻字符串模式串长度的哈希值。","like_count":0},{"had_liked":false,"id":51209,"user_name":"Differ","can_delete":false,"product_type":"c1","uid":1247101,"ip_address":"","ucode":"560F5D942262DB","user_header":"https://static001.geekbang.org/account/avatar/00/13/07/7d/1cd7ccba.jpg","comment_is_top":false,"comment_ctime":1545135165,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545135165","product_id":100017301,"comment_content":"求b[0, i-1] 的次长可匹配后缀子串，转化成了b[0,next[i-1]]的最长匹配后缀子串是真的巧妙<br>把次长问题又转成规模更小的最长问题<br>","like_count":0},{"had_liked":false,"id":50907,"user_name":"Laughing_Lz","can_delete":false,"product_type":"c1","uid":1251342,"ip_address":"","ucode":"7A7445E96F2978","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/0e/39307052.jpg","comment_is_top":false,"comment_ctime":1545063449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545063449","product_id":100017301,"comment_content":"本来打算放弃了，又百度了别人的文章，看到这篇，步骤讲的更加通俗易懂，然后再来看老师写的代码，也可以看懂了~老师写的前缀后缀子串什么的把我绕晕了，看懂别人文章之后再来看 总算是理解了。http:&#47;&#47;www.cnblogs.com&#47;c-cloud&#47;p&#47;3224788.html","like_count":0},{"had_liked":false,"id":50884,"user_name":"Laughing_Lz","can_delete":false,"product_type":"c1","uid":1251342,"ip_address":"","ucode":"7A7445E96F2978","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/0e/39307052.jpg","comment_is_top":false,"comment_ctime":1545060656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545060656","product_id":100017301,"comment_content":"「那 b[r, i-1] 肯定是 b[0, i-1] 的可匹配后缀子串，但并不一定是最长可匹配后缀子串。」后半句不是很理解，如果模式串是 b[0, i-1]，i-1 已经是最后一个字符了，那么为什么 b[r, i-1] 不一定是 b[0, i-1] 的最长可匹配后缀子串呢？","like_count":0},{"had_liked":false,"id":50683,"user_name":"子嘉","can_delete":false,"product_type":"c1","uid":1252422,"ip_address":"","ucode":"CF0DC72E2B6B9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/46/a141c7e6.jpg","comment_is_top":false,"comment_ctime":1545029324,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545029324","product_id":100017301,"comment_content":"老师 next最后一步 不匹配的 建议出一个模式串举例一下 这个图看着好懵。 看了一周了 意思就是 1 2 1 3 1 2 1 2 这样 到匹配前4后4“1 2 1 3”和“1 2 1 2”的3 和 2不匹配 就查看next里有没有和后缀子串 2 1 2、1 2、2相等的前缀子串？ 比如这个例子匹配到最后是1 2？","like_count":0},{"had_liked":false,"id":50614,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1545016668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545016668","product_id":100017301,"comment_content":"字符串匹配算法 KMP 最著名；<br>KMP 算法就是在试图寻找一种规律：在模式串和主串匹配的过程中，当遇到坏字符串后，对于已经比对过的好前缀，能否找到一种规律，将模式串一次性的滑动很多位------好前缀规则","like_count":0},{"had_liked":false,"id":50386,"user_name":"梅坊帝卿","can_delete":false,"product_type":"c1","uid":1240270,"ip_address":"","ucode":"702F019BA3356C","user_header":"","comment_is_top":false,"comment_ctime":1544965034,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544965034","product_id":100017301,"comment_content":"前缀子串 比如 abc 则有a ab<br>同理后缀子串也是<br>另外 next放的是最长匹配的结尾字符下标 看了好久才看懂 一开始总关注起始下标 看半天都觉得不对","like_count":0},{"had_liked":false,"id":49841,"user_name":"李","can_delete":false,"product_type":"c1","uid":1119312,"ip_address":"","ucode":"5C0FAA211F2E26","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg","comment_is_top":false,"comment_ctime":1544778210,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1544778210","product_id":100017301,"comment_content":"这里有个疑问，j=0, 下面next[j-1]  不就是next[-1] 吗？ 这个是不是有问题额？  <br> int j = 0;<br>  for (int i = 0; i &lt; n; ++i) {<br>    while (j &gt; 0 &amp;&amp; a[i] != b[j]) { &#47;&#47; 一直找到 a[i] 和 b[j]     没理解这句话的意思<br><br>      j = next[j - 1] + 1;<br>    }<br>    ","like_count":0},{"had_liked":false,"id":49772,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1544767646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544767646","product_id":100017301,"comment_content":"老师 图5中 <br>当好前缀候选是 abab时 后缀是bacd，没有可匹配字符，所以next_3=0啊？<br>图片里值为1<br>不知道，我理解的对不对","like_count":0},{"had_liked":false,"id":49734,"user_name":"zixuan","can_delete":false,"product_type":"c1","uid":1131300,"ip_address":"","ucode":"C72920DD05B074","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg","comment_is_top":false,"comment_ctime":1544758650,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544758650","product_id":100017301,"comment_content":"讲得挺好，体会到了算法的精妙。最关键的递归求next数组地方再举个具体的例子就更直观了。","like_count":0},{"had_liked":false,"id":49667,"user_name":"李","can_delete":false,"product_type":"c1","uid":1119312,"ip_address":"","ucode":"5C0FAA211F2E26","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg","comment_is_top":false,"comment_ctime":1544751103,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1544751103","product_id":100017301,"comment_content":"模式串中每个前缀（这些前缀都有可能是好前缀）的最长可匹配前缀子串的结尾字符下标<br>这句话有点拗口，下面的图也没看明白。<br>每个前缀这个能理解。<br>最长可匹配前缀子串 怎么理解？  谁和谁匹配？  前缀自己和前缀的子串匹配？ 然后最长的那个匹配？<br>匹配规则是啥？<br><br>","like_count":0},{"had_liked":false,"id":49480,"user_name":"李","can_delete":false,"product_type":"c1","uid":1119312,"ip_address":"","ucode":"5C0FAA211F2E26","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg","comment_is_top":false,"comment_ctime":1544695319,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1544695319","product_id":100017301,"comment_content":"我们把模式串一次性往后滑动 j-k 位，相当于，每次遇到坏字符的时候，我们就把 j 更新为 k，i 不变，然后继续比...<br><br>j更新为k怎么理解。<br>假设j是5，k是3，5更新为3. 这个怎么理解？<br>","like_count":0},{"had_liked":false,"id":49179,"user_name":"槛外人","can_delete":false,"product_type":"c1","uid":1053058,"ip_address":"","ucode":"3F821FB998E63A","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/82/ab3f0985.jpg","comment_is_top":false,"comment_ctime":1544617891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544617891","product_id":100017301,"comment_content":"求b[i-1]的次长匹配前缀，怎么变成了求[0,y]的最长匹配前缀？这一点没看懂","like_count":0},{"had_liked":false,"id":48989,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1544585461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544585461","product_id":100017301,"comment_content":"没理解 k = next[k]，能解释下这里的原理吗","like_count":0},{"had_liked":false,"id":48937,"user_name":"赵光斌","can_delete":false,"product_type":"c1","uid":1070738,"ip_address":"","ucode":"A23D384A2643D7","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/92/bbfdd3aa.jpg","comment_is_top":false,"comment_ctime":1544579908,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544579908","product_id":100017301,"comment_content":"for (int i = 0; i &lt; n; ++i) {<br>    while (j &gt; 0 &amp;&amp; a[i] != b[j]) { &#47;&#47; 一直找到 a[i] 和 b[j]<br>      j = next[j - 1] + 1;<br>    }<br>…<br>老师，请教下，看不明白，如果进了while循环，这里为什么还要++i？这样不会漏掉主串中的字符匹配吗？","like_count":0},{"had_liked":false,"id":48737,"user_name":"煦暖","can_delete":false,"product_type":"c1","uid":1245418,"ip_address":"","ucode":"96D0B236C4148A","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/ea/6ad346c1.jpg","comment_is_top":false,"comment_ctime":1544526241,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544526241","product_id":100017301,"comment_content":"嗯嗯，是我把下标和移动位数搞混了，谢谢老师","like_count":0},{"had_liked":false,"id":48660,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1544509423,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1544509423","product_id":100017301,"comment_content":"BM、KMP算法本身的大意自认为是都看懂了，不过KMP的算法复杂度分析没看懂。<br><br>“而 while 循环里 k=next[k]，实际上是在减小 k 的值，k 累积都没有增加超过 m，所以 while 循环里面 k=next[k] 总的执行次数也不可能超过 m。”<br>“而 j 总共增长的量都不会超过 n，那减少的量也不可能超过 n，所以 while 循环中的这条语句总的执行次数也不会超过 n，所以这部分的时间复杂度是 O(n)。”<br><br>不知所云。无论第一部分的k还是第二部分的j，他们增长的方式都是++。但是相应的减少则是通过赋值，而非持续的--。我们知道++和--都是有界限的，比如++不可能超过m和n，--不能小于0，但赋值就不一样了，因为赋值不会突破上下界，那即使做无数次赋值操作也不会使累积减少次数小于m或n。<br><br>BM算法与KMP算法的复杂度差在哪里呢？BM算法计算suffix数组和prefix数组的暴力算法时间复杂度差不多也是O（m^2）了，如果也可以用类似动态规划算法的方式优化到线性复杂度，那么也就是与KMP算法持平而已。那么BM算法高出KMP算法几倍的效率，是否源自于更加合理的向后滑动策略？也就是说坏字符规则+好后缀规则，要比好前缀规则更合理？","like_count":0},{"had_liked":false,"id":48461,"user_name":"刘远通","can_delete":false,"product_type":"c1","uid":1253307,"ip_address":"","ucode":"4D3EE819E4B235","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/bb/c488d5db.jpg","comment_is_top":false,"comment_ctime":1544448390,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544448390","product_id":100017301,"comment_content":"最长可匹配前缀子串和最长可匹配后缀子串 是等价的<br>而后缀子串 是可以有递归规律的 b(r,i) 和b(r,i+1)只要看b(i+1)和b(i+1-r)是否相等  r要遍历一下 ","like_count":0},{"had_liked":false,"id":48388,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1544433515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544433515","product_id":100017301,"comment_content":"楼上回答的<br>如果 next[i-1]=k-1，也就是说，子串 b[0, k-1] 是 b[0, i-1] 的最长可匹配前缀子串。如果子串 b[0, k-1] 的下一个字符 b[k]，与 b[0, i-1] 的下一个字符 b[i] 匹配，那子串 b[0, k] 就是 b[0, i] 的最长可匹配前缀子串。所以，next[i-1] 等于 k。<br><br>---------------<br><br>末尾应该是 next[i] 等于 k<br>------------------------------------------------<br>这个文章里面也麻烦改一下，看的时候没有先看下面导致容易看错","like_count":0},{"had_liked":false,"id":48365,"user_name":"小卡向前冲","can_delete":false,"product_type":"c1","uid":1124914,"ip_address":"","ucode":"1C8908A61FA00B","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/32/6354a589.jpg","comment_is_top":false,"comment_ctime":1544428992,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544428992","product_id":100017301,"comment_content":"这几个字符串匹配算法看下来，觉得最难理解的要算是KMP算法的失效函数的获得过程了。不过多读几遍后也算是基本理解了 :-p<br>ps: 失效函数讲解最后两段中，变量y被用在了两处，表述了不同的概念哈。头两次读时，感觉有点乱~~","like_count":0},{"had_liked":false,"id":48234,"user_name":"蒋礼锐","can_delete":false,"product_type":"c1","uid":1248897,"ip_address":"","ucode":"25E042066A1427","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/gM1ibHKPkrs5DSIp4aIuQ9jnYtNicc2tdG244PbaSvKw5jO9DWrhWghcVM1Y5Iq2QSpzLBUeWZQLhARst51z35mA/132","comment_is_top":false,"comment_ctime":1544405019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544405019","product_id":100017301,"comment_content":"最难理解的是前缀好子串的理解和具体实现。不是很常见的从左往右的实现方式，而是把从右往左的和从左往右的进行匹配，具体实现上需要去循环查找i-1的前缀好子串的最长前缀好子串，这个过程的代码虽然简单，一行while，一行赋值，但是理解起来有难度。<br><br>这个最长好子串弄懂了看之前的好后缀就好看多了。","like_count":0}]}