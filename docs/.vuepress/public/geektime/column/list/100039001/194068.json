{"id":194068,"title":"42 | 单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？","content":"<p>上一节课中，我们通过两个实战案例，讲解了单例模式的一些应用场景，比如，避免资源访问冲突、表示业务概念上的全局唯一类。除此之外，我们还学习了Java语言中，单例模式的几种实现方法。如果你熟悉的是其他编程语言，不知道你课后有没有自己去对照着实现一下呢？</p><p>尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用。所以，今天，我就针对这个说法详细地讲讲这几个问题：单例这种设计模式存在哪些问题？为什么会被称为反模式？如果不用单例，该如何表示全局唯一类？有何替代的解决方案？</p><p>话不多说，让我们带着这些问题，正式开始今天的学习吧！</p><h2>单例存在哪些问题?</h2><p>大部分情况下，我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID生成器类。单例模式书写简洁、使用方便，在代码中，我们不需要创建对象，直接通过类似IdGenerator.getInstance().getId()这样的方法来调用就可以了。但是，这种使用方法有点类似硬编码（hard code），会带来诸多问题。接下来，我们就具体看看到底有哪些问题。</p><h3>1.单例对OOP特性的支持不友好</h3><!-- [[[read_end]]] --><p>我们知道，OOP的四大特性是封装、抽象、继承、多态。单例这种设计模式对于其中的抽象、继承、多态都支持得不好。为什么这么说呢？我们还是通过IdGenerator这个例子来讲解。</p><pre><code>public class Order {\n  public void create(...) {\n    //...\n    long id = IdGenerator.getInstance().getId();\n    //...\n  }\n}\n\npublic class User {\n  public void create(...) {\n    // ...\n    long id = IdGenerator.getInstance().getId();\n    //...\n  }\n}\n</code></pre><p>IdGenerator的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的OOP的抽象特性。如果未来某一天，我们希望针对不同的业务采用不同的ID生成算法。比如，订单ID和用户ID采用不同的ID生成器来生成。为了应对这个需求变化，我们需要修改所有用到IdGenerator类的地方，这样代码的改动就会比较大。</p><pre><code>public class Order {\n  public void create(...) {\n    //...\n    long id = IdGenerator.getInstance().getId();\n    // 需要将上面一行代码，替换为下面一行代码\n    long id = OrderIdGenerator.getIntance().getId();\n    //...\n  }\n}\n\npublic class User {\n  public void create(...) {\n    // ...\n    long id = IdGenerator.getInstance().getId();\n    // 需要将上面一行代码，替换为下面一行代码\n    long id = UserIdGenerator.getIntance().getId();\n  }\n}\n</code></pre><p>除此之外，单例对继承、多态特性的支持也不友好。这里我之所以会用“不友好”这个词，而非“完全不支持”，是因为从理论上来讲，单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪，会导致代码的可读性变差。不明白设计意图的人，看到这样的设计，会觉得莫名其妙。所以，一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性。</p><h3>2.单例会隐藏类之间的依赖关系</h3><p>我们知道，代码的可读性非常重要。在阅读代码的时候，我们希望一眼就能看出类与类之间的依赖关系，搞清楚这个类依赖了哪些外部类。</p><p>通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，我们就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。</p><h3>3.单例对代码的扩展性不友好</h3><p>我们知道，单例类只能有一个对象实例。如果未来某一天，我们需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动。你可能会说，会有这样的需求吗？既然单例类大部分情况下都用来表示全局类，怎么会需要两个或者多个实例呢？</p><p>实际上，这样的需求并不少见。我们拿数据库连接池来举例解释一下。</p><p>在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。但之后我们发现，系统中有些SQL语句运行得非常慢。这些SQL语句在执行的时候，长时间占用数据库连接资源，导致其他SQL请求无法响应。为了解决这个问题，我们希望将慢SQL与其他SQL隔离开来执行。为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢SQL独享一个数据库连接池，其他SQL独享另外一个数据库连接池，这样就能避免慢SQL影响到其他SQL的执行。</p><p>如果我们将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设计成单例类。</p><h3>4.单例对代码的可测试性不友好</h3><p>单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如DB，我们在写单元测试的时候，希望能通过mock的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现mock替换。</p><p>除此之外，如果单例类持有成员变量（比如IdGenerator中的id成员变量），那它实际上相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是说，它的成员变量是可以被修改的，那我们在编写单元测试的时候，还需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题。关于这一点，你可以回过头去看下<a href=\"https://time.geekbang.org/column/article/186691\">第29讲</a>中的“其他常见的Anti-Patterns：全局变量”那部分的代码示例和讲解。</p><h3>5.单例不支持有参数的构造函数</h3><p>单例不支持有参数的构造函数，比如我们创建一个连接池的单例对象，我们没法通过参数来指定连接池的大小。针对这个问题，我们来看下都有哪些解决方案。</p><p>第一种解决思路是：创建完实例之后，再调用init()函数传递参数。需要注意的是，我们在使用这个单例类的时候，要先调用init()方法，然后才能调用getInstance()方法，否则代码会抛出异常。具体的代码实现如下所示：</p><pre><code>public class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton(int paramA, int paramB) {\n    this.paramA = paramA;\n    this.paramB = paramB;\n  }\n\n  public static Singleton getInstance() {\n    if (instance == null) {\n       throw new RuntimeException(&quot;Run init() first.&quot;);\n    }\n    return instance;\n  }\n\n  public synchronized static Singleton init(int paramA, int paramB) {\n    if (instance != null){\n       throw new RuntimeException(&quot;Singleton has been created!&quot;);\n    }\n    instance = new Singleton(paramA, paramB);\n    return instance;\n  }\n}\n\nSingleton.init(10, 50); // 先init，再使用\nSingleton singleton = Singleton.getInstance();\n</code></pre><p>第二种解决思路是：将参数放到getIntance()方法中。具体的代码实现如下所示：</p><pre><code>public class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton(int paramA, int paramB) {\n    this.paramA = paramA;\n    this.paramB = paramB;\n  }\n\n  public synchronized static Singleton getInstance(int paramA, int paramB) {\n    if (instance == null) {\n      instance = new Singleton(paramA, paramB);\n    }\n    return instance;\n  }\n}\n\nSingleton singleton = Singleton.getInstance(10, 50);\n</code></pre><p>不知道你有没有发现，上面的代码实现稍微有点问题。如果我们如下两次执行getInstance()方法，那获取到的singleton1和signleton2的paramA和paramB都是10和50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提示，这样就会误导用户。这个问题如何解决呢？留给你自己思考，你可以在留言区说说你的解决思路。</p><pre><code>Singleton singleton1 = Singleton.getInstance(10, 50);\nSingleton singleton2 = Singleton.getInstance(20, 30);\n</code></pre><p>第三种解决思路是：将参数放到另外一个全局变量中。具体的代码实现如下。Config是一个存储了paramA和paramB值的全局变量。里面的值既可以像下面的代码那样通过静态常量来定义，也可以从配置文件中加载得到。实际上，这种方式是最值得推荐的。</p><pre><code>public class Config {\n  public static final int PARAM_A = 123;\n  public static final int PARAM_B = 245;\n}\n\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton() {\n    this.paramA = Config.PARAM_A;\n    this.paramB = Config.PARAM_B;\n  }\n\n  public synchronized static Singleton getInstance() {\n    if (instance == null) {\n      instance = new Singleton();\n    }\n    return instance;\n  }\n}\n</code></pre><h2>有何替代解决方案？</h2><p>刚刚我们提到了单例的很多问题，你可能会说，即便单例有这么多问题，但我不用不行啊。我业务上有表示全局唯一类的需求，如果不用单例，我怎么才能保证这个类的对象全局唯一呢？</p><p>为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。这也是项目开发中经常用到的一种实现思路。比如，上一节课中讲的ID唯一递增生成器的例子，用静态方法实现一下，就是下面这个样子：</p><pre><code>// 静态方法实现方式\npublic class IdGenerator {\n  private static AtomicLong id = new AtomicLong(0);\n  \n  public static long getId() { \n    return id.incrementAndGet();\n  }\n}\n// 使用举例\nlong id = IdGenerator.getId();\n</code></pre><p>不过，静态方法这种实现思路，并不能解决我们之前提到的问题。实际上，它比单例更加不灵活，比如，它无法支持延迟加载。我们再来看看有没有其他办法。实际上，单例除了我们之前讲到的使用方法之外，还有另外一种使用方法。具体的代码如下所示：</p><pre><code>// 1. 老的使用方式\npublic demofunction() {\n  //...\n  long id = IdGenerator.getInstance().getId();\n  //...\n}\n\n// 2. 新的使用方式：依赖注入\npublic demofunction(IdGenerator idGenerator) {\n  long id = idGenerator.getId();\n}\n// 外部调用demofunction()的时候，传入idGenerator\nIdGenerator idGenerator = IdGenerator.getInsance();\ndemofunction(idGenerator);\n</code></pre><p>基于新的使用方式，我们将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其他问题，比如对OOP特性、扩展性、可测性不友好等问题，还是无法解决。</p><p>所以，如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类。实际上，类对象的全局唯一性可以通过多种不同的方式来保证。我们既可以通过单例模式来强制保证，也可以通过工厂模式、IOC容器（比如Spring IOC容器）来保证，还可以通过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。这就类似Java中内存对象的释放由JVM来负责，而C++中由程序员自己负责，道理是一样的。</p><p>对于替代方案工厂模式、IOC容器的详细讲解，我们放到后面的章节中讲解。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。</p><p><strong>1.单例存在哪些问题？</strong></p><ul>\n<li>单例对OOP特性的支持不友好</li>\n<li>单例会隐藏类之间的依赖关系</li>\n<li>单例对代码的扩展性不友好</li>\n<li>单例对代码的可测试性不友好</li>\n<li>单例不支持有参数的构造函数</li>\n</ul><p><strong>2.单例有什么替代解决方案？</strong></p><p>为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。不过，静态方法这种实现思路，并不能解决我们之前提到的问题。如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类了。比如，通过工厂模式、IOC容器（比如Spring IOC容器）来保证，由程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。</p><p>有人把单例当作反模式，主张杜绝在项目中使用。我个人觉得这有点极端。模式没有对错，关键看你怎么用。如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局的类，我们在其他地方new的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。</p><h2>课堂讨论</h2><p>1.如果项目中已经用了很多单例模式，比如下面这段代码，我们该如何在尽量减少代码改动的情况下，通过重构代码来提高代码的可测试性呢？</p><pre><code>public class Demo {\n  private UserRepo userRepo; // 通过构造哈函数或IOC容器依赖注入\n  \n  public boolean validateCachedUser(long userId) {\n    User cachedUser = CacheManager.getInstance().getUser(userId);\n    User actualUser = userRepo.getUser(userId);\n    // 省略核心逻辑：对比cachedUser和actualUser...\n  }\n}\n</code></pre><p>2.在单例支持参数传递的第二种解决方案中，如果我们两次执行getInstance(paramA, paramB)方法，第二次传递进去的参数是不生效的，而构建的过程也没有给与提示，这样就会误导用户。这个问题如何解决呢？</p><pre><code>Singleton singleton1 = Singleton.getInstance(10, 50);\nSingleton singleton2 = Singleton.getInstance(20, 30);\n</code></pre><p>欢迎留言和我分享你的思考和见解。如果有收获，也欢迎你把文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":176344,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1581039489,"is_pvip":false,"discussion_count":20,"race_medal":1,"score":"482617376641","product_id":100039001,"comment_content":"课堂讨论，<br>1. 把代码“User cachedUser = CacheManager.getInstance().getUser(userId);”单独提取出来做成一个单独的函数，这样这个函数就可以进行mock了，进而方便测试validateCachedUser。<br>2. 可以判断传进来的参数和已经存在的instance里面的两个成员变量的值，如果全部相等，就直接返回已经存在的instance，否则就新创建一个instance返回。示例如下：<br><br>public synchronized static Singleton getInstance(int paramA, int paramB) { <br>    if (instance == null) { <br>        instance = new Singleton(paramA, paramB); <br>    } else if (instance.paramA == paramA &amp;&amp; instance.paramB == paramB) {<br>        return instance;<br>    } else {<br>        instance = new Singleton(paramA, paramB);<br>    }<br>    return instance; <br>}","like_count":113,"discussions":[{"author":{"id":1231549,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ca/bd/a51ae4b2.jpg","nickname":"吃饭饭","note":"","ucode":"95CFA07CDA2957","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49759,"discussion_content":"这个貌似在 Java 编程思想中提到过，是可以这么理解的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573631492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176503,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1581073343,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"327998587839","product_id":100039001,"comment_content":"模式没有对错，关键看你怎么用。这句话说的很对，所以其实所谓单例模式的缺点这种说法还是有点牵强！","like_count":77,"discussions":[{"author":{"id":2336999,"avatar":"https://static001.geekbang.org/account/avatar/00/23/a8/e7/bedf7932.jpg","nickname":"哇哈哈","note":"","ucode":"3A4FD1A3E657C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559692,"discussion_content":"个人觉得单例模式是一种思想，要看你怎么实现这种思想，就java 目前那几种实现思想的代码有局限性，所以说叫做缺点，这才需要改进使它可以满足一些其他的业务需求吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648883573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015189,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/95/dd73022c.jpg","nickname":"我是曾经那个少年","note":"","ucode":"9F02F7FF147D14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530425,"discussion_content":"是的，用单例要知道他使用的场景。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637071845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185662,"user_name":"Richie","can_delete":false,"product_type":"c1","uid":1019588,"ip_address":"","ucode":"12314EF0347693","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","comment_is_top":false,"comment_ctime":1583657389,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"250691760557","product_id":100039001,"comment_content":"课堂讨论第2点，我认为应该先搞清楚需求，为什么需要在getInstance()方法中加参数，想要达到什么目的？<br>这里分两种情况讨论一下：<br>1. 如果的确需要一个全局唯一的类，并且这个类只能被初始化一次，那么应该采用文中提到的第三种解决思路，即将所需参数放到全局的配置文件中，从而避免多次初始化参数被忽略或者抛出运行时异常的问题；<br>2. 如果是要根据不同参数构造出不同的对象，并且相同参数的对象只被构造一次，那么应该改成在Singleton类中维护一个HashMap，然后每次调用getInstance()方法的时候，根据参数去判断对象是否已经存在了（可以采用双重检测），存在则直接返回，不存在再去创建，然后存储，返回。个人理解，这应该是单例+简单工厂的结合。","like_count":59,"discussions":[{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293265,"discussion_content":"思路清晰，棒","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1595494918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1019588,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","nickname":"Richie","note":"","ucode":"12314EF0347693","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293419,"discussion_content":"谢谢鼓励😬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595524659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":293265,"ip_address":""},"score":293419,"extra":""}]},{"author":{"id":1049235,"avatar":"https://static001.geekbang.org/account/avatar/00/10/02/93/fed4baec.jpg","nickname":"Null","note":"","ucode":"D48077EBAD2E87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388682,"discussion_content":"赞同！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628909654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180740,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1582379036,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"126136430620","product_id":100039001,"comment_content":"设计模式_42:<br># 作业<br>1. 可以把单例的对象以依赖注入的方式传入方法；<br>2. 第二次调用时，如果参数发生了变化，应该抛出异常。<br><br># 感想<br>坦白讲，一直以使用双重检测沾沾自喜。。。现在看来，要不要使用单例要比使用那种单例的实现方式更需要投入思考。","like_count":29,"discussions":[{"author":{"id":1055475,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","nickname":"iLeGeND","note":"","ucode":"4055A628A6E97C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352064,"discussion_content":"优雅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614588515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":209710,"user_name":"林子er","can_delete":false,"product_type":"c1","uid":1629256,"ip_address":"","ucode":"85637288F22CF0","user_header":"https://static001.geekbang.org/account/avatar/00/18/dc/48/9796286e.jpg","comment_is_top":false,"comment_ctime":1587603843,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61717145987","product_id":100039001,"comment_content":"由于单例本身存在的一系列缺点，而单例一般又都是全局的，因而一般我们项目中很少直接使用单例，而是通过容器注入，让容器充当单例和工厂。有时候我们甚至使用伪单例，即类本身并不是单例的，而是通过容器保证单例性，实际编程中按照约定只通过容器获取该实例。<br>参数化单例实际中是通过Map解决的，即同样的参数才返回同一个实例，不同的参数返回不同的实例，为了保证实例不会太多，一般可传的参数我们会事先做了限制，比如只能使用配置文件中配置的（如数据库连接池的名称）","like_count":15},{"had_liked":false,"id":176413,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1581053702,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"35940792070","product_id":100039001,"comment_content":"1. 如果项目中已经用了很多单例模式，比如下面这段代码，我们该如何在尽量减少代码改动的情况下，通过重构代码来提高代码的可测试性呢？<br>CacheManager.getInstance(long userId)中增加Mock开关，如：<br>private User mockUser;<br>public CacheManager.setMockObj(User mockUser)<br>public User getInstance(long userId) {<br>     if(mockUser != null &amp;&amp; mockUser.getUserId() == userId) {<br>          return mockUser<br>     }<br>}<br>2. 在单例支持参数传递的第二种解决方案中，如果我们两次执行 getInstance(paramA, paramB) 方法，第二次传递进去的参数是不生效的，而构建的过程也没有给与提示，这样就会误导用户。这个问题如何解决呢？<br>第一次构造Instance成功时需要记录paramA和paramB，在以后的调用需要匹配paramA与paramB构造成功Instance时的参数是否一至，不一至时需要抛出异常。","like_count":8},{"had_liked":false,"id":202103,"user_name":"小麦","can_delete":false,"product_type":"c1","uid":1216881,"ip_address":"","ucode":"55C7199A0D5659","user_header":"https://static001.geekbang.org/account/avatar/00/12/91/71/0b16655d.jpg","comment_is_top":false,"comment_ctime":1585903525,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"27355707301","product_id":100039001,"comment_content":"不太能理解的使用方式违背了基于接口而非实现的设计原则，比如 spring 中的 service 类一般也是单例的，也是继承接口，controller 的调用也是基于接口，不觉得有什么问题啊，如果实现类变了，也只是改注入而已啊。 ","like_count":6,"discussions":[{"author":{"id":1456188,"avatar":"https://static001.geekbang.org/account/avatar/00/16/38/3c/77738aa4.jpg","nickname":"毫无根据的沉溺于美妙的幻想","note":"","ucode":"CE318147D99E3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49543,"discussion_content":"OC 是Objective-C? 那它不支持多继承啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573611748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176308,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1581012441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27350816217","product_id":100039001,"comment_content":"打卡","like_count":6},{"had_liked":false,"id":176397,"user_name":"Eden Ma","can_delete":false,"product_type":"c1","uid":1457408,"ip_address":"","ucode":"755312F0D154F9","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/00/7daa7403.jpg","comment_is_top":false,"comment_ctime":1581049024,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23055885504","product_id":100039001,"comment_content":"<br>2、instance不为空抛出异常","like_count":5,"discussions":[{"author":{"id":1239557,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","nickname":"一道阳光","note":"","ucode":"F35207CCCEC6E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49498,"discussion_content":"对，我也想到了这点，但是为啥有些需要可以实现多重继承呢？百思不得其解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573606124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178311,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1581658828,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10171593420","product_id":100039001,"comment_content":"2.可以使用反射修改单例中参数信息","like_count":2},{"had_liked":false,"id":176952,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1581235090,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10171169682","product_id":100039001,"comment_content":"1.下面这段代码，我们该如何在尽量减少代码改动的情况下，通过重构代码来提高代码的可测试性呢？<br>将单例类中新增一个用于获取测试instance的函数,命名getTestInstance(User testUser),该函数中把需要的测试用例通过参数传入instance当中,当要做测试时就可以通过getTestInstance函数来获取实例得到需要的测试数据.<br>public boolean validateCachedUser(long userId) {<br>    User actualUser = userRepo.getUser(userId);<br>    &#47;&#47;User cachedUser = CacheManager.getInstance().getUser(userId);&#47;&#47;生产使用<br>    User cachedUser = CacheManager.getTestInstance(actualUser).getUser(userId);&#47;&#47;测试使用<br>    &#47;&#47; 省略核心逻辑：对比cachedUser和actualUser...<br>  }<br>2.第二次传递进去的参数是不生效的，而构建的过程也没有给与提示，这样就会误导用户。这个问题如何解决呢？<br>第二次调用getInstance时如果带有与之前相同参数就直接返回instance实例;如果参数不相同且业务允许构建新的instance实例就允许再第二次getInstance时构建新的实例,如果业务不允许就在构建时抛出异常.<br>public synchronized static Singleton getInstance(int paramA, int paramB) {<br>    if (instance == null) {<br>      instance = new Singleton(paramA, paramB);<br>    } else if (this.paramA != paramA || this.paramB != paramB) {<br>       &#47;&#47;instance = new Singleton(paramA, paramB);&#47;&#47; 业务允许<br>       throw new RuntimeException(&quot;Singleton has been created!&quot;);&#47;&#47; 业务不允许<br>   }<br>    return instance;<br>  }","like_count":2},{"had_liked":false,"id":176357,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1581042238,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"10170976830","product_id":100039001,"comment_content":"思考题1：<br>提出一个方法：public Uer getCahcedUser(userId){}，然后mock getCahcedUser方法。<br>测试：<br>public boolean validateCachedUesr(userid){<br>  User cachedUser = getMockCachedUser…<br>  User actualUser = userRepo.getUser(userid)<br>&#47;&#47; validate …<br>}<br><br>思考题2：<br>A singleton with parameters is NOT a singleton because you may have more object than one of them.<br>改进：得到单例对象后，再初始化参数。<br>SingletonObj singleton = SingletonObj.getInstance()<br>singleton.init(paramA, paramB)<br>","like_count":2,"discussions":[{"author":{"id":1153978,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","nickname":"Linuxer","note":"","ucode":"272D9D8089C3D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49961,"discussion_content":"不是你是这样，我也如此","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573653478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217443,"user_name":"Roger宇","can_delete":false,"product_type":"c1","uid":1703222,"ip_address":"","ucode":"CBA23C01409349","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/36/f947c340.jpg","comment_is_top":false,"comment_ctime":1589506215,"is_pvip":false,"replies":[{"id":"80476","content":"根据业务来估算的，有些业务本身就很慢，就判定为慢sql","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1589524621,"ip_address":"","comment_id":217443,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5884473511","product_id":100039001,"comment_content":"想问一下老师，所谓两个资源池，慢的请求独占一个的设计，如何知道一个sql请求会快会慢？快与慢更多是在运行后才知道的，已经进去运行了还怎么保证独占呢？除非有机制可以在处理sql请求之前评估可能需要的时间。","like_count":2,"discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49493,"discussion_content":"Go只有接口，哈哈哈！进一步简化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573605791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202817,"user_name":"小动物","can_delete":false,"product_type":"c1","uid":1031683,"ip_address":"","ucode":"BCC35CE768EB99","user_header":"https://static001.geekbang.org/account/avatar/00/0f/be/03/404edf37.jpg","comment_is_top":false,"comment_ctime":1586073571,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881040867","product_id":100039001,"comment_content":"之前重构过一个简单业务模块，原入口是一个简单的单例：biz1class.getinstance().doSomething()。但新需求单例模式不支持，需要支持不同处理业务的模式，于是重构。<br>当时的思路是，其实实际业务代码并不关心getinstance()后返回的是什么。所以这个方法的返回类型由原来的类换成接口对业务代码而言，基本无影响，最多重新编译下代码。<br>所以最后的方案是将原业务类提供的方法提取成合适的接口，并编写相关实现类。原getInstance()方法返回类型改成接口。并根据当前配置返回不同的实现类以满足不同的处理方式。<br><br>基于这个思路，文章中的问题应该就能解决了。让原先的biz1class的getinstance方法支持返回自己想要的实现即可。","like_count":1},{"had_liked":false,"id":176548,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1581084545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876051841","product_id":100039001,"comment_content":" 第一个问题，为了增加可测试性，也就是尽量可以测试中间结果。我觉得可以将cacheUser那一行代码和下一行代码分别抽取出来封装📦。<br>第二个问题，可以将参数保存在静态类中，本身这个类新增一个init函数，在new 对象后进行调用init。这样用户可以不需要加载参数。当然了，如果一定要在getInstance时传入参数，那么也可以校验参数是否和上一次传入的参数是否一致。","like_count":1},{"had_liked":false,"id":358408,"user_name":"@二十一大叔","can_delete":false,"product_type":"c1","uid":1075954,"ip_address":"上海","ucode":"394A7E80C5034C","user_header":"https://static001.geekbang.org/account/avatar/00/10/6a/f2/8829a0b8.jpg","comment_is_top":false,"comment_ctime":1664276132,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664276132","product_id":100039001,"comment_content":"1.<br>public class Demo {<br><br>        private UserRepo userRepo; &#47;&#47; 通过构造哈函数或IOC容器依赖注入<br>        private CacheManager cacheManager; &#47;&#47; 将获取CacheManager对象提出来，通过依赖注入的方式初始化<br><br>        public Demo(CacheManager cacheManager){<br>            this.cacheManager = cacheManager;<br>        }<br><br>        public boolean validateCachedUser(long userId) {<br>            User cachedUser = getCachedUser(userId);<br>            User actualUser =userRepo.getUser(userId);<br>            &#47;&#47; 省略核心逻辑：对比cachedUser和actualUser...<br>        }<br>        <br>        public User getCachedUser(long userId){<br>            return cacheManager.getInstance().getUser(userId);<br>        }<br><br>        static class MockManager extends CacheManager {<br>            private static MockManager mockManager;<br>            <br>            private MockManager(){}<br><br>            public static MockManager getInstance(){<br>                &#47;&#47;todo<br>                return mockManager;<br>            }<br><br>            public static User getUser(long userId){<br>                &#47;&#47; 返回mock数据<br>                return new User(userId);<br>            }<br>        }<br><br>    public static void main(String[] args) {<br>        CacheManager cacheManager = MockManager().getInstance();<br>        Demo demo = new Demo(cacheManager);<br>        User user = demo.getCachedUser(123L);<br>    }","like_count":0},{"had_liked":false,"id":354747,"user_name":"红烧冰淇淋","can_delete":false,"product_type":"c1","uid":2650490,"ip_address":"北京","ucode":"CF59ECC2FE70C6","user_header":"https://static001.geekbang.org/account/avatar/00/28/71/7a/3230370a.jpg","comment_is_top":false,"comment_ctime":1660741331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660741331","product_id":100039001,"comment_content":"难道单例模式最大的问题不是没办法横向扩展吗？<br><br>现在都是多实例部署了，单个实例内部的单例模式没有啥意义","like_count":1},{"had_liked":false,"id":350540,"user_name":"搬砖农民工👩‍🌾","can_delete":false,"product_type":"c1","uid":2873541,"ip_address":"","ucode":"50E0602562E968","user_header":"https://static001.geekbang.org/account/avatar/00/2b/d8/c5/6a553741.jpg","comment_is_top":false,"comment_ctime":1656993362,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656993362","product_id":100039001,"comment_content":"上节课中又说道，静态内部类也可以做到延迟加载，这节课说做不到，我看了下菜鸟教程，静态内部类是可以做到延迟加载的，不知是我理解做错了，还是老师不小心打错了","like_count":0},{"had_liked":false,"id":342969,"user_name":"Geek_7e0e83","can_delete":false,"product_type":"c1","uid":2142423,"ip_address":"","ucode":"554DEE2AAAE33C","user_header":"","comment_is_top":false,"comment_ctime":1650554154,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650554154","product_id":100039001,"comment_content":"1. 可以把单例的获取ID的功能移到另一个函数中封装起来，然后mock那个新的方法即可<br>2.可以当instance不为null 的时候 打印warn日志，提示用户输入的参数已经不生效了，或者换别的方式实现单例，比如配置文件的方式。而不是在instance方法上加入参","like_count":0},{"had_liked":false,"id":334311,"user_name":"知行","can_delete":false,"product_type":"c1","uid":1802022,"ip_address":"","ucode":"5AC8CBCC0AD48B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7f/26/c5127e9a.jpg","comment_is_top":false,"comment_ctime":1644884359,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644884359","product_id":100039001,"comment_content":"其实，单例模式可以被反射破坏","like_count":0},{"had_liked":false,"id":319498,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1635836854,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635836854","product_id":100039001,"comment_content":"总结<br>1、单例存在哪些问题?<br>\t1. 单例对 OOP 特性的支持不友好<br>\t2. 单例会隐藏类之间的依赖关系<br>\t3. 单例对代码的扩展性不友好<br>\t4. 单例对代码的可测试性不友好<br>\t5. 单例不支持有参数的构造函数<br>2、有何替代解决方案？<br>\t保证全局唯一，还可以使用静态方法。但它也不够灵活，不能懒加载<br>\t工厂模式、IOC 容器（比如 Spring IOC 容器）也可以保证唯一","like_count":0},{"had_liked":false,"id":319495,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1635836387,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635836387","product_id":100039001,"comment_content":"作业<br>1、两个对象以参数传入，然后直接对比2个对象即可，外部可以单写2个方法<br>2、看了好多评论个人看法有两个，一如果业务需要存在不同参数的实例，那单例的设计其实就不符合了；二如果需要只能一个实例，且根据业务参数实时变动那最好是开放一个update方法取修改，初始化就一次，后面修改用update方法","like_count":0},{"had_liked":false,"id":316920,"user_name":"MOSLX","can_delete":false,"product_type":"c1","uid":2732715,"ip_address":"","ucode":"FFE0FE1AED2BFB","user_header":"https://static001.geekbang.org/account/avatar/00/29/b2/ab/db3ce62d.jpg","comment_is_top":false,"comment_ctime":1634613271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634613271","product_id":100039001,"comment_content":"课堂讨论2，尝试维护一个HashMap容器，应该能根据不同的参数保持单例   <br> private static ParamSingleton instance = null;<br>    private static HashMap&lt;String, ParamSingleton&gt; context = new HashMap&lt;&gt;();<br>    private final int paramA;<br>    private final int paramB;<br><br>    private ParamSingleton(int paramA, int paramB){<br>        this.paramA = paramA;<br>        this.paramB = paramB;<br>    }<br><br>    public synchronized static ParamSingleton getInstance(int paramA, int paramB){<br>        String key = paramA + &quot;-&quot; + paramB;<br>        if(instance == null){<br>            instance = new ParamSingleton(paramA,paramB);<br>            context.put(key,instance);<br>        } else {<br>            instance = context.computeIfAbsent(key,k -&gt; new ParamSingleton(paramA,paramB));<br>        }<br>        return instance;<br>    }","like_count":0},{"had_liked":false,"id":304493,"user_name":"连星科技","can_delete":false,"product_type":"c1","uid":2642229,"ip_address":"","ucode":"C84FF7FF4AAE56","user_header":"https://static001.geekbang.org/account/avatar/00/28/51/35/d3a1144b.jpg","comment_is_top":false,"comment_ctime":1627454575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627454575","product_id":100039001,"comment_content":"go 语言可以用静态全局对象，结构对象命名小写，只能通过一个Get函数去获取。","like_count":0},{"had_liked":false,"id":296733,"user_name":"小江爱学术","can_delete":false,"product_type":"c1","uid":2628601,"ip_address":"","ucode":"554F40C6627AF4","user_header":"https://static001.geekbang.org/account/avatar/00/28/1b/f9/018197f1.jpg","comment_is_top":false,"comment_ctime":1623136180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623136180","product_id":100039001,"comment_content":"问题1. 在构造方法中通过参数的形式把单例传进来。<br>问题2. 既然叫单例，我认为本身就应该保证全局唯一性，通过getInstance传参的方法希望单例可以根据传参的不同动态改变，我认为本身不太可取，是令人疑惑的做法，还是应该在单例类中，以配置文件的方式加载参数，保证单例唯一性","like_count":0},{"had_liked":false,"id":295058,"user_name":"庄周梦蝶","can_delete":false,"product_type":"c1","uid":1693576,"ip_address":"","ucode":"7878ED3EB11E97","user_header":"https://static001.geekbang.org/account/avatar/00/19/d7/88/7dcde249.jpg","comment_is_top":false,"comment_ctime":1622199566,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1622199566","product_id":100039001,"comment_content":"老师，您讲的代替方案的意思不还是要保证只有一个实例么，也属于单例吧？","like_count":0},{"had_liked":false,"id":294944,"user_name":"JKwar","can_delete":false,"product_type":"c1","uid":1047466,"ip_address":"","ucode":"B733CA24D5701F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/aa/01fedf6c.jpg","comment_is_top":false,"comment_ctime":1622163168,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1622163168","product_id":100039001,"comment_content":"课堂讨论一：可以通过依赖注入的方式提高代码的可测试性，mock类即刻。<br>课堂讨论二：直接判断是否已经初始化，已经初始化就直接抛出异常。","like_count":0},{"had_liked":false,"id":288064,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1618284408,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618284408","product_id":100039001,"comment_content":"1、考虑将单例CacheManger单例对象作为Demo类的成员变量，通过构造函数注入，那就可以通过Mock出指定User对象进行后续对比测试<br>2、主要还是考察需求是这样的，按原文意思是需要不同参数不同实例，那么可以考虑通过Map维护传入参数和实例的映射关系，需要注意构建过程的安全性和指定参数的唯一性","like_count":0},{"had_liked":false,"id":279105,"user_name":"辉","can_delete":false,"product_type":"c1","uid":1697810,"ip_address":"","ucode":"0D7B2C24BA8BD2","user_header":"https://static001.geekbang.org/account/avatar/00/19/e8/12/74f387c8.jpg","comment_is_top":false,"comment_ctime":1613623236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613623236","product_id":100039001,"comment_content":"单例的出现就是为了解决一些存在的问题而出现的。至于说这是一种反模式，我觉得不太妥。任何东西都有两面性，单例也一样。对于一些公共的管理类来说，单例确实是比较好的选择。比如我要管理一个全局的网络状态，这时候讲这个管理类设置为单例就是合理的。","like_count":0},{"had_liked":false,"id":267475,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1607761564,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1607761564","product_id":100039001,"comment_content":"1. 把User cachedUser = CacheManager.getInstance().getUser(userId); <br>User actualUser = userRepo.getUser(userId);拆成两个方法，便于使用mock测试<br>2. getInstance方法不要加参数。","like_count":0},{"had_liked":false,"id":259777,"user_name":"心有不甘","can_delete":false,"product_type":"c1","uid":2222598,"ip_address":"","ucode":"4B48BC4B357C3A","user_header":"https://static001.geekbang.org/account/avatar/00/21/ea/06/1bfbbf4f.jpg","comment_is_top":false,"comment_ctime":1604830351,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604830351","product_id":100039001,"comment_content":"讨论一：<br>  啥是mock啊，啥是可测试性呢。 如果我要测试validateCachedUser(long userId) 方法, 直接单元测试这个方法, 传递参数进去，用断言判断运行值和期望值，这个算测试么？没有理解单例模式对这里的影响。<br><br>讨论二：为什么类中的参数AB要设置成final呢，不提供修改方法，值也会修改么。可否去掉final,在getInsatance方法中，再加入一次赋值呢?<br><br>public class Singleton { <br>  private static Singleton instance = null; <br>  private int paramA; <br>  private int paramB; <br>  private Singleton(int paramA, int paramB) { <br>    this.paramA = paramA; <br>    this.paramB = paramB; <br>  } <br>  public synchronized static Singleton getInstance(int paramA, int paramB) { <br>    if (instance == null) { <br>      instance = new Singleton(paramA, paramB); <br>    } <br>    instance.paramA = paramA;<br>    instance.paramB = paramB;<br>    return instance; <br>  }<br>}<br>","like_count":0},{"had_liked":false,"id":257411,"user_name":"Daiver","can_delete":false,"product_type":"c1","uid":1466447,"ip_address":"","ucode":"9B1A03AFBC79BC","user_header":"https://static001.geekbang.org/account/avatar/00/16/60/4f/db0e62b3.jpg","comment_is_top":false,"comment_ctime":1603962907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603962907","product_id":100039001,"comment_content":"内部使用一个Map，参数AB作为key，map存在则直接返回，map不存在实例化一个，并存入map中，然后返回。","like_count":0},{"had_liked":false,"id":253458,"user_name":"RedDevil","can_delete":false,"product_type":"c1","uid":1131128,"ip_address":"","ucode":"F8F5DC209BB3B9","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/78/7ba89c75.jpg","comment_is_top":false,"comment_ctime":1602744320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602744320","product_id":100039001,"comment_content":"看争哥的文章有种茅塞顿开的感觉","like_count":0},{"had_liked":false,"id":250696,"user_name":"Gopher","can_delete":false,"product_type":"c1","uid":1206229,"ip_address":"","ucode":"3C1F9012BB486D","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","comment_is_top":false,"comment_ctime":1601198500,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601198500","product_id":100039001,"comment_content":"1、应该是把CacheManger这个对应的类作为参数传到一个函数里，通过函数来getInstance()，这样mock 的CacheManger 就可以作为参数传进去了<br><br>2、抛出异常，如果是通过不同参数来返回不同的实例，就不应该用单利来做了","like_count":0},{"had_liked":false,"id":249774,"user_name":"Leaf","can_delete":false,"product_type":"c1","uid":1102194,"ip_address":"","ucode":"9AB56B7971237D","user_header":"https://static001.geekbang.org/account/avatar/00/10/d1/72/4cc8475c.jpg","comment_is_top":false,"comment_ctime":1600785885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600785885","product_id":100039001,"comment_content":"题目一，可以用一个类包一层，封装下 CacheManager，然后 mock 这封装类<br>题目二，如果允许存在参数不同实例不同，可以用支持并发的字典保存对象(key为params生成），这样就能支持参数不同实例不同","like_count":0},{"had_liked":false,"id":248068,"user_name":"神毓逍遥","can_delete":false,"product_type":"c1","uid":2147220,"ip_address":"","ucode":"83351CB18B190E","user_header":"https://static001.geekbang.org/account/avatar/00/20/c3/94/e89ebc50.jpg","comment_is_top":false,"comment_ctime":1599999909,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1599999909","product_id":100039001,"comment_content":"我是Python开发者，第二种希望传入参数生效是有这个场景需求的，比如数据库连接池，当在fork子进程时，配置参数发生变化时，希望重新生成对象，这时候需要不在__init__中实例化，而设计一个新函数，当传入force_refresh参数为True时重新实例化","like_count":0,"discussions":[{"author":{"id":1079816,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7a/08/4d3e47dd.jpg","nickname":"Aaron Cheung","note":"","ucode":"03972759C53667","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305763,"discussion_content":"很赞的分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600078471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242481,"user_name":"木子","can_delete":false,"product_type":"c1","uid":1784886,"ip_address":"","ucode":"F9548C192F9687","user_header":"https://static001.geekbang.org/account/avatar/00/1b/3c/36/94762d1c.jpg","comment_is_top":false,"comment_ctime":1597739114,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597739114","product_id":100039001,"comment_content":"在我们视野内（经验或者业务建模上），立足脚下的取应用单例模式","like_count":0},{"had_liked":false,"id":238508,"user_name":"Next","can_delete":false,"product_type":"c1","uid":1748213,"ip_address":"","ucode":"D5ADDF248A9504","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ac/f5/2f97e279.jpg","comment_is_top":false,"comment_ctime":1596185766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596185766","product_id":100039001,"comment_content":"针对单例扩展性的解决方法举例：<br>用户ID生成器：<br>语义是真正的全局唯一，采用单列；<br>且；<br>ID生成算法是可变更的，所以不直接使用某个通用的ID生成器，而是构建一个新的用户ID专用的生成器，包含某个实际的ID生成类的引用。如下，如果要更换ID的生成方法，只需替换掉SimpleSequenceIDGen。<br>public enum UserID {<br>    I;<br>    private IIDLongGen gen = new SimpleSequenceIDGen();<br><br>    public long generate() {<br>        return gen.generate();<br>    }<br><br>}","like_count":0},{"had_liked":false,"id":237939,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1596010232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596010232","product_id":100039001,"comment_content":"我的想法是，单例也是可以实现接口的，可以通过面向接口依赖注入。","like_count":0},{"had_liked":false,"id":237541,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1595858875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595858875","product_id":100039001,"comment_content":"第一个问题 前面的代码测试性已经讲过，将需要用到单例的功能再wrap出来一个函数和子类，测试时mock这个子类 并测试这个包裹函数即可。<br>第二个问题，还是用个 init或者updateParameter比较好 ，不过项目中几乎没有遇到过这样的实际问题。","like_count":0},{"had_liked":false,"id":235815,"user_name":"Chord","can_delete":false,"product_type":"c1","uid":2019109,"ip_address":"","ucode":"6E248DA470FACC","user_header":"https://static001.geekbang.org/account/avatar/00/1e/cf/25/8c91fd43.jpg","comment_is_top":false,"comment_ctime":1595209852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595209852","product_id":100039001,"comment_content":"请问，双重校验锁+静态内部类的实现方式，无法支持含参构造函数吗？","like_count":0},{"had_liked":false,"id":229555,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1593056722,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1593056722","product_id":100039001,"comment_content":"1、单例对OOP不友好。OOP四大特性，封装、继承、抽象、多态。单例违背基于接口而非实现设计原则，广义上来说违背了抽象特性。单例一般不会被继承，所以直接放弃了继承、多态。<br>2、单例会隐藏类之间的依赖关系。阅读代码希望一眼能看出类之间关系。一般通过构造函数、参数传递等方式声明类之间依赖关系，而单例不需显示创建、不需要传递参数。如果代码比较复杂，这种调用关系比较隐蔽，阅读代码就需要都看完每个函数的实现才能看出这种关系。<br>3、单例对代码扩展性不好。单例只有一个实例。如果想扩展多个实例，代码改动大，修改成本高。<br>4、单例对代码可测试性不好。单例如果依赖外部资源，想进行mock替换测试，但由于单例的硬编码，无法mock。还有如果有可变成员变量，多个测试用例执行，需要排除成员变量的变化导致测试用例通不过问题。<br>5、单例不支持有参构造函数。如果想定制这个单类，就比较麻烦，也会引发一些误解。<br><br>思考题1：User cachedUser = CacheManager.getInstance().getUser(userId);这个单独抽成一个方法，CacheManager单例通过依赖注入方式注入。User actualUser = userRepo.getUser(userId);这个也单独抽成一个方法。针对validateCachedUser写单元测试，只需要将获取两个用户信息的方法用mock替换即可。<br>思考题2：第一种通过抛出异常来提示重复。第二种通过覆盖方式进行。","like_count":0},{"had_liked":false,"id":225700,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1591837324,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591837324","product_id":100039001,"comment_content":"使用时替换，单例无法使用时替换","like_count":0},{"had_liked":false,"id":223326,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1591062809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591062809","product_id":100039001,"comment_content":"&lt;二周目拾遗&gt;<br><br><br>&#47;**<br> * 不知道你有没有发现，上面的代码实现稍微有点问题。<br> * 如果我们如下两次执行 getInstance() 方法，<br> * 那获取到的 singleton1 和 signleton2 的 paramA 和 paramB 都是 10 和 50。<br> * 也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提示，这样就会误导用户。这个问题如何解决呢？<br> * 留给你自己思考，你可以在留言区说说你的解决思路。*&#47;<br>public class Singleton {<br><br>    private static volatile Singleton INSTANCE;<br><br>    private static int paramA;<br>    private static int paramB;<br><br>    private Singleton(){}<br><br>    public static Singleton getInstance(int paramA, int paramB){<br>        if (INSTANCE == null){<br>            synchronized (Singleton.class){<br>                if (INSTANCE == null){<br>                    INSTANCE = new Singleton();<br>                }<br>            }<br>        }<br><br>        if (INSTANCE.paramA != paramA || INSTANCE.paramB != paramB){<br>            INSTANCE.paramA = paramA;<br>            INSTANCE.paramB = paramB;<br>        }<br><br>        return INSTANCE;<br>    }<br>}","like_count":0},{"had_liked":false,"id":221023,"user_name":"buggetout","can_delete":false,"product_type":"c1","uid":1880582,"ip_address":"","ucode":"63A948EF415FDD","user_header":"https://static001.geekbang.org/account/avatar/00/1c/b2/06/2086d76d.jpg","comment_is_top":false,"comment_ctime":1590383215,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590383215","product_id":100039001,"comment_content":"单例模式的缺点<br>不支持面向对象特性，更像是面向过程。<br>对代码的扩展性不好<br>对代码的可测试性不好<br>不能有带参构造函数<br>","like_count":0},{"had_liked":false,"id":221005,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1590377409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590377409","product_id":100039001,"comment_content":"1. 我觉得第一问的关键在于 里面用了个单列(如果多个线程都在用这个单例) 会影响测试结果，所以才会导致可测试性不高 所以考虑新增一个测试的数据或者实例 让正式的和测试的数据分开  同时还要加锁 ，避免资源竞争<br>2. 第二问 我觉得 应该是抛出一个异常(或者给出个提示) 已经初始化过了 最好是加个返回值 判断init是否成功已经失败的原因","like_count":0},{"had_liked":false,"id":215220,"user_name":"worthto","can_delete":false,"product_type":"c1","uid":1387712,"ip_address":"","ucode":"41D7ABBBD2E7FF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","comment_is_top":false,"comment_ctime":1588931968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588931968","product_id":100039001,"comment_content":"关于问题 现有的代码中有太多的单例，可以考虑重写现有的单例对象的newStance方法，然后再依赖注入一个单例对象的生成器InstanceBuilder类，把创建的方法放到这个类中。这样的话，就把创建这个单例对象的逻辑解耦了，单例只负责单例对象的管理。职责也单一。如果需要进行mock，那就写一个InstanceBuilderMock类进行测试。","like_count":0},{"had_liked":false,"id":211983,"user_name":"🎸spray","can_delete":false,"product_type":"c1","uid":1062202,"ip_address":"","ucode":"D183FDBB32222C","user_header":"https://static001.geekbang.org/account/avatar/00/10/35/3a/3afc8d67.jpg","comment_is_top":false,"comment_ctime":1588042805,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588042805","product_id":100039001,"comment_content":"2 - swift<br>final class Singleton {<br>    private static let _shared = Singleton()<br>    private var a: Int?<br>    private var b: Int?<br>    <br>    private init () {}<br>    public static func shared(a: Int = 0, b: Int = 0) -&gt; Singleton {<br>        _shared.a = a<br>        _shared.b = b<br>        return _shared<br>    }<br>}","like_count":0},{"had_liked":false,"id":210214,"user_name":"zhengyu.nie","can_delete":false,"product_type":"c1","uid":1541669,"ip_address":"","ucode":"FFE0377D323E46","user_header":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","comment_is_top":false,"comment_ctime":1587698807,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587698807","product_id":100039001,"comment_content":"数据连接池、线程池在Spring环境下其实还是单例的，在Spring重型注入框架体系下，基本上编程范式都是用对应的@Configuration注解下，注入隔离的池子。比如有一个ThreadPoolConfiguration，里面几个@Bean，每一个Bean是一个线程池，业务身份隔离，使用的地方依赖查找对应beanName的池子，托给Spring管理了。","like_count":0},{"had_liked":false,"id":204737,"user_name":"Wh1","can_delete":false,"product_type":"c1","uid":1282715,"ip_address":"","ucode":"6D28506B99A285","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/9b/65f98192.jpg","comment_is_top":false,"comment_ctime":1586447706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586447706","product_id":100039001,"comment_content":"将单例初始化参数放到Config类中这段代码其实存在问题，和第二种解决方案一样，如果我们在运行时动态修改了初始化参数，那么获取到的也会是用之前的参数创建的单例对象。<br>解决方案可以是：不直接对Config类中的参数赋值，而是通过 setter 在初始化 instance 之前进行赋值。原理其实和第一种解决方案差不太多。<br>但回过头想，如果一开始就预料到要通过不同参数创建不同的对象，那么这种场景也不适合使用单例模式。","like_count":0},{"had_liked":false,"id":204460,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1586402734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586402734","product_id":100039001,"comment_content":"第二题，如果第二次没成功，抛出异常即可。<br><br>没想到单例模式还有这么多缺点，这是我没想到过的，我看别的文章都是直接告诉我怎么实现单例模式，争哥牛逼","like_count":0},{"had_liked":false,"id":203114,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586141362,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586141362","product_id":100039001,"comment_content":"##思考题2<br>第二次没有生效也没有特殊提示的原因分析：因为第一次已经创建了实例，所以，第二次直接返回了。并没有走再次走到单例构造函数的执行，故而相关的值还是原来的值。","like_count":0},{"had_liked":false,"id":202968,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1586095039,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586095039","product_id":100039001,"comment_content":"我感觉单例的这些问题都不是问题，大不了就用依赖注入的方式，从外面传进去实例。至于单例本身可以了依赖接口开发","like_count":0},{"had_liked":false,"id":201494,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1585795651,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585795651","product_id":100039001,"comment_content":"到底哪一版jdk实现了实例化对象避免指令重排？？指令重排本来就是一种优化手段，我感觉不可能会全部禁用掉吧，手动volatile禁用才是最合理的。请老师回复一下","like_count":0},{"had_liked":false,"id":200973,"user_name":"Geek_0a912e","can_delete":false,"product_type":"c1","uid":1797776,"ip_address":"","ucode":"3764D74EECF8E6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKAyfsLlZkYjRiaSiaxf07h6hNEu2AKyoZpCYqoE5K7xv13LdwCwE7ZDnSxr8drc5gOumgiapbn27KicA/132","comment_is_top":false,"comment_ctime":1585700766,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1585700766","product_id":100039001,"comment_content":"这条没太看明白，麻烦再解释一下：单例不支持有参数的构造函数","like_count":0,"discussions":[{"author":{"id":2446652,"avatar":"","nickname":"Geek_70aee8","note":"","ucode":"ABC47717D5B655","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354533,"discussion_content":"我的看法是：正如问题讨论2中的情况，如果输入两组参数进去的话，需要修改单例类的代码，才能保证输入不同参数时生成不同单例类；如果两次输入参数一致，还得保证两次调用同一个单例类。所以，单例支持带参数的构造函数的话，会产生误导。\n解决方法：通过将参数写成配置文件的形式，然后构造函数内部通过读取配置信息生成对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615300102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1967515,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/7xB3OdNLiaPgZQibVAD52Jx04buk6Tb3I7A4wcdea2c6YXxJGdKgGCPgPuGWh69CffdSJKOqJFzVRVOEWBqFybJA/132","nickname":"Geek_83f2ce","note":"","ucode":"471D47B2A342E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294546,"discussion_content":"我也不太懂这一点，有没有懂的小伙伴？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595922749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198102,"user_name":"junmawang","can_delete":false,"product_type":"c1","uid":1763466,"ip_address":"","ucode":"977E9E25CE6C94","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e8/8a/803a42e0.jpg","comment_is_top":false,"comment_ctime":1585409229,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585409229","product_id":100039001,"comment_content":"针对与传递进去的参数是不生效的问题，可以在类中定义两个临时变量，对上一次创建实例对paramA, paramB赋值到临时变量，下次调用判断是否一致，不一致则重新创建","like_count":0},{"had_liked":false,"id":193623,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1584935396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584935396","product_id":100039001,"comment_content":"老师   我感觉这段其实不算是一种新的替代方案，它仍然算是“单例模式”啊，只不过这个例子比较特殊。<br><br>public class IdGenerator {  private static AtomicLong id = new AtomicLong(0);    public static long getId() {     return id.incrementAndGet();  }}<br><br><br>","like_count":0},{"had_liked":false,"id":187307,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1584080674,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584080674","product_id":100039001,"comment_content":"思考题：<br>1. 用工厂模式把CacheManager.getInstance()对象创建提出来<br>2. <br>public class Singleton {<br>    private static Singleton instance = null;<br>    private final int paramA;<br>    private final int paramB;<br>    private static int variableA = 0;<br>    private static int variableB = 0;<br><br>    private Singleton(int paramA, int paramB) {<br>        this.paramA = paramA;<br>        this.paramB = paramB;<br>    }<br><br>    public synchronized static Singleton getInstance(int paramA, int paramB) {<br>        if (instance == null) {<br>            instance = new Singleton(paramA, paramB);<br>            variableA = paramA;<br>            variableB = paramB;<br>        } else if (paramA == variableA &amp;&amp; paramB == variableB) {<br>            return instance;<br>        } else {<br>            throw new RuntimeException(&quot;Parameter 20&#47;30 creation failed&quot;);<br>        }<br>        return instance;<br>    }<br><br>}<br>","like_count":0},{"had_liked":false,"id":183107,"user_name":"雷刚","can_delete":false,"product_type":"c1","uid":1655725,"ip_address":"","ucode":"115FE2BE1AAB61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132","comment_is_top":false,"comment_ctime":1582954565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582954565","product_id":100039001,"comment_content":"以前写过一个 TelnetManager 的类，写单元测试的时候很痛苦，不过那时候只是觉得单例不好写单元测试，没有细想，听了老师的分析才豁然开朗","like_count":0},{"had_liked":false,"id":181047,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1582465760,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582465760","product_id":100039001,"comment_content":"1. 把 CacheManager.getInstance().getUser(userId);封装成方法<br>2. 做一个判断。如果已经初始化抛出异常","like_count":0},{"had_liked":false,"id":179793,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1582100552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582100552","product_id":100039001,"comment_content":"讨论题1: 这里测试的不是单例对象, 而是依赖单例的类, 所以单例可以直接用依赖注入的形式传入即可, Demo类不要在内部创建单例对象, 而是直接使用外部传入的单例对象.<br>讨论题2: 把不同的参数转成字符串作为key, 再用一个字典针对每一个key单独创建单例对象, 这样可以保证传入的参数相同时获取到的对象是同一个, 不同参数对应不同单例对象.","like_count":0},{"had_liked":false,"id":179495,"user_name":"HYM","can_delete":false,"product_type":"c1","uid":1054178,"ip_address":"","ucode":"4E82D9A285DAFF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/e2/c21553c4.jpg","comment_is_top":false,"comment_ctime":1582015910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582015910","product_id":100039001,"comment_content":"第一个问题：把cache user的获取改成函数返回，这样可以在测试的时候对函数进行mock。<br>第二个问题：此时需要比较已经存在的instance的参数和传入的新参数是否一致，一致就返回instance，不一致直接报错。","like_count":0},{"had_liked":false,"id":178737,"user_name":"桂城老托尼","can_delete":false,"product_type":"c1","uid":1306032,"ip_address":"","ucode":"139E4B8EE88B79","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","comment_is_top":false,"comment_ctime":1581810136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581810136","product_id":100039001,"comment_content":"感谢分享，尝试回答下<br>1,cacheManager作为demo的属性，构造demo对象时 获取单例，而非每次调用方法时获取。<br>2，compareAndUpdate 思路去解决这个问题，不过虽然能解决问题，但这种用法真的好吗？太刁钻了~","like_count":0},{"had_liked":false,"id":178618,"user_name":"FIGNT","can_delete":false,"product_type":"c1","uid":1540988,"ip_address":"","ucode":"D9DB185AE9E67C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","comment_is_top":false,"comment_ctime":1581760000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581760000","product_id":100039001,"comment_content":"1、将单例获取对象的代码抽离单独方法。再对方法mock<br>2、如果参数不相同，直接报错，告诉使用者如何使用。<br>public synchronized static Singleton getInstance(int paramA, int paramB) {<br>    if (instance == null) {<br>      instance = new Singleton(paramA, paramB);<br>    }else{<br>    \tif(paramA == this.paramA &amp;&amp; paramB == this.paramB){<br>    \t\treturn instance;<br>    \t}else{<br>    \t\tthrow new RuntimeException(&quot;illegal argument,please use getInstance(&quot;+this.paramA+&quot;,&quot;+this.paramB+&quot;) method&quot;);<br>    \t}<br>    }<br>  }","like_count":0},{"had_liked":false,"id":178045,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1581577673,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581577673","product_id":100039001,"comment_content":"课堂讨论: 1. 把 User cachedUser = CacheManager.getInstance().getUser(userId); 抽出来, 变成一个函数,这样就可以对函数 mock 了<br>             2. 在进 getInstance函数的时候, 对全局变量 instance 置空<br><br>","like_count":0},{"had_liked":false,"id":177933,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1581553616,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581553616","product_id":100039001,"comment_content":"打卡～","like_count":0},{"had_liked":false,"id":177448,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1581394703,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581394703","product_id":100039001,"comment_content":"第二次调用getInstance时如果带有与之前相同参数就直接返回instance实例;如果参数不相同且业务允许构建新的instance实例就允许再第二次getInstance时构建新的实例,如果业务不允许就在构建时抛出异常.","like_count":0},{"had_liked":false,"id":177283,"user_name":"bin","can_delete":false,"product_type":"c1","uid":1307082,"ip_address":"","ucode":"EC4F4194082715","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/ca/9b9b8a7c.jpg","comment_is_top":false,"comment_ctime":1581341486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581341486","product_id":100039001,"comment_content":"第一个问题：把 CacheManager.getInstance().getUser() 封装成一个函数,可以用来mock<br>public User getCacheUser(long userId){<br>}<br><br>第二个问题，加一个判断，<br><br>public synchronized static Singleton getInstance(int paramA, int paramB) {<br> if (instance == null) { <br>     instance = new Singleton(paramA, paramB); <br>     return instance;<br> }<br>if( instance != null &amp;&amp; (paramA != this.paramA || paramB != this.paramB )  ){<br>     throw new RunTimeException(&quot;不能重复初始化&quot;);<br>}<br> return instance; <br>}","like_count":0},{"had_liked":false,"id":177239,"user_name":"天天向上卡索","can_delete":false,"product_type":"c1","uid":1009850,"ip_address":"","ucode":"E3724C3B39BD3F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/68/ba/c0cf8bf3.jpg","comment_is_top":false,"comment_ctime":1581330360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581330360","product_id":100039001,"comment_content":"在 .net core 里，依赖注入模式的使用比较多，对于一些配置会通过options模式来处理，option也可以注入，很灵活","like_count":0},{"had_liked":false,"id":176980,"user_name":"Uncle.Wang","can_delete":false,"product_type":"c1","uid":1456955,"ip_address":"","ucode":"9A4F646CFC237F","user_header":"https://static001.geekbang.org/account/avatar/00/16/3b/3b/b8c00291.jpg","comment_is_top":false,"comment_ctime":1581240820,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1581240820","product_id":100039001,"comment_content":"我遇到的问题是：在client端开发的时候，工程中有大量单例，这些单例中保存着数据，而这些数据可能是和用户账户相关联的，一旦切换账号，面临reset这些单例的问题，往往存在遗漏。如果大量存在这种单例，会很难维护。","like_count":0,"discussions":[{"author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222043,"discussion_content":"你这个要用观察者模式，观察到账号变了，各自自觉更新数据。而不是被动更新数据。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586094515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176924,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1581228054,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1581228054","product_id":100039001,"comment_content":"<br><br><br><br>课堂讨论 <br><br>1. 修改validateCachedUser()方法形参: <br><br>   public boolean validateCachedUser(int userId, \tCacheManager manager){...}<br><br>​    <br><br>2. 带有参数的getInstance()的一种实现方式:<br><br>   public syncrinized static Singleton getInstance(int paramA, int paramB){<br><br>   ​    if(instance == null){<br><br>   ​        instance = new Singleton(paramA, paramB);<br><br>   ​        }<br><br>   <br><br>   ​    if(this.paramA != paramA || this.paramB != paramB){<br><br>   ​        instance = new Singleton(paramA, paramB);<br><br>   ​        }<br><br>   <br><br>   ​    return instance;<br><br>   }","like_count":0,"discussions":[{"author":{"id":1046893,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f9/6d/b623562a.jpg","nickname":"霹雳大仙pp","note":"","ucode":"F654FD9AEC1D56","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":195625,"discussion_content":" CacheManager带在形参里，违反了迪米特法则，抽成一个protected方法更好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583291970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176920,"user_name":"mghio","can_delete":false,"product_type":"c1","uid":1213078,"ip_address":"","ucode":"74883EDE4FD0DC","user_header":"https://static001.geekbang.org/account/avatar/00/12/82/96/aa795685.jpg","comment_is_top":false,"comment_ctime":1581225613,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581225613","product_id":100039001,"comment_content":"优秀，单例模式竟然还有这么多问题以前只是用，从来没有考虑过这方面","like_count":0},{"had_liked":false,"id":176699,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1581141690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581141690","product_id":100039001,"comment_content":"1.把单例部分抽出来；<br>2.为空或者一致的时候返回可用instance，不一致则抛错。","like_count":0},{"had_liked":false,"id":176680,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1581137134,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581137134","product_id":100039001,"comment_content":"问题2使用不同参数构造不同单例，是这个需求吗？如果是那么维护类就不能只有一个instance的成员变量，应该考虑有类似cachedMap的方式，instance要实现equals和hashCode方法，针对不同入参作为不同的key，线程安全的去访问cachedMap进行存取。","like_count":0},{"had_liked":false,"id":176581,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1581091338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581091338","product_id":100039001,"comment_content":"直接更新属性怕是会有一个安全问题吧，一个长线程如果一直在使用对象，一个其他线程进来后，把这个单例对象的属性直接修改了。长线程接下来如果使用到单例对象，属性就全变了。线程安全性太差了。","like_count":0},{"had_liked":false,"id":176407,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1581052034,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581052034","product_id":100039001,"comment_content":"第一个问题可以先抽取一个函数，然后mock 第二个问题，可以比较传入的参数对比，相同才进行新建对应对象","like_count":0},{"had_liked":false,"id":176358,"user_name":"好吃不贵","can_delete":false,"product_type":"c1","uid":1316993,"ip_address":"","ucode":"6576E2BECE4F7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/18/81/83b6ade2.jpg","comment_is_top":false,"comment_ctime":1581042586,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581042586","product_id":100039001,"comment_content":"关于单例模式的替换方案。类实现时normalClass用普通写法，构造函数也是public的。在类外面，全局定义static normalClass obj;这样直接调用obj的方法是不是也是全局唯一了，至少同一进程内是一样的，也算是一种单例的替代方案？","like_count":0},{"had_liked":false,"id":176349,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1581040330,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581040330","product_id":100039001,"comment_content":"1.通过参数的方式将单例类传递进函数。<br>2.如果单例对象存在，就对比两个成员变量，不一致就抛出异常提示调用方，一致就直接返回单例对象。","like_count":0},{"had_liked":false,"id":176337,"user_name":"石维康","can_delete":false,"product_type":"c1","uid":1067564,"ip_address":"","ucode":"E39ED8416B2C01","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/2c/f8451d77.jpg","comment_is_top":false,"comment_ctime":1581038842,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1581038842","product_id":100039001,"comment_content":"<br>public class Singleton {<br>  private static Singleton instance = null;<br>  private final int paramA;<br>  private final int paramB;<br><br>  private Singleton(int paramA, int paramB) {<br>    this.paramA = paramA;<br>    this.paramB = paramB;<br>  }<br><br>  public static Singleton getInstance() {<br>    if (instance == null) {<br>       throw new RuntimeException(&quot;Run init() first.&quot;);<br>    }<br>    return instance;<br>  }<br><br>  public synchronized static Singleton init(int paramA, int paramB) {<br>    if (instance != null){<br>       throw new RuntimeException(&quot;Singleton has been created!&quot;);<br>    }<br>    instance = new Singleton(paramA, paramB);<br>    return instance;<br>  }<br>}<br><br>Singleton.init(10, 50); &#47;&#47; 先init，再使用<br>Singleton singleton = Singleton.getInstance();<br><br>请问老师这里的init方法为何需要返回一个Singleton？写成void不行吗？","like_count":0,"discussions":[{"author":{"id":1316993,"avatar":"https://static001.geekbang.org/account/avatar/00/14/18/81/83b6ade2.jpg","nickname":"好吃不贵","note":"","ucode":"6576E2BECE4F7C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163161,"discussion_content":"貌似void也可以？不过返回的instance的话，系统初始化时候可以判断是不是初始化成功了，更好些。猜测。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581055682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176344,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1581039489,"is_pvip":false,"discussion_count":20,"race_medal":1,"score":"482617376641","product_id":100039001,"comment_content":"课堂讨论，<br>1. 把代码“User cachedUser = CacheManager.getInstance().getUser(userId);”单独提取出来做成一个单独的函数，这样这个函数就可以进行mock了，进而方便测试validateCachedUser。<br>2. 可以判断传进来的参数和已经存在的instance里面的两个成员变量的值，如果全部相等，就直接返回已经存在的instance，否则就新创建一个instance返回。示例如下：<br><br>public synchronized static Singleton getInstance(int paramA, int paramB) { <br>    if (instance == null) { <br>        instance = new Singleton(paramA, paramB); <br>    } else if (instance.paramA == paramA &amp;&amp; instance.paramB == paramB) {<br>        return instance;<br>    } else {<br>        instance = new Singleton(paramA, paramB);<br>    }<br>    return instance; <br>}","like_count":113,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510703,"discussion_content":"加油，爱你","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176503,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1581073343,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"327998587839","product_id":100039001,"comment_content":"模式没有对错，关键看你怎么用。这句话说的很对，所以其实所谓单例模式的缺点这种说法还是有点牵强！","like_count":77,"discussions":[{"author":{"id":2336999,"avatar":"https://static001.geekbang.org/account/avatar/00/23/a8/e7/bedf7932.jpg","nickname":"哇哈哈","note":"","ucode":"3A4FD1A3E657C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559692,"discussion_content":"个人觉得单例模式是一种思想，要看你怎么实现这种思想，就java 目前那几种实现思想的代码有局限性，所以说叫做缺点，这才需要改进使它可以满足一些其他的业务需求吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648883573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015189,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/95/dd73022c.jpg","nickname":"我是曾经那个少年","note":"","ucode":"9F02F7FF147D14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530425,"discussion_content":"是的，用单例要知道他使用的场景。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637071845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185662,"user_name":"Richie","can_delete":false,"product_type":"c1","uid":1019588,"ip_address":"","ucode":"12314EF0347693","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","comment_is_top":false,"comment_ctime":1583657389,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"250691760557","product_id":100039001,"comment_content":"课堂讨论第2点，我认为应该先搞清楚需求，为什么需要在getInstance()方法中加参数，想要达到什么目的？<br>这里分两种情况讨论一下：<br>1. 如果的确需要一个全局唯一的类，并且这个类只能被初始化一次，那么应该采用文中提到的第三种解决思路，即将所需参数放到全局的配置文件中，从而避免多次初始化参数被忽略或者抛出运行时异常的问题；<br>2. 如果是要根据不同参数构造出不同的对象，并且相同参数的对象只被构造一次，那么应该改成在Singleton类中维护一个HashMap，然后每次调用getInstance()方法的时候，根据参数去判断对象是否已经存在了（可以采用双重检测），存在则直接返回，不存在再去创建，然后存储，返回。个人理解，这应该是单例+简单工厂的结合。","like_count":59,"discussions":[{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293265,"discussion_content":"思路清晰，棒","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1595494918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1019588,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","nickname":"Richie","note":"","ucode":"12314EF0347693","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293419,"discussion_content":"谢谢鼓励😬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595524659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":293265,"ip_address":""},"score":293419,"extra":""}]},{"author":{"id":1049235,"avatar":"https://static001.geekbang.org/account/avatar/00/10/02/93/fed4baec.jpg","nickname":"Null","note":"","ucode":"D48077EBAD2E87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388682,"discussion_content":"赞同！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628909654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180740,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1582379036,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"126136430620","product_id":100039001,"comment_content":"设计模式_42:<br># 作业<br>1. 可以把单例的对象以依赖注入的方式传入方法；<br>2. 第二次调用时，如果参数发生了变化，应该抛出异常。<br><br># 感想<br>坦白讲，一直以使用双重检测沾沾自喜。。。现在看来，要不要使用单例要比使用那种单例的实现方式更需要投入思考。","like_count":29,"discussions":[{"author":{"id":1055475,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","nickname":"iLeGeND","note":"","ucode":"4055A628A6E97C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352064,"discussion_content":"优雅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614588515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":209710,"user_name":"林子er","can_delete":false,"product_type":"c1","uid":1629256,"ip_address":"","ucode":"85637288F22CF0","user_header":"https://static001.geekbang.org/account/avatar/00/18/dc/48/9796286e.jpg","comment_is_top":false,"comment_ctime":1587603843,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61717145987","product_id":100039001,"comment_content":"由于单例本身存在的一系列缺点，而单例一般又都是全局的，因而一般我们项目中很少直接使用单例，而是通过容器注入，让容器充当单例和工厂。有时候我们甚至使用伪单例，即类本身并不是单例的，而是通过容器保证单例性，实际编程中按照约定只通过容器获取该实例。<br>参数化单例实际中是通过Map解决的，即同样的参数才返回同一个实例，不同的参数返回不同的实例，为了保证实例不会太多，一般可传的参数我们会事先做了限制，比如只能使用配置文件中配置的（如数据库连接池的名称）","like_count":15},{"had_liked":false,"id":176413,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1581053702,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"35940792070","product_id":100039001,"comment_content":"1. 如果项目中已经用了很多单例模式，比如下面这段代码，我们该如何在尽量减少代码改动的情况下，通过重构代码来提高代码的可测试性呢？<br>CacheManager.getInstance(long userId)中增加Mock开关，如：<br>private User mockUser;<br>public CacheManager.setMockObj(User mockUser)<br>public User getInstance(long userId) {<br>     if(mockUser != null &amp;&amp; mockUser.getUserId() == userId) {<br>          return mockUser<br>     }<br>}<br>2. 在单例支持参数传递的第二种解决方案中，如果我们两次执行 getInstance(paramA, paramB) 方法，第二次传递进去的参数是不生效的，而构建的过程也没有给与提示，这样就会误导用户。这个问题如何解决呢？<br>第一次构造Instance成功时需要记录paramA和paramB，在以后的调用需要匹配paramA与paramB构造成功Instance时的参数是否一至，不一至时需要抛出异常。","like_count":8,"discussions":[{"author":{"id":1387712,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","nickname":"worthto","note":"","ucode":"41D7ABBBD2E7FF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261030,"discussion_content":"个人觉得mock代码放入到正常的代码示例中，是不可取的，侵入性太强。现有的代码中有太多的单例，可以考虑重写现有的单例对象的newStance方法，然后再依赖注入一个单例对象的生成器InstanceBuilder类，把创建的方法放到这个类中。这样的话，就把创建这个单例对象的逻辑解耦了，单例只负责单例对象的管理。职责也单一。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1588931903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1611025,"avatar":"https://static001.geekbang.org/account/avatar/00/18/95/11/eb431e52.jpg","nickname":"沈康","note":"","ucode":"02AFA50738AB8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165097,"discussion_content":"第一种方法不好呀，感觉1楼的好点","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581254603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019588,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","nickname":"Richie","note":"","ucode":"12314EF0347693","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200069,"discussion_content":"第一问的回答中，我觉得思路不错，但是代码写法有点问题。要Mock的应该是CacheManager实例，而不是User实例；而且，getInstance()方法本是无参数的，这样写就不兼容了，语义上也不对，方法返回的应该是CacheManager对象而不是User对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583654117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202103,"user_name":"小麦","can_delete":false,"product_type":"c1","uid":1216881,"ip_address":"","ucode":"55C7199A0D5659","user_header":"https://static001.geekbang.org/account/avatar/00/12/91/71/0b16655d.jpg","comment_is_top":false,"comment_ctime":1585903525,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"27355707301","product_id":100039001,"comment_content":"不太能理解的使用方式违背了基于接口而非实现的设计原则，比如 spring 中的 service 类一般也是单例的，也是继承接口，controller 的调用也是基于接口，不觉得有什么问题啊，如果实现类变了，也只是改注入而已啊。 ","like_count":6,"discussions":[{"author":{"id":1394822,"avatar":"https://static001.geekbang.org/account/avatar/00/15/48/86/54c68afe.jpg","nickname":"铁男神sama","note":"","ucode":"0A3E3E61D36EDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308996,"discussion_content":"逻辑鬼才","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601166144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296314,"discussion_content":"Spring这种容器技术不是严格意义上的单例模式，是单例的替代品了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596508101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1958147,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e1/03/f937e673.jpg","nickname":"🍀","note":"","ucode":"60E0AC2A55B63B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226619,"discussion_content":"此接口非彼接口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586437420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176308,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1581012441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27350816217","product_id":100039001,"comment_content":"打卡","like_count":6},{"had_liked":false,"id":176397,"user_name":"Eden Ma","can_delete":false,"product_type":"c1","uid":1457408,"ip_address":"","ucode":"755312F0D154F9","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/00/7daa7403.jpg","comment_is_top":false,"comment_ctime":1581049024,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23055885504","product_id":100039001,"comment_content":"<br>2、instance不为空抛出异常","like_count":5},{"had_liked":false,"id":178311,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1581658828,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10171593420","product_id":100039001,"comment_content":"2.可以使用反射修改单例中参数信息","like_count":2},{"had_liked":false,"id":176952,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1581235090,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10171169682","product_id":100039001,"comment_content":"1.下面这段代码，我们该如何在尽量减少代码改动的情况下，通过重构代码来提高代码的可测试性呢？<br>将单例类中新增一个用于获取测试instance的函数,命名getTestInstance(User testUser),该函数中把需要的测试用例通过参数传入instance当中,当要做测试时就可以通过getTestInstance函数来获取实例得到需要的测试数据.<br>public boolean validateCachedUser(long userId) {<br>    User actualUser = userRepo.getUser(userId);<br>    &#47;&#47;User cachedUser = CacheManager.getInstance().getUser(userId);&#47;&#47;生产使用<br>    User cachedUser = CacheManager.getTestInstance(actualUser).getUser(userId);&#47;&#47;测试使用<br>    &#47;&#47; 省略核心逻辑：对比cachedUser和actualUser...<br>  }<br>2.第二次传递进去的参数是不生效的，而构建的过程也没有给与提示，这样就会误导用户。这个问题如何解决呢？<br>第二次调用getInstance时如果带有与之前相同参数就直接返回instance实例;如果参数不相同且业务允许构建新的instance实例就允许再第二次getInstance时构建新的实例,如果业务不允许就在构建时抛出异常.<br>public synchronized static Singleton getInstance(int paramA, int paramB) {<br>    if (instance == null) {<br>      instance = new Singleton(paramA, paramB);<br>    } else if (this.paramA != paramA || this.paramB != paramB) {<br>       &#47;&#47;instance = new Singleton(paramA, paramB);&#47;&#47; 业务允许<br>       throw new RuntimeException(&quot;Singleton has been created!&quot;);&#47;&#47; 业务不允许<br>   }<br>    return instance;<br>  }","like_count":2},{"had_liked":false,"id":176357,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1581042238,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"10170976830","product_id":100039001,"comment_content":"思考题1：<br>提出一个方法：public Uer getCahcedUser(userId){}，然后mock getCahcedUser方法。<br>测试：<br>public boolean validateCachedUesr(userid){<br>  User cachedUser = getMockCachedUser…<br>  User actualUser = userRepo.getUser(userid)<br>&#47;&#47; validate …<br>}<br><br>思考题2：<br>A singleton with parameters is NOT a singleton because you may have more object than one of them.<br>改进：得到单例对象后，再初始化参数。<br>SingletonObj singleton = SingletonObj.getInstance()<br>singleton.init(paramA, paramB)<br>","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501424,"discussion_content":"在夹缝中求生存啊~讨口饭吃不容易的😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594781167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217443,"user_name":"Roger宇","can_delete":false,"product_type":"c1","uid":1703222,"ip_address":"","ucode":"CBA23C01409349","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/36/f947c340.jpg","comment_is_top":false,"comment_ctime":1589506215,"is_pvip":false,"replies":[{"id":"80476","content":"根据业务来估算的，有些业务本身就很慢，就判定为慢sql","user_name":"作者回复","comment_id":217443,"uid":"1190123","ip_address":"","utype":1,"ctime":1589524621,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5884473511","product_id":100039001,"comment_content":"想问一下老师，所谓两个资源池，慢的请求独占一个的设计，如何知道一个sql请求会快会慢？快与慢更多是在运行后才知道的，已经进去运行了还怎么保证独占呢？除非有机制可以在处理sql请求之前评估可能需要的时间。","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501298,"discussion_content":"先休息休息~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594632602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202817,"user_name":"小动物","can_delete":false,"product_type":"c1","uid":1031683,"ip_address":"","ucode":"BCC35CE768EB99","user_header":"https://static001.geekbang.org/account/avatar/00/0f/be/03/404edf37.jpg","comment_is_top":false,"comment_ctime":1586073571,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881040867","product_id":100039001,"comment_content":"之前重构过一个简单业务模块，原入口是一个简单的单例：biz1class.getinstance().doSomething()。但新需求单例模式不支持，需要支持不同处理业务的模式，于是重构。<br>当时的思路是，其实实际业务代码并不关心getinstance()后返回的是什么。所以这个方法的返回类型由原来的类换成接口对业务代码而言，基本无影响，最多重新编译下代码。<br>所以最后的方案是将原业务类提供的方法提取成合适的接口，并编写相关实现类。原getInstance()方法返回类型改成接口。并根据当前配置返回不同的实现类以满足不同的处理方式。<br><br>基于这个思路，文章中的问题应该就能解决了。让原先的biz1class的getinstance方法支持返回自己想要的实现即可。","like_count":1},{"had_liked":false,"id":176548,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1581084545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876051841","product_id":100039001,"comment_content":" 第一个问题，为了增加可测试性，也就是尽量可以测试中间结果。我觉得可以将cacheUser那一行代码和下一行代码分别抽取出来封装📦。<br>第二个问题，可以将参数保存在静态类中，本身这个类新增一个init函数，在new 对象后进行调用init。这样用户可以不需要加载参数。当然了，如果一定要在getInstance时传入参数，那么也可以校验参数是否和上一次传入的参数是否一致。","like_count":1},{"had_liked":false,"id":358408,"user_name":"@二十一大叔","can_delete":false,"product_type":"c1","uid":1075954,"ip_address":"上海","ucode":"394A7E80C5034C","user_header":"https://static001.geekbang.org/account/avatar/00/10/6a/f2/8829a0b8.jpg","comment_is_top":false,"comment_ctime":1664276132,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664276132","product_id":100039001,"comment_content":"1.<br>public class Demo {<br><br>        private UserRepo userRepo; &#47;&#47; 通过构造哈函数或IOC容器依赖注入<br>        private CacheManager cacheManager; &#47;&#47; 将获取CacheManager对象提出来，通过依赖注入的方式初始化<br><br>        public Demo(CacheManager cacheManager){<br>            this.cacheManager = cacheManager;<br>        }<br><br>        public boolean validateCachedUser(long userId) {<br>            User cachedUser = getCachedUser(userId);<br>            User actualUser =userRepo.getUser(userId);<br>            &#47;&#47; 省略核心逻辑：对比cachedUser和actualUser...<br>        }<br>        <br>        public User getCachedUser(long userId){<br>            return cacheManager.getInstance().getUser(userId);<br>        }<br><br>        static class MockManager extends CacheManager {<br>            private static MockManager mockManager;<br>            <br>            private MockManager(){}<br><br>            public static MockManager getInstance(){<br>                &#47;&#47;todo<br>                return mockManager;<br>            }<br><br>            public static User getUser(long userId){<br>                &#47;&#47; 返回mock数据<br>                return new User(userId);<br>            }<br>        }<br><br>    public static void main(String[] args) {<br>        CacheManager cacheManager = MockManager().getInstance();<br>        Demo demo = new Demo(cacheManager);<br>        User user = demo.getCachedUser(123L);<br>    }","like_count":0},{"had_liked":false,"id":354747,"user_name":"红烧冰淇淋","can_delete":false,"product_type":"c1","uid":2650490,"ip_address":"北京","ucode":"CF59ECC2FE70C6","user_header":"https://static001.geekbang.org/account/avatar/00/28/71/7a/3230370a.jpg","comment_is_top":false,"comment_ctime":1660741331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660741331","product_id":100039001,"comment_content":"难道单例模式最大的问题不是没办法横向扩展吗？<br><br>现在都是多实例部署了，单个实例内部的单例模式没有啥意义","like_count":1},{"had_liked":false,"id":350540,"user_name":"搬砖农民工👩‍🌾","can_delete":false,"product_type":"c1","uid":2873541,"ip_address":"","ucode":"50E0602562E968","user_header":"https://static001.geekbang.org/account/avatar/00/2b/d8/c5/6a553741.jpg","comment_is_top":false,"comment_ctime":1656993362,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656993362","product_id":100039001,"comment_content":"上节课中又说道，静态内部类也可以做到延迟加载，这节课说做不到，我看了下菜鸟教程，静态内部类是可以做到延迟加载的，不知是我理解做错了，还是老师不小心打错了","like_count":0},{"had_liked":false,"id":342969,"user_name":"Geek_7e0e83","can_delete":false,"product_type":"c1","uid":2142423,"ip_address":"","ucode":"554DEE2AAAE33C","user_header":"","comment_is_top":false,"comment_ctime":1650554154,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650554154","product_id":100039001,"comment_content":"1. 可以把单例的获取ID的功能移到另一个函数中封装起来，然后mock那个新的方法即可<br>2.可以当instance不为null 的时候 打印warn日志，提示用户输入的参数已经不生效了，或者换别的方式实现单例，比如配置文件的方式。而不是在instance方法上加入参","like_count":0},{"had_liked":false,"id":334311,"user_name":"知行","can_delete":false,"product_type":"c1","uid":1802022,"ip_address":"","ucode":"5AC8CBCC0AD48B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7f/26/c5127e9a.jpg","comment_is_top":false,"comment_ctime":1644884359,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644884359","product_id":100039001,"comment_content":"其实，单例模式可以被反射破坏","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501275,"discussion_content":"喜欢你的昵称！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594598495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319498,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1635836854,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635836854","product_id":100039001,"comment_content":"总结<br>1、单例存在哪些问题?<br>\t1. 单例对 OOP 特性的支持不友好<br>\t2. 单例会隐藏类之间的依赖关系<br>\t3. 单例对代码的扩展性不友好<br>\t4. 单例对代码的可测试性不友好<br>\t5. 单例不支持有参数的构造函数<br>2、有何替代解决方案？<br>\t保证全局唯一，还可以使用静态方法。但它也不够灵活，不能懒加载<br>\t工厂模式、IOC 容器（比如 Spring IOC 容器）也可以保证唯一","like_count":0},{"had_liked":false,"id":319495,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1635836387,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635836387","product_id":100039001,"comment_content":"作业<br>1、两个对象以参数传入，然后直接对比2个对象即可，外部可以单写2个方法<br>2、看了好多评论个人看法有两个，一如果业务需要存在不同参数的实例，那单例的设计其实就不符合了；二如果需要只能一个实例，且根据业务参数实时变动那最好是开放一个update方法取修改，初始化就一次，后面修改用update方法","like_count":0},{"had_liked":false,"id":316920,"user_name":"MOSLX","can_delete":false,"product_type":"c1","uid":2732715,"ip_address":"","ucode":"FFE0FE1AED2BFB","user_header":"https://static001.geekbang.org/account/avatar/00/29/b2/ab/db3ce62d.jpg","comment_is_top":false,"comment_ctime":1634613271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634613271","product_id":100039001,"comment_content":"课堂讨论2，尝试维护一个HashMap容器，应该能根据不同的参数保持单例   <br> private static ParamSingleton instance = null;<br>    private static HashMap&lt;String, ParamSingleton&gt; context = new HashMap&lt;&gt;();<br>    private final int paramA;<br>    private final int paramB;<br><br>    private ParamSingleton(int paramA, int paramB){<br>        this.paramA = paramA;<br>        this.paramB = paramB;<br>    }<br><br>    public synchronized static ParamSingleton getInstance(int paramA, int paramB){<br>        String key = paramA + &quot;-&quot; + paramB;<br>        if(instance == null){<br>            instance = new ParamSingleton(paramA,paramB);<br>            context.put(key,instance);<br>        } else {<br>            instance = context.computeIfAbsent(key,k -&gt; new ParamSingleton(paramA,paramB));<br>        }<br>        return instance;<br>    }","like_count":0},{"had_liked":false,"id":304493,"user_name":"连星科技","can_delete":false,"product_type":"c1","uid":2642229,"ip_address":"","ucode":"C84FF7FF4AAE56","user_header":"https://static001.geekbang.org/account/avatar/00/28/51/35/d3a1144b.jpg","comment_is_top":false,"comment_ctime":1627454575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627454575","product_id":100039001,"comment_content":"go 语言可以用静态全局对象，结构对象命名小写，只能通过一个Get函数去获取。","like_count":0},{"had_liked":false,"id":296733,"user_name":"小江爱学术","can_delete":false,"product_type":"c1","uid":2628601,"ip_address":"","ucode":"554F40C6627AF4","user_header":"https://static001.geekbang.org/account/avatar/00/28/1b/f9/018197f1.jpg","comment_is_top":false,"comment_ctime":1623136180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623136180","product_id":100039001,"comment_content":"问题1. 在构造方法中通过参数的形式把单例传进来。<br>问题2. 既然叫单例，我认为本身就应该保证全局唯一性，通过getInstance传参的方法希望单例可以根据传参的不同动态改变，我认为本身不太可取，是令人疑惑的做法，还是应该在单例类中，以配置文件的方式加载参数，保证单例唯一性","like_count":0},{"had_liked":false,"id":295058,"user_name":"庄周梦蝶","can_delete":false,"product_type":"c1","uid":1693576,"ip_address":"","ucode":"7878ED3EB11E97","user_header":"https://static001.geekbang.org/account/avatar/00/19/d7/88/7dcde249.jpg","comment_is_top":false,"comment_ctime":1622199566,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1622199566","product_id":100039001,"comment_content":"老师，您讲的代替方案的意思不还是要保证只有一个实例么，也属于单例吧？","like_count":0},{"had_liked":false,"id":294944,"user_name":"JKwar","can_delete":false,"product_type":"c1","uid":1047466,"ip_address":"","ucode":"B733CA24D5701F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/aa/01fedf6c.jpg","comment_is_top":false,"comment_ctime":1622163168,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1622163168","product_id":100039001,"comment_content":"课堂讨论一：可以通过依赖注入的方式提高代码的可测试性，mock类即刻。<br>课堂讨论二：直接判断是否已经初始化，已经初始化就直接抛出异常。","like_count":0},{"had_liked":false,"id":288064,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1618284408,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618284408","product_id":100039001,"comment_content":"1、考虑将单例CacheManger单例对象作为Demo类的成员变量，通过构造函数注入，那就可以通过Mock出指定User对象进行后续对比测试<br>2、主要还是考察需求是这样的，按原文意思是需要不同参数不同实例，那么可以考虑通过Map维护传入参数和实例的映射关系，需要注意构建过程的安全性和指定参数的唯一性","like_count":0},{"had_liked":false,"id":279105,"user_name":"辉","can_delete":false,"product_type":"c1","uid":1697810,"ip_address":"","ucode":"0D7B2C24BA8BD2","user_header":"https://static001.geekbang.org/account/avatar/00/19/e8/12/74f387c8.jpg","comment_is_top":false,"comment_ctime":1613623236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613623236","product_id":100039001,"comment_content":"单例的出现就是为了解决一些存在的问题而出现的。至于说这是一种反模式，我觉得不太妥。任何东西都有两面性，单例也一样。对于一些公共的管理类来说，单例确实是比较好的选择。比如我要管理一个全局的网络状态，这时候讲这个管理类设置为单例就是合理的。","like_count":0},{"had_liked":false,"id":267475,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1607761564,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1607761564","product_id":100039001,"comment_content":"1. 把User cachedUser = CacheManager.getInstance().getUser(userId); <br>User actualUser = userRepo.getUser(userId);拆成两个方法，便于使用mock测试<br>2. getInstance方法不要加参数。","like_count":0},{"had_liked":false,"id":259777,"user_name":"心有不甘","can_delete":false,"product_type":"c1","uid":2222598,"ip_address":"","ucode":"4B48BC4B357C3A","user_header":"https://static001.geekbang.org/account/avatar/00/21/ea/06/1bfbbf4f.jpg","comment_is_top":false,"comment_ctime":1604830351,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604830351","product_id":100039001,"comment_content":"讨论一：<br>  啥是mock啊，啥是可测试性呢。 如果我要测试validateCachedUser(long userId) 方法, 直接单元测试这个方法, 传递参数进去，用断言判断运行值和期望值，这个算测试么？没有理解单例模式对这里的影响。<br><br>讨论二：为什么类中的参数AB要设置成final呢，不提供修改方法，值也会修改么。可否去掉final,在getInsatance方法中，再加入一次赋值呢?<br><br>public class Singleton { <br>  private static Singleton instance = null; <br>  private int paramA; <br>  private int paramB; <br>  private Singleton(int paramA, int paramB) { <br>    this.paramA = paramA; <br>    this.paramB = paramB; <br>  } <br>  public synchronized static Singleton getInstance(int paramA, int paramB) { <br>    if (instance == null) { <br>      instance = new Singleton(paramA, paramB); <br>    } <br>    instance.paramA = paramA;<br>    instance.paramB = paramB;<br>    return instance; <br>  }<br>}<br>","like_count":0},{"had_liked":false,"id":257411,"user_name":"Daiver","can_delete":false,"product_type":"c1","uid":1466447,"ip_address":"","ucode":"9B1A03AFBC79BC","user_header":"https://static001.geekbang.org/account/avatar/00/16/60/4f/db0e62b3.jpg","comment_is_top":false,"comment_ctime":1603962907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603962907","product_id":100039001,"comment_content":"内部使用一个Map，参数AB作为key，map存在则直接返回，map不存在实例化一个，并存入map中，然后返回。","like_count":0},{"had_liked":false,"id":253458,"user_name":"RedDevil","can_delete":false,"product_type":"c1","uid":1131128,"ip_address":"","ucode":"F8F5DC209BB3B9","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/78/7ba89c75.jpg","comment_is_top":false,"comment_ctime":1602744320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602744320","product_id":100039001,"comment_content":"看争哥的文章有种茅塞顿开的感觉","like_count":0},{"had_liked":false,"id":250696,"user_name":"Gopher","can_delete":false,"product_type":"c1","uid":1206229,"ip_address":"","ucode":"3C1F9012BB486D","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","comment_is_top":false,"comment_ctime":1601198500,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601198500","product_id":100039001,"comment_content":"1、应该是把CacheManger这个对应的类作为参数传到一个函数里，通过函数来getInstance()，这样mock 的CacheManger 就可以作为参数传进去了<br><br>2、抛出异常，如果是通过不同参数来返回不同的实例，就不应该用单利来做了","like_count":0},{"had_liked":false,"id":249774,"user_name":"Leaf","can_delete":false,"product_type":"c1","uid":1102194,"ip_address":"","ucode":"9AB56B7971237D","user_header":"https://static001.geekbang.org/account/avatar/00/10/d1/72/4cc8475c.jpg","comment_is_top":false,"comment_ctime":1600785885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600785885","product_id":100039001,"comment_content":"题目一，可以用一个类包一层，封装下 CacheManager，然后 mock 这封装类<br>题目二，如果允许存在参数不同实例不同，可以用支持并发的字典保存对象(key为params生成），这样就能支持参数不同实例不同","like_count":0},{"had_liked":false,"id":248068,"user_name":"神毓逍遥","can_delete":false,"product_type":"c1","uid":2147220,"ip_address":"","ucode":"83351CB18B190E","user_header":"https://static001.geekbang.org/account/avatar/00/20/c3/94/e89ebc50.jpg","comment_is_top":false,"comment_ctime":1599999909,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1599999909","product_id":100039001,"comment_content":"我是Python开发者，第二种希望传入参数生效是有这个场景需求的，比如数据库连接池，当在fork子进程时，配置参数发生变化时，希望重新生成对象，这时候需要不在__init__中实例化，而设计一个新函数，当传入force_refresh参数为True时重新实例化","like_count":0,"discussions":[{"author":{"id":1079816,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7a/08/4d3e47dd.jpg","nickname":"Aaron Cheung","note":"","ucode":"03972759C53667","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305763,"discussion_content":"很赞的分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600078471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242481,"user_name":"木子","can_delete":false,"product_type":"c1","uid":1784886,"ip_address":"","ucode":"F9548C192F9687","user_header":"https://static001.geekbang.org/account/avatar/00/1b/3c/36/94762d1c.jpg","comment_is_top":false,"comment_ctime":1597739114,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597739114","product_id":100039001,"comment_content":"在我们视野内（经验或者业务建模上），立足脚下的取应用单例模式","like_count":0},{"had_liked":false,"id":238508,"user_name":"Next","can_delete":false,"product_type":"c1","uid":1748213,"ip_address":"","ucode":"D5ADDF248A9504","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ac/f5/2f97e279.jpg","comment_is_top":false,"comment_ctime":1596185766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596185766","product_id":100039001,"comment_content":"针对单例扩展性的解决方法举例：<br>用户ID生成器：<br>语义是真正的全局唯一，采用单列；<br>且；<br>ID生成算法是可变更的，所以不直接使用某个通用的ID生成器，而是构建一个新的用户ID专用的生成器，包含某个实际的ID生成类的引用。如下，如果要更换ID的生成方法，只需替换掉SimpleSequenceIDGen。<br>public enum UserID {<br>    I;<br>    private IIDLongGen gen = new SimpleSequenceIDGen();<br><br>    public long generate() {<br>        return gen.generate();<br>    }<br><br>}","like_count":0},{"had_liked":false,"id":237939,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1596010232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596010232","product_id":100039001,"comment_content":"我的想法是，单例也是可以实现接口的，可以通过面向接口依赖注入。","like_count":0},{"had_liked":false,"id":237541,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1595858875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595858875","product_id":100039001,"comment_content":"第一个问题 前面的代码测试性已经讲过，将需要用到单例的功能再wrap出来一个函数和子类，测试时mock这个子类 并测试这个包裹函数即可。<br>第二个问题，还是用个 init或者updateParameter比较好 ，不过项目中几乎没有遇到过这样的实际问题。","like_count":0},{"had_liked":false,"id":235815,"user_name":"Chord","can_delete":false,"product_type":"c1","uid":2019109,"ip_address":"","ucode":"6E248DA470FACC","user_header":"https://static001.geekbang.org/account/avatar/00/1e/cf/25/8c91fd43.jpg","comment_is_top":false,"comment_ctime":1595209852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595209852","product_id":100039001,"comment_content":"请问，双重校验锁+静态内部类的实现方式，无法支持含参构造函数吗？","like_count":0},{"had_liked":false,"id":229555,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1593056722,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1593056722","product_id":100039001,"comment_content":"1、单例对OOP不友好。OOP四大特性，封装、继承、抽象、多态。单例违背基于接口而非实现设计原则，广义上来说违背了抽象特性。单例一般不会被继承，所以直接放弃了继承、多态。<br>2、单例会隐藏类之间的依赖关系。阅读代码希望一眼能看出类之间关系。一般通过构造函数、参数传递等方式声明类之间依赖关系，而单例不需显示创建、不需要传递参数。如果代码比较复杂，这种调用关系比较隐蔽，阅读代码就需要都看完每个函数的实现才能看出这种关系。<br>3、单例对代码扩展性不好。单例只有一个实例。如果想扩展多个实例，代码改动大，修改成本高。<br>4、单例对代码可测试性不好。单例如果依赖外部资源，想进行mock替换测试，但由于单例的硬编码，无法mock。还有如果有可变成员变量，多个测试用例执行，需要排除成员变量的变化导致测试用例通不过问题。<br>5、单例不支持有参构造函数。如果想定制这个单类，就比较麻烦，也会引发一些误解。<br><br>思考题1：User cachedUser = CacheManager.getInstance().getUser(userId);这个单独抽成一个方法，CacheManager单例通过依赖注入方式注入。User actualUser = userRepo.getUser(userId);这个也单独抽成一个方法。针对validateCachedUser写单元测试，只需要将获取两个用户信息的方法用mock替换即可。<br>思考题2：第一种通过抛出异常来提示重复。第二种通过覆盖方式进行。","like_count":0},{"had_liked":false,"id":225700,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1591837324,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591837324","product_id":100039001,"comment_content":"使用时替换，单例无法使用时替换","like_count":0},{"had_liked":false,"id":223326,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1591062809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591062809","product_id":100039001,"comment_content":"&lt;二周目拾遗&gt;<br><br><br>&#47;**<br> * 不知道你有没有发现，上面的代码实现稍微有点问题。<br> * 如果我们如下两次执行 getInstance() 方法，<br> * 那获取到的 singleton1 和 signleton2 的 paramA 和 paramB 都是 10 和 50。<br> * 也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提示，这样就会误导用户。这个问题如何解决呢？<br> * 留给你自己思考，你可以在留言区说说你的解决思路。*&#47;<br>public class Singleton {<br><br>    private static volatile Singleton INSTANCE;<br><br>    private static int paramA;<br>    private static int paramB;<br><br>    private Singleton(){}<br><br>    public static Singleton getInstance(int paramA, int paramB){<br>        if (INSTANCE == null){<br>            synchronized (Singleton.class){<br>                if (INSTANCE == null){<br>                    INSTANCE = new Singleton();<br>                }<br>            }<br>        }<br><br>        if (INSTANCE.paramA != paramA || INSTANCE.paramB != paramB){<br>            INSTANCE.paramA = paramA;<br>            INSTANCE.paramB = paramB;<br>        }<br><br>        return INSTANCE;<br>    }<br>}","like_count":0},{"had_liked":false,"id":221023,"user_name":"buggetout","can_delete":false,"product_type":"c1","uid":1880582,"ip_address":"","ucode":"63A948EF415FDD","user_header":"https://static001.geekbang.org/account/avatar/00/1c/b2/06/2086d76d.jpg","comment_is_top":false,"comment_ctime":1590383215,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590383215","product_id":100039001,"comment_content":"单例模式的缺点<br>不支持面向对象特性，更像是面向过程。<br>对代码的扩展性不好<br>对代码的可测试性不好<br>不能有带参构造函数<br>","like_count":0},{"had_liked":false,"id":221005,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1590377409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590377409","product_id":100039001,"comment_content":"1. 我觉得第一问的关键在于 里面用了个单列(如果多个线程都在用这个单例) 会影响测试结果，所以才会导致可测试性不高 所以考虑新增一个测试的数据或者实例 让正式的和测试的数据分开  同时还要加锁 ，避免资源竞争<br>2. 第二问 我觉得 应该是抛出一个异常(或者给出个提示) 已经初始化过了 最好是加个返回值 判断init是否成功已经失败的原因","like_count":0},{"had_liked":false,"id":215220,"user_name":"worthto","can_delete":false,"product_type":"c1","uid":1387712,"ip_address":"","ucode":"41D7ABBBD2E7FF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","comment_is_top":false,"comment_ctime":1588931968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588931968","product_id":100039001,"comment_content":"关于问题 现有的代码中有太多的单例，可以考虑重写现有的单例对象的newStance方法，然后再依赖注入一个单例对象的生成器InstanceBuilder类，把创建的方法放到这个类中。这样的话，就把创建这个单例对象的逻辑解耦了，单例只负责单例对象的管理。职责也单一。如果需要进行mock，那就写一个InstanceBuilderMock类进行测试。","like_count":0},{"had_liked":false,"id":211983,"user_name":"🎸spray","can_delete":false,"product_type":"c1","uid":1062202,"ip_address":"","ucode":"D183FDBB32222C","user_header":"https://static001.geekbang.org/account/avatar/00/10/35/3a/3afc8d67.jpg","comment_is_top":false,"comment_ctime":1588042805,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588042805","product_id":100039001,"comment_content":"2 - swift<br>final class Singleton {<br>    private static let _shared = Singleton()<br>    private var a: Int?<br>    private var b: Int?<br>    <br>    private init () {}<br>    public static func shared(a: Int = 0, b: Int = 0) -&gt; Singleton {<br>        _shared.a = a<br>        _shared.b = b<br>        return _shared<br>    }<br>}","like_count":0},{"had_liked":false,"id":210214,"user_name":"zhengyu.nie","can_delete":false,"product_type":"c1","uid":1541669,"ip_address":"","ucode":"FFE0377D323E46","user_header":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","comment_is_top":false,"comment_ctime":1587698807,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587698807","product_id":100039001,"comment_content":"数据连接池、线程池在Spring环境下其实还是单例的，在Spring重型注入框架体系下，基本上编程范式都是用对应的@Configuration注解下，注入隔离的池子。比如有一个ThreadPoolConfiguration，里面几个@Bean，每一个Bean是一个线程池，业务身份隔离，使用的地方依赖查找对应beanName的池子，托给Spring管理了。","like_count":0},{"had_liked":false,"id":204737,"user_name":"Wh1","can_delete":false,"product_type":"c1","uid":1282715,"ip_address":"","ucode":"6D28506B99A285","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/9b/65f98192.jpg","comment_is_top":false,"comment_ctime":1586447706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586447706","product_id":100039001,"comment_content":"将单例初始化参数放到Config类中这段代码其实存在问题，和第二种解决方案一样，如果我们在运行时动态修改了初始化参数，那么获取到的也会是用之前的参数创建的单例对象。<br>解决方案可以是：不直接对Config类中的参数赋值，而是通过 setter 在初始化 instance 之前进行赋值。原理其实和第一种解决方案差不太多。<br>但回过头想，如果一开始就预料到要通过不同参数创建不同的对象，那么这种场景也不适合使用单例模式。","like_count":0},{"had_liked":false,"id":204460,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1586402734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586402734","product_id":100039001,"comment_content":"第二题，如果第二次没成功，抛出异常即可。<br><br>没想到单例模式还有这么多缺点，这是我没想到过的，我看别的文章都是直接告诉我怎么实现单例模式，争哥牛逼","like_count":0},{"had_liked":false,"id":203114,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586141362,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586141362","product_id":100039001,"comment_content":"##思考题2<br>第二次没有生效也没有特殊提示的原因分析：因为第一次已经创建了实例，所以，第二次直接返回了。并没有走再次走到单例构造函数的执行，故而相关的值还是原来的值。","like_count":0},{"had_liked":false,"id":202968,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1586095039,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586095039","product_id":100039001,"comment_content":"我感觉单例的这些问题都不是问题，大不了就用依赖注入的方式，从外面传进去实例。至于单例本身可以了依赖接口开发","like_count":0},{"had_liked":false,"id":201494,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1585795651,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585795651","product_id":100039001,"comment_content":"到底哪一版jdk实现了实例化对象避免指令重排？？指令重排本来就是一种优化手段，我感觉不可能会全部禁用掉吧，手动volatile禁用才是最合理的。请老师回复一下","like_count":0},{"had_liked":false,"id":200973,"user_name":"Geek_0a912e","can_delete":false,"product_type":"c1","uid":1797776,"ip_address":"","ucode":"3764D74EECF8E6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKAyfsLlZkYjRiaSiaxf07h6hNEu2AKyoZpCYqoE5K7xv13LdwCwE7ZDnSxr8drc5gOumgiapbn27KicA/132","comment_is_top":false,"comment_ctime":1585700766,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1585700766","product_id":100039001,"comment_content":"这条没太看明白，麻烦再解释一下：单例不支持有参数的构造函数","like_count":0,"discussions":[{"author":{"id":2446652,"avatar":"","nickname":"Geek_70aee8","note":"","ucode":"ABC47717D5B655","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354533,"discussion_content":"我的看法是：正如问题讨论2中的情况，如果输入两组参数进去的话，需要修改单例类的代码，才能保证输入不同参数时生成不同单例类；如果两次输入参数一致，还得保证两次调用同一个单例类。所以，单例支持带参数的构造函数的话，会产生误导。\n解决方法：通过将参数写成配置文件的形式，然后构造函数内部通过读取配置信息生成对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615300102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1967515,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/7xB3OdNLiaPgZQibVAD52Jx04buk6Tb3I7A4wcdea2c6YXxJGdKgGCPgPuGWh69CffdSJKOqJFzVRVOEWBqFybJA/132","nickname":"Geek_83f2ce","note":"","ucode":"471D47B2A342E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294546,"discussion_content":"我也不太懂这一点，有没有懂的小伙伴？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595922749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198102,"user_name":"junmawang","can_delete":false,"product_type":"c1","uid":1763466,"ip_address":"","ucode":"977E9E25CE6C94","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e8/8a/803a42e0.jpg","comment_is_top":false,"comment_ctime":1585409229,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585409229","product_id":100039001,"comment_content":"针对与传递进去的参数是不生效的问题，可以在类中定义两个临时变量，对上一次创建实例对paramA, paramB赋值到临时变量，下次调用判断是否一致，不一致则重新创建","like_count":0},{"had_liked":false,"id":193623,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1584935396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584935396","product_id":100039001,"comment_content":"老师   我感觉这段其实不算是一种新的替代方案，它仍然算是“单例模式”啊，只不过这个例子比较特殊。<br><br>public class IdGenerator {  private static AtomicLong id = new AtomicLong(0);    public static long getId() {     return id.incrementAndGet();  }}<br><br><br>","like_count":0},{"had_liked":false,"id":187307,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1584080674,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584080674","product_id":100039001,"comment_content":"思考题：<br>1. 用工厂模式把CacheManager.getInstance()对象创建提出来<br>2. <br>public class Singleton {<br>    private static Singleton instance = null;<br>    private final int paramA;<br>    private final int paramB;<br>    private static int variableA = 0;<br>    private static int variableB = 0;<br><br>    private Singleton(int paramA, int paramB) {<br>        this.paramA = paramA;<br>        this.paramB = paramB;<br>    }<br><br>    public synchronized static Singleton getInstance(int paramA, int paramB) {<br>        if (instance == null) {<br>            instance = new Singleton(paramA, paramB);<br>            variableA = paramA;<br>            variableB = paramB;<br>        } else if (paramA == variableA &amp;&amp; paramB == variableB) {<br>            return instance;<br>        } else {<br>            throw new RuntimeException(&quot;Parameter 20&#47;30 creation failed&quot;);<br>        }<br>        return instance;<br>    }<br><br>}<br>","like_count":0},{"had_liked":false,"id":183107,"user_name":"雷刚","can_delete":false,"product_type":"c1","uid":1655725,"ip_address":"","ucode":"115FE2BE1AAB61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132","comment_is_top":false,"comment_ctime":1582954565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582954565","product_id":100039001,"comment_content":"以前写过一个 TelnetManager 的类，写单元测试的时候很痛苦，不过那时候只是觉得单例不好写单元测试，没有细想，听了老师的分析才豁然开朗","like_count":0},{"had_liked":false,"id":181047,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1582465760,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582465760","product_id":100039001,"comment_content":"1. 把 CacheManager.getInstance().getUser(userId);封装成方法<br>2. 做一个判断。如果已经初始化抛出异常","like_count":0},{"had_liked":false,"id":179793,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1582100552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582100552","product_id":100039001,"comment_content":"讨论题1: 这里测试的不是单例对象, 而是依赖单例的类, 所以单例可以直接用依赖注入的形式传入即可, Demo类不要在内部创建单例对象, 而是直接使用外部传入的单例对象.<br>讨论题2: 把不同的参数转成字符串作为key, 再用一个字典针对每一个key单独创建单例对象, 这样可以保证传入的参数相同时获取到的对象是同一个, 不同参数对应不同单例对象.","like_count":0},{"had_liked":false,"id":179495,"user_name":"HYM","can_delete":false,"product_type":"c1","uid":1054178,"ip_address":"","ucode":"4E82D9A285DAFF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/e2/c21553c4.jpg","comment_is_top":false,"comment_ctime":1582015910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582015910","product_id":100039001,"comment_content":"第一个问题：把cache user的获取改成函数返回，这样可以在测试的时候对函数进行mock。<br>第二个问题：此时需要比较已经存在的instance的参数和传入的新参数是否一致，一致就返回instance，不一致直接报错。","like_count":0},{"had_liked":false,"id":178737,"user_name":"桂城老托尼","can_delete":false,"product_type":"c1","uid":1306032,"ip_address":"","ucode":"139E4B8EE88B79","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","comment_is_top":false,"comment_ctime":1581810136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581810136","product_id":100039001,"comment_content":"感谢分享，尝试回答下<br>1,cacheManager作为demo的属性，构造demo对象时 获取单例，而非每次调用方法时获取。<br>2，compareAndUpdate 思路去解决这个问题，不过虽然能解决问题，但这种用法真的好吗？太刁钻了~","like_count":0},{"had_liked":false,"id":178618,"user_name":"FIGNT","can_delete":false,"product_type":"c1","uid":1540988,"ip_address":"","ucode":"D9DB185AE9E67C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","comment_is_top":false,"comment_ctime":1581760000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581760000","product_id":100039001,"comment_content":"1、将单例获取对象的代码抽离单独方法。再对方法mock<br>2、如果参数不相同，直接报错，告诉使用者如何使用。<br>public synchronized static Singleton getInstance(int paramA, int paramB) {<br>    if (instance == null) {<br>      instance = new Singleton(paramA, paramB);<br>    }else{<br>    \tif(paramA == this.paramA &amp;&amp; paramB == this.paramB){<br>    \t\treturn instance;<br>    \t}else{<br>    \t\tthrow new RuntimeException(&quot;illegal argument,please use getInstance(&quot;+this.paramA+&quot;,&quot;+this.paramB+&quot;) method&quot;);<br>    \t}<br>    }<br>  }","like_count":0},{"had_liked":false,"id":178045,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1581577673,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581577673","product_id":100039001,"comment_content":"课堂讨论: 1. 把 User cachedUser = CacheManager.getInstance().getUser(userId); 抽出来, 变成一个函数,这样就可以对函数 mock 了<br>             2. 在进 getInstance函数的时候, 对全局变量 instance 置空<br><br>","like_count":0},{"had_liked":false,"id":177933,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1581553616,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581553616","product_id":100039001,"comment_content":"打卡～","like_count":0},{"had_liked":false,"id":177448,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1581394703,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581394703","product_id":100039001,"comment_content":"第二次调用getInstance时如果带有与之前相同参数就直接返回instance实例;如果参数不相同且业务允许构建新的instance实例就允许再第二次getInstance时构建新的实例,如果业务不允许就在构建时抛出异常.","like_count":0},{"had_liked":false,"id":177283,"user_name":"bin","can_delete":false,"product_type":"c1","uid":1307082,"ip_address":"","ucode":"EC4F4194082715","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/ca/9b9b8a7c.jpg","comment_is_top":false,"comment_ctime":1581341486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581341486","product_id":100039001,"comment_content":"第一个问题：把 CacheManager.getInstance().getUser() 封装成一个函数,可以用来mock<br>public User getCacheUser(long userId){<br>}<br><br>第二个问题，加一个判断，<br><br>public synchronized static Singleton getInstance(int paramA, int paramB) {<br> if (instance == null) { <br>     instance = new Singleton(paramA, paramB); <br>     return instance;<br> }<br>if( instance != null &amp;&amp; (paramA != this.paramA || paramB != this.paramB )  ){<br>     throw new RunTimeException(&quot;不能重复初始化&quot;);<br>}<br> return instance; <br>}","like_count":0},{"had_liked":false,"id":177239,"user_name":"天天向上卡索","can_delete":false,"product_type":"c1","uid":1009850,"ip_address":"","ucode":"E3724C3B39BD3F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/68/ba/c0cf8bf3.jpg","comment_is_top":false,"comment_ctime":1581330360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581330360","product_id":100039001,"comment_content":"在 .net core 里，依赖注入模式的使用比较多，对于一些配置会通过options模式来处理，option也可以注入，很灵活","like_count":0},{"had_liked":false,"id":176980,"user_name":"Uncle.Wang","can_delete":false,"product_type":"c1","uid":1456955,"ip_address":"","ucode":"9A4F646CFC237F","user_header":"https://static001.geekbang.org/account/avatar/00/16/3b/3b/b8c00291.jpg","comment_is_top":false,"comment_ctime":1581240820,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1581240820","product_id":100039001,"comment_content":"我遇到的问题是：在client端开发的时候，工程中有大量单例，这些单例中保存着数据，而这些数据可能是和用户账户相关联的，一旦切换账号，面临reset这些单例的问题，往往存在遗漏。如果大量存在这种单例，会很难维护。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503177,"discussion_content":"小伙你妹啊 我都中年油腻大叔了������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597412235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176924,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1581228054,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1581228054","product_id":100039001,"comment_content":"<br><br><br><br>课堂讨论 <br><br>1. 修改validateCachedUser()方法形参: <br><br>   public boolean validateCachedUser(int userId, \tCacheManager manager){...}<br><br>​    <br><br>2. 带有参数的getInstance()的一种实现方式:<br><br>   public syncrinized static Singleton getInstance(int paramA, int paramB){<br><br>   ​    if(instance == null){<br><br>   ​        instance = new Singleton(paramA, paramB);<br><br>   ​        }<br><br>   <br><br>   ​    if(this.paramA != paramA || this.paramB != paramB){<br><br>   ​        instance = new Singleton(paramA, paramB);<br><br>   ​        }<br><br>   <br><br>   ​    return instance;<br><br>   }","like_count":0,"discussions":[{"author":{"id":1046893,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f9/6d/b623562a.jpg","nickname":"霹雳大仙pp","note":"","ucode":"F654FD9AEC1D56","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":195625,"discussion_content":" CacheManager带在形参里，违反了迪米特法则，抽成一个protected方法更好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583291970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176920,"user_name":"mghio","can_delete":false,"product_type":"c1","uid":1213078,"ip_address":"","ucode":"74883EDE4FD0DC","user_header":"https://static001.geekbang.org/account/avatar/00/12/82/96/aa795685.jpg","comment_is_top":false,"comment_ctime":1581225613,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581225613","product_id":100039001,"comment_content":"优秀，单例模式竟然还有这么多问题以前只是用，从来没有考虑过这方面","like_count":0},{"had_liked":false,"id":176699,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1581141690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581141690","product_id":100039001,"comment_content":"1.把单例部分抽出来；<br>2.为空或者一致的时候返回可用instance，不一致则抛错。","like_count":0},{"had_liked":false,"id":176680,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1581137134,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581137134","product_id":100039001,"comment_content":"问题2使用不同参数构造不同单例，是这个需求吗？如果是那么维护类就不能只有一个instance的成员变量，应该考虑有类似cachedMap的方式，instance要实现equals和hashCode方法，针对不同入参作为不同的key，线程安全的去访问cachedMap进行存取。","like_count":0},{"had_liked":false,"id":176581,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1581091338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581091338","product_id":100039001,"comment_content":"直接更新属性怕是会有一个安全问题吧，一个长线程如果一直在使用对象，一个其他线程进来后，把这个单例对象的属性直接修改了。长线程接下来如果使用到单例对象，属性就全变了。线程安全性太差了。","like_count":0},{"had_liked":false,"id":176407,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1581052034,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581052034","product_id":100039001,"comment_content":"第一个问题可以先抽取一个函数，然后mock 第二个问题，可以比较传入的参数对比，相同才进行新建对应对象","like_count":0},{"had_liked":false,"id":176358,"user_name":"好吃不贵","can_delete":false,"product_type":"c1","uid":1316993,"ip_address":"","ucode":"6576E2BECE4F7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/18/81/83b6ade2.jpg","comment_is_top":false,"comment_ctime":1581042586,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581042586","product_id":100039001,"comment_content":"关于单例模式的替换方案。类实现时normalClass用普通写法，构造函数也是public的。在类外面，全局定义static normalClass obj;这样直接调用obj的方法是不是也是全局唯一了，至少同一进程内是一样的，也算是一种单例的替代方案？","like_count":0},{"had_liked":false,"id":176349,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1581040330,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581040330","product_id":100039001,"comment_content":"1.通过参数的方式将单例类传递进函数。<br>2.如果单例对象存在，就对比两个成员变量，不一致就抛出异常提示调用方，一致就直接返回单例对象。","like_count":0},{"had_liked":false,"id":176337,"user_name":"石维康","can_delete":false,"product_type":"c1","uid":1067564,"ip_address":"","ucode":"E39ED8416B2C01","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/2c/f8451d77.jpg","comment_is_top":false,"comment_ctime":1581038842,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1581038842","product_id":100039001,"comment_content":"<br>public class Singleton {<br>  private static Singleton instance = null;<br>  private final int paramA;<br>  private final int paramB;<br><br>  private Singleton(int paramA, int paramB) {<br>    this.paramA = paramA;<br>    this.paramB = paramB;<br>  }<br><br>  public static Singleton getInstance() {<br>    if (instance == null) {<br>       throw new RuntimeException(&quot;Run init() first.&quot;);<br>    }<br>    return instance;<br>  }<br><br>  public synchronized static Singleton init(int paramA, int paramB) {<br>    if (instance != null){<br>       throw new RuntimeException(&quot;Singleton has been created!&quot;);<br>    }<br>    instance = new Singleton(paramA, paramB);<br>    return instance;<br>  }<br>}<br><br>Singleton.init(10, 50); &#47;&#47; 先init，再使用<br>Singleton singleton = Singleton.getInstance();<br><br>请问老师这里的init方法为何需要返回一个Singleton？写成void不行吗？","like_count":0,"discussions":[{"author":{"id":1316993,"avatar":"https://static001.geekbang.org/account/avatar/00/14/18/81/83b6ade2.jpg","nickname":"好吃不贵","note":"","ucode":"6576E2BECE4F7C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163161,"discussion_content":"貌似void也可以？不过返回的instance的话，系统初始化时候可以判断是不是初始化成功了，更好些。猜测。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581055682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}