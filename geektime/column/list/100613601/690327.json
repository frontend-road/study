{"id":690327,"title":"04｜从JIT到AOT：JVM编译器的云原生演进之路","content":"<p>你好，我是康杨。今天我们来聊一聊JVM的编译器。</p><p>JVM的一个重要职责就是把字节码拿到实际运行的物理机上去执行，其中重要的一环，就是根据不同的底层操作系统和CPU架构，把字节码转化为实际物理机能够识别的机器码。</p><p><img src=\"https://static001.geekbang.org/resource/image/yy/b2/yy3970yy80b5749a167747b6905216b2.png?wh=1920x607\" alt=\"图片\"></p><h2>字节码转化为机器码的发展历程</h2><p>在JVM的演进历程中，字节码到机器码的转化环节共经历了三个发展阶段，分别是解释执行阶段、解释执行+编译执行阶段、提前编译阶段。</p><p><img src=\"https://static001.geekbang.org/resource/image/de/7d/de5aca6c5d034abaf30cb77412f5587d.png?wh=1920x1248\" alt=\"图片\"></p><h3>解释执行（Interpreter Execution)</h3><p>解释执行就是将编译好的字节码一行一行地翻译成机器码执行。这种模式在JVM的早期版本中就已经存在了，它舍弃了编译时间，只在程序运行时把字节码实时翻译为机器代码。</p><p>在解释执行过程中，由于每次都需要重新解释字节码，相同的字节码会存在被反复多次翻译执行的情况，所以采用这种模式的程序运行性能一般比较低。为此，JVM在解释执行的基础上引入了即时编译执行技术。</p><h3>即时编译（Just in Time Compilation）</h3><p>即时编译也就是我们常说的JIT，以方法为单位，即时编译将字节码一次性翻译为机器码后再执行。JIT编译器从JDK 1.1 版本开始引入。通过这种技术，JVM 就可以发现某段字节码被反复执行，从而启动JIT编译器，把这段字节码编译成机器代码，提高运行速度。</p><!-- [[[read_end]]] --><p>这种方式虽然会根据运行时机器的实时状态，比如内存状态等，生成最优的机器代码，但是它也需要占用额外的内存空间，并与运行时的程序竞争CPU资源。并且需要在系统运行一段时间后才能达到运行时的性能巅峰。这就像你刚刚入职一家公司，需要有一个了解的过程，熟悉之后，才能达到最佳的工作状态。</p><p>但是这与云原生时代系统启动即性能巅峰的要求是有出入的。所以虽然主流的JVM依然是采用解释执行 + 编译执行的混合模式，但是更符合云原生要求的提前编译模式已经开始崭露头角。</p><h3>提前编译（Ahead of Time Compilation）</h3><p>提前编译也就是我们常说的AOT。AOT编译器是从JDK 1.9开始引入的 JEP 295规范。与JIT编译器不同，AOT是在程序运行前就把字节码编译成了机器码。</p><p>使用AOT编译器的优势在于你可以在部署应用程序前编译代码，而不是在运行时才编译，这可以减少应用程序启动时和运行时需要的 CPU资源，优化资源的使用方式，减少启动延迟时间，提高性能。这就像你在入职一家公司之前，就提前了解并达到了对应岗位的技能要求，这样你在入职的第一天就能达到最佳的工作状态。</p><p>从最初的解释执行，到即时编译技术，再到最新推出的提前编译技术，JVM在追求字节码执行性能提升的道路上，从依赖自身平台无关性的解决方案一步步转变到依赖云原生时代由容器提供平台无关性的解决方案上。下面我们就来详细聊一聊JVM中的JIT和AOT技术。</p><h2>详解 JIT</h2><p><img src=\"https://static001.geekbang.org/resource/image/51/00/51d96aaf8d19a9bd1353f43740576100.png?wh=1920x522\" alt=\"图片\"></p><p>在实际的生产实践中，一般是将解释执行与编译执行结合起来使用，以达到最佳的性能。这背后的逻辑和JVM将堆分成新生代和老年代一样，除了JVM中对象的生命周期存在二八定律，我们所运行的代码也同样存在二八定律，也就是说 80%的CPU时间是在处理20%的代码，这就是JIT可以通过深度优化热点代码来提升性能的原因。</p><h3>混合模式下Java代码执行流程</h3><p><img src=\"https://static001.geekbang.org/resource/image/24/40/243fe603388dffe7414ee700c7610440.png?wh=1920x1121\" alt=\"图片\"></p><p>你可以看一下混合模式（解释执行+编译执行）下 Java 代码的执行过程，主要分为 4 个阶段。</p><ol>\n<li>前端编译：将Java源代码通过Javac编译器编译成字节码，就是我们常说的编译过程。</li>\n<li>加载：JVM中的类加载器（Classloader）读取字节码文件，并在JVM运行时空间中生成对应的内容。</li>\n<li>解释执行：JVM解释器开始工作，逐行读取字节码，并把字节码翻译为底层系统可以执行的机器码。</li>\n<li>即时编译：JVM在运行时将热点代码编译成机器码，并缓存起来，下次需要执行同样的字节码时，直接运行对应的机器码。</li>\n</ol><h3>JIT 触发时机</h3><p>JVM通过分析代码的运行情况，如方法调用频率、循环代码等，决定是否将某段字节码编译成本机代码，以提高运行速率。</p><p>即时编译的触发机制具有一定的动态性，并不是所有的Java代码都会被编译为机器代码，只有在监视和分析后确认为热点代码的才会被转化为机器代码。具体的策略细节可能会因为JVM的版本、配置选项、运行环境等因素而有所改变。</p><pre><code class=\"language-java\">public class TestJIT {\n&nbsp;&nbsp;&nbsp; private static final int NUM = 15000;\n&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp; public static void main(String[] args) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testMethod();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; NUM; i++) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testMethod();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; public static void testMethod() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; NUM; i++) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // do something...\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>对应的部分字节码：</p><pre><code class=\"language-java\">public class TestJIT\n&nbsp; public static final int NUM;\n&nbsp; public static void main(java.lang.String[]);\n&nbsp;&nbsp;&nbsp; Code:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0: iconst_0\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1: istore_1\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2: goto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5: invokestatic&nbsp; #6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Method testMethod&amp; #40;&amp; #41;V\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8: iinc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1, 1\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11: iload_1\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12: getstatic &nbsp;&nbsp;&nbsp; #2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Field NUM:I\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15: if_icmplt &nbsp;&nbsp;&nbsp; 5\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18: return\n&nbsp; public static void testMethod();\n&nbsp;&nbsp;&nbsp; Code:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0: iconst_0\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1: istore_0\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2: iload_0\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3: getstatic &nbsp;&nbsp;&nbsp; #2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Field NUM:I\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6: if_icmpge &nbsp;&nbsp;&nbsp; 14\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9: iinc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 1\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12: goto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15: return\n}\n</code></pre><p>在main方法内，调用了testMethod方法（字节码第5行），并在一个循环中多次调用这个方法。字节码第2行的 <code>go to</code> 和15行的 <code>if_icmpit</code> 指令表示这个循环。</p><p>每次调用这个方法都会执行testMethod内部又一个循环。当程序执行时，这些频繁执行的热点代码就可能会被JVM的运行时编译器（JIT）注意到，并把这些代码编译优化为机器码。JVM 中默认编译阈值是 10000，这个值可能会因为JVM及版本的不同有所差异，当方法调用次数或方法中的循环次数超过这个阈值的时候，JIT 编译器就会尝试把这个方法的字节码编译成机器码，来达到优化的目的。</p><p>需要注意的是，这只是一个触发JIT可能性很高的示例，并不保证 JVM 一定会编译testMethod()方法。是否真正编译，取决于 JVM 的实际运行情况和具体实现策略，比如 JVM 的内存使用情况、CPU 负载情况，以及 JIT 编译器的具体实现等。也就是说，并不能通过一段固定的 Java 代码或字节码，确切地知道在哪部分会触发 JIT 编译。</p><h3>JIT 编译优化</h3><p>编译优化是JIT编译器的一个关键功能。它在运行时收集代码的信息并进行优化。通过动态分析方法调用、循环结构等，JIT编译优化可以提高代码的执行效率。具体来说，JIT编译优化会在运行时对Java字节码进行优化，使用方法内联、循环展开及逃逸分析等技术来提高代码的性能。下面我们就来详细聊下JIT的逃逸分析技术。</p><h4>逃逸分析</h4><p>逃逸分析是一个很重要的JIT优化技术。它的作用是判断对象是否会在方法外部被访问到，也就是逃出方法的作用域。逃逸分析是JIT编译器的一个步骤，通过JIT我们能够确定哪些对象可以被限制在方法内部使用，不会逃逸到外部，然后可以对它们进行优化，比如把它们分配在栈上而不是堆上，或者进行标量替换，把一个对象拆散成多个基本类型来存储。</p><p>通过这种方式，我们可以更加高效地分配内存并减少垃圾回收的压力。下面是一个简单的Java示例，演示逃逸分析的过程。</p><pre><code class=\"language-java\">public class EscapeAnalysis {\n&nbsp;&nbsp;&nbsp; public static void main(String[] args) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Food food = createFood();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x = food.getX();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"x: \" + x);\n&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; private static Food createFood() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new Food(10);\n&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; private static class Food {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private int x;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Food(int x) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.x = x;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public int getX() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>createFood()方法中创建的Food对象经过逃逸分析后，可以在main()方法中直接进行变量赋值，避免了对象的动态分配。</p><p>你可以看一下使用逃逸分析技术优化过后的代码示例。</p><pre><code class=\"language-java\">public class EscapeAnalysis {\n&nbsp;&nbsp;&nbsp; public static void main(String[] args) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x = 10;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"x: \" + x);\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>对象的创建被优化为直接在main()方法中分配并赋值给 <code>x</code> 变量，避免了对象的动态分配。</p><h4>适用场景</h4><p>逃逸分析的优化主要针对局部变量，判断堆上分配的对象是否逃逸出方法的作用域。合理地设计代码结构和数据的使用方式能够更好地利用逃逸分析来优化程序的性能。我们还可以通过逃逸分析减少堆上分配对象的开销，提高内存利用率。</p><p>我整理了一些使用逃逸分析的最佳实践，你可以参考。</p><ol>\n<li>对于临时对象或短期使用的对象，尽量使用局部变量来存储，以减少对象逃逸的可能性。</li>\n<li>避免在方法中返回对象引用，特别是如果对象只在方法内部使用。</li>\n<li>使用final关键字来限制对象的可变性，这样JIT编译器更容易进行逃逸分析和优化。</li>\n<li>对于复杂的数据结构，尽量使用基本类型、数组或集合类，以减少对象的分配和逃逸。</li>\n</ol><p>JIT编译优化对于提高Java应用程序的性能至关重要。通过深入理解JIT编译优化的原理与最佳实践，我们可以最大程度地利用JIT编译优化来提升代码的执行效率。</p><h2><strong>JIT编译器的演进：</strong>从C1、C2到Graal</h2><p>最早JIT主要有两种编译器，C1和C2。C1的主要优点是编译速度快，但优化代码的能力较弱；而C2编译器虽然编译过程较慢，但能更有效地优化代码。在各种服务端程序和分层编译算法中，C1和C2都扮演着重要的角色。但是C2编译器已有近20年的历史，代码复杂并且设计中存在一些缺陷，使其维护工作变得困难。为了解决这一问题，JDK 10推出了一款全新的JIT编译器：Graal（JEP 317）。</p><p>Graal是C2的接班者，核心代码全是用Java编写的。Graal扬长避短，吸纳了C2的优势，并加入了新的架构设计。通过这些改进，Graal很快在性能方面超过了C2，并在某些特定场景下显示出了极佳的性能。</p><p><img src=\"https://static001.geekbang.org/resource/image/96/58/96d3360696ab370129a860406eedaf58.png?wh=1920x1107\" alt=\"图片\"></p><h2>从 JIT 到 AOT</h2><p>为了支持云原生和容器化环境，JVM在执行Java程序时也在逐步从JIT编译转向AOT编译。这种转变可以通过GraalVM等工具来实现。</p><p>在传统的JIT编译中，Java程序在运行时会将字节码逐行编译成机器代码。这种动态编译能够针对运行时的状态和调用频率进行优化，但也导致了性能延迟和启动速度较慢的问题。</p><p>为了解决这些问题并适应云原生环境，JVM引入了AOT编译。AOT编译是在程序运行之前将字节码直接编译成本地机器代码。这种方式可以提高程序的运行速度和启动速度，并减少运行时动态编译的开销。</p><p>为了从JIT过渡到AOT，JVM将字节码与AOT编译相结合。在JIT编译运行时，JVM会监视代码的执行情况并收集相关的运行时信息，然后将这些信息传递给AOT编译器。AOT编译器会利用这些信息对字节码进行优化，并生成可执行的本地机器代码。这样，当相同的代码再次执行时，就可以直接使用AOT编译得到的机器代码，而无需再次启动JIT编译。</p><p>这种JIT和AOT结合的方式可以在保持性能优化和动态适应性的同时，拥有更快的启动时间和更高的执行速度。这样Java程序就能更好地适应云原生和容器化的环境了，性能和可扩展性也更好。</p><p><img src=\"https://static001.geekbang.org/resource/image/f5/b1/f5507352fd62eabfe5cb7f9fb562b1b1.png?wh=1920x795\" alt=\"图片\"></p><p>我整理了JIT和AOT在启动速度、内存占用等方面的区别。通过对比，你会发现JIT和AOT有各自擅长的领域和应用场景。所以在生产环境中实际选择时，最好是结合应用的特点，充分权衡，选择最适合的解决方案。</p><h2>重点回顾</h2><p>我们都知道JVM的字节码需要转化为底层物理硬件识别的机器码才能真正运行起来。而在这个转化的过程中，我们需要用到编译器，最开始我们看到的是逐行编辑字节码的解释执行，随着时代的发展又衍生出了到基于热点代码识别，以方法为粒度将热点代码转化为机器码的即时编译技术。现在为了更好地适应对启动速度和性能的要求，JVM又通过AOT技术实现了提前编译，并结合容器的平台无关性，来打造JVM的云原生运行基础。</p><h2>思考题</h2><p>这节课我们学习了JVM的编译器，那你能说一说在编译器部分我们可以通过哪些方式提升程序的性能吗，此外这节课我们重点讨论了JIT的原理，你知道触发JIT的时机是什么吗？</p><p>欢迎你把你的答案分享到评论区，和我一起讨论，也欢迎你把这节课分享给需要的朋友，我们下节课再见！</p><h2>💡点亮你的知识框架图</h2><p><img src=\"https://static001.geekbang.org/resource/image/9f/41/9f17660c02bf462c629beyya8792a441.jpg?wh=8572x6326\" alt=\"图片\"></p>","comments":[{"had_liked":false,"id":380312,"user_name":"浩仔是程序员","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"广东","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1693359124,"is_pvip":false,"replies":[{"id":138648,"content":"这个问题非常好，使用AOT后无法直接使用反射等动态的特性，目前业内有两个解决方案分别是Spring Boot 3和Quarkus，他们提供了在使用AOT编译时处理反射和动态代理问题的解决方案。它们通过编译时生成配置、代码分析和优化等手段，实现了AOT编译和Java的动态特性的结合，我会在实战篇中详细介绍这部分，可以到时候关注下","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1694230662,"ip_address":"北京","comment_id":380312,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"AOT还可以使用反射和动态代理吗？","like_count":7,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627519,"discussion_content":"这个问题非常好，使用AOT后无法直接使用反射等动态的特性，目前业内有两个解决方案分别是Spring Boot 3和Quarkus，他们提供了在使用AOT编译时处理反射和动态代理问题的解决方案。它们通过编译时生成配置、代码分析和优化等手段，实现了AOT编译和Java的动态特性的结合，我会在实战篇中详细介绍这部分，可以到时候关注下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694230662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1310674,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ff/d2/9d36c2fe.jpg","nickname":"N阶矩阵","note":"","ucode":"0B09091FC7FFD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":628718,"discussion_content":"是不是动态链接也不能用了？但是动态链接在java中基本上是无处不在的吧。求老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1695730402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":627519,"ip_address":"北京","group_id":0},"score":628718,"extra":""}]}]},{"had_liked":false,"id":380291,"user_name":"临风","can_delete":false,"product_type":"c1","uid":1145430,"ip_address":"广东","ucode":"59A7F3DDD94D76","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/56/29877cb9.jpg","comment_is_top":false,"comment_ctime":1693318505,"is_pvip":true,"replies":[{"id":138649,"content":"总结的非常好👍🏻","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1694231703,"ip_address":"北京","comment_id":380291,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"    java首先是通过javac编译成字节码，然后jvm才能通过执行字节码执行程序。jvm有两种执行方式，解释执行和编译执行，解释执行就是jvm直接翻译字节码为机器码运行，编译执行是jvm先将字节码编译成机器码并且缓存起来再执行。\n    很明显解释执行在第一次绝对是比编译执行快的，但如果一段代码执行的次数多了，那么编译执行的效率反而是比解释执行高了。所以jvm会将热点代码进行编译执行，而大部分代码仍然保持解释执行。这也是为什么Java需要运行一段时间才能达到性能巅峰的原因。\n    java使用c1（速度快、优化差、针对简单的逻辑）、c2（速度慢、优化好、针对复杂的逻辑）来进行编译，使用C++编写的，现在已经难以维护了。所以使用java推出了新的graal编译器代替c2编译器。这些编译器都属于JIT的范畴，都是在运行时去编译代码。\n    为了适应云原生的背景，java推出了aot，支持直接将java文件编译为二进制执行文件，使用graal VM代替jvm执行，实现了毫秒级的启动时间。由于没有了运行时，对整个java生态也提出了挑战，不过spring boot3已经率先支持了这一特性。\n    以上就是对本文的小结和自己一些简单的认识，如果有问题，还望老师指正。","like_count":6,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627522,"discussion_content":"总结的非常好👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694231703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380385,"user_name":"追逐我的明天。","can_delete":false,"product_type":"c1","uid":3257899,"ip_address":"北京","ucode":"12C8B126E239BB","user_header":"https://static001.geekbang.org/account/avatar/00/31/b6/2b/af79073f.jpg","comment_is_top":false,"comment_ctime":1693470244,"is_pvip":false,"replies":[{"id":138654,"content":"通过逃逸分析，JVM可以知道一个对象的使用范围，从而确定该对象是否可以&quot;逃逸&quot;出方法或线程等。如果一个对象只能从创建它的线程访问，那么就可以在栈上分配它的内存，而不是在堆上。这样可以避免后续的垃圾回收。对于上面的代码，经过逃逸分析，我们可以看到 `food` 对象只在 `main` 函数中使用，它没有被返回或者没有被其他线程引用，也就是说它的&quot;使用范围&quot;仅限于当前线程。因此，JVM就可以直接在栈上分配 `food` 对象的内存，从而提高程序性能。这是逃逸分析的基本思想，不过在实际的JVM实现中，这种优化可能并不会发生，因为只有当对象的大小和存活时间符合一定的条件时，才会将对象的内存分配从堆转移到栈。上述代码只是一个简单的示例，实际上JVM的发现过程可能比这个要复杂得多。","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1694240626,"ip_address":"北京","comment_id":380385,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"关于逃逸分析 我想问个问题\n作者原话：通过 JIT 我们能够确定哪些对象可以被限制在方法内部使用，不会逃逸到外部，然后可以对它们进行优化\n但是下面的代码示例，引用肯定被传递到外面了，但是这段代码不还是被优化了嘛？我现在不太明白是传递到外面的 会被优化 还是不会被优化呢？","like_count":2,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627528,"discussion_content":"通过逃逸分析，JVM可以知道一个对象的使用范围，从而确定该对象是否可以&#34;逃逸&#34;出方法或线程等。如果一个对象只能从创建它的线程访问，那么就可以在栈上分配它的内存，而不是在堆上。这样可以避免后续的垃圾回收。对于上面的代码，经过逃逸分析，我们可以看到 `food` 对象只在 `main` 函数中使用，它没有被返回或者没有被其他线程引用，也就是说它的&#34;使用范围&#34;仅限于当前线程。因此，JVM就可以直接在栈上分配 `food` 对象的内存，从而提高程序性能。这是逃逸分析的基本思想，不过在实际的JVM实现中，这种优化可能并不会发生，因为只有当对象的大小和存活时间符合一定的条件时，才会将对象的内存分配从堆转移到栈。上述代码只是一个简单的示例，实际上JVM的发现过程可能比这个要复杂得多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694240627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380187,"user_name":"学无涯","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"北京","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1693185467,"is_pvip":false,"replies":[{"id":138457,"content":"1. 峰值吞吐：AOT在运行时能够快速获取和执行代码，它的执行速度比JIT快。【一段时间内吞吐量的最大值，吞吐量越高，性能越好，所以图片显示AOT的条比JIT长】\n2. 编译时间：因为是即时编译，所以JIT比AOT更快。\n3. 包大小：因为AOT编译器需要将整个应用程序编译成可执行的二进制文件，所以AOT的包大小要比JIT大。\n\n可能这张图片会让人产生一些误解，谢谢你的反馈，我们调整一下🌹","user_name":"编辑回复","user_name_real":"编辑","uid":2843479,"ctime":1693194287,"ip_address":"北京","comment_id":380187,"utype":2}],"discussion_count":0,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"看老师发的jit对比aot的图，好像aot除了启动时间，其他方面都不如jit，是我理解错了吗？","like_count":2},{"had_liked":false,"id":381222,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"北京","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1694833863,"is_pvip":false,"replies":[{"id":139140,"content":"主流的 JVM 实现，如 HotSpot，还是首先优先支持 JIT 编译，只有在特定的场景下才会考虑使用 AOT 编译，因此，SkyWalking 在大部分情况下应该是可以正常使用的。但如果在你的应用中启用了 AOT 编译，并且发现 SkyWalking 无法正确工作，那么你可能需要考虑关闭 AOT 编译，或者寻找其他的解决方案。","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1696516094,"ip_address":"北京","comment_id":381222,"utype":1}],"discussion_count":1,"race_medal":2,"score":2,"product_id":100613601,"comment_content":"请教老师，使用 AOT 之后，一些基于字节码增强技术的框架是不是也无法支持了，比如 SkyWalking？","like_count":1,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629024,"discussion_content":"主流的 JVM 实现，如 HotSpot，还是首先优先支持 JIT 编译，只有在特定的场景下才会考虑使用 AOT 编译，因此，SkyWalking 在大部分情况下应该是可以正常使用的。但如果在你的应用中启用了 AOT 编译，并且发现 SkyWalking 无法正确工作，那么你可能需要考虑关闭 AOT 编译，或者寻找其他的解决方案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696516094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380773,"user_name":"小飞同学","can_delete":false,"product_type":"c1","uid":1232599,"ip_address":"浙江","ucode":"1F89B1BA1EEF52","user_header":"https://static001.geekbang.org/account/avatar/00/12/ce/d7/074920d5.jpg","comment_is_top":false,"comment_ctime":1694133983,"is_pvip":false,"replies":[{"id":138650,"content":"Ahead-of-Time（AOT）编译并没有完全替代Just-in-Time（JIT）编译，而是和JIT编译结合在一起来使用。AOT编译和JIT编译各有优缺点。例如，AOT编译的优点在于它可以在应用程序运行前进行，从而减少了应用程序启动时的延迟。另一方面，它的缺点是，由于它不能利用到运行时的信息，例如运行时的类型信息和热点代码信息等，因此它往往无法达到JIT编译那样的优化程度。因此，目前的JVM实现往往结合使用AOT编译和JIT编译，以便同时利用二者的优点。一般的做法是，在应用程序启动时，先使用AOT编译生成的代码，然后在运行过程中，通过JIT编译对热点代码进行更深度的优化。这种做法既可以减少应用程序的启动延迟，又可以保证应用程序运行时的高效性能。","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1694232178,"ip_address":"北京","comment_id":380773,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"那为啥不直接用aot直接将字节码转换为机器码？jit编译器感觉可以废弃了","like_count":1,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627523,"discussion_content":"Ahead-of-Time（AOT）编译并没有完全替代Just-in-Time（JIT）编译，而是和JIT编译结合在一起来使用。AOT编译和JIT编译各有优缺点。例如，AOT编译的优点在于它可以在应用程序运行前进行，从而减少了应用程序启动时的延迟。另一方面，它的缺点是，由于它不能利用到运行时的信息，例如运行时的类型信息和热点代码信息等，因此它往往无法达到JIT编译那样的优化程度。因此，目前的JVM实现往往结合使用AOT编译和JIT编译，以便同时利用二者的优点。一般的做法是，在应用程序启动时，先使用AOT编译生成的代码，然后在运行过程中，通过JIT编译对热点代码进行更深度的优化。这种做法既可以减少应用程序的启动延迟，又可以保证应用程序运行时的高效性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694232178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":381195,"user_name":"小麦","can_delete":false,"product_type":"c1","uid":1216881,"ip_address":"广东","ucode":"55C7199A0D5659","user_header":"https://static001.geekbang.org/account/avatar/00/12/91/71/0b16655d.jpg","comment_is_top":false,"comment_ctime":1694771092,"is_pvip":false,"replies":[{"id":139135,"content":"这两种技术各有优势，也各有劣势。对于JIT，每次程序启动时都需要花费时间进行编译，甚至在运行时也需要不断编译新发现的热点代码。而AOT虽然可以避免运行时编译带来的延迟，但是因为无法利用运行时信息进行优化，所以其生成的代码的效率往往不如JIT。但是，如果我们能够找到一种方法，利用运行时的信息进行AOT编译，那么就可以把两者的优势结合起来。这就是JVM将字节码与AOT编译相结合的原因：它先使用JIT编译器进行编译，找出热点代码并进行优化，然后把这些信息传递给AOT编译器，让它对字节码进行进一步的优化。通过这种方式，我们既可以利用运行时的信息进行优化，获得高效的机器码，又可以避免运行时编译带来的延迟，从而实现更快的程序启动和执行速度。","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1696515519,"ip_address":"北京","comment_id":381195,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"为了从 JIT 过渡到 AOT，JVM 将字节码与 AOT 编译相结合。在 JIT 编译运行时，JVM 会监视代码的执行情况并收集相关的运行时信息，然后将这些信息传递给 AOT 编译器。AOT 编译器会利用这些信息对字节码进行优化，并生成可执行的本地机器代码。这样，当相同的代码再次执行时，就可以直接使用 AOT 编译得到的机器代码，而无需再次启动 JIT 编译。\n\n从此描述中，没看出在 JIT 编译器识别出热点代码后，交给 AOT 编译器的好处是什么","like_count":0,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629019,"discussion_content":"这两种技术各有优势，也各有劣势。对于JIT，每次程序启动时都需要花费时间进行编译，甚至在运行时也需要不断编译新发现的热点代码。而AOT虽然可以避免运行时编译带来的延迟，但是因为无法利用运行时信息进行优化，所以其生成的代码的效率往往不如JIT。但是，如果我们能够找到一种方法，利用运行时的信息进行AOT编译，那么就可以把两者的优势结合起来。这就是JVM将字节码与AOT编译相结合的原因：它先使用JIT编译器进行编译，找出热点代码并进行优化，然后把这些信息传递给AOT编译器，让它对字节码进行进一步的优化。通过这种方式，我们既可以利用运行时的信息进行优化，获得高效的机器码，又可以避免运行时编译带来的延迟，从而实现更快的程序启动和执行速度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696515519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182516,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","nickname":"王盛武","note":"","ucode":"DE7EF246D3DCE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630166,"discussion_content":"@老师 这个期望 是如果？还是已经实现了呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698143541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136480,"avatar":"https://static001.geekbang.org/account/avatar/00/11/57/60/65b006a6.jpg","nickname":"Chief","note":"","ucode":"CAFB24CBA215A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629781,"discussion_content":"磨刀不误砍柴工，AOT就是提前磨刀，JIT是运行时拿刀磨（缓存后就是磨好的刀）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1697622447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380655,"user_name":"geektime_zpf","can_delete":false,"product_type":"c1","uid":1041743,"ip_address":"广东","ucode":"FD61BCAD02CA54","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/4f/731ef2c1.jpg","comment_is_top":false,"comment_ctime":1693959536,"is_pvip":true,"replies":[{"id":138655,"content":"JIT 编译器在运行时收集的信息，可以通过一些内部机制传递给 AOT 编译器，用于对字节码进行优化。具体来说，这个传递的过程可能是通过 JIT 编译器将信息存储在一些特定的数据结构中，这些数据结构可以被 AOT 编译器读取。也可能是通过 JVM 提供的一些 API，允许 AOT 编译器查询 JIT 编译器的信息。然后，AOT 编译器就可以利用这些信息进行优化了。\n例如，如果 JIT 编译器收集到的信息显示某个方法被频繁调用，那么 AOT 编译器就可能会针对这个方法进行特别的优化，使其运行更快地优化方法的执行（比如，使用内联、循环展开、去除死代码等手段），并把优化后的代码缓存起来，下次直接使用。","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1694240998,"ip_address":"北京","comment_id":380655,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"“为了从 JIT 过渡到 AOT，JVM 将字节码与 AOT 编译相结合。在 JIT 编译运行时，JVM 会监视代码的执行情况并收集相关的运行时信息，然后将这些信息传递给 AOT 编译器。AOT 编译器会利用这些信息对字节码进行优化，并生成可执行的本地机器代码。”，老师好，文中这几句不理解，jit收集的运行时信息，怎样传递给aot？","like_count":0,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627529,"discussion_content":"JIT 编译器在运行时收集的信息，可以通过一些内部机制传递给 AOT 编译器，用于对字节码进行优化。具体来说，这个传递的过程可能是通过 JIT 编译器将信息存储在一些特定的数据结构中，这些数据结构可以被 AOT 编译器读取。也可能是通过 JVM 提供的一些 API，允许 AOT 编译器查询 JIT 编译器的信息。然后，AOT 编译器就可以利用这些信息进行优化了。\n例如，如果 JIT 编译器收集到的信息显示某个方法被频繁调用，那么 AOT 编译器就可能会针对这个方法进行特别的优化，使其运行更快地优化方法的执行（比如，使用内联、循环展开、去除死代码等手段），并把优化后的代码缓存起来，下次直接使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694240998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380298,"user_name":"Levi","can_delete":false,"product_type":"c1","uid":2221236,"ip_address":"北京","ucode":"F804879872BB76","user_header":"https://static001.geekbang.org/account/avatar/00/21/e4/b4/889954ca.jpg","comment_is_top":false,"comment_ctime":1693323821,"is_pvip":false,"replies":[{"id":138656,"content":"如果在定义一个对象时，用final关键字来修饰它，那么这个对象一旦被初始化后就不能再被修改，它的内部状态是不可变的。这样，JIT编译器在进行逃逸分析时，就可以更准确地判断出哪些对象没有发生逃逸，然后对它们进行优化，提升程序的运行效率。 ","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1694241251,"ip_address":"北京","comment_id":380298,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"使用 final 关键字来限制对象的可变性，这样 JIT 编译器更容易进行逃逸分析和优化。\n老师这句话不太理解，能解释一下吗请问","like_count":0,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627530,"discussion_content":"如果在定义一个对象时，用final关键字来修饰它，那么这个对象一旦被初始化后就不能再被修改，它的内部状态是不可变的。这样，JIT编译器在进行逃逸分析时，就可以更准确地判断出哪些对象没有发生逃逸，然后对它们进行优化，提升程序的运行效率。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694241251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380227,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"河南","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1693232064,"is_pvip":false,"replies":[{"id":138657,"content":" A1：AOT（Ahead-of-Time Compilation）是指在运行程序之前，就已经将代码完全编译成本地机器码，所以的确主要关注的是编译时。然而，运行时的一些相关特性（比如反射，动态加载等）可能被限制或者需要一些特殊的处理。\nA2：是的，AOT编译需要选择目标平台或者特定的运行环境。因为它直接将代码编译成特定平台的机器码，所以需要知道目标平台的硬件和操作系统信息。\nA3：AOT并不必须和JIT结合。它们是两种截然不同的技术，各有各的优缺点。但在一些实现方案中，它们可能会结合使用，比如在Java的HotSpot虚拟机中，它支持一种混合模式，在程序启动初期使用解释执行，然后根据运行时的信息选择热点代码进行JIT或AOT编译，以提高效率。\nA4：在AOT和JIT的对比中，AOT的吞吐量可能会小于JIT。因为AOT在程序运行前就已经进行了全部编译，初始启动时性能较好，但由于缺乏运行时信息，可能无法对特定的运行时行为进行优化。相反，JIT可以在运行时针对实际代码的行为进行优化，因此在运行一段时间后，其性能可能会优于AOT，吞吐量也就相应更高。同时，这一点也会受到实现方式等多种因素的影响，并不是绝对的。 ","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1694241404,"ip_address":"北京","comment_id":380227,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"请教老师几个问题啊：\nQ1：AOT难道没有运行时吗？\n本课的第二张图，就是编译的那个图，AOT只有编译时，难道没有运行时吗？\nQ2：AOT提前编译，编译的时候需要选择目标平台吗？比如，目标是Linux或Windows。\nQ3：AOT必须与JIT结合吗？从文中看，好像AOT是基于JIT才能工作。\nQ4：AOT与JIT的对比图中，吞吐量这一项，AOT的条比JIT的短，\n这个正确吗?","like_count":0,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627531,"discussion_content":" A1：AOT（Ahead-of-Time Compilation）是指在运行程序之前，就已经将代码完全编译成本地机器码，所以的确主要关注的是编译时。然而，运行时的一些相关特性（比如反射，动态加载等）可能被限制或者需要一些特殊的处理。\nA2：是的，AOT编译需要选择目标平台或者特定的运行环境。因为它直接将代码编译成特定平台的机器码，所以需要知道目标平台的硬件和操作系统信息。\nA3：AOT并不必须和JIT结合。它们是两种截然不同的技术，各有各的优缺点。但在一些实现方案中，它们可能会结合使用，比如在Java的HotSpot虚拟机中，它支持一种混合模式，在程序启动初期使用解释执行，然后根据运行时的信息选择热点代码进行JIT或AOT编译，以提高效率。\nA4：在AOT和JIT的对比中，AOT的吞吐量可能会小于JIT。因为AOT在程序运行前就已经进行了全部编译，初始启动时性能较好，但由于缺乏运行时信息，可能无法对特定的运行时行为进行优化。相反，JIT可以在运行时针对实际代码的行为进行优化，因此在运行一段时间后，其性能可能会优于AOT，吞吐量也就相应更高。同时，这一点也会受到实现方式等多种因素的影响，并不是绝对的。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694241404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":396094,"user_name":"AmosLiu","can_delete":false,"product_type":"c1","uid":2032832,"ip_address":"广东","ucode":"ADCB4EF6A47CC8","user_header":"https://static001.geekbang.org/account/avatar/00/1f/04/c0/42c70741.jpg","comment_is_top":false,"comment_ctime":1733097068,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100613601,"comment_content":"思考题个人总结\n1、提升程序性能的编译器优化方式\n1）前端优化（编译阶段）：\n（1）方法内联：减少方法调用开销；\n（2）常量折叠：编译时替换常量表达式；\n（3）循环展开：减少循环控制的开销。\n\n2）后端优化（运行时由JIT完成）：\n（1）逃逸分析：栈上分配、同步省略；\n（2）动态内联：将热点方法直接替换为调用点的具体代码；\n（3）分支预测：优化条件判断，提高分支命中率。\n3）JVM参数优化：\n（1）-XX:+TieredCompilation：分层编译；\n（2）-Xmx&#47;-Xms：调整堆大小；\n（3）-XX:CompileThreshold=10000：设置热点方法触发阈值。\n\n2、JIT 的原理\n1）热点检测：通过计数器监控方法调用次数和循环执行频率；\n2）动态优化：根据运行时数据优化代码；\n3）分层编译：逐步将代码从解释执行优化到本地机器码。\n\n3、JIT 的触发时机\n1）计数器触发：方法调用或循环执行次数达到默认阈值（如 10,000 次），阈值可通过 -XX:CompileThreshold 调整；\n2）代码热点识别：频繁调用的代码块会被标记为热点；\n3）性能反馈优化：运行过程中根据实际执行情况动态调整。","like_count":0},{"had_liked":false,"id":382881,"user_name":"王盛武","can_delete":false,"product_type":"c1","uid":1182516,"ip_address":"北京","ucode":"DE7EF246D3DCE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","comment_is_top":false,"comment_ctime":1698145104,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100613601,"comment_content":"基于栈和基于寄存器的架构，性能上有多少差异？ Android上的Java是基于寄存器","like_count":0},{"had_liked":false,"id":382879,"user_name":"王盛武","can_delete":false,"product_type":"c1","uid":1182516,"ip_address":"北京","ucode":"DE7EF246D3DCE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","comment_is_top":false,"comment_ctime":1698144662,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100613601,"comment_content":"下面这段课文，是期望 还是已经实现了？\n\n这种 JIT 和 AOT 结合的方式可以在保持性能优化和动态适应性的同时，拥有更快的启动时间和更高的执行速度。这样 Java 程序就能更好地适应云原生和容器化的环境了，性能和可扩展性也更好。","like_count":0},{"had_liked":false,"id":382592,"user_name":"Chief","can_delete":false,"product_type":"c1","uid":1136480,"ip_address":"上海","ucode":"CAFB24CBA215A8","user_header":"https://static001.geekbang.org/account/avatar/00/11/57/60/65b006a6.jpg","comment_is_top":false,"comment_ctime":1697620876,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100613601,"comment_content":"混合模式下 Java 代码执行流程的那张图，右上角的【编译执行】是不是有点歧义，缓存的机器码这个时候是可以直接执行的吧？ \n左边：编译执行 ---&gt; 是 ---&gt; 编译器编译 ---&gt; 执行\n下边：缓存 ---&gt; 执行","like_count":0}]}