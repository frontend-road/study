{"id":120351,"title":"31丨为什么大部分RDBMS都会支持MVCC？","content":"<p>上一篇文章中，我们讲到了锁的划分，以及乐观锁和悲观锁的思想。今天我们就来看下MVCC，它就是采用乐观锁思想的一种方式。那么它到底有什么用呢？</p><p>我们知道事务有4个隔离级别，以及可能存在的三种异常问题，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c2/9b/c2e9a4ce5793b031f3846890d0f6189b.png?wh=1331*694\" alt=\"\"><br>\n在MySQL中，默认的隔离级别是可重复读，可以解决脏读和不可重复读的问题，但不能解决幻读问题。如果我们想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的事务并发能力。</p><p>有没有一种方式，可以不采用锁机制，而是通过乐观锁的方式来解决不可重复读和幻读问题呢？实际上MVCC机制的设计，就是用来解决这个问题的，它可以在大多数情况下替代行级锁，降低系统的开销。</p><p><img src=\"https://static001.geekbang.org/resource/image/56/a0/568bb507e1edb431d8121a2cb5c7caa0.png?wh=1500*552\" alt=\"\"><br>\n今天的课程主要包括以下几个方面的内容：</p><ol>\n<li>MVCC机制的思想是什么？为什么RDBMS会采用MVCC机制？</li>\n<li>在InnoDB中，MVCC机制是如何实现的 ？</li>\n<li>Read View是如何工作的？</li>\n</ol><h2>MVCC是什么，解决了什么问题</h2><p>MVCC的英文全称是Multiversion Concurrency Control，中文翻译过来就是多版本并发控制技术。从名字中也能看出来，MVCC是通过数据行的多个版本管理来实现数据库的并发控制，简单来说它的思想就是保存数据的历史版本。这样我们就可以通过比较版本号决定数据是否显示出来（具体的规则后面会介绍到），读取数据的时候不需要加锁也可以保证事务的隔离效果。</p><!-- [[[read_end]]] --><p>通过MVCC我们可以解决以下几个问题：</p><ol>\n<li>读写之间阻塞的问题，通过MVCC可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。</li>\n<li>降低了死锁的概率。这是因为MVCC采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。</li>\n<li>解决一致性读的问题。一致性读也被称为快照读，当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。</li>\n</ol><h3>什么是快照读，什么是当前读</h3><p>那么什么是快照读呢？快照读读取的是快照数据。不加锁的简单的SELECT都属于快照读，比如这样：</p><pre><code>SELECT * FROM player WHERE ...\n</code></pre><p>当前读就是读取最新数据，而不是历史版本的数据。加锁的SELECT，或者对数据进行增删改都会进行当前读，比如：</p><pre><code>SELECT * FROM player LOCK IN SHARE MODE;\n</code></pre><pre><code>SELECT * FROM player FOR UPDATE;\n</code></pre><pre><code>INSERT INTO player values ...\n</code></pre><pre><code>DELETE FROM player WHERE ...\n</code></pre><pre><code>UPDATE player SET ...\n</code></pre><p>这里需要说明的是，快照读就是普通的读操作，而当前读包括了加锁的读取和DML操作。</p><p>上面讲MVCC的作用，你可能觉得有些抽象。我们用具体的例子体会一下。</p><p>比如我们有个账户金额表user_balance，包括三个字段，分别是username用户名、balance余额和bankcard卡号，具体的数据示意如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/be/46/bec7af5d84bc7d4295fd205491d85e46.png?wh=904*365\" alt=\"\"><br>\n为了方便，我们假设user_balance表中只有用户A和B有余额，其他人的账户余额均为0。下面我们考虑一个使用场景。</p><p>用户A和用户B之间进行转账，此时数据库管理员想要查询user_balance表中的总金额：</p><pre><code>SELECT SUM(balance) FROM user_balance\n</code></pre><p>你可以思考下，如果数据库不支持MVCC机制，而是采用自身的锁机制来实现的话，可能会出现怎样的情况呢？</p><p>情况1：因为需要采用加行锁的方式，用户A给B转账时间等待很久，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/2d/27/2df06836628ce9735364ca932003f927.png?wh=922*430\" alt=\"\"><br>\n你能看到为了保证数据的一致性，我们需要给统计到的数据行都加上行锁。这时如果A所在的数据行加上了行锁，就不能给B转账了，只能等到所有操作完成之后，释放行锁再继续进行转账，这样就会造成用户事务处理的等待时间过长。</p><p>情况2：当我们读取的时候用了加行锁，可能会出现死锁的情况，如下图所示。比如当我们读到A有1000元的时候，此时B开始执行给A转账：</p><pre><code>UPDATE user_balance SET balance=balance-100 WHERE username ='B'\n\n</code></pre><p>执行完之后马上执行下一步：</p><pre><code>UPDATE user_balance SET balance=balance+100 WHERE username ='A'\n</code></pre><p>我们会发现此时A被锁住了，而管理员事务还需要对B进行访问，但B被用户事务锁住了，此时就发生了死锁。</p><p><img src=\"https://static001.geekbang.org/resource/image/3b/41/3b6c7ae9db7e1952fd9ae264e7147b41.png?wh=886*430\" alt=\"\"><br>\nMVCC可以解决读写互相阻塞的问题，这样提升了效率，同时因为采用了乐观锁的思想，降低了死锁的概率。</p><h2>InnoDB中的MVCC是如何实现的？</h2><p>我刚才讲解了MVCC的思想和作用，实际上MVCC没有正式的标准，所以在不同的DBMS中，MVCC的实现方式可能是不同的，你可以参考相关的DBMS文档。今天我来讲一下InnoDB中MVCC的实现机制。</p><p>在了解InnoDB中MVCC的实现方式之前，我们需要了解InnoDB是如何存储记录的多个版本的。这里的多版本对应的就是MVCC前两个字母的释义：Multi Version，我们需要了解和它相关的数据都有哪些，存储在哪里。这些数据包括事务版本号、行记录中的隐藏列和Undo Log。</p><h3>事务版本号</h3><p>每开启一个事务，我们都会从数据库中获得一个事务ID（也就是事务版本号），这个事务ID是自增长的，通过ID大小，我们就可以判断事务的时间顺序。</p><h3>行记录的隐藏列</h3><p>InnoDB的叶子段存储了数据页，数据页中保存了行记录，而在行记录中有一些重要的隐藏字段，如下图所示：</p><ol>\n<li>db_row_id：隐藏的行ID，用来生成默认聚集索引。如果我们创建数据表的时候没有指定聚集索引，这时InnoDB就会用这个隐藏ID来创建聚集索引。采用聚集索引的方式可以提升数据的查找效率。</li>\n<li>db_trx_id：操作这个数据的事务ID，也就是最后一个对该数据进行插入或更新的事务ID。</li>\n<li>db_roll_ptr：回滚指针，也就是指向这个记录的Undo Log信息。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/d1/20/d15a5d0a313492b208d2aad410173b20.png?wh=838*178\" alt=\"\"></p><h3>Undo Log</h3><p>InnoDB将行记录快照保存在了Undo Log里，我们可以在回滚段中找到它们，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/47/81/4799c77b8cdfda50e49a391fea727281.png?wh=838*538\" alt=\"\"><br>\n从图中你能看到回滚指针将数据行的所有快照记录都通过链表的结构串联了起来，每个快照的记录都保存了当时的db_trx_id，也是那个时间点操作这个数据的事务ID。这样如果我们想要找历史快照，就可以通过遍历回滚指针的方式进行查找。</p><h2>Read View是如何工作的</h2><p>在MVCC机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在Undo Log里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢？这时就需要用到Read View了，它帮我们解决了行的可见性问题。Read View保存了当前事务开启时所有活跃（还没有提交）的事务列表，换个角度你可以理解为Read View保存了不应该让这个事务看到的其他的事务ID列表。</p><p>在Read VIew中有几个重要的属性：</p><ol>\n<li>trx_ids，系统当前正在活跃的事务ID集合。</li>\n<li>low_limit_id，活跃的事务中最大的事务ID。</li>\n<li>up_limit_id，活跃的事务中最小的事务ID。</li>\n<li>creator_trx_id，创建这个Read View的事务ID。</li>\n</ol><p>如图所示，trx_ids为trx2、trx3、trx5和trx8的集合，活跃的最大事务ID（low_limit_id）为trx8，活跃的最小事务ID（up_limit_id）为trx2。</p><p><img src=\"https://static001.geekbang.org/resource/image/a7/00/a7fe7d4a0e25fce469c3d00e5e3ec600.png?wh=760*223\" alt=\"\"><br>\n假设当前有事务creator_trx_id想要读取某个行记录，这个行记录的事务ID为trx_id，那么会出现以下几种情况。</p><p>如果trx_id &lt; 活跃的最小事务ID（up_limit_id），也就是说这个行记录在这些活跃的事务创建之前就已经提交了，那么这个行记录对该事务是可见的。</p><p>如果trx_id &gt; 活跃的最大事务ID（low_limit_id），这说明该行记录在这些活跃的事务创建之后才创建，那么这个行记录对当前事务不可见。</p><p>如果up_limit_id &lt; trx_id &lt; low_limit_id，说明该行记录所在的事务trx_id在目前creator_trx_id这个事务创建的时候，可能还处于活跃的状态，因此我们需要在trx_ids集合中进行遍历，如果trx_id存在于trx_ids集合中，证明这个事务trx_id还处于活跃状态，不可见。否则，如果trx_id不存在于trx_ids集合中，证明事务trx_id已经提交了，该行记录可见。</p><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过多版本并发控制技术找到它：</p><ol>\n<li>首先获取事务自己的版本号，也就是事务ID；</li>\n<li>获取Read View；</li>\n<li>查询得到的数据，然后与Read View中的事务版本号进行比较；</li>\n<li>如果不符合ReadView规则，就需要从Undo Log中获取历史快照；</li>\n<li>最后返回符合规则的数据。</li>\n</ol><p>你能看到InnoDB中，MVCC是通过Undo Log + Read View进行数据读取，Undo Log保存了历史快照，而Read View规则帮我们判断当前版本的数据是否可见。</p><p>需要说明的是，在隔离级别为读已提交（Read Commit）时，一个事务中的每一次SELECT查询都会获取一次Read View。如表所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/5d/5c/5dfd6b7491484ad49efc5f08b214bf5c.png?wh=1203*398\" alt=\"\"><br>\n你能看到，在读已提交的隔离级别下，同样的查询语句都会重新获取一次Read View，这时如果Read View不同，就可能产生不可重复读或者幻读的情况。</p><p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次SELECT的时候会获取一次Read View，而后面所有的SELECT都会复用这个Read View，如下表所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/f2/7b9c80fb892f858e08a64fc8ef7257f2.png?wh=1012*341\" alt=\"\"></p><h2>InnoDB是如何解决幻读的</h2><p>不过这里需要说明的是，在可重复读的情况下，InnoDB可以通过Next-Key锁+MVCC来解决幻读问题。</p><p>在读已提交的情况下，即使采用了MVCC方式也会出现幻读。如果我们同时开启事务A和事务B，先在事务A中进行某个条件范围的查询，读取的时候采用排它锁，在事务B中增加一条符合该条件范围的数据，并进行提交，然后我们在事务A中再次查询该条件范围的数据，就会发现结果集中多出一个符合条件的数据，这样就出现了幻读。</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/cb/4f112ba8411db336f58c8db9c9e8f0cb.png?wh=864*485\" alt=\"\"><br>\n出现幻读的原因是在读已提交的情况下，InnoDB只采用记录锁（Record Locking）。这里要介绍下InnoDB三种行锁的方式：</p><ol>\n<li>记录锁：针对单个行记录添加锁。</li>\n<li>间隙锁（Gap Locking）：可以帮我们锁住一个范围（索引之间的空隙），但不包括记录本身。采用间隙锁的方式可以防止幻读情况的产生。</li>\n<li>Next-Key锁：帮我们锁住一个范围，同时锁定记录本身，相当于间隙锁+记录锁，可以解决幻读的问题。</li>\n</ol><p>在隔离级别为可重复读时，InnoDB会采用Next-Key锁的机制，帮我们解决幻读问题。</p><p>还是这个例子，我们能看到当我们想要插入球员艾利克斯·伦（身高2.16米）的时候，事务B会超时，无法插入该数据。这是因为采用了Next-Key锁，会将height&gt;2.08的范围都进行锁定，就无法插入符合这个范围的数据了。然后事务A重新进行条件范围的查询，就不会出现幻读的情况。</p><p><img src=\"https://static001.geekbang.org/resource/image/3b/4e/3b876d3a4d5c11352ba10cebf9c7ab4e.png?wh=1816*1018\" alt=\"\"></p><h2>总结</h2><p>今天关于MVCC的内容有些多，通过学习你应该能对采用MVCC这种乐观锁的方式来保证事务的隔离效果更有体会。</p><p>我们需要记住，MVCC的核心就是Undo Log+ Read View，“MV”就是通过Undo Log来保存数据的历史版本，实现多版本的管理，“CC”是通过Read View来实现管理，通过Read View原则来决定数据是否显示。同时针对不同的隔离级别，Read View的生成策略不同，也就实现了不同的隔离级别。</p><p>MVCC是一种机制，MySQL、Oracle、SQL Server和PostgreSQL的实现方式均有不同，我们在学习的时候，更主要的是要理解MVCC的设计思想。</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/5a/4f1cb2414cae9216ee6b3a5fa19a855a.jpg?wh=2366*2313\" alt=\"\"><br>\n最后给你留几道思考题吧，为什么隔离级别为读未提交时，不适用于MVCC机制呢？第二个问题是，读已提交和可重复读这两个隔离级别的Read View策略有何不同？</p><p>欢迎你在评论区写下你的思考，也欢迎把这篇文章分享给你的朋友或者同事，让我们一起来学习进步。</p>","neighbors":{"left":{"article_title":"30丨锁：悲观锁和乐观锁是什么？","id":119044},"right":{"article_title":"32丨查询优化器是如何工作的？","id":125429}},"comments":[{"had_liked":false,"id":126300,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1566358899,"is_pvip":false,"replies":[{"id":"47667","content":"对的 读未提交不需要版本控制","user_name":"作者回复","comment_id":126300,"uid":"1306094","ip_address":"","utype":1,"ctime":1566901126,"user_name_real":"cy"}],"discussion_count":4,"race_medal":0,"score":"160480148851","product_id":100029501,"comment_content":"我来回答一下思考题：<br>为什么隔离级别为读未提交时，不适用于 MVCC 机制呢？<br>因为隔离级别是读未提交，所以跟本就不需要版本控制，直接读取最新的数据就好了。<br><br>读已提交和可重复读这两个隔离级别的 Read View 策略有何不同？<br>读已提交每一次Select都会重新查询Read View，保证可以读到其它事务的提交。<br>可重复读会复用第一次查询到的Read View,不会读到其它事务的提交，加上Next-Key锁的配合，从而避免幻读。","like_count":38,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463932,"discussion_content":"对的 读未提交不需要版本控制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566901126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1721278,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLAhj2fB8NI2TPI1SNicgiciczuMUHyAb9HHBkkKJHrgtR162fsicaTqdAneHfuVX7icDXaVibDHstM9L47g/132","nickname":"Geek_0c1732","note":"","ucode":"6276D0412CCE51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258105,"discussion_content":"read view是快照读时使用的，next-key锁是当前读使用的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588647153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1572636,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ff/1c/d049776e.jpg","nickname":"wonderq_gk","note":"","ucode":"9A10DDC39DBB6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6724,"discussion_content":"牛皮","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567069321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1127175,"avatar":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","nickname":"JustDoDT","note":"","ucode":"6AF0B80F00EAEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5892,"discussion_content":"优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566529243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127173,"user_name":"DZ","can_delete":false,"product_type":"c1","uid":1132240,"ip_address":"","ucode":"452555FA0F9E0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/46/d0/6bafd7d4.jpg","comment_is_top":false,"comment_ctime":1566576778,"is_pvip":false,"replies":[{"id":"47083","content":"对的 分析总结的很好","user_name":"作者回复","comment_id":127173,"uid":"1306094","ip_address":"","utype":1,"ctime":1566623812,"user_name_real":"cy"}],"discussion_count":1,"race_medal":0,"score":"83170955402","product_id":100029501,"comment_content":"1. 为什么隔离级别为读未提交时，不适用于 MVCC 机制呢？<br><br>“读未提交”隔离级别不需要多版本数据。每个事务都读取最新数据，假设事务A把X从0改成1，无论事务A是否提交，事务B读到X为1，如果事务A回滚，事务B再次读X，自然就得到0，根本不需要MVCC帮衬。<br><br>2. 读已提交和可重复读这两个隔离级别的 Read View 策略有何不同？<br><br>“读已提交”时，每次SELECT操作都创建Read View，无论SELECT是否相同，所以可能出现前后两次读到的结果不等，即不可重复读。<br>“可重复读”时，首次SELECT操作才创建Read View并复用给后续的相同SELECT操作，前后两次读到的结果一定相等，避免了不可重复读。","like_count":20,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464354,"discussion_content":"对的 分析总结的很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566623812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222347,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1590756161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53130363713","product_id":100029501,"comment_content":"以为我看不懂，却原来只是恐惧学习mvcc，仔细看，3、5遍再结合《mysql45讲》的几节，慢慢琢磨品味，终于明白些了。继续学习，比昨天的自己更优秀","like_count":13},{"had_liked":false,"id":126146,"user_name":"asdf100","can_delete":false,"product_type":"c1","uid":1043738,"ip_address":"","ucode":"39D8D71453E575","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/ce7f7d54.jpg","comment_is_top":false,"comment_ctime":1566330317,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"27336134093","product_id":100029501,"comment_content":"如图所示，trx_ids 为 trx2、trx3、trx5 和 trx8 的集合，活跃的最大事务 ID（low_limit_id）为 trx10，活跃的最小事务 ID（up_limit_id）为 trx4。<br><br>没理解这个10和4怎么来的，不是说就2 3 5 8这个活跃事务吗？","like_count":6,"discussions":[{"author":{"id":1133918,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/5e/c5c62933.jpg","nickname":"lmtoo","note":"","ucode":"FCD5B9C941D448","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5549,"discussion_content":"哈哈哈，我有同样的疑问？觉得莫名其妙","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566351936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1474214,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7e/a6/4e331ef4.jpg","nickname":"骑行的掌柜J","note":"","ucode":"3163102651C653","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265741,"discussion_content":"我这里已经改了哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589432781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344431,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","nickname":"马以","note":"","ucode":"3FEA06CA14DE28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5545,"discussion_content":"应该是个笔误吧\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566350820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237931,"user_name":"宋雄斌","can_delete":false,"product_type":"c1","uid":1433647,"ip_address":"","ucode":"52FA63AA616319","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/2f/3aee5f24.jpg","comment_is_top":false,"comment_ctime":1596008491,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"14480910379","product_id":100029501,"comment_content":"RR  为什么还是会产生幻读呀，后面事务插入的数据它们的事务ID不应该比第一次获取的Read View 的事务ID大吗，那么后面插入的数据不应该看不到的吗？？","like_count":3,"discussions":[{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344688,"discussion_content":"老师举得例子应该是加了锁的当前读，如果是快照读的话不加锁就是用MVCC，前者是后面插入的数据失败来实现当前读取的数据一致性，后者是后面插入的数据不可见来实现版本读取的一致性","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611559314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1961927,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLz44WGtTHNfFfZfzaGRpbYib9xKiamIeKDzQfb7xzu9jEot7507MKGtyiaU3Y8PnO7UZFNI45eR9PWw/132","nickname":"guo_splane","note":"","ucode":"7CA77FE4BA3488","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335201,"discussion_content":"行锁不会对范围的值起作用那；所以加next key ；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608115061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1084993,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8e/41/709e9677.jpg","nickname":"袁帅","note":"","ucode":"A71A89B9F1BD69","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316006,"discussion_content":"对呀，我也有这个疑问， 而且我也验证了，全表扫描，后插入的数据也查不到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603347662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1084993,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8e/41/709e9677.jpg","nickname":"袁帅","note":"","ucode":"A71A89B9F1BD69","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":344685,"discussion_content":"后插入的数据查不到不应该是对的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611559193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":316006,"ip_address":""},"score":344685,"extra":""}]}]},{"had_liked":false,"id":129780,"user_name":"空知","can_delete":false,"product_type":"c1","uid":1013283,"ip_address":"","ucode":"C448E98238DD36","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg","comment_is_top":false,"comment_ctime":1567247439,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14452149327","product_id":100029501,"comment_content":"老师 问下：<br>1、如果RV不符合 就需要去Undo Log里面去判断快照记录了，这里对于快照记录 会一直比较下去直到找到一个可见版本 或者查询全部历史版本为止？<br>2、间隙锁 锁住一个范围不包含 行记录本身，是指 对某条记录添加间隙锁之后 还可以针对这条记录本身做修改操作吗？","like_count":3},{"had_liked":false,"id":126986,"user_name":"安静的boy","can_delete":false,"product_type":"c1","uid":1196475,"ip_address":"","ucode":"F5F44B75228A85","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/bb/21ce60d2.jpg","comment_is_top":false,"comment_ctime":1566530578,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14451432466","product_id":100029501,"comment_content":"想说一下最后一个列子，innodb是如何解决幻读的。作者举的例子是innodb在当前读的情况下如何解决幻读（通过加next-key 锁）。如果在快照读下，利用readView就可以解决了。","like_count":3,"discussions":[{"author":{"id":1815965,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/b5/9d/43fdda38.jpg","nickname":"奥沙西泮","note":"","ucode":"07BDBAAA2F2305","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211608,"discussion_content":"read-view解决不了幻读 UNDO LOG分为  UPDATE和INSERT","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584869837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1196475,"avatar":"https://static001.geekbang.org/account/avatar/00/12/41/bb/21ce60d2.jpg","nickname":"安静的boy","note":"","ucode":"F5F44B75228A85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1815965,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/b5/9d/43fdda38.jpg","nickname":"奥沙西泮","note":"","ucode":"07BDBAAA2F2305","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211619,"discussion_content":"这个怎么说 能详细解释下吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584870352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":211608,"ip_address":""},"score":211619,"extra":""}]}]},{"had_liked":false,"id":232000,"user_name":"岛の茶","can_delete":false,"product_type":"c1","uid":1511263,"ip_address":"","ucode":"09E0782C238E2A","user_header":"https://static001.geekbang.org/account/avatar/00/17/0f/5f/355f409e.jpg","comment_is_top":false,"comment_ctime":1593828445,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10183763037","product_id":100029501,"comment_content":"既然在InnoDB的事务隔离级别可重复读情况，同一个事务中的每一次快照查都会复用第一次快照查的ReadVIew，那么应该看不到其他事务已提交的内容呀，怎么还会出现幻读问题呢？","like_count":2,"discussions":[{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344689,"discussion_content":"我的理解是：老师举得例子应该是加了锁的当前读，如果是快照读的话不加锁就是用MVCC，前者是后面插入的数据失败来实现当前读取的数据一致性，后者是后面插入的数据不可见来实现版本读取的一致性，因为我在其他文章中看到过，这应该是两种读取方式 都可以解决幻读的，只是一个是用了悲观锁思想一个是用了乐观锁思想","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611559410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2027690,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f0/aa/6ba4a1ab.jpg","nickname":"℡ㄨ和尚ふ","note":"","ucode":"E26B2BC7D8E4FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293032,"discussion_content":"我的理解是：可重复读是指在第一次查询指定范围内的所有记录，给这些查到的每一条记录都加上了排它锁，也就是不能对这些已经查到的记录进行读写操作，但是如果再插入一条记录的话，这条插入的记录是不属于上一次查询到的记录当中的任何一条的，即排它锁起不到作用，而且后插入的记录的这个事务应该是没有进入readView的，因为readView中的事务都是当前不可见的事务，所以产生了幻读。\n纯属个人理解，仅限参考","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595418322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221445,"user_name":"陈逸新","can_delete":false,"product_type":"c1","uid":1243628,"ip_address":"","ucode":"33B93A77DAAEA9","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/ec/9587eb26.jpg","comment_is_top":false,"comment_ctime":1590500401,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"10180434993","product_id":100029501,"comment_content":"RC下MVVC的一个疑惑点。<br><br>假设两个事务先后开始，事务A（事务ID100）、事务B（事务ID101）。<br>事务B更新了一条记录，然后提交，此时该记录的trx_id=101。<br>接着事务A对该记录进行查询，生成视图，活跃的事务列表为 [100]，而101&gt;100，按照可见规则，理应不访问。<br>按照MVVC的规则，得出的结论和RC应有的结论矛盾。<br><br>这里的矛盾，数据库具体是如何处理的？","like_count":2,"discussions":[{"author":{"id":2978255,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/71/cf/6ab03210.jpg","nickname":"在意再忆！","note":"","ucode":"2DDCD765DB85AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573995,"discussion_content":"这个老师讲的有问题，我在别的地方看到的read view格式是这样的，max_trx_id指的是那个全局事物id，也就是应该分配给下一个事物的ID，这样的话就能解释你的这个问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653789721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1480419,"avatar":"https://static001.geekbang.org/account/avatar/00/16/96/e3/dd40ec58.jpg","nickname":"火车日记","note":"","ucode":"62C57DFA6CDF74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556925,"discussion_content":"感觉trx_ids会重新统计下，最大事物id和最小事物id不会变，这样就能说得通了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647573477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2815900,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/f7/9c/69c5c5dc.jpg","nickname":"越锋利","note":"","ucode":"63E9E3F3C7D53D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411918,"discussion_content":"我感觉是 RC 的名字起的不好，RC 这个级别的意思是，保证你不会读到还没 commit 的数据，但不是说，只要已经 commit 的你就一定能读到。要是能读到，其实感觉是幻读？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636032743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2028952,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/98/c490d236.jpg","nickname":"小团","note":"","ucode":"B81FD9742B1F22","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292234,"discussion_content":" rc下每次查询会重新计算视图。所以b提交后a查询的事务视图是【100，101】","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595149394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2101081,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI5a9ianL7JOjmEKTEw075rKDeBD0YqD5cBlgY6nbdPiaskIVqa1HHYm7pibeVnoPqibEWr6a3rqc0xdA/132","nickname":"何时不漂泊","note":"","ucode":"4C47064E5B6C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2028952,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/98/c490d236.jpg","nickname":"小团","note":"","ucode":"B81FD9742B1F22","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371534,"discussion_content":"可是101这个事务已经提交了呀，不是活跃的事务了，怎么能查出到视图呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619831043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":292234,"ip_address":""},"score":371534,"extra":""}]}]},{"had_liked":false,"id":206807,"user_name":"桂冠远航","can_delete":false,"product_type":"c1","uid":1155463,"ip_address":"","ucode":"5959E1A1DAA05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","comment_is_top":false,"comment_ctime":1586938949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10176873541","product_id":100029501,"comment_content":"老师应该少说了一个细节，就是要对height加索引，因为不加索引的update操作是表锁。","like_count":3},{"had_liked":false,"id":194649,"user_name":"汪zZ","can_delete":false,"product_type":"c1","uid":1234757,"ip_address":"","ucode":"8B93062A683902","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/45/d1621188.jpg","comment_is_top":false,"comment_ctime":1585095112,"is_pvip":true,"replies":[{"id":"75464","content":"加油 这篇确实有一定难度 ^_^","user_name":"作者回复","comment_id":194649,"uid":"1306094","ip_address":"","utype":1,"ctime":1585875069,"user_name_real":"cy"}],"discussion_count":1,"race_medal":1,"score":"10175029704","product_id":100029501,"comment_content":"内容量大，看了三遍，感觉有点懂了","like_count":3,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488865,"discussion_content":"加油 这篇确实有一定难度 ^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585875069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169834,"user_name":"饭团","can_delete":false,"product_type":"c1","uid":1332557,"ip_address":"","ucode":"E24F240CC91BE8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","comment_is_top":false,"comment_ctime":1578454066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10168388658","product_id":100029501,"comment_content":"重读第二遍  才理解了真谛  真是读书百遍  其义自见！","like_count":3},{"had_liked":false,"id":136802,"user_name":"Yuhui","can_delete":false,"product_type":"c1","uid":1110470,"ip_address":"","ucode":"811933B016179F","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/c6/6f39a982.jpg","comment_is_top":false,"comment_ctime":1569512417,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10159447009","product_id":100029501,"comment_content":"请教老师以下几个问题：<br>1. MVCC机制在各个数据库中默认是打开的还是关闭的？<br>2. 是否可以控制MVCC机制的打开和关闭？<br>3. 如何查看数据记录的隐藏列？<br>谢谢！","like_count":2,"discussions":[{"author":{"id":1815965,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/b5/9d/43fdda38.jpg","nickname":"奥沙西泮","note":"","ucode":"07BDBAAA2F2305","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211607,"discussion_content":"Innodb就是用MVCC的只要达到读提交就会开启MVCC和记录锁，达到可重复读就会开心MVCC+NEXT-KEY锁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584869776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1024164,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a0/a4/b060c723.jpg","nickname":"阿斯蒂芬","note":"","ucode":"61D5E3BDA4EBC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1815965,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/b5/9d/43fdda38.jpg","nickname":"奥沙西泮","note":"","ucode":"07BDBAAA2F2305","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280646,"discussion_content":"那怎么理解可重复读会出现幻读？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591585798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":211607,"ip_address":""},"score":280646,"extra":""}]}]},{"had_liked":false,"id":136421,"user_name":"峻铭","can_delete":false,"product_type":"c1","uid":1106202,"ip_address":"","ucode":"63AB23BADACA88","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/1a/20977779.jpg","comment_is_top":false,"comment_ctime":1569428156,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10159362748","product_id":100029501,"comment_content":"测试结果发现比2.08矮的插入是也会阻塞","like_count":2,"discussions":[{"author":{"id":1155463,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","nickname":"桂冠远航","note":"","ucode":"5959E1A1DAA05D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":233685,"discussion_content":"老师应该少说了一个细节，就是要对height加索引，因为不加索引的update操作是表锁。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586938930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126510,"user_name":"Alpha","can_delete":false,"product_type":"c1","uid":1001861,"ip_address":"","ucode":"60CA15A25EC796","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/85/3f161d95.jpg","comment_is_top":false,"comment_ctime":1566398485,"is_pvip":false,"replies":[{"id":"63517","content":"Read View的规则：<br>如果 trx_id &lt; 活跃的最小事务 ID（up_limit_id），也就是说这个行记录在这些活跃的事务创建之前就已经提交了，那么这个行记录对该事务是可见的。<br><br>如果 trx_id &gt; 活跃的最大事务 ID（low_limit_id），这说明该行记录在这些活跃的事务创建之后才创建，那么这个行记录对当前事务不可见。<br><br>如果 up_limit_id &lt; trx_id &lt; low_limit_id，说明该行记录所在的事务 trx_id 在目前 creator_trx_id 这个事务创建的时候，可能还处于活跃的状态，因此我们需要在 trx_ids 集合中进行遍历，如果 trx_id 存在于 trx_ids 集合中，证明这个事务 trx_id 还处于活跃状态，不可见。否则，如果 trx_id 不存在于 trx_ids 集合中，证明事务 trx_id 已经提交了，该行记录可见。","user_name":"作者回复","comment_id":126510,"uid":"1306094","ip_address":"","utype":1,"ctime":1577516357,"user_name_real":"cy"}],"discussion_count":4,"race_medal":0,"score":"10156333077","product_id":100029501,"comment_content":"Step 4. 如果不符合Read View 规则，就需要从Undo Log中获取历史快照。不太明白这里的&quot;Read View规则&quot;指的是什么？","like_count":2,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464025,"discussion_content":"Read View的规则：\n如果 trx_id &amp;lt; 活跃的最小事务 ID（up_limit_id），也就是说这个行记录在这些活跃的事务创建之前就已经提交了，那么这个行记录对该事务是可见的。\n\n如果 trx_id &amp;gt; 活跃的最大事务 ID（low_limit_id），这说明该行记录在这些活跃的事务创建之后才创建，那么这个行记录对当前事务不可见。\n\n如果 up_limit_id &amp;lt; trx_id &amp;lt; low_limit_id，说明该行记录所在的事务 trx_id 在目前 creator_trx_id 这个事务创建的时候，可能还处于活跃的状态，因此我们需要在 trx_ids 集合中进行遍历，如果 trx_id 存在于 trx_ids 集合中，证明这个事务 trx_id 还处于活跃状态，不可见。否则，如果 trx_id 不存在于 trx_ids 集合中，证明事务 trx_id 已经提交了，该行记录可见。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577516357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1084993,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8e/41/709e9677.jpg","nickname":"袁帅","note":"","ucode":"A71A89B9F1BD69","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316002,"discussion_content":"不符合Read View 规则   与  可见|不可见的关系是什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603347451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1084993,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8e/41/709e9677.jpg","nickname":"袁帅","note":"","ucode":"A71A89B9F1BD69","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":377700,"discussion_content":"ReadView就是用来判断这条数据是否可见","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622780492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":316002,"ip_address":""},"score":377700,"extra":""}]},{"author":{"id":1000060,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/7c/8ef14715.jpg","nickname":"🄽🄸🅇🅄🅂","note":"","ucode":"853763C229A5AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7519,"discussion_content":"Read View的规则，就是前面的三个如果：如果trx_id<up_limit_id...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567527849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212652,"user_name":"steve","can_delete":false,"product_type":"c1","uid":1354489,"ip_address":"","ucode":"AB6D3E9FF8E77C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJETibDh9wrP19gj9VdlLRmppuG1FibI7nyUGldEXCnoqKibKIB18UMxyEHBkZNlf5vibLNeofiaN5U6Hw/132","comment_is_top":false,"comment_ctime":1588170369,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5883137665","product_id":100029501,"comment_content":"争哥求解答，我看这个源码：<br>http:&#47;&#47;www.iskm.org&#47;mysql56&#47;read0read_8cc_source.html<br>view-&gt;low_limit_no = trx_sys-&gt;max_trx_id;，<br>貌似low_limit_no应该是当前系统最大的trx_id才对啊，如果是活跃id列表的最大值貌似不太合理。","like_count":1,"discussions":[{"author":{"id":1474214,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7e/a6/4e331ef4.jpg","nickname":"骑行的掌柜J","note":"","ucode":"3163102651C653","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265712,"discussion_content":"哥们你是不是走错场了？争哥？😂","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1589429572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160634,"user_name":"朱成亮","can_delete":false,"product_type":"c1","uid":1008920,"ip_address":"","ucode":"669B049357B3FA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJqWuvuicHD7RVlEDJamWNmwVdkjeH4pLxPXoicwqbnpOibI1MFFz9SIVJmQeKSZQRP9np1NUV3wpmnA/132","comment_is_top":false,"comment_ctime":1575990285,"is_pvip":true,"replies":[{"id":"62600","content":"对的 稍微有些难理解，慢慢来","user_name":"作者回复","comment_id":160634,"uid":"1306094","ip_address":"","utype":1,"ctime":1577072898,"user_name_real":"cy"}],"discussion_count":1,"race_medal":0,"score":"5870957581","product_id":100029501,"comment_content":"这块有点难~","like_count":1,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477441,"discussion_content":"对的 稍微有些难理解，慢慢来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577072898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135743,"user_name":"L荀","can_delete":false,"product_type":"c1","uid":1156395,"ip_address":"","ucode":"0D8827D9F6032D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/2b/e876e7d4.jpg","comment_is_top":false,"comment_ctime":1569251346,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5864218642","product_id":100029501,"comment_content":"不理解的请教下作者大神：1.可重复读级别下，新加入的行，版本号高于当前事物版本号，不用next-key锁，应该也不会出现幻读，这个怎么理解啊。2.例子中为什么加了for update 读锁呀，不是应该不用锁的么","like_count":1},{"had_liked":false,"id":134620,"user_name":"Ryoma","can_delete":false,"product_type":"c1","uid":1130590,"ip_address":"","ucode":"7F692369239692","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","comment_is_top":false,"comment_ctime":1568880840,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"5863848136","product_id":100029501,"comment_content":"如果有的同学看了前面的，没有看到这一章 MVCC。是不是就会产生误解，比如 MySQL Innodb 在可重复读隔离级别下，会发生幻读现象？这类观点，在之前说的时候，是不是需要提前说一下？","like_count":1},{"had_liked":false,"id":133549,"user_name":"innovationmech","can_delete":false,"product_type":"c1","uid":1232321,"ip_address":"","ucode":"9377EAD5C6373E","user_header":"https://static001.geekbang.org/account/avatar/00/12/cd/c1/19531313.jpg","comment_is_top":false,"comment_ctime":1568602802,"is_pvip":false,"replies":[{"id":"53366","content":"加油","user_name":"作者回复","comment_id":133549,"uid":"1306094","ip_address":"","utype":1,"ctime":1570428989,"user_name_real":"cy"}],"discussion_count":1,"race_medal":0,"score":"5863570098","product_id":100029501,"comment_content":"看了几遍文章和留言，有点懂了。。。","like_count":1,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467422,"discussion_content":"加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570428989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344543,"user_name":"路在哪","can_delete":false,"product_type":"c1","uid":1816609,"ip_address":"","ucode":"A4822AD07AD102","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b8/21/f692bdb0.jpg","comment_is_top":false,"comment_ctime":1651638703,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651638703","product_id":100029501,"comment_content":"好难，看不明白","like_count":0},{"had_liked":false,"id":338568,"user_name":"火车日记","can_delete":false,"product_type":"c1","uid":1480419,"ip_address":"","ucode":"62C57DFA6CDF74","user_header":"https://static001.geekbang.org/account/avatar/00/16/96/e3/dd40ec58.jpg","comment_is_top":false,"comment_ctime":1647573895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647573895","product_id":100029501,"comment_content":"最后rc级别的快照读其实可以解决幻读问题，当前读才不可以对吗？","like_count":0},{"had_liked":false,"id":319997,"user_name":"越锋利","can_delete":false,"product_type":"c1","uid":2815900,"ip_address":"","ucode":"63E9E3F3C7D53D","user_header":"https://static001.geekbang.org/account/avatar/00/2a/f7/9c/69c5c5dc.jpg","comment_is_top":false,"comment_ctime":1636032168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636032168","product_id":100029501,"comment_content":"所以 InnoDB 在可重复读这个级别既可以避免幻读了？","like_count":0},{"had_liked":false,"id":307095,"user_name":"爱吾尚","can_delete":false,"product_type":"c1","uid":2602405,"ip_address":"","ucode":"049C04B6BD9D11","user_header":"https://static001.geekbang.org/account/avatar/00/27/b5/a5/1c62fe9c.jpg","comment_is_top":false,"comment_ctime":1628858019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628858019","product_id":100029501,"comment_content":"你好，想问下MVCC实现过程的第四步和第五步我的理解对不对，就是遍历undo log列表将版本号进行比对，如果可见则返回结果，如果不可见则沿着回滚指针继续寻找判断","like_count":0},{"had_liked":false,"id":298721,"user_name":"文野","can_delete":false,"product_type":"c1","uid":1857196,"ip_address":"","ucode":"6193A3648DD557","user_header":"","comment_is_top":false,"comment_ctime":1624276369,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624276369","product_id":100029501,"comment_content":"drop table if exists `test`;<br>CREATE TABLE `test` (<br>   `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#39;编号&#39;,<br>   `aa` bigint unsigned NOT NULL COMMENT &#39;aa&#39;,<br>   PRIMARY KEY (`id`),<br>   KEY `idx_aa` (`aa`),<br>) ENGINE=InnoDB COMMENT=&#39;测试&#39;;<br><br>tx1：<br>update test set aa = 15 where id = 100;<br>select * from test where aa = 15 limit 10; <br><br>tx1的第二条查询的时候是怎么用索引查的呢","like_count":0},{"had_liked":false,"id":290881,"user_name":"何时不漂泊","can_delete":false,"product_type":"c1","uid":2101081,"ip_address":"","ucode":"4C47064E5B6C14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI5a9ianL7JOjmEKTEw075rKDeBD0YqD5cBlgY6nbdPiaskIVqa1HHYm7pibeVnoPqibEWr6a3rqc0xdA/132","comment_is_top":false,"comment_ctime":1619831349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619831349","product_id":100029501,"comment_content":"RC下MVVC的一个疑惑点。<br><br>假设两个事务先后开始，事务A（事务ID100）、事务B（事务ID101）。<br>事务B更新了一条记录，然后提交，此时该记录的trx_id=101。<br>接着事务A对该记录进行查询，生成视图，活跃的事务列表为 [100]，而101&gt;100，按照可见规则，理应不访问。<br>按照MVVC的规则，得出的结论和RC应有的结论矛盾。<br><br>这里的矛盾，数据库具体是如何处理的？<br>我感觉这个和视图中最大事务id的由来有关系，但是想不明白<br><br>我这个问题和陈逸新同学的问题是一样的，希望作者解答一下","like_count":0},{"had_liked":false,"id":260708,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1605086997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605086997","product_id":100029501,"comment_content":"第一个问题：读线程实际上看的是脏页，此时不作任何有效性保证，自然MVCC也是多余的。比较常见的就是ms sql的with (nolock)<br>第二个问题：生成readVIew时，会判断当前隔离级别是否为RC，如是，则调用read_view_close_for_mysql()，那么自然每次rc都要重新生成read view，也就无法解决可重复读了","like_count":0},{"had_liked":false,"id":255443,"user_name":"袁帅","can_delete":false,"product_type":"c1","uid":1084993,"ip_address":"","ucode":"A71A89B9F1BD69","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/41/709e9677.jpg","comment_is_top":false,"comment_ctime":1603346223,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1603346223","product_id":100029501,"comment_content":"那这么说，在可重复读的隔离级别下，mysql 不存在幻读问题了，是吗？","like_count":0,"discussions":[{"author":{"id":2815900,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/f7/9c/69c5c5dc.jpg","nickname":"越锋利","note":"","ucode":"63E9E3F3C7D53D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411919,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636032863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255439,"user_name":"白菜","can_delete":false,"product_type":"c1","uid":2230467,"ip_address":"","ucode":"C3AE527ECE970E","user_header":"https://static001.geekbang.org/account/avatar/00/22/08/c3/bf4fe285.jpg","comment_is_top":false,"comment_ctime":1603344351,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603344351","product_id":100029501,"comment_content":"关于三个隐藏字段，我看了下文档：<br>https:&#47;&#47;dev.mysql.com&#47;doc&#47;refman&#47;5.7&#47;en&#47;innodb-multi-versioning.html<br><br>Internally, InnoDB adds three fields to each row stored in the database. A 6-byte DB_TRX_ID field indicates the transaction identifier for the last transaction that inserted or updated the row. Also, a deletion is treated internally as an update where a special bit in the row is set to mark it as deleted. Each row also contains a 7-byte DB_ROLL_PTR field called the roll pointer. The roll pointer points to an undo log record written to the rollback segment. If the row was updated, the undo log record contains the information necessary to rebuild the content of the row before it was updated. A 6-byte DB_ROW_ID field contains a row ID that increases monotonically as new rows are inserted. If InnoDB generates a clustered index automatically, the index contains row ID values. Otherwise, the DB_ROW_ID column does not appear in any index.<br><br>其中还提到 “删除在内部被视为更新，其中行中的一个特殊位被设置为已删除”，这个特殊位是在这三个隐藏字段中吗？还是一个独立的字段（也就是说有四个隐藏字段）？","like_count":0},{"had_liked":false,"id":251289,"user_name":"库淘淘","can_delete":false,"product_type":"c1","uid":1310240,"ip_address":"","ucode":"90813B0C46E978","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqibSwKPg7hiapc49qoM4dibhM3fYANPjfltF2ibBZ3dHX2hibjg5EIIcziahrmjO5R2XrcRibvU39TQS7jg/132","comment_is_top":false,"comment_ctime":1601451289,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601451289","product_id":100029501,"comment_content":"看了很多mvcc介绍，总感觉理解不透彻，看到老师总结，感觉恍然大悟  厉害","like_count":0},{"had_liked":false,"id":249470,"user_name":"袁帅","can_delete":false,"product_type":"c1","uid":1084993,"ip_address":"","ucode":"A71A89B9F1BD69","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/41/709e9677.jpg","comment_is_top":false,"comment_ctime":1600667242,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1600667242","product_id":100029501,"comment_content":"&quot;这是因为采用了 Next-Key 锁，会将 height&gt;2.08 的范围都进行锁定，就无法插入符合这个范围的数据了&quot;<br><br>这里height  是个索引键才会  采用 Next-Key 吗？  如果没加索引接着会有  幻读的情况吧<br>","like_count":0},{"had_liked":false,"id":248784,"user_name":"voyager.life","can_delete":false,"product_type":"c1","uid":1322902,"ip_address":"","ucode":"F4ED5FE161BFF0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoVYQQcjNoJVfvic0vicfHjgTD5ERr3Hax4v9CLsBackq1urO0jM9wcnlH4rQ8WBPd5dQ3zFy4icInsQ/132","comment_is_top":false,"comment_ctime":1600309509,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600309509","product_id":100029501,"comment_content":"一个疑问：up_limit_id &lt; trx_id &lt; low_limit_id 且 creator_trx_id &lt; trx_id 且 trx_id不在 trx_ids集合，说明该条记录位于 creator_trx_id事务之后创建的事务之中并且该事务已经提交，这时的行记录应该对creator_trx_id事务不可见？逻辑如同 &quot;如果 trx_id &gt; 活跃的最大事务 ID（low_limit_id），这说明该行记录在这些活跃的事务创建之后才创建，那么这个行记录对当前事务不可见。&quot;","like_count":0},{"had_liked":false,"id":232569,"user_name":"charles rong","can_delete":false,"product_type":"c1","uid":2042738,"ip_address":"","ucode":"3E1ABB7C26A0F1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BreNqD709wsLj9uaQRXZxPwibPSibs1ylH1OKVl2QV5deCJricFVqXDRJFNBIb59wiasmvMnrgqcvZ8RLwhOkszCww/132","comment_is_top":false,"comment_ctime":1594040450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594040450","product_id":100029501,"comment_content":"是否可以解释一下为什么可重复读隔离级别的MVCC的undo log和read-view不能解决幻读？我感觉可以啊。<br>假设事务10第一次统计高度大于2.08的数据项个数，然后事务11插入一条高度大于2.08的数据项X，然后事务10第二次统计高度大于2.08的数据项个数。由于第一次读和第二次读用了同一个read-view，那么创建数据项X的事务11应该是read-view的活跃事务，第二次读也不会被读出来，那这样也不会有幻读的错误啊？？？","like_count":0},{"had_liked":false,"id":228718,"user_name":"Marvin","can_delete":false,"product_type":"c1","uid":1138706,"ip_address":"","ucode":"D955A98C48CBEF","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/12/268826e6.jpg","comment_is_top":false,"comment_ctime":1592794077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592794077","product_id":100029501,"comment_content":"最后几个例子的中心思想，不知道对不对。<br><br>1. 普通的select语句，利用mvcc的read view就可以解决幻读，因为读取的是&quot;历史记录&quot;。<br>2. slelect加上for update的子句，其实是加上了排他锁，此时如果是&quot;读已提交&quot;的隔离级别，其他事务是可以insert的，因为当前行锁的实现是记录锁, 造成幻读。但是如果修改为&quot;可重复读的&quot;隔离级别，行锁实现修改为next-key,  此时其他线程的insert会被阻止，无法并发，解决了幻读的问题。","like_count":0},{"had_liked":false,"id":222392,"user_name":"雩而雨","can_delete":false,"product_type":"c1","uid":1879570,"ip_address":"","ucode":"0311B11F806AFB","user_header":"https://static001.geekbang.org/account/avatar/00/1c/ae/12/a7c1f5da.jpg","comment_is_top":false,"comment_ctime":1590775236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590775236","product_id":100029501,"comment_content":"有错：max_trx_id应该是下一个未被分配的事务ID<br>MySQL5.6：<br>view-&gt;low_limit_no = trx_sys-&gt;max_trx_id;<br>max_trx_id：The smallest number not yet assigned as a transaction id or transaction number","like_count":0},{"had_liked":false,"id":201554,"user_name":"林林","can_delete":false,"product_type":"c1","uid":1613227,"ip_address":"","ucode":"7B6318B971E430","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","comment_is_top":false,"comment_ctime":1585803109,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585803109","product_id":100029501,"comment_content":"读已提交的read view是只在第一次查询时做限制，可重复读的read view是在每一次查询时都做限制","like_count":0,"discussions":[{"author":{"id":1613227,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","nickname":"林林","note":"","ucode":"7B6318B971E430","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219762,"discussion_content":"反过来了，读已提交时，是每次select都创建read view，而可重复读是，只有第一次select时才创建read view","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585803768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177813,"user_name":"Geek_ade3cb","can_delete":false,"product_type":"c1","uid":1815632,"ip_address":"","ucode":"5DD2BAF1E1DDF3","user_header":"","comment_is_top":false,"comment_ctime":1581507126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581507126","product_id":100029501,"comment_content":"请问一下，如果某行记录x当前的活跃事务是[2,3]。此时版本号为4的事务想要修改该行记录，根据mvcc，他会拿到版本号为1的x，进行修改，提交修改，并将x的版本号变为4。之后版本号为5的事务查询事务x时，是否也只能拿到版本号为1的x（因为版本号4大于当前活跃事务[2,3]）？那这样是否会导致数据库查询不到之前自己修改并已提交的数据？求老师解答","like_count":0},{"had_liked":false,"id":169488,"user_name":"rike","can_delete":false,"product_type":"c1","uid":1583833,"ip_address":"","ucode":"920AAD0BD9245C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","comment_is_top":false,"comment_ctime":1578364471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578364471","product_id":100029501,"comment_content":"事务并发处理的3个异常，在15讲中的例子我试了，把事务隔离级别修改后，事务隔离级别与事务并发处理图中的现象与实际的执行结果无法对应，我上网查了很多文章，看不明白，也询问了一些dba，他们都讲不明白，他们说事务并发处理的3个异常区别不是很大，他们只是停留在理论的层面上，因为数据库不是我开发的，这个我也不懂。","like_count":0},{"had_liked":false,"id":165295,"user_name":"ballgod","can_delete":false,"product_type":"c1","uid":1584098,"ip_address":"","ucode":"C20E95E98EAC43","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIR9QrAn9TZOrJMSYMyN96PAuAjETVrN5SPp3hMbfUAGIWtHceWPEoQtPdXeuBn7VB7dagtxynAIA/132","comment_is_top":false,"comment_ctime":1577195122,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1577195122","product_id":100029501,"comment_content":"老师您好，为了解决幻读问题，解决方法是有两种：1）设置串行化 2）设置为可重复读，同时采用mvcc + next-key解决。第一种是可以通过设置隔离方式实现。第二种是如何实现？是设置为可重复读后然后再怎么操作才能使用mvcc机制或者说具体是如何实现？  不知道这样表述是否正确，麻烦老师指点，谢谢","like_count":0,"discussions":[{"author":{"id":1024164,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a0/a4/b060c723.jpg","nickname":"阿斯蒂芬","note":"","ucode":"61D5E3BDA4EBC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280647,"discussion_content":"我也有这个疑问，如果mvcc和锁都是InnoDB自动触发的，那么按理可重复读就已经解决了幻读问题，但是实际上所有的资料都表示可重复读隔离级别下还是有幻读的可能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591585878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137770,"user_name":"GLADIATOR","can_delete":false,"product_type":"c1","uid":1448564,"ip_address":"","ucode":"6FE14E0BCD6240","user_header":"https://static001.geekbang.org/account/avatar/00/16/1a/74/8f7f8786.jpg","comment_is_top":false,"comment_ctime":1569840888,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569840888","product_id":100029501,"comment_content":"MySQL可重复读加next key是可以解决幻读的","like_count":0},{"had_liked":false,"id":133972,"user_name":"study～","can_delete":false,"product_type":"c1","uid":1621959,"ip_address":"","ucode":"6EFD4E284CD22F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJBG6cXQGiayJlFxTeN3IPOichoX5NjdhqTt8rmyiaJDfd5VytLSrjwrufDAOdpoxFuROOLiawFh0mnBg/132","comment_is_top":false,"comment_ctime":1568709283,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1568709283","product_id":100029501,"comment_content":"既然 事务A已经上了 排他锁，，其他用户怎么可以对上锁的记录进行修改？","like_count":0,"discussions":[{"author":{"id":1188679,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/47/b44e3e80.jpg","nickname":"Guan","note":"","ucode":"EDE51DBE7A736D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38052,"discussion_content":"因为只锁了行，没有锁区间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571717528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132805,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1568243127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568243127","product_id":100029501,"comment_content":"在 Read VIew 中有几个重要的属性：<br><br>trx_ids，系统当前正在活跃的事务 ID 集合。这个事务ID集合是针对这一行的事物集合吧，不是整个mysql的系统事务集合","like_count":0},{"had_liked":false,"id":126270,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1566355365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566355365","product_id":100029501,"comment_content":"InnoDB的MVCC不可以防止出现幻读吗？比如文中的例子，A事件在开启的时候，B事务还没有提交，在A事件执行的过程中B事务提交了，在A事务读取数据的时候，通过查询Read View，应该会发现B提交的行记录是活跃的或者未提交的事务id，所以就算没有Next-key锁，A事务也读不到B事务提交的数据吧？","like_count":0},{"had_liked":false,"id":126267,"user_name":"LW","can_delete":false,"product_type":"c1","uid":1325297,"ip_address":"","ucode":"89820332658E98","user_header":"https://static001.geekbang.org/account/avatar/00/14/38/f1/996a070d.jpg","comment_is_top":false,"comment_ctime":1566355231,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566355231","product_id":100029501,"comment_content":"读未提交的意思就是所有更新都可见，所以没必要用MVCC机制了。读已提交每次读都要检查当前的活跃事务更新Read View，保证可以读到其他事务提交的最新数据。可重复读的Read View是记录当前事务开始时的活跃事务，这样在当前事务处理期间，才能避免其他事务提交后出现幻读。","like_count":0},{"had_liked":false,"id":126253,"user_name":"我行我素","can_delete":false,"product_type":"c1","uid":1224678,"ip_address":"","ucode":"4C69542FAB0671","user_header":"https://static001.geekbang.org/account/avatar/00/12/af/e6/9c77acff.jpg","comment_is_top":false,"comment_ctime":1566353438,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566353438","product_id":100029501,"comment_content":"2.读已提交的隔离级别下，同样的查询语句都会重新获取Read View，<br>可重复的隔离级别下，一个事物只在第一次SELECT的时候获取一次Read View","like_count":0},{"had_liked":false,"id":126219,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1566350972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566350972","product_id":100029501,"comment_content":"最后一个可重复读隔离级别，当事务A读的时候，如果事务B新增的时候首先是会阻塞吧？如果阻塞时间超过最大事务超时时间才会报错，感觉这个地方说直接报错，可能有些童鞋会有误解～","like_count":0}]}