{"id":14660,"title":"10 | 通道的基本操作","content":"<p>作为Go语言最有特色的数据类型，通道（channel）完全可以与goroutine（也可称为go程）并驾齐驱，共同代表Go语言独有的并发编程模式和编程哲学。</p><blockquote>\n<p><span class=\"reference\">Don’t communicate by sharing memory; share memory by communicating. （不要通过共享内存来通信，而应该通过通信来共享内存。）</span></p>\n</blockquote><p>这是作为Go语言的主要创造者之一的Rob Pike的至理名言，这也充分体现了Go语言最重要的编程理念。而通道类型恰恰是后半句话的完美实现，我们可以利用通道在多个goroutine之间传递数据。</p><h2>前导内容：通道的基础知识</h2><p>通道类型的值本身就是并发安全的，这也是Go语言自带的、唯一一个可以满足并发安全性的类型。它使用起来十分简单，并不会徒增我们的心智负担。</p><p>在声明并初始化一个通道的时候，我们需要用到Go语言的内建函数<code>make</code>。就像用<code>make</code>初始化切片那样，我们传给这个函数的第一个参数应该是代表了通道的具体类型的类型字面量。</p><p>在声明一个通道类型变量的时候，我们首先要确定该通道类型的元素类型，这决定了我们可以通过这个通道传递什么类型的数据。</p><p>比如，类型字面量<code>chan int</code>，其中的<code>chan</code>是表示通道类型的关键字，而<code>int</code>则说明了该通道类型的元素类型。又比如，<code>chan string</code>代表了一个元素类型为<code>string</code>的通道类型。</p><!-- [[[read_end]]] --><p>在初始化通道的时候，<code>make</code>函数除了必须接收这样的类型字面量作为参数，还可以接收一个<code>int</code>类型的参数。</p><p>后者是可选的，用于表示该通道的容量。所谓通道的容量，就是指通道最多可以缓存多少个元素值。由此，虽然这个参数是<code>int</code>类型的，但是它是不能小于<code>0</code>的。</p><p>当容量为<code>0</code>时，我们可以称通道为非缓冲通道，也就是不带缓冲的通道。而当容量大于<code>0</code>时，我们可以称为缓冲通道，也就是带有缓冲的通道。非缓冲通道和缓冲通道有着不同的数据传递方式，这个我在后面会讲到。</p><p><strong>一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符<code>&lt;-</code>。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向。</strong></p><pre><code>package main\n\nimport &quot;fmt&quot;\n\nfunc main() {\n\tch1 := make(chan int, 3)\n\tch1 &lt;- 2\n\tch1 &lt;- 1\n\tch1 &lt;- 3\n\telem1 := &lt;-ch1\n\tfmt.Printf(&quot;The first element received from channel ch1: %v\\n&quot;,\n\t\telem1)\n}\n</code></pre><p>在demo20.go文件中，我声明并初始化了一个元素类型为<code>int</code>、容量为<code>3</code>的通道<code>ch1</code>，并用三条语句，向该通道先后发送了三个元素值<code>2</code>、<code>1</code>和<code>3</code>。</p><p>这里的语句需要这样写：依次敲入通道变量的名称（比如<code>ch1</code>）、接送操作符<code>&lt;-</code>以及想要发送的元素值（比如<code>2</code>），并且这三者之间最好用空格进行分割。</p><p>这显然表达了“这个元素值将被发送该通道”这个语义。由于该通道的容量为3，所以，我可以在通道不包含任何元素值的时候，连续地向该通道发送三个值，此时这三个值都会被缓存在通道之中。</p><p>当我们需要从通道接收元素值的时候，同样要用接送操作符<code>&lt;-</code>，只不过，这时需要把它写在变量名的左边，用于表达“要从该通道接收一个元素值”的语义。</p><p>比如：<code>&lt;-ch1</code>，这也可以被叫做接收表达式。在一般情况下，接收表达式的结果将会是通道中的一个元素值。</p><p>如果我们需要把如此得来的元素值存起来，那么在接收表达式的左边就需要依次添加赋值符号（<code>=</code>或<code>:=</code>）和用于存值的变量的名字。因此，语句<code>elem1 := &lt;-ch1</code>会将最先进入<code>ch1</code>的元素<code>2</code>接收来并存入变量<code>elem1</code>。</p><p>现在我们来看一道与此有关的题目。<strong>今天的问题是：对通道的发送和接收操作都有哪些基本的特性？</strong></p><p>这个问题的背后隐藏着很多的知识点，<strong>我们来看一下典型回答</strong>。</p><p>它们的基本特性如下。</p><ol>\n<li>对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。</li>\n<li>发送操作和接收操作中对元素值的处理都是不可分割的。</li>\n<li>发送操作在完全完成之前会被阻塞。接收操作也是如此。</li>\n</ol><h2>问题解析</h2><p><strong>我们先来看第一个基本特性。</strong> 在同一时刻，Go语言的运行时系统（以下简称运行时系统）只会执行对同一个通道的任意个发送操作中的某一个。</p><p>直到这个元素值被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行。</p><p>类似的，在同一时刻，运行时系统也只会执行，对同一个通道的任意个接收操作中的某一个。</p><p>直到这个元素值完全被移出该通道之后，其他针对该通道的接收操作才可能被执行。即使这些操作是并发执行的也是如此。</p><p>这里所谓的并发执行，你可以这样认为，多个代码块分别在不同的goroutine之中，并有机会在同一个时间段内被执行。</p><p>另外，对于通道中的同一个元素值来说，发送操作和接收操作之间也是互斥的。例如，虽然会出现，正在被复制进通道但还未复制完成的元素值，但是这时它绝不会被想接收它的一方看到和取走。</p><p><strong>这里要注意的一个细节是，元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本。</strong></p><p>另一方面，元素值从通道进入外界时会被移动。这个移动操作实际上包含了两步，第一步是生成正在通道中的这个元素值的副本，并准备给到接收方，第二步是删除在通道中的这个元素值。</p><p><strong>顺着这个细节再来看第二个基本特性。</strong> 这里的“不可分割”的意思是，它们处理元素值时都是一气呵成的，绝不会被打断。</p><p>例如，发送操作要么还没复制元素值，要么已经复制完毕，绝不会出现只复制了一部分的情况。</p><p>又例如，接收操作在准备好元素值的副本之后，一定会删除掉通道中的原值，绝不会出现通道中仍有残留的情况。</p><p>这既是为了保证通道中元素值的完整性，也是为了保证通道操作的唯一性。对于通道中的同一个元素值来说，它只可能是某一个发送操作放入的，同时也只可能被某一个接收操作取出。</p><p><strong>再来说第三个基本特性。</strong> 一般情况下，发送操作包括了“复制元素值”和“放置副本到通道内部”这两个步骤。</p><p>在这两个步骤完全完成之前，发起这个发送操作的那句代码会一直阻塞在那里。也就是说，在它之后的代码不会有执行的机会，直到这句代码的阻塞解除。</p><p>更细致地说，在通道完成发送操作之后，运行时系统会通知这句代码所在的goroutine，以使它去争取继续运行代码的机会。</p><p>另外，接收操作通常包含了“复制通道内的元素值”“放置副本到接收方”“删掉原值”三个步骤。</p><p>在所有这些步骤完全完成之前，发起该操作的代码也会一直阻塞，直到该代码所在的goroutine收到了运行时系统的通知并重新获得运行机会为止。</p><p>说到这里，你可能已经感觉到，<strong>如此阻塞代码其实就是为了实现操作的互斥和元素值的完整。</strong></p><p>下面我来说一个关于通道操作阻塞的问题。</p><h2>知识扩展</h2><p><strong>问题1：发送操作和接收操作在什么时候可能被长时间的阻塞？</strong></p><p>先说针对<strong>缓冲通道</strong>的情况。如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。</p><p>这时，通道会优先通知最早因此而等待的、那个发送操作所在的goroutine，后者会再次执行发送操作。</p><p>由于发送操作在这种情况下被阻塞后，它们所在的goroutine会顺序地进入通道内部的发送等待队列，所以通知的顺序总是公平的。</p><p>相对的，如果通道已空，那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。这时，通道会通知最早等待的那个接收操作所在的goroutine，并使它再次执行接收操作。</p><p>因此而等待的、所有接收操作所在的goroutine，都会按照先后顺序被放入通道内部的接收等待队列。</p><p>对于<strong>非缓冲通道</strong>，情况要简单一些。无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。由此可见，非缓冲通道是在用同步的方式传递数据。也就是说，只有收发双方对接上了，数据才会被传递。</p><p>并且，数据是直接从发送方复制到接收方的，中间并不会用非缓冲通道做中转。相比之下，缓冲通道则在用异步的方式传递数据。</p><p>在大多数情况下，缓冲通道会作为收发双方的中间件。正如前文所述，元素值会先从发送方复制到缓冲通道，之后再由缓冲通道复制给接收方。</p><p>但是，当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方。</p><p>以上说的都是在正确使用通道的前提下会发生的事情。下面我特别说明一下，由于错误使用通道而造成的阻塞。</p><p>对于值为<code>nil</code>的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。它们所属的goroutine中的任何代码，都不再会被执行。</p><p>注意，由于通道类型是引用类型，所以它的零值就是<code>nil</code>。换句话说，当我们只声明该类型的变量但没有用<code>make</code>函数对它进行初始化时，该变量的值就会是<code>nil</code>。我们一定不要忘记初始化通道！</p><p>你可以去看一下demo21.go，我在里面用代码罗列了一下会造成阻塞的几种情况。</p><p><strong>问题2：发送操作和接收操作在什么时候会引发panic？</strong></p><p>对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发panic。但是通道一旦关闭，再对它进行发送操作，就会引发panic。</p><p>另外，如果我们试图关闭一个已经关闭了的通道，也会引发panic。注意，接收操作是可以感知到通道的关闭的，并能够安全退出。</p><p>更具体地说，当我们把接收表达式的结果同时赋给两个变量时，第二个变量的类型就是一定<code>bool</code>类型。它的值如果为<code>false</code>就说明通道已经关闭，并且再没有元素值可取了。</p><p>注意，如果通道关闭时，里面还有元素值未被取出，那么接收表达式的第一个结果，仍会是通道中的某一个元素值，而第二个结果值一定会是<code>true</code>。</p><p>因此，通过接收表达式的第二个结果值，来判断通道是否关闭是可能有延时的。</p><p>由于通道的收发操作有上述特性，所以除非有特殊的保障措施，我们千万不要让接收方关闭通道，而应当让发送方做这件事。这在demo22.go中有一个简单的模式可供参考。</p><h2>总结</h2><p>今天我们讲到了通道的一些常规操作，包括初始化、发送、接收和关闭。通道类型是Go语言特有的，所以你一开始肯定会感到陌生，其中的一些规则和奥妙还需要你铭记于心，并细心体会。</p><p>首先是在初始化通道时设定其容量的意义，这有时会让通道拥有不同的行为模式。对通道的发送操作和接收操作都有哪些基本特性，也是我们必须清楚的。</p><p>这涉及了它们什么时候会互斥，什么时候会造成阻塞，什么时候会引起panic，以及它们收发元素值的顺序是怎样的，它们是怎样保证元素值的完整性的，元素值通常会被复制几次，等等。</p><p>最后别忘了，通道也是Go语言的并发编程模式中重要的一员。</p><h2>思考题</h2><p>我希望你能通过试验获得下述问题的答案。</p><ol>\n<li>通道的长度代表着什么？它在什么时候会通道的容量相同？</li>\n<li>元素值在经过通道传递时会被复制，那么这个复制是浅表复制还是深层复制呢？</li>\n</ol><p><a href=\"https://github.com/hyper0x/Golang_Puzzlers\">戳此查看Go语言专栏文章配套详细代码。</a></p><p></p>","neighbors":{"left":{"article_title":"09 | 字典的操作和约束","id":14123},"right":{"article_title":"11 | 通道的高级玩法","id":14664}},"comments":[{"had_liked":false,"id":24017,"user_name":"忘怀","can_delete":false,"product_type":"c1","uid":1024839,"ip_address":"","ucode":"1DF55045285958","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/47/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1536756177,"is_pvip":false,"replies":[{"id":"8934","content":"对，这就是传指针值的好处之一。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1536975777,"ip_address":"","comment_id":24017,"utype":1}],"discussion_count":1,"race_medal":0,"score":"233464990161","product_id":100013101,"comment_content":"Go里没有深copy。<br>即便有的话这里可能也不会用吧，创建一个指针的内存开销绝大多数情况下要比重新开辟一块内存再把数据复制过来好的多吧。<br>老师，这么说对吗？","like_count":55,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423810,"discussion_content":"对，这就是传指针值的好处之一。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536975777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":26584,"user_name":"colonel","can_delete":false,"product_type":"c1","uid":1200916,"ip_address":"","ucode":"F71EE1C23A8D83","user_header":"https://static001.geekbang.org/account/avatar/00/12/53/14/2b93d757.jpg","comment_is_top":false,"comment_ctime":1537684428,"is_pvip":false,"replies":[{"id":"9666","content":"环形链表","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1537690494,"ip_address":"","comment_id":26584,"utype":1}],"discussion_count":2,"race_medal":0,"score":"169041408972","product_id":100013101,"comment_content":"通道底层存储数据的是链表还是数组？","like_count":40,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424678,"discussion_content":"环形链表","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1537690494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394425,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631878861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22782,"user_name":"江山如画","can_delete":false,"product_type":"c1","uid":1188280,"ip_address":"","ucode":"BEB6228E6135B5","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/b8/aca814dd.jpg","comment_is_top":false,"comment_ctime":1535972165,"is_pvip":false,"replies":[{"id":"8289","content":"再说一遍，Go语言里没有深层复制。数组是值类型，所以会被完全复制。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1536061933,"ip_address":"","comment_id":22782,"utype":1}],"discussion_count":11,"race_medal":0,"score":"147564860229","product_id":100013101,"comment_content":"老师回复我后突然感觉不对劲，结构体是值类型，通道传输的时候会新拷贝一份对象，底层数据结构会被复制，引用类型可能就不一定了，又用数组和切片试了下，发现切片在通道传输的时候底层数据结构不会被复制，改了一个另外一个也会跟着改变，所以切片这里应该是浅复制，数组一个改了对另一个没有影响是深层复制，代码：<br><br>&#47;&#47;<br>\tch := make(chan []int, 1)<br>\ts1 := []int{1, 2, 3}<br>\tch &lt;- s1<br>\ts2 := &lt;-ch<br><br>\ts2[0] = 100<br>\tfmt.Println(s1, s2) &#47;&#47;[100 2 3] [100 2 3]<br><br>\t&#47;&#47;<br>\tch2 := make(chan [3]int, 1)<br>\ts3 := [3]int{1, 2, 3}<br>\tch2 &lt;- s3<br>\ts4 := &lt;-ch2<br><br>\ts3[0] = 100<br>\tfmt.Println(s3, s4) &#47;&#47;[100 2 3] [1 2 3]","like_count":35,"discussions":[{"author":{"id":1201009,"avatar":"https://static001.geekbang.org/account/avatar/00/12/53/71/a4e9f20e.jpg","nickname":"言午木杉","note":"","ucode":"300BEDC1B07DF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102452,"discussion_content":"切片只是底层数组的一个映射，像之前说的一样切片是一个“窗口”，对切片的操作都会让底层数组产生变化。而s3,s4都是数组，所以在进入通道的时候是值传递，所以是不同的两块数组，改变其中一个值并不会影响到另外一个数组","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1577347159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207580,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6d/1c/d9746372.jpg","nickname":"EricJones","note":"","ucode":"0A80B609400D6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373908,"discussion_content":"浅复制：对于值类型的话是完全拷贝一份，而对于引用类型是拷贝其地址。你这里的 s1 和 s2 是切片类型，切片类型是引用类型。所以这里拷贝指针地址。s3 和 s4 是数组，数组是值类型，所以是完全拷贝一份。\n深复制：无论是什么类型都会完整的拷贝一份。\n","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1620913113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1483113,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a1/69/0ddda908.jpg","nickname":"满怀","note":"","ucode":"EFAC662A37D684","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303302,"discussion_content":"go语言只有两种类型，引用类型和值类型，在复制的时候无论是哪种类型都是值复制，也就是所谓的浅复制。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1599209789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423262,"discussion_content":"再说一遍，Go语言里没有深层复制。数组是值类型，所以会被完全复制。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1536061933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1226968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b8/d8/f81b5604.jpg","nickname":"hcyycb","note":"","ucode":"77FF6CA41F9E66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541508,"discussion_content":"为什么那么多人在纠缠这个值传递还是引用传递？很难吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640419570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394427,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631878924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207580,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6d/1c/d9746372.jpg","nickname":"EricJones","note":"","ucode":"0A80B609400D6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373906,"discussion_content":"s1 和 s2 是切片引用类型，这是引用类型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620912843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207580,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6d/1c/d9746372.jpg","nickname":"EricJones","note":"","ucode":"0A80B609400D6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373902,"discussion_content":"首先谁能解释下浅复制和深复制？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620912413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1149004,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/4c/2c3d2c7d.jpg","nickname":"小强","note":"","ucode":"CC3D3A9E5D9A42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281449,"discussion_content":"没理解完全复制和深层复制有啥区别啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591749728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1063436,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3a/0c/17060d56.jpg","nickname":"xw__goss","note":"","ucode":"673E4602F4E182","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82107,"discussion_content":"利用copy函数，也算是深层复制～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576320718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1198931,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erAciaibSTF6wtauVUFEK1yq27gEJ46LjumKxhSIs2I3u7JAxgSicrRfvcM4niaemqlbcyOYktWVlKwEg/132","nickname":"木凡","note":"","ucode":"88E016DA94B4F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1503,"discussion_content":"完全复制 是不是就是深层复制啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562667320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22726,"user_name":"melon","can_delete":false,"product_type":"c1","uid":1023773,"ip_address":"","ucode":"7A80C20EBCAAA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/1d/ec173090.jpg","comment_is_top":false,"comment_ctime":1535940946,"is_pvip":false,"replies":[{"id":"8197","content":"对，所以注释中才会那么说。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1535957872,"ip_address":"","comment_id":22726,"utype":1}],"discussion_count":1,"race_medal":0,"score":"113205090642","product_id":100013101,"comment_content":"感觉chanel有点像socket的同步阻塞模式，只不过channel的发送端和接收端共享一个缓冲，套接字则是发送这边有发送缓冲，接收这边有接收缓冲，而且socket接收端如果先close的话，发送端再发送数据的也会引发panic（linux上会触发SIG_PIPE信号，不处理程序就崩溃了）。<br><br>另使用demo21.go测试发送接收阻塞情况时需要额外空跑一个goroutine，否则会引发这样的panic（至 少1.11版是这样）：fatal error: all goroutines are asleep - deadlock!","like_count":27,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423239,"discussion_content":"对，所以注释中才会那么说。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535957872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22752,"user_name":"来碗绿豆汤","can_delete":false,"product_type":"c1","uid":1070051,"ip_address":"","ucode":"B0AB63B8D9729F","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg","comment_is_top":false,"comment_ctime":1535949134,"is_pvip":false,"replies":[{"id":"8202","content":"其实都是浅表复制。数组因为是值类型的，所以即使是浅复制也能完全复制过来。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1535959316,"ip_address":"","comment_id":22752,"utype":1}],"discussion_count":2,"race_medal":0,"score":"78845360462","product_id":100013101,"comment_content":"深copy还是浅copy,跟具体数据类型有关，引用型数据就是浅copy，数值型数据就是深copy.如，如果是切片类型则是浅copy,如果是数组则是深copy","like_count":19,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423252,"discussion_content":"其实都是浅表复制。数组因为是值类型的，所以即使是浅复制也能完全复制过来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535959316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1260026,"avatar":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","nickname":"安排","note":"","ucode":"F78CFA9624CAEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129661,"discussion_content":"都是浅拷贝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578725319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72304,"user_name":"会哭的鱼","can_delete":false,"product_type":"c1","uid":1199600,"ip_address":"","ucode":"AB2E35807C2392","user_header":"https://static001.geekbang.org/account/avatar/00/12/4d/f0/45110cac.jpg","comment_is_top":false,"comment_ctime":1551582663,"is_pvip":false,"replies":[{"id":"26219","content":"你理解的没错，在同一时刻，只有一个goroutine能够对某一个通道进行取出操作，其他的试图对这个通道进行取出操作的goroutine都会被阻塞，并进入通道内部的队列排队。通道会保证这种操作是互斥的，并且是原子性的（完全取走一个元素值之后，下一个元素值才有可能被取）。<br><br>我回答那位同学的意思是：两个go函数中的代码是有可能同时（在同一个很小的时间段内）执行到“取出操作”那一行代码的。不过我们完全不用在意，因为通道和运行时系统会保证这类操作的并发安全。<br><br>可能我那个回答太短了吧，咱俩没有对上口径。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1551611850,"ip_address":"","comment_id":72304,"utype":1}],"discussion_count":4,"race_medal":0,"score":"61681124807","product_id":100013101,"comment_content":"老师您好，通道这里我看了好几遍了，对于评论中有一个问题一直不明白，非常希望老师能够解答一下！<br><br>同学阿拉丁的瓜的提问：<br>请问老师，缓冲通道内的值是被并行读出的吗？<br>比如两个goroutine分别为r1和r2；一个装满的容量为2的chan。<br>当r1正在取出先入的数据时，r2是否可以取出后入的数据；还是说r2必须阻塞，等到先入数据被完全取走之后才能开始读取后入的数据？<br><br>老师回答：<br>作者回复: 可以同时进行，通道是并发安全的。但是不一定哪个g拿到哪个元素值。<br><br>个人不明白，按照我看完的理解，同一个通道不管有多少并发在接收操作，同一个通道同时只能被一个goroutine操作，其他的都要在这个接收操作完成 “复制通道内的元素值”“放置副本到接收方”“删掉原值”三步完全完成后才可以继续进行的，负责就要一直阻塞才对<br><br>老师原文中是这样的：<br>类似的，在同一时刻，运行时系统也只会执行，对同一个通道的任意个接收操作中的某一个。<br>直到这个元素值完全被移出该通道之后，其他针对该通道的接收操作才可能被执行。即使这些操作是并发执行的也是如此。<br>这里所谓的并发执行，你可以这样认为，多个代码块分别在不同的 goroutine 之中，并有机会在同一个时间段内被执行。<br>请老师解答一下我这个疑惑，非常感谢！","like_count":15,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441532,"discussion_content":"你理解的没错，在同一时刻，只有一个goroutine能够对某一个通道进行取出操作，其他的试图对这个通道进行取出操作的goroutine都会被阻塞，并进入通道内部的队列排队。通道会保证这种操作是互斥的，并且是原子性的（完全取走一个元素值之后，下一个元素值才有可能被取）。\n\n我回答那位同学的意思是：两个go函数中的代码是有可能同时（在同一个很小的时间段内）执行到“取出操作”那一行代码的。不过我们完全不用在意，因为通道和运行时系统会保证这类操作的并发安全。\n\n可能我那个回答太短了吧，咱俩没有对上口径。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551611850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394426,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631878905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1526355,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","nickname":"moonfox","note":"","ucode":"902BFF40EFA9FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284386,"discussion_content":"如果r2只能在r1取走数据后再读取，这就是按顺序读取，读取通道的效率感觉变低了，比如读出一个元素要1秒钟，如果r2要等r1的话则需要2秒才能读完通道内数据，r2如果和r1同时都可以读的话，1秒就可以读完了。不知应该是哪种情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592526003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1226968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b8/d8/f81b5604.jpg","nickname":"hcyycb","note":"","ucode":"77FF6CA41F9E66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1526355,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","nickname":"moonfox","note":"","ucode":"902BFF40EFA9FA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541509,"discussion_content":"如果r1和r2是并发，那么其实，你没有办法控制是哪一个协程先执行，哪一个协程后执行的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640419789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":284386,"ip_address":""},"score":541509,"extra":""}]}]},{"had_liked":false,"id":22762,"user_name":"有铭","can_delete":false,"product_type":"c1","uid":1046302,"ip_address":"","ucode":"2C7CB36CA5C04C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132","comment_is_top":false,"comment_ctime":1535960795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53075568347","product_id":100013101,"comment_content":"通道看上去像线程安全队列。那么这玩意在低层基于什么原理实现？cas？自旋？内核锁？性能如何","like_count":13},{"had_liked":false,"id":26098,"user_name":"My dream","can_delete":false,"product_type":"c1","uid":1077733,"ip_address":"","ucode":"2FEFB344230C17","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/e5/bcdc382a.jpg","comment_is_top":false,"comment_ctime":1537499060,"is_pvip":false,"replies":[{"id":"9670","content":"原则上可以传任何类型的数据。不过，要是传指针的话要自己保证安全啊，原始数据放篡改之类的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1537690749,"ip_address":"","comment_id":26098,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48782139316","product_id":100013101,"comment_content":"老师，请教一下，通道的传值可以直接传指针不，你讲的拷贝，那么内存开销是很大的，如果通道传指针的话，会不会好很多","like_count":12,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424526,"discussion_content":"原则上可以传任何类型的数据。不过，要是传指针的话要自己保证安全啊，原始数据放篡改之类的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537690749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22658,"user_name":"请叫我小岳同学","can_delete":false,"product_type":"c1","uid":1130999,"ip_address":"","ucode":"E35BBA40FF052A","user_header":"https://static001.geekbang.org/account/avatar/00/11/41/f7/8345488c.jpg","comment_is_top":false,"comment_ctime":1535908073,"is_pvip":false,"replies":[{"id":"8201","content":"第一个问题，长度代表通道当前包含的元素个数，容量就是初始化时你设置的那个数。<br><br>第二个问题你再想想，可以做做试验。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1535958470,"ip_address":"","comment_id":22658,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48780548329","product_id":100013101,"comment_content":"1. 通道的长度，表示channel 缓冲的长度。当channel处于阻塞状态时，容纳最多的同类型的长度。<br>2. 深拷贝","like_count":11,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423213,"discussion_content":"第一个问题，长度代表通道当前包含的元素个数，容量就是初始化时你设置的那个数。\n\n第二个问题你再想想，可以做做试验。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535958470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107776,"user_name":"Geek_a8be59","can_delete":false,"product_type":"c1","uid":1563985,"ip_address":"","ucode":"BEC0F57B51DC44","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdiaUiaCYQe9tibemaNU5ya7RrU3MYcSGEIG7zF27u0ZDnZs5lYxPb7KPrAsj3bibM79QIOnPXAatfIw/132","comment_is_top":false,"comment_ctime":1561607326,"is_pvip":false,"replies":[{"id":"38994","content":"所以说不要用“协程”这个概念，因为“协程（coroutine）”指的是程序在同一个线程内的自行调度，是应用程序本身完全可控的。而 goroutine 的调度是 Go 语言的运行时系统发起的。<br><br>你不要揣测 Go 语言的调度器会怎样调度。你首先要知道哪些代码点是调度的时机（注意，到了调度时机也不一定发生调度，只是时机而已）。你还要知道如果想让多个 goroutine 按照你拟定的流程执行就需要用到 Channel 以及各种同步工具。<br><br>你说的“跳转到”只能在 coroutine 场景下才能这么说。在 goroutine 的场景下，没有“跳转”这么一说。<br><br>其一，你在上面的 for 语句中启用了一个 goroutine，你怎么就能断定后面的代码一定会先于这个 go 函数执行？不要做这种假设。因为连 goroutine 的调度都是并发的。<br><br>其二，两个 goroutine 一个 channel，一个 goroutine 发，一个 goroutine 取。这个 ch1 什么时候满、什么时候空，你基本上是确定不了的。因为两个 for 循环 在迭代的过程中都可能因被调用而换下 CPU。<br><br>其三，你要知道，几乎任何函数调用都存在调度时机，更何况是像 fmt.Println 这种需要 I&#47;O 的重型操作。所以，为什么你那前一个 for 循环结束之后就不能被调度了呢？<br><br>以上是我通过你的文字表达猜测并回答的，并不一定完全匹配你要问的问题。还有问题的话再问我。<br><br>我觉得你对“并发”和“调度”这两个概念不清楚。我建议你好好看看专栏里讲 goroutine 的那几篇文章。有必要的话，买我的《Go 并发编程实战》第二版从头学一下。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1561616436,"ip_address":"","comment_id":107776,"utype":1}],"discussion_count":3,"race_medal":0,"score":"40216312990","product_id":100013101,"comment_content":"\tch1 := make(chan int, 2)<br>\t&#47;&#47; 发送方。<br>\tgo func() {<br>\t\tfor i := 0; i &lt; 10; i++ {<br>\t\t\tfmt.Printf(&quot;Sender: sending element %v...\\n&quot;, i)<br>\t\t\tch1 &lt;- i<br>\t\t}<br>\t\tfmt.Println(&quot;Sender: close the channel...&quot;)<br>\t\tclose(ch1)<br>\t}()<br><br>\t&#47;&#47; 接收方。<br>\tfor {<br>\t\telem, ok := &lt;-ch1<br>\t\tif !ok {<br>\t\t\tfmt.Println(&quot;Receiver: closed channel&quot;)<br>\t\t\tbreak<br>\t\t}<br>\t\tfmt.Printf(&quot;Receiver: received an element: %v\\n&quot;, elem)<br>\t}<br><br>\tfmt.Println(&quot;End.&quot;)<br><br><br>老师，根据您的提供的源码有三个问题需请教。<br>第一问题:第一次携程调度应该发生主携程中的elem, ok := &lt;-ch1 这个代码处，这时候应该在chan有等待的协成，再第一向chan1&lt;-i传值得时候，根据您的描述&quot;当发送操作在执行的时候发现空的通道中，正好有等待的接收,那么会把元素直接复制给对方&quot;。照这么说应该在这次就跳转到主协成中，并打印出接收到的数据了。但是实际是先发送i=3的时候才做第一次携程调度，请问这是为什么？<br>第二问题：缓存区的大小不是设置的是2么，为什么length当发送了i=3的时候才会阻塞发生调度呢，正常不是应该i=2的时候么<br>第三个问题：当for循环结束了以后 就是在chan关闭之前，为什么又能调度到主协成让他接收呢。不应该到这个协成调用结束么？","like_count":10,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455669,"discussion_content":"所以说不要用“协程”这个概念，因为“协程（coroutine）”指的是程序在同一个线程内的自行调度，是应用程序本身完全可控的。而 goroutine 的调度是 Go 语言的运行时系统发起的。\n\n你不要揣测 Go 语言的调度器会怎样调度。你首先要知道哪些代码点是调度的时机（注意，到了调度时机也不一定发生调度，只是时机而已）。你还要知道如果想让多个 goroutine 按照你拟定的流程执行就需要用到 Channel 以及各种同步工具。\n\n你说的“跳转到”只能在 coroutine 场景下才能这么说。在 goroutine 的场景下，没有“跳转”这么一说。\n\n其一，你在上面的 for 语句中启用了一个 goroutine，你怎么就能断定后面的代码一定会先于这个 go 函数执行？不要做这种假设。因为连 goroutine 的调度都是并发的。\n\n其二，两个 goroutine 一个 channel，一个 goroutine 发，一个 goroutine 取。这个 ch1 什么时候满、什么时候空，你基本上是确定不了的。因为两个 for 循环 在迭代的过程中都可能因被调用而换下 CPU。\n\n其三，你要知道，几乎任何函数调用都存在调度时机，更何况是像 fmt.Println 这种需要 I/O 的重型操作。所以，为什么你那前一个 for 循环结束之后就不能被调度了呢？\n\n以上是我通过你的文字表达猜测并回答的，并不一定完全匹配你要问的问题。还有问题的话再问我。\n\n我觉得你对“并发”和“调度”这两个概念不清楚。我建议你好好看看专栏里讲 goroutine 的那几篇文章。有必要的话，买我的《Go 并发编程实战》第二版从头学一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561616436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1312493,"avatar":"https://static001.geekbang.org/account/avatar/00/14/06/ed/5a167dda.jpg","nickname":"niceshot","note":"","ucode":"2C2BBC07A6E02D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377234,"discussion_content":"不一定的 你的fmt io占用了一部分时间 你可以把ch<- 和printf顺序调换一下又不一样了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622555689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1563985,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdiaUiaCYQe9tibemaNU5ya7RrU3MYcSGEIG7zF27u0ZDnZs5lYxPb7KPrAsj3bibM79QIOnPXAatfIw/132","nickname":"Geek_a8be59","note":"","ucode":"BEC0F57B51DC44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488,"discussion_content":"谢谢老师的解答。这让我了解好多，我把php的协成和goroutine搞混掉了，忘记了是多线程的，但是还是不清楚什么代码是有调度时机的，还需要在好好去了解。现在我对代码做了稍微改动\nfunc main() {\n\truntime.GOMAXPROCS(1)\n\tch1 := make(chan int, 2)\n\n\t// 发送方。\n\tgo func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tch1 <- i\n\t\t\tfmt.Printf(&#34;次数:%v,Sender: sending chan length %v...\\n&#34;, i,len(ch1))\n\t\t}\n\t\tfmt.Println(&#34;Sender: close the channel...&#34;)\n\t\tclose(ch1)\n\t}()\n\n\t// 接收方。\n\tfor {\n\t\telem, ok := <-ch1\n\t\tif !ok {\n\t\t\tfmt.Println(&#34;Receiver: closed channel&#34;)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(&#34;Receiver: received an element: %v\\n&#34;, elem)\n\t}\n\n\tfmt.Println(&#34;End.&#34;)\n\n\n}\n\n运行结果:\n次数:0,Sender: sending chan length 0...\n次数:1,Sender: sending chan length 1...\n次数:2,Sender: sending chan length 2...\nReceiver: received an element: 0\nReceiver: received an element: 1\nReceiver: received an element: 2\nReceiver: received an element: 3\n次数:3,Sender: sending chan length 0...\n次数:4,Sender: sending chan length 0...\n次数:5,Sender: sending chan length 1...\n次数:6,Sender: sending chan length 2...\nReceiver: received an element: 4\nReceiver: received an element: 5\nReceiver: received an element: 6\nReceiver: received an element: 7\n次数:7,Sender: sending chan length 0...\n次数:8,Sender: sending chan length 0...\n次数:9,Sender: sending chan length 1...\nSender: close the channel...\nReceiver: received an element: 8\nReceiver: received an element: 9\nReceiver: closed channel\nEnd.\n\n现在是单线程状态了.\n这里的&#34;次数:0,Sender: sending chan length 0...&#34;是不是当我第一个i=0的时候，发现有等待的chan发生了调度了，再elem, ok := <-ch1这边接受到了以后，还没到打印的那一步又有一个调度跑到上面那个地方，直到第一次通道满以后，再发生调度了。才会产生前面这样的效果","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561618188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23030,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1536114120,"is_pvip":false,"replies":[{"id":"8402","content":"浅拷贝只是拷贝值以及值中直接包含的东西，深拷贝就是把所有深层次的结构一并拷贝。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1536216179,"ip_address":"","comment_id":23030,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40190819784","product_id":100013101,"comment_content":"老师，我知道 golang 这门语言中所有的变量赋值操作都是 value copy的，不论这个变量是值类型，还是指针类型。关于您这里说的 shallow copy 与 deep copy 的问题我还是不是很清楚， google 了一下，每门语言的支持都不太一样，您是怎么定义这两个概念的？能否详细说一下？","like_count":10,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423378,"discussion_content":"浅拷贝只是拷贝值以及值中直接包含的东西，深拷贝就是把所有深层次的结构一并拷贝。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536216179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22755,"user_name":"苏浅","can_delete":false,"product_type":"c1","uid":1102398,"ip_address":"","ucode":"F7AD45AF84DA82","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/t82qauAVn2m2uQicV7eBByBMehSvUlj6tLOsiaBlficcsKB57vYfthTgoyWTpoW5X6OQOrdL0nVWlMBg2L3ictTJAw/132","comment_is_top":false,"comment_ctime":1535949822,"is_pvip":false,"replies":[{"id":"8196","content":"需要手动关闭，这是个很好的习惯，而且也可以利用关的动作来给接收方传递一个信号。Go的GC只会清理被分配到堆上的、不再有任何引用的对象。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1535957603,"ip_address":"","comment_id":22755,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40190655486","product_id":100013101,"comment_content":"通道必须要手动关闭吗？go会自动清理吗？","like_count":10,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423254,"discussion_content":"需要手动关闭，这是个很好的习惯，而且也可以利用关的动作来给接收方传递一个信号。Go的GC只会清理被分配到堆上的、不再有任何引用的对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535957603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165964,"user_name":"kk","can_delete":false,"product_type":"c1","uid":1198399,"ip_address":"","ucode":"E65D5DCE26F666","user_header":"https://static001.geekbang.org/account/avatar/00/12/49/3f/77a92aab.jpg","comment_is_top":false,"comment_ctime":1577352310,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27347156086","product_id":100013101,"comment_content":"技术课却没几行代码，全是大段的文字，读起来晦涩佶屈","like_count":7,"discussions":[{"author":{"id":1115232,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","nickname":"Fan","note":"","ucode":"3BF28670FD9407","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386593,"discussion_content":"还不如直接看官网","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627658165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1221991,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a5/67/bf286335.jpg","nickname":"AllenGFLiu","note":"","ucode":"90FA8A619A2629","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342659,"discussion_content":"代碼都在文章最後老師放的鏈接里,自行下載下來後對照著文章所屬的文件夾就可以看到文字描述時需要寫的代碼.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610768646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74974,"user_name":"Xiaolan🇨🇳","can_delete":false,"product_type":"c1","uid":1432750,"ip_address":"","ucode":"7AAA2C89947B55","user_header":"https://static001.geekbang.org/account/avatar/00/15/dc/ae/7fa307a3.jpg","comment_is_top":false,"comment_ctime":1552344127,"is_pvip":false,"replies":[{"id":"28889","content":"它是面向同一个进程的。多个进程之间内存一般不会共享，所以没法用channel。进程间通讯可以考虑IPC方法，比如有名管道，你可以参看一下os.Pipe函数的文档。其实进程间通讯最强大和灵活的还是socket。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1553400234,"ip_address":"","comment_id":74974,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27322147903","product_id":100013101,"comment_content":"通道的使用场景是不是同一个进程的不同线程间通讯使用？如果是不同程序进程还可以使用吗？","like_count":6,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442765,"discussion_content":"它是面向同一个进程的。多个进程之间内存一般不会共享，所以没法用channel。进程间通讯可以考虑IPC方法，比如有名管道，你可以参看一下os.Pipe函数的文档。其实进程间通讯最强大和灵活的还是socket。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553400234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108140,"user_name":"Geek_a8be59","can_delete":false,"product_type":"c1","uid":1563985,"ip_address":"","ucode":"BEC0F57B51DC44","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdiaUiaCYQe9tibemaNU5ya7RrU3MYcSGEIG7zF27u0ZDnZs5lYxPb7KPrAsj3bibM79QIOnPXAatfIw/132","comment_is_top":false,"comment_ctime":1561686484,"is_pvip":false,"replies":[{"id":"39298","content":"为什么非要知道那些 goroutine 都是第几个呢？再说了，你那个 NowTotal 中的<br><br>for i:=0;i&lt;s.now;i++ {<br>        s.nowtotal&lt;-i<br>}<br><br>相当于向 nowtotal 发送 0、1、2、3、4、5、6、7、8、9。那你的 Wait 方法每次给 total 赋的值就是不一样的。即使你的  if total == s.now-1 可以判断已经够 10 个 goroutine了，可 s.chanArr&lt;-i 不应该是最后一个 Wait 方法做的事。你想想，你这样只能完成一次“阻塞 9 个，满 10 个放行”。 <br><br>我觉得你实现得不好。职责划分不清晰。你应该将把控的逻辑放在 NowTotal 方法里。Wait 方法每执行一次就通过通道告诉 NowTotal 一下。告诉完了，Wait 方法用另一个通道阻塞自己。一旦够了 10 个，NowTotal 就通过第二个通道放行。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1561814017,"ip_address":"","comment_id":108140,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18741555668","product_id":100013101,"comment_content":"对昨天您提的问题做了一下补充：<br>1. 你的 Wait 方法里的那个 for 语句是干嘛的？<br>2. total :=&lt;-s.nowtotal 中的 total 不是一个会改变的数啊，那你后边的 total == s.now-1 判断就存在问题。<br>------------------------------<br>&#47;&#47; 抽象一个栅栏<br>type Barrier interface {<br>\tWait ()<br>}<br>&#47;&#47; 创建栅栏对象<br>func NewBarrier (n int) Barrier {<br>\tvar barrier = &amp;barrier{}<br>\tbarrier.now = n<br>\tbarrier.chanArr = make(chan int)<br>\tbarrier.nowtotal = make(chan int)<br>\tgo barrier.NowTotal()<br>\treturn barrier<br>}<br>func (s *barrier) NowTotal() {\t\t&#47;&#47;用于判断当前属于第几个运行的goroutine<br><br>\tfor i:=0;i&lt;s.now;i++ {<br>\t\ts.nowtotal&lt;-i<br>\t}<br>}<br>func (s *barrier) Wait()  {<br>\ttotal :=&lt;-s.nowtotal<br>\tif total == s.now-1 {\t\t&#47;&#47;这里s.now-1等于9就是说明这是第10个goroutine<br>\t\tfor i:=0;i&lt;total;i++ {\t&#47;&#47;这个是为了去唤醒剩余的9个。注：题目的要求就是前9个goroutine阻塞，第10个goroutine去唤醒他们<br><br>\t\t\ts.chanArr&lt;-i<br>\t\t}<br>\t } else {<br>\t\tnum:=&lt;-s.chanArr<br>\t\tfmt.Printf(&quot;拿到了数据:%v\\n&quot;,num)<br>\t}<br>}<br>&#47;&#47; 栅栏的实现类<br>type barrier struct {<br>\tchanArr  chan int<br>\tnowtotal chan int<br>\tnow int<br>}<br>&#47;&#47; 测试代码<br>func main () {<br><br>\t&#47;&#47; 创建栅栏对象<br>\tb := NewBarrier(10)<br><br>\t&#47;&#47; 达到的效果：前9个协程调用Wait()阻塞，第10个调用后10个协程全部唤醒<br>\tfor i:=0; i&lt;10; i++ {<br>\t\tgo b.Wait()<br>\t}<br>\tselect {<br><br>\t}<br>}<br><br>第一个您的问题：for循环主要去唤醒其他阻塞的goroutine<br>第二个您的问题：s.nowtotal 一直是在变得呀，通过传i进来，主要说明当前是运行的第几个goroutine<br>只是整体用的语意不这么明确<br>这样您看我的能实现要求么？","like_count":4,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455839,"discussion_content":"为什么非要知道那些 goroutine 都是第几个呢？再说了，你那个 NowTotal 中的\n\nfor i:=0;i&amp;lt;s.now;i++ {\n        s.nowtotal&amp;lt;-i\n}\n\n相当于向 nowtotal 发送 0、1、2、3、4、5、6、7、8、9。那你的 Wait 方法每次给 total 赋的值就是不一样的。即使你的  if total == s.now-1 可以判断已经够 10 个 goroutine了，可 s.chanArr&amp;lt;-i 不应该是最后一个 Wait 方法做的事。你想想，你这样只能完成一次“阻塞 9 个，满 10 个放行”。 \n\n我觉得你实现得不好。职责划分不清晰。你应该将把控的逻辑放在 NowTotal 方法里。Wait 方法每执行一次就通过通道告诉 NowTotal 一下。告诉完了，Wait 方法用另一个通道阻塞自己。一旦够了 10 个，NowTotal 就通过第二个通道放行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561814017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39495,"user_name":"勇.Max","can_delete":false,"product_type":"c1","uid":1248128,"ip_address":"","ucode":"AE5DBC10805A9B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0b/80/a0533acb.jpg","comment_is_top":false,"comment_ctime":1542290562,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"18722159746","product_id":100013101,"comment_content":"老师，有个问题困惑很久，如果传指针的话，接收方和发送方不在一台机器上，指针还有效吗？(指针不是指向本地内存的吗)","like_count":4,"discussions":[{"author":{"id":1206539,"avatar":"https://static001.geekbang.org/account/avatar/00/12/69/0b/780b0aac.jpg","nickname":"nora","note":"","ucode":"3A3EABF27D0261","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109914,"discussion_content":"channel 是面向同一个进程的。多个进程之间内存一般不会共享，所以没法用channel。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1577714533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1566538,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e7/4a/0ea220d6.jpg","nickname":"1043","note":"","ucode":"85802E6C90B65F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372373,"discussion_content":"..","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620301990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1445123,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0d/03/e59341b4.jpg","nickname":"亚","note":"","ucode":"CDF4DFC3F3619A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284817,"discussion_content":"同一个进程不可能拆分到不同机器上面的，你是跟socket弄混了吧。一个是进程间通讯，一个是线程间/协程间通讯","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592649537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28131,"user_name":"My dream","can_delete":false,"product_type":"c1","uid":1077733,"ip_address":"","ucode":"2FEFB344230C17","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/e5/bcdc382a.jpg","comment_is_top":false,"comment_ctime":1538011225,"is_pvip":false,"replies":[{"id":"10648","content":"如果你的通道要给外人使用，或者通过通道对外提供功能，那就不要传指针值了，容易造成安全漏洞，另外这个时候最好限制下通道的方向。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1538452774,"ip_address":"","comment_id":28131,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18717880409","product_id":100013101,"comment_content":"通道传值首先要保证原始数据的安全性是吗？所以一般不建议用传指针的方式来通讯，是不是这样理解的","like_count":5,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425152,"discussion_content":"如果你的通道要给外人使用，或者通过通道对外提供功能，那就不要传指针值了，容易造成安全漏洞，另外这个时候最好限制下通道的方向。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538452774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23096,"user_name":"wh","can_delete":false,"product_type":"c1","uid":1081702,"ip_address":"","ucode":"C5A7906D63527B","user_header":"https://static001.geekbang.org/account/avatar/00/10/81/66/7921c84a.jpg","comment_is_top":false,"comment_ctime":1536150821,"is_pvip":false,"replies":[{"id":"8399","content":"可以用另外的标志位做，比如context。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1536215784,"ip_address":"","comment_id":23096,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18716020005","product_id":100013101,"comment_content":"不要从接受端关闭channel算是基本原则了，另外如果有多个并发发送者，1个或多个接收者，有什么普适选择可以分享吗？","like_count":4,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423412,"discussion_content":"可以用另外的标志位做，比如context。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536215784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22799,"user_name":"皮卡丘","can_delete":false,"product_type":"c1","uid":1135596,"ip_address":"","ucode":"0F814B6BF331D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/ec/3f6ae1aa.jpg","comment_is_top":false,"comment_ctime":1535978758,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18715847942","product_id":100013101,"comment_content":"很明显现象是浅拷贝，为啥那么多说深拷贝的","like_count":4},{"had_liked":false,"id":122600,"user_name":"🐶","can_delete":false,"product_type":"c1","uid":1459980,"ip_address":"","ucode":"D9E46DDB64BA77","user_header":"https://static001.geekbang.org/account/avatar/00/16/47/0c/f2f0245e.jpg","comment_is_top":false,"comment_ctime":1565431906,"is_pvip":false,"replies":[{"id":"45149","content":"好，收到。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1565576712,"ip_address":"","comment_id":122600,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14450333794","product_id":100013101,"comment_content":"通道的长度代表着整个通道已经存在的元素值len可以查看，类似于切片，而容量则是刚开始设定的值，整个chan可以看成一个已经长度的队列，操作也可以跟队列相类比。<br>go没有深拷贝，只有浅拷贝，通过值拷贝，而没有所谓的引用拷贝，也是因为这样，整个go语言才能使得效率很高，内存占用少！<br>建议：老师可以画一些图来理清思路，因为一直看文字会很累...","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462326,"discussion_content":"好，收到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565576712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102571,"user_name":"左氧佛沙星人","can_delete":false,"product_type":"c1","uid":1195278,"ip_address":"","ucode":"0D8295E1DABA8C","user_header":"https://static001.geekbang.org/account/avatar/00/12/3d/0e/92176eaa.jpg","comment_is_top":false,"comment_ctime":1560254153,"is_pvip":true,"replies":[{"id":"37176","content":"问题很明显啊，怎么能用 for sign == 0 呢？两个问题，一个是你不能假定 go 函数（这里是 send 函数）的执行时机。另一个是你这样使用 sign 变量不是并发安全的，产生了竞态条件。用你的 stateChan 做状态传递多好。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1560308029,"ip_address":"","comment_id":102571,"utype":1}],"discussion_count":5,"race_medal":0,"score":"14445156041","product_id":100013101,"comment_content":"老师，我在做一道题，1个goroutine产生100个随机数放入一个channel，然后同时启动10个goroutine来读取，下面是我的代码，但是跑完了，fatal error: all goroutines are asleep - deadlock!直接提示死锁，能帮忙看下原因吗，老师<br><br>main.main.func2(0xc0000a0000, 0xc00009e000)<br>\t&#47;Users&#47;go&#47;src&#47;cliTest&#47;exam&#47;100IntChan.go:34 +0xc9<br>created by main.main<br>\t&#47;Users&#47;go&#47;src&#47;cliTest&#47;exam&#47;100IntChan.go:29 +0x110<br><br>package main<br><br><br>import (<br>\t&quot;math&#47;rand&quot;<br>\t&quot;log&quot;<br>)<br><br><br><br>func main() {<br>\t<br>\tintChan := make(chan int,100)<br>\tstateChan :=  make(chan struct{}, 10)<br>\tsign := 0<br>\tsend := func() {<br>\t\tfor i:=0;i&lt;100;i++ {<br>\t\t\tintChan &lt;- rand.Intn(100)<br>\t\t}<br>\t\tsign = 1<br>\t}<br>\t<br>\tgo send()<br>\tfor sign == 0 {<br>\t<br>\t}<br>\t<br>\tfor j:=0;j&lt;10;j++ {<br>\t\tgo func() {<br>\t\t\tdefer func() {<br>\t\t\t\tstateChan &lt;- struct{}{}<br>\t\t\t}()<br>\t\t\tfor {<br>\t\t\t\telem, ok := &lt;-intChan<br>\t\t\t\tif ok {<br>\t\t\t\t\tlog.Print(elem,&quot;\\n&quot;)<br>\t\t\t\t} else {<br>\t\t\t\t\tbreak<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}()<br>\t}<br>\t&lt;- stateChan<br>\t&lt;- stateChan<br>\t&lt;- stateChan<br>\t&lt;- stateChan<br>\t&lt;- stateChan<br>\t&lt;- stateChan<br>\t&lt;- stateChan<br>\t&lt;- stateChan<br>\t&lt;- stateChan<br>\t&lt;- stateChan<br>\t<br>}","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453483,"discussion_content":"问题很明显啊，怎么能用 for sign == 0 呢？两个问题，一个是你不能假定 go 函数（这里是 send 函数）的执行时机。另一个是你这样使用 sign 变量不是并发安全的，产生了竞态条件。用你的 stateChan 做状态传递多好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560308029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603571,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKgNge1sNXIWCFeUOa53cU5Glfw24sjxibBxTiaTb45LmU9bRDlDgBib9goFZXmoKwXTOJ4JMvVHHbiaA/132","nickname":"潘林林","note":"","ucode":"31576141FE4A1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404257,"discussion_content":"intChan  在存入数据后你没有关闭 \n导致后面从intChan 中取完一直在等待了 \n就不会走else  也就不会触发defer 中 stateChan <- struct{}{}\n主go成下面又在等待 <- stateChan\n所以deadlock","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634270275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219868,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9d/1c/c18b3d43.jpg","nickname":"刀","note":"","ucode":"158625E5941318","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62512,"discussion_content":"send函数里面修改sign = 1，main goroutine是感知不到的了，是两条线上的数据了，main goroutine的sign一直是0，所以产生了死锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574848883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1563985,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdiaUiaCYQe9tibemaNU5ya7RrU3MYcSGEIG7zF27u0ZDnZs5lYxPb7KPrAsj3bibM79QIOnPXAatfIw/132","nickname":"Geek_a8be59","note":"","ucode":"BEC0F57B51DC44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431,"discussion_content":"这位代码中方法内部sign为什么能改变外部的sign值，这不是不在同一代码块了么，主要不知道这块知识是什么知识点 也不知道怎么去查，请老师解答一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561546882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1445123,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0d/03/e59341b4.jpg","nickname":"亚","note":"","ucode":"CDF4DFC3F3619A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1563985,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdiaUiaCYQe9tibemaNU5ya7RrU3MYcSGEIG7zF27u0ZDnZs5lYxPb7KPrAsj3bibM79QIOnPXAatfIw/132","nickname":"Geek_a8be59","note":"","ucode":"BEC0F57B51DC44","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284820,"discussion_content":"你查一下go语言闭包的说明","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592650198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":431,"ip_address":""},"score":284820,"extra":""}]}]},{"had_liked":false,"id":95897,"user_name":"小鹏宇","can_delete":false,"product_type":"c1","uid":1318442,"ip_address":"","ucode":"BCB1D22A0A3D07","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/2a/b7155819.jpg","comment_is_top":false,"comment_ctime":1558249044,"is_pvip":false,"replies":[{"id":"34363","content":"你可以再仔细看一下无缓冲通道的操作规则。你先在主 goroutine 里做接收操作（或发送操作），就等于把主 goroutine 阻塞了。后面你自定义的 go 语句根本还没来得及执行。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1558321806,"ip_address":"","comment_id":95897,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14443150932","product_id":100013101,"comment_content":"func main() {<br><br>\tch1 := make(chan int)<br><br>\tgo func() {<br>\t\tfmt.Println(&lt;-ch1)<br>\t}()<br><br>\tch1 &lt;- 1<br><br>\ttime.Sleep(time.Second)<br>}<br>这样是不会阻塞的，下面的代码就会报错 fatal error: all goroutines are asleep - deadlock!<br>func main() {<br><br>\tch1 := make(chan int)<br>\tch1 &lt;- 1<br>\tgo func() {<br>\t\tfmt.Println(&lt;-ch1)<br>\t}()<br><br>\ttime.Sleep(time.Second)<br>}<br><br>难道ch1 &lt;- 1是把下面那个goroutine也阻塞了？","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450632,"discussion_content":"你可以再仔细看一下无缓冲通道的操作规则。你先在主 goroutine 里做接收操作（或发送操作），就等于把主 goroutine 阻塞了。后面你自定义的 go 语句根本还没来得及执行。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1558321806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278779,"user_name":"李刚","can_delete":false,"product_type":"c1","uid":1424487,"ip_address":"","ucode":"BFA253F932F01B","user_header":"https://static001.geekbang.org/account/avatar/00/15/bc/67/2e19e8ef.jpg","comment_is_top":false,"comment_ctime":1613316318,"is_pvip":false,"replies":[{"id":"101420","content":"这一步“通过一个goroutine往某一个channel里顺序的不断发送命令”使得channel中的命令是有序的。<br><br>但是，这一步“通过10个goroutine不断的从这个channel里取命令出来进行执行”会让命令执行的顺序随机。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1613625253,"ip_address":"","comment_id":278779,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10203250910","product_id":100013101,"comment_content":"channel是并发安全的，如果我通过一个goroutine往某一个channel里顺序的不断发送命令，然后通过10个goroutine不断的从这个channel里取命令出来进行执行。<br>那是不是表示，执行命令的顺序也一定是我写入到channe里时的顺序。","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515497,"discussion_content":"这一步“通过一个goroutine往某一个channel里顺序的不断发送命令”使得channel中的命令是有序的。\n\n但是，这一步“通过10个goroutine不断的从这个channel里取命令出来进行执行”会让命令执行的顺序随机。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613625253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168386,"user_name":"dingjiayi","can_delete":false,"product_type":"c1","uid":1485477,"ip_address":"","ucode":"DAE189F6FB1B55","user_header":"https://static001.geekbang.org/account/avatar/00/16/aa/a5/194613c1.jpg","comment_is_top":false,"comment_ctime":1578058831,"is_pvip":false,"replies":[{"id":"65372","content":"通道不保证原子操作，只保证互斥。如果非说有的话，那也是在“发”和“收”的那两个小步骤是原子的。另外，通道保证并发的对象也只是自身而已。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1578120901,"ip_address":"","comment_id":168386,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10167993423","product_id":100013101,"comment_content":"通道的三个特性，可以看做通道原子操作的体现？","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480208,"discussion_content":"通道不保证原子操作，只保证互斥。如果非说有的话，那也是在“发”和“收”的那两个小步骤是原子的。另外，通道保证并发的对象也只是自身而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578120901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164267,"user_name":"lixiaofeng","can_delete":false,"product_type":"c1","uid":1100200,"ip_address":"","ucode":"0D6710D95B6FFB","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/a8/98507423.jpg","comment_is_top":false,"comment_ctime":1576919839,"is_pvip":false,"replies":[{"id":"62437","content":"因为有发有收啊。发的goroutine和收的goroutine都受Go语言运行时系统的调度。这种调度是内部机制。因此不要假设可以连续发几个，这只是巧合而已。<br><br>再次强调，除去同步阻塞、系统调用、定时器等因素之外，你可以把这种调度理解为伪随机的，因为系统底层可以影响调度的因素有不少，这些因素在应用程序层面几乎都是不可控的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1576940278,"ip_address":"","comment_id":164267,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10166854431","product_id":100013101,"comment_content":"下面的是老师给出的 demo22.go 的代码。<br>问题是：声明的是两个元素长度的channel ， 为什么可以连续发送四个元素？<br>func main(){<br>\tfchan02()<br>}<br><br>func fchan02(){<br>\tch1 := make(chan int, 2)<br>\tgo func(){<br>\t\tfor i :=0; i&lt;10; i++{<br>\t\t\tfmt.Println(&quot;sender: sendering emement: &quot;, i)<br>\t\t\tch1 &lt;- i<br>\t\t}<br>\t}()<br><br>\tfor {<br>\t\telem, ok := &lt;-ch1<br>\t\tif !ok {<br>\t\t\tfmt.Println(&quot;receive: close channel&quot;)<br>\t\t\tbreak<br>\t\t}<br>\t\tfmt.Println(&quot;receive: receive an element: &quot;, elem)<br>\t}<br>}<br><br>sender: sendering emement:  0<br>sender: sendering emement:  1<br>sender: sendering emement:  2<br>sender: sendering emement:  3<br>receive: receive an element:  0<br>receive: receive an element:  1<br>receive: receive an element:  2<br>receive: receive an element:  3<br>sender: sendering emement:  4<br>sender: sendering emement:  5<br>sender: sendering emement:  6<br>sender: sendering emement:  7<br>receive: receive an element:  4<br>receive: receive an element:  5<br>receive: receive an element:  6<br>receive: receive an element:  7<br>sender: sendering emement:  8<br>sender: sendering emement:  9<br>receive: receive an element:  8<br>receive: receive an element:  9<br>fatal error: all goroutines are asleep - deadlock!","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478699,"discussion_content":"因为有发有收啊。发的goroutine和收的goroutine都受Go语言运行时系统的调度。这种调度是内部机制。因此不要假设可以连续发几个，这只是巧合而已。\n\n再次强调，除去同步阻塞、系统调用、定时器等因素之外，你可以把这种调度理解为伪随机的，因为系统底层可以影响调度的因素有不少，这些因素在应用程序层面几乎都是不可控的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576940278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2997610,"avatar":"","nickname":"Geek_superkai","note":"","ucode":"11BD59E867CEF8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582879,"discussion_content":"因此不要假设可以连续发几个，这只是巧合而已。这个我运行了很多次,都是一样的数量,是和系统有关系吗?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659749852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2997610,"avatar":"","nickname":"Geek_superkai","note":"","ucode":"11BD59E867CEF8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582878,"discussion_content":"那这个demo22是为了想表达什么呢?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659749807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127521,"user_name":"小苹果","can_delete":false,"product_type":"c1","uid":1204164,"ip_address":"","ucode":"719AF8C4FD2E48","user_header":"https://static001.geekbang.org/account/avatar/00/12/5f/c4/ea2acdb9.jpg","comment_is_top":false,"comment_ctime":1566733220,"is_pvip":false,"replies":[{"id":"47298","content":"我记得在文章里说了，如果通道关闭的时候里面还有值，那么接收方还可以继续接收剩下的值。直到里面空了，第二个变量才会是 false。这时，第一个变量一定会是通道元素类型的零值。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1566786278,"ip_address":"","comment_id":127521,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10156667812","product_id":100013101,"comment_content":"当我们把接收表达式的结果同时赋给两个变量时，第二个变量的类型就是一定bool类型。它的值如果为false就说明通道已经关闭，并且再没有元素值可取了。<br><br>老师，当第二个变量为false时，第一个变量的值还是对方发送过来的值吗？还是应该丢弃？","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464533,"discussion_content":"我记得在文章里说了，如果通道关闭的时候里面还有值，那么接收方还可以继续接收剩下的值。直到里面空了，第二个变量才会是 false。这时，第一个变量一定会是通道元素类型的零值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566786278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":25166,"user_name":"阿拉丁的瓜灯儿","can_delete":false,"product_type":"c1","uid":1241909,"ip_address":"","ucode":"346AE382D8C0DA","user_header":"","comment_is_top":false,"comment_ctime":1537260099,"is_pvip":false,"replies":[{"id":"9370","content":"可以同时进行，通道是并发安全的。但是不一定哪个g拿到哪个元素值。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1537442940,"ip_address":"","comment_id":25166,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10127194691","product_id":100013101,"comment_content":"请问老师，缓冲通道内的值是被并行读出的吗？<br>比如两个goroutine分别为r1和r2；一个装满的容量为2的chan。<br>当r1正在取出先入的数据时，r2是否可以取出后入的数据；还是说r2必须阻塞，等到先入数据被完全取走之后才能开始读取后入的数据？","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424210,"discussion_content":"可以同时进行，通道是并发安全的。但是不一定哪个g拿到哪个元素值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537442940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22783,"user_name":"皮卡丘","can_delete":false,"product_type":"c1","uid":1135596,"ip_address":"","ucode":"0F814B6BF331D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/ec/3f6ae1aa.jpg","comment_is_top":false,"comment_ctime":1535972317,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10125906909","product_id":100013101,"comment_content":"长度代表缓冲的个数，当缓冲满时和容量相等<br>浅拷贝，可以改变发送方引用的值","like_count":2},{"had_liked":false,"id":293056,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1621176660,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"5916143956","product_id":100013101,"comment_content":"Don&#39;t communicate by sharing memory; share memory by communicating<br><br>通道类型是 Go 语言自带的唯一并发安全的类型，一个通道相当于一个先进先出队列。<br><br>元素值从外界进入通道时会被复制，进入通道的是它的副本（复制元素值、放置副本到通道内部）；元素值从通道进入外界时会被移动（生成副本、放置副本到接收方、删除通道中的元素值）<br><br>非缓冲通道用同步的方式传递数据，缓冲通道使用异步的方式传递数据<br><br>对于思考题：<br><br>1. 通道的长度代表缓冲区大小，在缓冲区满的时候，与通道容量相同<br>2. 元素值的复制应该是浅表复制<br><br>看了一下留言，老师在这里挖了个坑，“Go 语言里面没有深层复制”","like_count":1},{"had_liked":false,"id":254047,"user_name":"小罗希冀","can_delete":false,"product_type":"c1","uid":1311995,"ip_address":"","ucode":"88416458FF0041","user_header":"https://static001.geekbang.org/account/avatar/00/14/04/fb/40f298bb.jpg","comment_is_top":false,"comment_ctime":1603028973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5897996269","product_id":100013101,"comment_content":"1. 通道的长度表示缓存区的大小<br>2. 通道的拷贝就是值拷贝, 如果传进去的是指针值, 那么就是指针值的副本, 如果传进去的是值, 那么就是值的副本<br>","like_count":1},{"had_liked":false,"id":234704,"user_name":"x","can_delete":false,"product_type":"c1","uid":1234454,"ip_address":"","ucode":"AB74494440A008","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/16/43b4814c.jpg","comment_is_top":false,"comment_ctime":1594776250,"is_pvip":false,"replies":[{"id":"86643","content":"我说的是内部机制。非缓冲通道会持有已经到来的发送方和接收方的指针。一旦双方都存在，通道就直接把数据从发送方复制到接收方，通道内部没有中转的步骤。“发送”和“接收”的操作当然会是正常的啦。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1594790691,"ip_address":"","comment_id":234704,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5889743546","product_id":100013101,"comment_content":"老师，文章中您说   &quot;并且，数据是直接从发送方复制到接收方的，中间并不会用非缓冲通道做中转。&quot;，这样的话如果我们用select来监听该通道的状态，岂不是监听不到。 因为不走非缓冲通道？ ","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501478,"discussion_content":"我说的是内部机制。非缓冲通道会持有已经到来的发送方和接收方的指针。一旦双方都存在，通道就直接把数据从发送方复制到接收方，通道内部没有中转的步骤。“发送”和“接收”的操作当然会是正常的啦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594790691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30507,"user_name":"凯","can_delete":false,"product_type":"c1","uid":1202828,"ip_address":"","ucode":"4CA509DA58B3A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/5a/8c/cee414db.jpg","comment_is_top":false,"comment_ctime":1538897606,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833864902","product_id":100013101,"comment_content":"请问一下go语言可以实现并行运算么？我接触到现在看到的好像都是并发而非并行。","like_count":1},{"had_liked":false,"id":23816,"user_name":"新垣结裤","can_delete":false,"product_type":"c1","uid":1198555,"ip_address":"","ucode":"BFE7CB24C4EDC0","user_header":"https://static001.geekbang.org/account/avatar/00/12/49/db/ee5e8b43.jpg","comment_is_top":false,"comment_ctime":1536671069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5831638365","product_id":100013101,"comment_content":"播音员的声音好磁性啊","like_count":1},{"had_liked":false,"id":22837,"user_name":"sophyu","can_delete":false,"product_type":"c1","uid":1209951,"ip_address":"","ucode":"428CE4ABC30379","user_header":"https://static001.geekbang.org/account/avatar/00/12/76/5f/cceadf96.jpg","comment_is_top":false,"comment_ctime":1535993809,"is_pvip":true,"replies":[{"id":"8284","content":"写代码吧，这么说说不清楚。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1536061600,"ip_address":"","comment_id":22837,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5830961105","product_id":100013101,"comment_content":"请教老师：对于非缓冲通道c ，首先main goroutine创建一个task goroutine，再执行通道发送操作c &lt;- value …；main goroutine被阻塞；task goroutine执行，其中进行通道接收操作，value从main goroutine传输到task goroutine…此时是task goroutine继续往下执行呢？还是main goroutine执行？","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423290,"discussion_content":"写代码吧，这么说说不清楚。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536061600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22819,"user_name":"colben","can_delete":false,"product_type":"c1","uid":1200769,"ip_address":"","ucode":"5E5DBA48578E96","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/81/745475e9.jpg","comment_is_top":false,"comment_ctime":1535985304,"is_pvip":false,"replies":[{"id":"8286","content":"不可以，这是基本的Go语言语法。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1536061713,"ip_address":"","comment_id":22819,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5830952600","product_id":100013101,"comment_content":"channel 是否可以通过 .Read() 和 .Write() 来读写？那个 “&lt;-“ 敲起来真心费劲，以前学 C 时就受不了那个结构体指针.成员变量写法“-&gt;”","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423280,"discussion_content":"不可以，这是基本的Go语言语法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536061713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22786,"user_name":"冰激凌的眼泪","can_delete":false,"product_type":"c1","uid":1087945,"ip_address":"","ucode":"5DCB974667E93A","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg","comment_is_top":false,"comment_ctime":1535973644,"is_pvip":false,"replies":[{"id":"8287","content":"Go语言里没有深拷贝。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1536061763,"ip_address":"","comment_id":22786,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5830940940","product_id":100013101,"comment_content":"还没解释过深拷贝和浅拷贝的含义<br>只好按照java里的理解了<br>根据文章里说的，估计和使用&quot;=&quot;的效果是一样的","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423263,"discussion_content":"Go语言里没有深拷贝。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536061763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353344,"user_name":"泰一","can_delete":false,"product_type":"c1","uid":1757959,"ip_address":"北京","ucode":"D85C764BA108CE","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d3/07/5fc3c694.jpg","comment_is_top":false,"comment_ctime":1659369904,"is_pvip":false,"replies":[{"id":"128578","content":"因为向“已经关闭的通道”发送值会引发 panic 啊。而从“已经关闭的通道”接收值最多会阻塞当前的 goroutine，而且在接收的时候我们还可以通过 value, ok := &lt;- chan1 这种方式避免阻塞，另外用 for 语句试图接收“已经关闭的通道”中的值也只是会让 for 语句安静地结束执行。<br><br>当然了，你要是能保证在关闭某个通道之后绝不会再向它发送值，那么也是可以在接收端关闭通道的。但问题是，我们很难保证这一点，尤其是在程序不断被修改、逻辑越发复杂的情况下。更关键的是，这种无意制造的 bug 会比较隐晦，在测试的时候不容易发现，会把这种 bug 带到线上。到那时候就麻烦了，会造成线上事故。所以为了保险起见，还是不要在接收端关闭通道。<br><br>最后，顺便提一下，使用 context.Context 之类的信号机制或许可以规避掉这类风险。比如，接收端在收到“某个专用的 Context”发来的信号之后再“安全地”关闭通道（这属于一种程序开发者自己设计的约定）。不过这种设计会增加程序的复杂度，需要仔细考量是不是利大于弊。<br>","user_name":"作者回复","user_name_real":"作者","uid":"1026643","ctime":1659621359,"ip_address":"北京","comment_id":353344,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1659369904","product_id":100013101,"comment_content":"“由于通道的收发操作有上述特性，所以除非有特殊的保障措施，我们千万不要让接收方关闭通道，而应当让发送方做这件事。”<br><br>老师能详细说下，究竟为什么不能让接收方关闭通道吗？接收方关闭了通道能有啥后果？还有就是您说的通道的收发的具体哪个特性使得我们必须不能再接收方关闭通道呢？辛苦老师答疑解惑。","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582740,"discussion_content":"因为向“已经关闭的通道”发送值会引发 panic 啊。而从“已经关闭的通道”接收值最多会阻塞当前的 goroutine，而且在接收的时候我们还可以通过 value, ok := <- chan1 这种方式避免阻塞，另外用 for 语句试图接收“已经关闭的通道”中的值也只是会让 for 语句安静地结束执行。\n\n当然了，你要是能保证在关闭某个通道之后绝不会再向它发送值，那么也是可以在接收端关闭通道的。但问题是，我们很难保证这一点，尤其是在程序不断被修改、逻辑越发复杂的情况下。更关键的是，这种无意制造的 bug 会比较隐晦，在测试的时候不容易发现，会把这种 bug 带到线上。到那时候就麻烦了，会造成线上事故。所以为了保险起见，还是不要在接收端关闭通道。\n\n最后，顺便提一下，使用 context.Context 之类的信号机制或许可以规避掉这类风险。比如，接收端在收到“某个专用的 Context”发来的信号之后再“安全地”关闭通道（这属于一种程序开发者自己设计的约定）。不过这种设计会增加程序的复杂度，需要仔细考量是不是利大于弊。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659621359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347451,"user_name":"EvanSung","can_delete":false,"product_type":"c1","uid":1542472,"ip_address":"","ucode":"0945F016568422","user_header":"https://static001.geekbang.org/account/avatar/00/17/89/48/7c849f0d.jpg","comment_is_top":false,"comment_ctime":1654051811,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654051811","product_id":100013101,"comment_content":"这节写的真好，赞赞赞！！！","like_count":0},{"had_liked":false,"id":332781,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1643602857,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1643602857","product_id":100013101,"comment_content":"长度代表当前存储的元素个数。拷贝传输的都是浅拷贝","like_count":0},{"had_liked":false,"id":322890,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1637647342,"is_pvip":false,"replies":[{"id":"117258","content":"你应该把那个嵌套结构也贴上来。<br><br>不过我已经发现了一个问题：不论是不是深拷贝，你肯定都可以从通道的另一端拿到完整的值啊。<br><br>第二个问题：什么叫“嵌入”，这个词已经很形象了吧？嵌入的结构会与被嵌入的结构形成一个整体。只复制这个整体就是浅复制。<br><br>第三个问题：你这个实验本身是有问题的。如果想看两端是不是同一个值，需要修改一下看看，如果修改一个后另一个也同样变化，就是同一个值，否则就是原值和副本的关系。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1637725002,"ip_address":"","comment_id":322890,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1637647342","product_id":100013101,"comment_content":"shallow copy只会拷贝对象的直接值，deep copy会层层拷贝，我理解无论数据类型是指针类型还是值类型，chan的发送和接收都只做浅拷贝，但我做了个实验，<br>3个结构体嵌套的对象作为通道的元素，当接收端收到这个元素时，是可以拿到内部嵌套的结构体的内容的，这个不算是深拷贝吗？<br>\tba := base{&quot;a&quot;, &quot;b&quot;, 1}<br>\tco := concrete{ba, &quot;c&quot;, &quot;d&quot;}<br>\tcon := concrete2{co, 2}<br>\tch := make(chan concrete2, 3)<br>\tch &lt;- con<br>\tres, _ := &lt;-ch<br>\tfmt.Printf(&quot;get element from chan: %v\\n&quot;, res)<br><br>\tconSlice := []concrete2{con}<br>\tch2 := make(chan []concrete2, 3)<br>\tch2 &lt;- conSlice<br>\tres2, _ := &lt;-ch2<br>\tfmt.Printf(&quot;get element from chan: %v, the content inside the element is %v\\n&quot;, res2, res2[0])<br><br>\tch3 := make(chan *concrete2, 3)<br>\tch3 &lt;- &amp;con<br>\tres3, _ := &lt;-ch3<br>\tfmt.Printf(&quot;get element from chan: %v\\n&quot;, *&amp;res3)<br>打印：<br>get element from chan: {{{a b 1} c d} 2}<br>get element from chan: [{{{a b 1} c d} 2}], the content inside the element is {{{a b 1} c d} 2}<br>get element from chan: &amp;{{{a b 1} c d} 2}","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532886,"discussion_content":"你应该把那个嵌套结构也贴上来。\n\n不过我已经发现了一个问题：不论是不是深拷贝，你肯定都可以从通道的另一端拿到完整的值啊。\n\n第二个问题：什么叫“嵌入”，这个词已经很形象了吧？嵌入的结构会与被嵌入的结构形成一个整体。只复制这个整体就是浅复制。\n\n第三个问题：你这个实验本身是有问题的。如果想看两端是不是同一个值，需要修改一下看看，如果修改一个后另一个也同样变化，就是同一个值，否则就是原值和副本的关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637725002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101006,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","nickname":"jxs1211","note":"","ucode":"B7F1F2D84389E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533092,"discussion_content":"其实我想弄清楚的是通道复制元素的时候，如果内部有嵌套的结构，是不是会逐层拷贝的？这种拷贝是不是算深拷贝？因为我的理解通道操作操作的拷贝，如果是浅拷贝只会复制第1层，深拷贝才会逐层复制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637768519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322889,"user_name":"工程师kiki c++","can_delete":false,"product_type":"c1","uid":2837359,"ip_address":"","ucode":"EF7D9899BDFDC6","user_header":"https://static001.geekbang.org/account/avatar/00/2b/4b/6f/28cd35f7.jpg","comment_is_top":false,"comment_ctime":1637646880,"is_pvip":false,"replies":[{"id":"117212","content":"对的","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1637648780,"ip_address":"","comment_id":322889,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1637646880","product_id":100013101,"comment_content":"回答深拷贝和浅拷贝可能需要理解啥事深拷贝，浅拷贝。<br>如果拷贝的对象里的元素包含引用（像一个列表里储存着另一个列表，存的就是另一个列表的引用），那浅拷贝和深拷贝是不同的，浅拷贝虽然将原有对象复制一份，但是依然保存的是引用，所以对新对象里的引用里的值进行修改，依然会改变原对象里的列表的值，新对象和原对象完全分离开并没有完全分离开。而深拷贝则不同，它会将原对象里的引用也新创建一个，即新建一个列表，然后放的是新列表的引用，这样就可以将新对象和原对象完全分离开。<br>","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532579,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637648780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2892697,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/23/99/913a1fd8.jpg","nickname":"Geek_144ae0","note":"","ucode":"F8722D68F67BD8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558093,"discussion_content":"这也验证了通道里面放切片，然后接收后，进行修改值，也会影响原有的切片","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648090549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310196,"user_name":"Seven","can_delete":false,"product_type":"c1","uid":2403766,"ip_address":"","ucode":"37D99CF8535CDE","user_header":"https://static001.geekbang.org/account/avatar/00/24/ad/b6/a8caa2c7.jpg","comment_is_top":false,"comment_ctime":1630545661,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1630545661","product_id":100013101,"comment_content":"通道长度：通道现有元素个数，通道满了。通道的长度和其容量相当。<br>应该是值拷贝，浅层拷贝","like_count":0},{"had_liked":false,"id":308491,"user_name":"Casper","can_delete":false,"product_type":"c1","uid":1022129,"ip_address":"","ucode":"69282EB175B48E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/b1/f89a84d0.jpg","comment_is_top":false,"comment_ctime":1629643619,"is_pvip":true,"discussion_count":1,"race_medal":5,"score":"1629643619","product_id":100013101,"comment_content":"浅表复制的示例代码:<br>package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;time&quot;<br>)<br><br>type Names struct {<br>\tname []string<br>}<br><br>func main() {<br>\tm := make(chan Names, 1)<br><br>\tgo func() {<br>\t\tname := Names{[]string{&quot;1&quot;, &quot;2&quot;}}<br>\t\tm &lt;- name<br><br>        &#47;&#47; 进入放入通道后, 再修改其值<br>\t\tname.name[1] = &quot;22&quot;<br>\t}()<br><br>    &#47;&#47; 主routine休息2s, 让子 routine 有足够的时间修改值<br>\ttime.Sleep(time.Second * 2)<br>\te := &lt;-m<br>    &#47;&#47; 最后发现其值是修改后的值, 因此可以证明是浅拷贝<br>\tfmt.Println(e.name)<br>}<br><br>","like_count":0,"discussions":[{"author":{"id":1603571,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKgNge1sNXIWCFeUOa53cU5Glfw24sjxibBxTiaTb45LmU9bRDlDgBib9goFZXmoKwXTOJ4JMvVHHbiaA/132","nickname":"潘林林","note":"","ucode":"31576141FE4A1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404281,"discussion_content":"你这个例子很容易给人照成误解\n结构体是值类型的 一般channel里面结构体的变更不会影响原有结构体\n但是你这个结构体里面的name是个切片 切片是引用类型的 导致了channel里面的切片变更影响到原有的切片","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634278977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305907,"user_name":"Geek_8cf0a3","can_delete":false,"product_type":"c1","uid":2109366,"ip_address":"","ucode":"D1ACDE82193AA2","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLn1rhQ7nlmQgyEZhgfgH0s9BicusXhTG7J6Tcxib2oDVoKVTbia9CcNIkicj2L2a2xqQRicF4FhPepjqA/132","comment_is_top":false,"comment_ctime":1628226720,"is_pvip":false,"replies":[{"id":"110751","content":"哪有加锁那么简单...","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1628320237,"ip_address":"","comment_id":305907,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1628226720","product_id":100013101,"comment_content":"所谓三个特性不就是加了一个锁？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524558,"discussion_content":"哪有加锁那么简单...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628320237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252847,"user_name":"余向华","can_delete":false,"product_type":"c1","uid":1119778,"ip_address":"","ucode":"263773616D2C83","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/22/2205cf0a.jpg","comment_is_top":false,"comment_ctime":1602501143,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602501143","product_id":100013101,"comment_content":"1、通道的长度代表通道存储的数据，只有通道的数据已经满了之后，才会相同。<br>2、浅层copy，只是复制了值过去。","like_count":0},{"had_liked":false,"id":240492,"user_name":"郭小菜","can_delete":false,"product_type":"c1","uid":1017297,"ip_address":"","ucode":"C4044C80BB331B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKYfcUOVhf3vhEBUNGHgtIcw8ujMZnkabicLzzjn3xwdeeic2PJSe7ibJgMx2UjF0d7L4B4gsRpaqe2A/132","comment_is_top":false,"comment_ctime":1596945834,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1596945834","product_id":100013101,"comment_content":"感觉少用一点后者这样的措辞比较好。有些地方本来加了修饰词，后者就显得阅读起来不舒服","like_count":0},{"had_liked":false,"id":208468,"user_name":"😳","can_delete":false,"product_type":"c1","uid":1452857,"ip_address":"","ucode":"9AFB87EF308539","user_header":"https://static001.geekbang.org/account/avatar/00/16/2b/39/19041d78.jpg","comment_is_top":false,"comment_ctime":1587365345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587365345","product_id":100013101,"comment_content":"通道的长度指当前包含的元素个数，通道满了的时候和容量是相同的<br>","like_count":0},{"had_liked":false,"id":201296,"user_name":"芒果少侠","can_delete":false,"product_type":"c1","uid":1350159,"ip_address":"","ucode":"98D0BBB52BB80F","user_header":"https://static001.geekbang.org/account/avatar/00/14/9a/0f/da7ed75a.jpg","comment_is_top":false,"comment_ctime":1585747139,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585747139","product_id":100013101,"comment_content":"package main<br><br>import &quot;fmt&quot;<br><br>func main() {<br><br>\tch := make(chan []int, 3)<br><br>\tarr := []int{1, 3 , 4}<br>\tch &lt;- arr<br><br>\t&#47;&#47; len代表缓冲通道内元素的个数，cap代表其缓冲大小值<br>\tfmt.Println(len(ch), cap(ch))<br><br>\trecvCh := &lt;-ch<br>\trecvCh[0] = 2<br><br>\t&#47;&#47; 证明了channel的复制是浅拷贝<br>\tfmt.Println(arr, recvCh)<br><br>}<br>","like_count":0},{"had_liked":false,"id":200820,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1217554,"ip_address":"","ucode":"C5A540BC5A60B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","comment_is_top":false,"comment_ctime":1585656525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585656525","product_id":100013101,"comment_content":"问题1：chan的长度就是chan目前所拥有的元素的数量，当一直塞入新元素导致发起方协程阻塞时，len(chan)==cap(ch)<br>问题2：chan的拷贝是浅拷贝，通过sli去测试，发现从chan拿出的副本sli的元素地址和初始的sli元素地址相同","like_count":0},{"had_liked":false,"id":194496,"user_name":"starj","can_delete":false,"product_type":"c1","uid":1108791,"ip_address":"","ucode":"3546E42F1340B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/37/a2f4c9f8.jpg","comment_is_top":false,"comment_ctime":1585063230,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585063230","product_id":100013101,"comment_content":"需要实践下再回来看","like_count":0},{"had_liked":false,"id":189597,"user_name":"Cyril","can_delete":false,"product_type":"c1","uid":1024693,"ip_address":"","ucode":"29FFFAC32F911B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a2/b5/4dc0c109.jpg","comment_is_top":false,"comment_ctime":1584532867,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584532867","product_id":100013101,"comment_content":"Go没有深copy","like_count":0},{"had_liked":false,"id":185080,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1583479626,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583479626","product_id":100013101,"comment_content":"通道的总结<br>通道主要是用来进行通信并且唯一一种保证并发安全的go语言类型<br>是一种引用类型 需要使用make函数来初始化， 在使用之前必须要使用make初始化<br>在初始化时 make需要两个函数<br>1. 类型 chan int 指明通道内的元素类型为int<br>2. 第二个参数为容量 是可选参数 int类型但不能小于0<br>   填0或者不填的时候 表明通道是不带缓冲的 这个时候需要 一个发送和一个接收操作交替执行,不然会阻塞<br>主要操作分为<br>1. 往通道里面发送数据<br>    发送操作的过程 复制一个元素副本 把副本放入到通道当中<br>    如果通道带缓冲 在通道未满之前 可以正常发送，但是如果通道已满 则会把当前协程放入到通道的发送等待对待列当中 等到前一个发送操作完成过后 再从发送等待队列当中取队首的协程唤醒并进行发送操作<br>    从上面的发送操作来看发送操作是原子操作 在拷贝和放置到通道过程中是不会被打断的，所以保证了数据的完整性<br>  如果不带缓存 则要么通道没有数据 要么就必须要一个发送一个接收交替进行 否则会阻塞<br>2. 从通道读数据<br>  这个就不用分缓存或者非缓存了 如果通道中有元素则读出元素 否则将会阻塞<br>  接收元素的流程 从通道中拷贝元素 然后把元素复制给外界变量 删除通道中的元素(为什么要删除元素，无论是缓存还是非缓存 必须要把通道腾出空间，以放置新元素,并且旧的元素已经没用了)<br>3. 会引起阻塞的非正常操作<br>  对一个值为nil的通道进行操作 将会永远阻塞 所以在使用之前必须初始化<br>4. 会引起panic的操作<br>  4.1 对一个已经关闭了的通道执行关闭操作<br>  4.2 对一个已经关闭了的通道执行发送操作 (所以关闭操作应该放置在发送端进行)<br>通过接受方法的 v1, succ := &lt;-chan 可以判断是否已经关闭了 <br>如果通道已经关闭了 并且通道内没有元素 则succ为false 如果通道关闭了 但是通道内还有元素 则succ为true<br>关于思考题<br>1. 我觉得通道的长度 应该和数组的长度差不多类似表示 通道中元素的个数 通道已满时 通道长度和通道容量相等<br>2. 肯定是深拷贝 如果元素当中有指针的话  进行浅拷贝会出问题的","like_count":0},{"had_liked":false,"id":165891,"user_name":"言午木杉","can_delete":false,"product_type":"c1","uid":1201009,"ip_address":"","ucode":"300BEDC1B07DF1","user_header":"https://static001.geekbang.org/account/avatar/00/12/53/71/a4e9f20e.jpg","comment_is_top":false,"comment_ctime":1577341437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577341437","product_id":100013101,"comment_content":"&#47;&#47; 示例2。<br>\tch2 := make(chan int, 1)<br>\t&#47;&#47;elem, ok := &lt;-ch2 &#47;&#47; 通道已空，因此这里会造成阻塞。可以发到另外的 goruntine 内，当有的时候会调度<br>\t&#47;&#47; _, _ = elem, ok<br>\t&#47;&#47; 要用 sync.WaitGroup 同步的方式来等其他的 goroutine 调度成后才能退出，要用以下写法<br>\tvar wg sync.WaitGroup<br>\twg.Add(1)<br>\tgo func(wg *sync.WaitGroup) {<br>\t\tfor  {<br>\t\t\telem, ok := &lt;-ch2<br>\t\t\tfmt.Println(elem, ok)<br>\t\t\twg.Done()<br>\t\t}<br>\t}(&amp;wg)<br><br>\tch2 &lt;- 2<br>\twg.Wait()","like_count":0},{"had_liked":false,"id":164262,"user_name":"lixiaofeng","can_delete":false,"product_type":"c1","uid":1100200,"ip_address":"","ucode":"0D6710D95B6FFB","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/a8/98507423.jpg","comment_is_top":false,"comment_ctime":1576918946,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576918946","product_id":100013101,"comment_content":"通道---不要通过共享内存来通信，而要通过通信来共享内存。<br>通道是go语言自带的，唯一一个可以满足并发安全性的类型。<br>通道的声明：make(chan int , 3), 通道类型的元素类型是int， 通道的容量是3（容量就是通道可以缓存多少个元素值）。<br>通道底层存储的是环形链表。<br>一个通道相当于一个FIFO（先进先出）队列。<br>对于同一个通道，发送之间操作是互斥的，接收也是互斥的。<br>发送操作和接收操作中，对元素的处理都是不可分割的。<br>发送操在完全完成之前会被阻塞，接收操作也是如此。也就是说，需要完后发送或者接受操作之后，代码才会继续执行。<br>发送操作：元素值从外界进入通道时，会被复制。进入通道的是等号右边右边的值，而是他的副本。<br>接收操作：1，生成通道中元素值得副本，传送给接收方； 2删除通道中的这个元素。<br>对于缓冲通道，若通道已满，发送操作会被阻塞，进而阻塞程序， 直到通道中有元素被接收走。<br>对于非缓冲通道，最开始执行的操作都会被阻塞，直到配对的操作开始执行。","like_count":0},{"had_liked":false,"id":163736,"user_name":"Nicky","can_delete":false,"product_type":"c1","uid":1584150,"ip_address":"","ucode":"A76D3D46D8CDD1","user_header":"https://static001.geekbang.org/account/avatar/00/18/2c/16/091e9756.jpg","comment_is_top":false,"comment_ctime":1576780789,"is_pvip":false,"replies":[{"id":"62319","content":"通道的主要用途是在不同的goroutine之间进行通信，但是像你这样在同一个goroutine里面自发自收也是没问题的啊。你要分清用途和功能。你用通道实现功能是你自己说了算的。<br><br>你这个问题的关键在于，【标注3】完成之后通道就满了，你直接再执行【标注5】是不行的，因为通道满了塞不进去新值了。【标注4】的执行正好从通道里拿走一个值，因而又有了新的空位，所以再执行【标注5】就没有问题了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1576822624,"ip_address":"","comment_id":163736,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576780789","product_id":100013101,"comment_content":"老师，你好！关于channel的基本用法，我有一个疑问，希望你能帮我解答。<br>下面是我的代码（我的go版本是1.13.4）<br><br>package main<br><br>func main() {<br>\tch := make(chan string, 3) &#47;&#47; 创建缓冲区为3 的  通道<br>\tch &lt;- &quot;a&quot;  &#47;&#47; 标注1  main goroutine  向 通道ch 发送 &quot;a&quot;<br>\tch &lt;- &quot;b&quot;  &#47;&#47; 标注2  main goroutine  向 通道ch 发送 &quot;b&quot;<br>\tch &lt;- &quot;c&quot;  &#47;&#47; 标注3  main goroutine  向 通道ch 发送 &quot;c&quot;<br>\t&lt;- ch\t   &#47;&#47; 标注4 请问，接收 通道ch 数据 的是哪个goroutine<br>\tch &lt;- &quot;d&quot;  &#47;&#47; 标注5  main goroutine  向 通道ch 发送 &quot;d&quot;<br>}<br>假如main函数中注释&#47;删除掉[标注4]行的代码，会报“ deadlock!”错误。这个我理解，因为超过了缓冲区大小。<br>但是，在标注3和标注5之间加入标注4的代码，就不会报错。<br>我的疑问是：<br>channel不是在不同的goroutine之间进行通信吗？<br>main goroutine 向 通道ch 发送 “a”、“b”、“c”、“d”<br>请问，接收（&lt;- ch）的goroutine是哪个？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478519,"discussion_content":"通道的主要用途是在不同的goroutine之间进行通信，但是像你这样在同一个goroutine里面自发自收也是没问题的啊。你要分清用途和功能。你用通道实现功能是你自己说了算的。\n\n你这个问题的关键在于，【标注3】完成之后通道就满了，你直接再执行【标注5】是不行的，因为通道满了塞不进去新值了。【标注4】的执行正好从通道里拿走一个值，因而又有了新的空位，所以再执行【标注5】就没有问题了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576822624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140078,"user_name":"蜉蝣","can_delete":false,"product_type":"c1","uid":1229070,"ip_address":"","ucode":"77CF92496855D4","user_header":"https://static001.geekbang.org/account/avatar/00/12/c1/0e/2b987d54.jpg","comment_is_top":false,"comment_ctime":1570802818,"is_pvip":false,"replies":[{"id":"54207","content":"这篇文章里说的完全复制强调的是“一气呵成”，指的是值已经被完整地复制了。这与深拷贝不是一回事。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1570850599,"ip_address":"","comment_id":140078,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570802818","product_id":100013101,"comment_content":"请问老师   完全复制和深拷贝的区别在哪里","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470235,"discussion_content":"这篇文章里说的完全复制强调的是“一气呵成”，指的是值已经被完整地复制了。这与深拷贝不是一回事。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570850599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122681,"user_name":"magina","can_delete":false,"product_type":"c1","uid":1138499,"ip_address":"","ucode":"9546701896A09F","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/43/3799a0f3.jpg","comment_is_top":false,"comment_ctime":1565487656,"is_pvip":false,"replies":[{"id":"45148","content":"一般情况问题不大，也就是占用资源。不过不是 daemon 性质的最后择机关闭。如果只在某几个 goroutine 里面用，等这几个go 函数都执行完了，里面的所有资源也就都被回收了，所以通常问题不大。全局的大量不关可能会有一些问题。不过这也要具体情况具体分析。最好养成用完就关的好习惯。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1565576676,"ip_address":"","comment_id":122681,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565487656","product_id":100013101,"comment_content":"channel一直不关有问题吗","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462358,"discussion_content":"一般情况问题不大，也就是占用资源。不过不是 daemon 性质的最后择机关闭。如果只在某几个 goroutine 里面用，等这几个go 函数都执行完了，里面的所有资源也就都被回收了，所以通常问题不大。全局的大量不关可能会有一些问题。不过这也要具体情况具体分析。最好养成用完就关的好习惯。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565576676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118291,"user_name":"Calios","can_delete":false,"product_type":"c1","uid":1004758,"ip_address":"","ucode":"B1AA60164DC42A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/d6/124e2e93.jpg","comment_is_top":false,"comment_ctime":1564310905,"is_pvip":false,"replies":[{"id":"43384","content":"👍","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1564364930,"ip_address":"","comment_id":118291,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564310905","product_id":100013101,"comment_content":"写了一小段时间的golang项目后，回来看专栏查缺补漏。🤣","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460346,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107860,"user_name":"Geek_a8be59","can_delete":false,"product_type":"c1","uid":1563985,"ip_address":"","ucode":"BEC0F57B51DC44","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdiaUiaCYQe9tibemaNU5ya7RrU3MYcSGEIG7zF27u0ZDnZs5lYxPb7KPrAsj3bibM79QIOnPXAatfIw/132","comment_is_top":false,"comment_ctime":1561625056,"is_pvip":false,"replies":[{"id":"39050","content":"好像需要重新向我提问题。<br><br>有几个疑问：<br><br>1. 你的 Wait 方法里的那个 for 语句是干嘛的？<br>2. total :=&lt;-s.nowtotal 中的 total 不是一个会改变的数啊，那你后边的 total == s.now-1 判断就存在问题。<br><br>感觉你需要再明确一下你那个字段的用途。<br><br>给你一个提示吧：<br><br>&#47;&#47; 栅栏的实现类<br>type barrier struct {<br>\tmax    int &#47;&#47; 最大等待者数量。<br>\twaitCh chan struct{} &#47;&#47; 等待者计数通道。<br>\tsignCh chan struct{} &#47;&#47; 放行信号通道。<br>}<br><br>你写 go barrier.NowTotal() 的思路是对的。但是没把通道用好。两个通道，一个用于在 Wait 方法中发元素值，一个用于在 Wait 放中收元素值。在 NowTotal 方法中正好相反。合在一起之后，Wait 方法一发一收就能实现功能。 ","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1561638972,"ip_address":"","comment_id":107860,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561625056","product_id":100013101,"comment_content":"老实您好，极客时间这边对您的解答做了回复你那边收的到通知么 还是需要我重新提交留言你们那边才能看的到呢？<br>针对chan的我网上看到一类似面试题，比较感兴趣也做了一下，自己水平有限 ，请教一下我的代码能满足上面的需求。<br>题目要求:<br><br>&#47;&#47; 抽象一个栅栏<br>type Barrier interface {<br>    Wait ()<br>}<br>&#47;&#47; 创建栅栏对象<br>func NewBarrier (n int) Barrier {<br>   <br>}<br>&#47;&#47; 栅栏的实现类<br>type barrier struct {<br> <br>}<br>&#47;&#47; 测试代码<br>func main () {<br>    &#47;&#47; 创建栅栏对象<br>    b := NewBarrier(10)<br>    &#47;&#47; 达到的效果：前9个协程调用Wait()阻塞，第10个调用后10个协程全部唤醒<br>    for i:=0; i&lt;10; i++ {<br>        go b.Wait()<br>    }<br>}<br>需要对上面的NewBarrier()函数和barrier这个类进行修改，达到预期的效果。而且还要有条件约束，就是不能用任何同步相关的操作，但可以用chan，前提是无缓冲模式的<br>--------------------------<br>我提供的答案（好像正确，但不知道有没有考虑不全的地方）：<br>type Barrier interface {<br>\tWait ()<br>}<br>&#47;&#47; 创建栅栏对象<br>func NewBarrier (n int) Barrier {<br>\tvar barrier = &amp;barrier{}<br>\tbarrier.now = n<br>\tbarrier.chanArr = make(chan int)<br>\tbarrier.nowtotal = make(chan int)<br>\tgo barrier.NowTotal()<br>\treturn barrier<br>}<br>func (s *barrier) NowTotal() {<br><br>\tfor i:=0;i&lt;s.now;i++ {<br>\t\ts.nowtotal&lt;-i<br>\t}<br>}<br>func (s *barrier) Wait()  {<br>\ttotal :=&lt;-s.nowtotal<br>\tif total == s.now-1 {<br>\t\tfor i:=0;i&lt;total;i++ {<br><br>\t\t\ts.chanArr&lt;-i<br>\t\t}<br>\t } else {<br>\t\tnum:=&lt;-s.chanArr<br>\t\tfmt.Printf(&quot;拿到了数据:%v\\n&quot;,num)<br>\t}<br>}<br>&#47;&#47; 栅栏的实现类<br>type barrier struct {<br>\tchanArr  chan int<br>\tnowtotal chan int<br>\tnow int<br>}<br>&#47;&#47; 测试代码<br>func main () {<br><br>\t&#47;&#47; 创建栅栏对象<br>\tb := NewBarrier(10)<br><br>\t&#47;&#47; 达到的效果：前9个协程调用Wait()阻塞，第10个调用后10个协程全部唤醒<br>\tfor i:=0; i&lt;10; i++ {<br>\t\tgo b.Wait()<br>\t}<br>\tselect {<br><br>\t}<br>}<br>","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455711,"discussion_content":"好像需要重新向我提问题。\n\n有几个疑问：\n\n1. 你的 Wait 方法里的那个 for 语句是干嘛的？\n2. total :=&amp;lt;-s.nowtotal 中的 total 不是一个会改变的数啊，那你后边的 total == s.now-1 判断就存在问题。\n\n感觉你需要再明确一下你那个字段的用途。\n\n给你一个提示吧：\n\n// 栅栏的实现类\ntype barrier struct {\n\tmax    int // 最大等待者数量。\n\twaitCh chan struct{} // 等待者计数通道。\n\tsignCh chan struct{} // 放行信号通道。\n}\n\n你写 go barrier.NowTotal() 的思路是对的。但是没把通道用好。两个通道，一个用于在 Wait 方法中发元素值，一个用于在 Wait 放中收元素值。在 NowTotal 方法中正好相反。合在一起之后，Wait 方法一发一收就能实现功能。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561638972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106330,"user_name":"同同","can_delete":false,"product_type":"c1","uid":1182020,"ip_address":"","ucode":"30A979C716E1CB","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/44/42102bbf.jpg","comment_is_top":false,"comment_ctime":1561272242,"is_pvip":false,"replies":[{"id":"38880","content":"首先你得理解，int、float32、string 以及 []int 这些类型都是值类型。对于值类型来说没有“深层”只有“浅层”。也就是说，这类值只有一层，只包含值本身（不像 map 和 slice 那样包含了指向底层数据结构的指针）。对这类值的拷贝就是浅拷贝，根本就不存在深拷贝的概念。<br>","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1561542592,"ip_address":"","comment_id":106330,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1561272242","product_id":100013101,"comment_content":"老师你好,我有几个关于深拷贝多的问题 ,我做了几个实验 基本数据类型 int float string 及数组 都是深拷贝<br>只有map[] slice 是浅拷贝 和你说的&quot;Go里没有深copy。&quot; 不符合请问这个为什么","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455047,"discussion_content":"首先你得理解，int、float32、string 以及 []int 这些类型都是值类型。对于值类型来说没有“深层”只有“浅层”。也就是说，这类值只有一层，只包含值本身（不像 map 和 slice 那样包含了指向底层数据结构的指针）。对这类值的拷贝就是浅拷贝，根本就不存在深拷贝的概念。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561542592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105161,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","nickname":"helloworld","note":"","ucode":"1EECCA0F43E278","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87042,"discussion_content":"struct也是值类型, 如果struct中的字段有引用类型的字段呢, 拷贝struct算不算深拷贝?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576639846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105161,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","nickname":"helloworld","note":"","ucode":"1EECCA0F43E278","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87038,"discussion_content":"[]int这个不是slice吗, slice不是引用类型吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576639601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103030,"user_name":"左氧佛沙星人","can_delete":false,"product_type":"c1","uid":1195278,"ip_address":"","ucode":"0D8295E1DABA8C","user_header":"https://static001.geekbang.org/account/avatar/00/12/3d/0e/92176eaa.jpg","comment_is_top":false,"comment_ctime":1560351019,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1560351019","product_id":100013101,"comment_content":"谢谢老师","like_count":0},{"had_liked":false,"id":95546,"user_name":"晒太阳","can_delete":false,"product_type":"c1","uid":1080706,"ip_address":"","ucode":"99CFF3D5A4FE72","user_header":"https://static001.geekbang.org/account/avatar/00/10/7d/82/5ed8a955.jpg","comment_is_top":false,"comment_ctime":1558079048,"is_pvip":false,"replies":[{"id":"34151","content":"一个通道值的容量就是它能够存储的元素值的最大数量。这里不存在任何歧义或偏差。通道是一种并发安全的数据类型，所以你可以并发地操作它的值。这些操作是有明确的规则的。我在文章中已经有所说明。<br><br>一个实验展现出来的表象有时候会与本质不一致。这时候就会产生误导。所以在设计实验的时候一定要严谨和小心。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1558091373,"ip_address":"","comment_id":95546,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558079048","product_id":100013101,"comment_content":"实验结果看来，比如一个容量为2的通道中真正存储的数据为4条，我怎么理解这个通道中真正的可以存放数据的容量？<br>还有，一个通道压入4条数据，从实验结果看，是等待这4条数据都取完才开始压入新的数据，是不是通道必须把压入的数据都取完才再次压入数据。","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450507,"discussion_content":"一个通道值的容量就是它能够存储的元素值的最大数量。这里不存在任何歧义或偏差。通道是一种并发安全的数据类型，所以你可以并发地操作它的值。这些操作是有明确的规则的。我在文章中已经有所说明。\n\n一个实验展现出来的表象有时候会与本质不一致。这时候就会产生误导。所以在设计实验的时候一定要严谨和小心。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558091373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94085,"user_name":"窝窝头","can_delete":false,"product_type":"c1","uid":1063866,"ip_address":"","ucode":"5C2635ED6484F8","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/ba/3b30dcde.jpg","comment_is_top":false,"comment_ctime":1557716599,"is_pvip":true,"replies":[{"id":"33608","content":"通道的长度的含义是该通道在此刻有多个元素值，容量的含义是该通道最多可以容纳多少个元素值。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1557739959,"ip_address":"","comment_id":94085,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557716599","product_id":100013101,"comment_content":"长度跟容量的概念应该跟数组的是一样的<br>元素复制应该是浅复制，不然开销太大","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449907,"discussion_content":"通道的长度的含义是该通道在此刻有多个元素值，容量的含义是该通道最多可以容纳多少个元素值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557739959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51169,"user_name":"sket","can_delete":false,"product_type":"c1","uid":1197729,"ip_address":"","ucode":"C7E24300D794F7","user_header":"http://thirdwx.qlogo.cn/mmopen/KFgDEHIEpnSjjGClCeqmKYJsSOQo40BMHRTtNYrWyQP9WypAjTToplVND944one2pkEyH5Oib4m4wUOJ9xBEIZQ/132","comment_is_top":false,"comment_ctime":1545124434,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545124434","product_id":100013101,"comment_content":"go run .\\demo21.go<br>fatal error: all goroutines are asleep - deadlock!<br><br>goroutine 1 [chan send]:<br>main.main()<br>        D:&#47;go&#47;src&#47;puzzlers&#47;article10&#47;q2&#47;demo21.go:7 +0x7a<br>exit status 2","like_count":0},{"had_liked":false,"id":49709,"user_name":"melody_future","can_delete":false,"product_type":"c1","uid":1072632,"ip_address":"","ucode":"AEF6218FDA0B0A","user_header":"https://static001.geekbang.org/account/avatar/00/10/5d/f8/62a8b90d.jpg","comment_is_top":false,"comment_ctime":1544755770,"is_pvip":false,"replies":[{"id":"19223","content":"浅表复制，只复制元素值，元素值里面再指向的东西就不会复制了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1545576586,"ip_address":"","comment_id":49709,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1544755770","product_id":100013101,"comment_content":"“再说一遍，Go语言里没有深层复制。数组是值类型，所以会被完全复制。”<br>请教一下，切片对copy属于什么复制","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432736,"discussion_content":"浅表复制，只复制元素值，元素值里面再指向的东西就不会复制了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545576586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49649,"user_name":"实验室清洁工","can_delete":false,"product_type":"c1","uid":1198345,"ip_address":"","ucode":"ECF771E7141DBA","user_header":"https://static001.geekbang.org/account/avatar/00/12/49/09/58c0a054.jpg","comment_is_top":false,"comment_ctime":1544749739,"is_pvip":false,"replies":[{"id":"19224","content":"通常，值进入通道时会被复制一次，然后出通道的时候依照通道内的那个值再被复制一次并给到接收方。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1545576770,"ip_address":"","comment_id":49649,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1544749739","product_id":100013101,"comment_content":"接收操作通常包含了“复制通道内的元素值”“放置副本到接收方”“删掉原值”三个步骤。这里原值是指通道里的值吗？还是进入通道之前的值啊，或者两者都是？？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432702,"discussion_content":"通常，值进入通道时会被复制一次，然后出通道的时候依照通道内的那个值再被复制一次并给到接收方。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545576770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43678,"user_name":"Mr.Ching🦔","can_delete":false,"product_type":"c1","uid":1302773,"ip_address":"","ucode":"5CA7DB8D1D9AD6","user_header":"https://static001.geekbang.org/account/avatar/00/13/e0/f5/16e2fa44.jpg","comment_is_top":false,"comment_ctime":1543280090,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543280090","product_id":100013101,"comment_content":"老师，大量并发情况下，通道很容易阻塞(配置了100个go 程，每个go 程里创建的通道容量为500。) 这个有好的解决方案或者思路吗？希望看到了能给指点下","like_count":0},{"had_liked":false,"id":41984,"user_name":"luffy","can_delete":false,"product_type":"c1","uid":1244950,"ip_address":"","ucode":"702034E116A99F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/16/b0ab9a73.jpg","comment_is_top":false,"comment_ctime":1542886290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542886290","product_id":100013101,"comment_content":"元素值从外界进入通道时被复制，元素值从通道进入外界时生成正在通道中的这个元素的副本，这是做了两次复制吗？？","like_count":0},{"had_liked":false,"id":35740,"user_name":"kc","can_delete":false,"product_type":"c1","uid":1133248,"ip_address":"","ucode":"3D4C215D5AC733","user_header":"https://static001.geekbang.org/account/avatar/00/11/4a/c0/5eed10dc.jpg","comment_is_top":false,"comment_ctime":1540780146,"is_pvip":false,"replies":[{"id":"13305","content":"这样看当时chan的状态了啊。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1541481484,"ip_address":"","comment_id":35740,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540780146","product_id":100013101,"comment_content":"不同goroutine之间对同一channel进行操作时，是否会产生阻塞呢？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427654,"discussion_content":"这样看当时chan的状态了啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541481484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31061,"user_name":"象牙塔下的渣渣","can_delete":false,"product_type":"c1","uid":1248575,"ip_address":"","ucode":"B87FC8A56D29CB","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/3f/d2accda7.jpg","comment_is_top":false,"comment_ctime":1539078175,"is_pvip":false,"replies":[{"id":"11830","content":"答案我最后再补，别急。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1539578783,"ip_address":"","comment_id":31061,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539078175","product_id":100013101,"comment_content":"有些问题建议在下节课上说一下或者在代码里说一下答案","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426206,"discussion_content":"答案我最后再补，别急。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539578783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23697,"user_name":"张震","can_delete":false,"product_type":"c1","uid":1198715,"ip_address":"","ucode":"9CC2C74AE2B4BC","user_header":"https://static001.geekbang.org/account/avatar/00/12/4a/7b/e97b26a4.jpg","comment_is_top":false,"comment_ctime":1536591429,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536591429","product_id":100013101,"comment_content":"func receiveForever(name string, c chan int) {    for {        v := &lt;-c        fmt.Printf(name+&quot; receive:%v\\n&quot;, v)    }}<br>func receive(name string, c chan int) {    for i := 0; i &lt; 10; i++ {        v := &lt;-c        fmt.Printf(name+&quot; receive:%v\\n&quot;, v)    }<br>}<br>为什么这两个方法的结果不一样？貌似第一个方法没有阻塞","like_count":0},{"had_liked":false,"id":22853,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1536019899,"is_pvip":false,"replies":[{"id":"8283","content":"当然不是，这两个词早就有了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1536061531,"ip_address":"","comment_id":22853,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1536019899","product_id":100013101,"comment_content":"老师我特别想知道，您所说的“浅复制”和“深复制”是你自己发明的词汇吗？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423295,"discussion_content":"当然不是，这两个词早就有了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536061531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22787,"user_name":"冰激凌的眼泪","can_delete":false,"product_type":"c1","uid":1087945,"ip_address":"","ucode":"5DCB974667E93A","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg","comment_is_top":false,"comment_ctime":1535973725,"is_pvip":false,"replies":[{"id":"8288","content":"这是Go语言规范中描述的基本规则。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1536061808,"ip_address":"","comment_id":22787,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1535973725","product_id":100013101,"comment_content":"既然nil导致阻塞，为什么不直接设计成抛出panic呢？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423264,"discussion_content":"这是Go语言规范中描述的基本规则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536061808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22730,"user_name":"江山如画","can_delete":false,"product_type":"c1","uid":1188280,"ip_address":"","ucode":"BEB6228E6135B5","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/b8/aca814dd.jpg","comment_is_top":false,"comment_ctime":1535942011,"is_pvip":false,"replies":[{"id":"8198","content":"第二个问题，你可以再传递一个Student的指针试试。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1535958044,"ip_address":"","comment_id":22730,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1535942011","product_id":100013101,"comment_content":"第一个问题：<br><br> 非缓冲通道 长度=容量<br>\tc1 := make(chan int)<br>\tfmt.Println(len(c1), cap(c1)) &#47;&#47;0 0<br><br>\t&#47;&#47;缓冲通道 len代表通道中已存入的元素数量，cap代表整个缓冲区的大小<br>\tc2 := make(chan int, 2)<br>\tfmt.Println(len(c2), cap(c2)) &#47;&#47;0 2<br>\tc2 &lt;- 1<br>\tfmt.Println(len(c2), cap(c2)) &#47;&#47;1 2<br><br>\t&#47;&#47;缓冲通道 当缓冲通道已满的时候，len = cap<br>\tc2 &lt;- 2<br>\tfmt.Println(len(c2), cap(c2)) &#47;&#47;2 2<br><br>第二个问题：<br>&#47;&#47;向缓冲通道中压入一个 Student对象 stu1，再从通道中取出赋值给 stu2<br>&#47;&#47;打印 stu1 和 stu2 的地址，发现不一样<br>&#47;&#47;说明从通道中取出的 Student对象 被重新分配了内存，所以是深层复制<br>ch := make(chan Student, 1)<br>stu1 := Student{&quot;Bob&quot;}<br>ch &lt;- stu1<br>stu2 := &lt;-ch<br>fmt.Printf(&quot;stu1:%p  stu2:%p\\n&quot;, &amp;stu1, &amp;stu2) &#47;&#47;stu1:0xc00000e1f0  stu2:0xc00000e200<br><br>type Student struct {<br>\tname string<br>}","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423241,"discussion_content":"第二个问题，你可以再传递一个Student的指针试试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535958044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22677,"user_name":"余泽锋","can_delete":false,"product_type":"c1","uid":1003207,"ip_address":"","ucode":"5AB1499746C003","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/c7/8c2d0a3d.jpg","comment_is_top":false,"comment_ctime":1535934161,"is_pvip":false,"replies":[{"id":"8200","content":"第二个问题跟通道类型是否为引用类型没关系。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1535958360,"ip_address":"","comment_id":22677,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1535934161","product_id":100013101,"comment_content":"1.阻塞的时候，长度和容量一样<br>2.通道类型是引用类型，所以复制应该是深复制","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423220,"discussion_content":"第二个问题跟通道类型是否为引用类型没关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535958360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}