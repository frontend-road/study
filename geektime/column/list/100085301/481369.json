{"id":481369,"title":"加餐｜宏编程（下）：用 syn/quote 优雅地构建宏","content":"<p>你好，我是陈天。</p><p>上堂课我们用最原始的方式构建了一个 RawBuilder 派生宏，本质就是从 TokenStream 中抽取需要的数据，然后生成包含目标代码的字符串，最后再把字符串转换成 TokenStream。</p><p>说到解析 TokenStream 是个苦力活，那么必然会有人做更好的工具。 <a href=\"https://github.com/dtolnay/syn\">syn</a>/<a href=\"https://github.com/dtolnay/quote\">quote</a> 这两个库就是Rust宏生态下处理 TokenStream 的解析以及代码生成很好用的库。</p><p>今天我们就尝试用这个 syn / quote工具，来构建一个同样的 Builder 派生宏，你可以对比一下两次的具体的实现，感受 syn / quote 构建过程宏的方便之处。</p><h2>syn crate 简介</h2><p>先看syn。<strong>syn 是一个对 TokenStream 解析的库，它提供了丰富的数据结构，对语法树中遇到的各种 Rust 语法都有支持</strong>。</p><p>比如一个 Struct 结构，在 TokenStream 中，看到的就是一系列 TokenTree，而通过 syn 解析后，struct 的各种属性以及它的各个字段，都有明确的类型。这样，我们可以很方便地通过模式匹配来选择合适的类型进行对应的处理。</p><p><strong>syn 还提供了对 derive macro 的特殊支持</strong>——<a href=\"https://docs.rs/syn/latest/syn/struct.DeriveInput.html\">DeriveInput</a> 类型：</p><pre><code class=\"language-rust\">pub struct DeriveInput {\n    pub attrs: Vec&lt;Attribute&gt;,\n    pub vis: Visibility,\n    pub ident: Ident,\n    pub generics: Generics,\n    pub data: Data,\n}\n</code></pre><!-- [[[read_end]]] --><p>通过 DeriveInput 类型，我们可以很方便地解析派生宏。比如这样：</p><pre><code class=\"language-rust\">#[proc_macro_derive(Builder)]\npub fn derive_builder(input: TokenStream) -&gt; TokenStream {\n    // Parse the input tokens into a syntax tree\n    let input = parse_macro_input!(input as DeriveInput);\n    ...\n}\n</code></pre><p>只需要使用 <code>parse_macro_input!(input as DeriveInput)</code>，我们就不必和 TokenStream 打交道，而是使用解析出来的 DeriveInput。上一讲我们从 TokenStream 里拿出来 struct 的名字，都费了一番功夫，这里直接访问 DeriveInput 的 ident 域就达到同样的目的，是不是非常人性化。</p><h3>Parse trait</h3><p>你也许会问：为啥这个 parse_macro_input 有如此魔力？我也可以使用它做类似的解析么？</p><p>要回答这个问题，我们直接看代码找答案（<a href=\"https://docs.rs/syn/latest/src/syn/parse_macro_input.rs.html#108-128\">来源</a>）：</p><pre><code class=\"language-rust\">macro_rules! parse_macro_input {\n    ($tokenstream:ident as $ty:ty) =&gt; {\n        match $crate::parse_macro_input::parse::&lt;$ty&gt;($tokenstream) {\n            $crate::__private::Ok(data) =&gt; data,\n            $crate::__private::Err(err) =&gt; {\n                return $crate::__private::TokenStream::from(err.to_compile_error());\n            }\n        }\n    };\n    ($tokenstream:ident with $parser:path) =&gt; {\n        match $crate::parse::Parser::parse($parser, $tokenstream) {\n            $crate::__private::Ok(data) =&gt; data,\n            $crate::__private::Err(err) =&gt; {\n                return $crate::__private::TokenStream::from(err.to_compile_error());\n            }\n        }\n    };\n    ($tokenstream:ident) =&gt; {\n        $crate::parse_macro_input!($tokenstream as _)\n    };\n}\n</code></pre><p>结合上一讲的内容，相信你不难理解，如果我们调用 <code>parse_macro_input!(input as DeriveInput)</code>，实际上它执行了 <code>$crate::parse_macro_input::parse::&lt;DeriveInput&gt;(input)</code>。</p><p>那么，这个 parse 函数究竟从何而来？继续看代码（<a href=\"https://docs.rs/syn/latest/src/syn/parse_macro_input.rs.html#138-152\">来源</a>）：</p><pre><code class=\"language-rust\">pub fn parse&lt;T: ParseMacroInput&gt;(token_stream: TokenStream) -&gt; Result&lt;T&gt; {\n    T::parse.parse(token_stream)\n}\n\npub trait ParseMacroInput: Sized {\n    fn parse(input: ParseStream) -&gt; Result&lt;Self&gt;;\n}\n\nimpl&lt;T: Parse&gt; ParseMacroInput for T {\n    fn parse(input: ParseStream) -&gt; Result&lt;Self&gt; {\n        &lt;T as Parse&gt;::parse(input)\n    }\n}\n</code></pre><p>从这段代码我们得知，任何实现了 ParseMacroInput trait 的类型 T，都支持 parse() 函数。进一步的，<strong>任何 T，只要实现了 Parse trait，就自动实现了 ParseMacroInput trait</strong>。</p><p>而这个 <a href=\"https://docs.rs/syn/latest/syn/parse/trait.Parse.html\">Parse trait</a>，就是一切魔法背后的源泉：</p><pre><code class=\"language-rust\">pub trait Parse: Sized {\n    fn parse(input: ParseStream&lt;'_&gt;) -&gt; Result&lt;Self&gt;;\n}\n</code></pre><p>syn 下面几乎所有的数据结构都实现了 Parse trait，包括 DeriveInput。所以，如果我们想自己构建一个数据结构，可以通过 <code>parse_macro_input!</code> 宏从 TokenStream 里读取内容，并写入这个数据结构，<strong>最好的方式是为我们的数据结构实现 Parse trait</strong>。</p><p>关于 Parse trait 的使用，今天就不深入下去了，如果你感兴趣，可以看看 DeriveInput 对 Parse 的实现（<a href=\"https://docs.rs/syn/latest/src/syn/derive.rs.html#96-162\">代码</a>）。你也可以进一步看我们前几讲使用过的 <a href=\"https://github.com/launchbadge/sqlx\">sqlx</a> 下的 query! 宏<a href=\"https://github.com/launchbadge/sqlx/blob/335eed45455daf5b65b9e36d44d7f4343ba421e6/sqlx-macros/src/query/input.rs#L36-L110\">内部对 Parse trait 的实现</a>。</p><h2>quote crate 简介</h2><p>在宏编程的世界里，<strong>quote 是一个特殊的原语，它把代码转换成可以操作的数据（代码即数据）</strong>。看到这里，你是不是想到了Lisp，是的，quote 这个概念来源于 Lisp，在 Lisp 里，<code>(+ 1 2)</code> 是代码，而 <code>‘(+ 1 2)</code> 是这个代码 quote 出来的数据。</p><p>我们上一讲在生成 TokenStream 的时候，使用的是最原始的把包含代码的字符串转换成 TokenStream 的方法。这种方法虽然可以通过使用模板很好地工作，但在构建代码的过程中，我们操作的数据结构已经失去了语义。</p><p>有没有办法让我们就像撰写正常的 Rust 代码一样，保留所有的语义，然后把它们转换成 TokenStream？</p><p>有的，<strong>可以使用 quote crate</strong>。它提供了一个 <code>quote!</code> 宏，会替换代码中所有的 <code>#(...)</code>，生成 TokenStream。比如要写一个 hello() 方法，可以这样：</p><pre><code class=\"language-rust\">quote! {\n    fn hello() {\n        println!(\"Hello world!\");\n    }\n}\n</code></pre><p>这比使用字符串模板生成代码的方式更直观，功能更强大，而且保留代码的所有语义。</p><p><code>quote!</code> 做替换的方式和 <code>macro_rules!</code> 非常类似，也支持重复匹配，一会在具体写代码的时候可以看到。</p><h2>用 syn/quote 重写 Builder 派生宏</h2><p>好，现在我们对 sync/quote 有了一个粗浅的认识，接下来就照例通过撰写代码更好地熟悉它们的功能。</p><p>怎么做，经过昨天的学习，相信你现在也比较熟悉了，大致就是<strong>先从 TokenStream 抽取需要的数据，再通过模板，把抽取出来的数据转换成目标代码（TokenStream）</strong>。</p><p>由于 syn/quote 生成的 TokenStream 是 <a href=\"https://github.com/dtolnay/proc-macro2\">proc-macro2</a> 的类型，所以我们还需要使用这个库，简单说明一下proc-macro2，它是对 proc-macro 的简单封装，使用起来更方便，而且可以让过程宏可以单元测试。</p><p>我们在上一讲中创建的项目中添加更多的依赖：</p><pre><code class=\"language-rust\">[dependencies]\nanyhow = \"1\"\naskama = \"0.11\" # 处理 jinjia 模板，模板需要放在和 src 平行的 templates 目录下\nproc-macro2 = \"1\" # proc-macro 的封装\nquote = \"1\" # 用于生成代码的 TokenStream\nsyn = { version = \"1\", features = [\"extra-traits\"] } # 用于解析 TokenStream，使用 extra-traits 可以用于 Debug\n</code></pre><p>注意 syn crate 默认所有数据结构都不带一些基本的 trait，比如 Debug，所以如果你想打印数据结构的话，需要使用 extra-traits feature。</p><h3>Step1：看看 DeriveInput 都输出什么？</h3><p>在 <a href=\"http://lib.rs\">lib.rs</a> 中，先添加新的 Builder 派生宏：</p><pre><code class=\"language-rust\">use syn::{parse_macro_input, DeriveInput};\n\n#[proc_macro_derive(Builder)]\npub fn derive_builder(input: TokenStream) -&gt; TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n    println!(\"{:#?}\", input);\n    TokenStream::default()\n}\n</code></pre><p>通过 <code>parse_macro_input!</code>，我们得到了一个 DeriveInput 结构的数据。这里可以打印一下，看看会输出什么。</p><p>所以在 examples/command.rs 中，先为 Command 引入 Builder 宏：</p><pre><code class=\"language-rust\">use macros::{Builder, RawBuilder};\n\n#[allow(dead_code)]\n#[derive(Debug, RawBuilder, Builder)]\npub struct Command {\n    executable: String,\n    args: Vec&lt;String&gt;,\n    env: Vec&lt;String&gt;,\n    current_dir: Option&lt;String&gt;,\n}\n</code></pre><p>然后运行 <code>cargo run --example command</code>，就可以看到非常详尽的 DeriveInput 的输出：</p><ul>\n<li>对于 struct name，可以直接从 ident 中获取</li>\n<li>对于 fields，需要从 data 内部的 DataStruct { fields } 中取。目前，我们只关心每个 field 的 ident 和 ty。</li>\n</ul><h3>Step2：定义自己的用于处理 derive 宏的数据结构</h3><p>和上一讲一样，我们需要定义一个数据结构，来获取构建 TokenStream 用到的信息。</p><p>所以对比着上一讲，可以定义如下数据结构：</p><pre><code class=\"language-rust\">struct Fd {\n    name: Ident,\n    ty: Type,\n\t\toptional: bool,\n}\n\npub struct BuilderContext {\n    name: Ident,\n    fields: Vec&lt;Fd&gt;,\n}\n</code></pre><h3>Step3：把 DeriveInput 转换成自己的数据结构</h3><p>接下来要做的，就是把 DeriveInput 转换成我们需要的 BuilderContext。</p><p>所以来写两个 From<t> trait 的实现，分别把 Field 转换成 Fd，DeriveInput 转换成 BuilderContext：</t></p><pre><code class=\"language-rust\">/// 把一个 Field 转换成 Fd\nimpl From&lt;Field&gt; for Fd {\n    fn from(f: Field) -&gt; Self {\n        let (optional, ty) = get_option_inner(f.ty);\n        Self {\n            // 此时，我们拿到的是 NamedFields，所以 ident 必然存在\n            name: f.ident.unwrap(),\n            optional,\n            ty,\n        }\n    }\n}\n\n/// 把 DeriveInput 转换成 BuilderContext\nimpl From&lt;DeriveInput&gt; for BuilderContext {\n    fn from(input: DeriveInput) -&gt; Self {\n        let name = input.ident;\n\n        let fields = if let Data::Struct(DataStruct {\n            fields: Fields::Named(FieldsNamed { named, .. }),\n            ..\n        }) = input.data\n        {\n            named\n        } else {\n            panic!(\"Unsupported data type\");\n        };\n\n        let fds = fields.into_iter().map(Fd::from).collect();\n        Self { name, fields: fds }\n    }\n}\n\n// 如果是 T = Option&lt;Inner&gt;，返回 (true, Inner)；否则返回 (false, T)\nfn get_option_inner(ty: Type) -&gt; (bool, Type) {\n    todo!()\n}\n</code></pre><p>是不是简单的有点难以想象？</p><p>注意在从 input 中获取 fields 时，我们用了一个嵌套很深的模式匹配：</p><pre><code class=\"language-rust\">if let Data::Struct(DataStruct {\n    fields: Fields::Named(FieldsNamed { named, .. }),\n    ..\n}) = input.data\n{\n    named\n}\n</code></pre><p>如果没有强大的模式匹配的支持，获取 FieldsNamed 会是非常冗长的代码。你可以仔细琢磨这两个 From<t> 的实现，它很好地体现了 Rust 的优雅。</t></p><p>在处理 Option<t> 类型的时候，我们用了一个还不存在的函数 get_option_inner()，这样一个函数是为了实现，如果是 T = Option<inner>，就返回 (true, Inner)，否则返回 (false, T)。</inner></t></p><h3>Step4：使用 quote 生成代码</h3><p>准备好 BuilderContext，就可以生成代码了。来写一个 render() 方法：</p><pre><code class=\"language-rust\">impl BuilderContext {\n    pub fn render(&amp;self) -&gt; TokenStream {\n        let name = &amp;self.name;\n        // 生成 XXXBuilder 的 ident\n        let builder_name = Ident::new(&amp;format!(\"{}Builder\", name), name.span());\n\n        let optionized_fields = self.gen_optionized_fields();\n        let methods = self.gen_methods();\n        let assigns = self.gen_assigns();\n\n        quote! {\n            /// Builder 结构\n            #[derive(Debug, Default)]\n            struct #builder_name {\n                #(#optionized_fields,)*\n            }\n\n            /// Builder 结构每个字段赋值的方法，以及 build() 方法\n            impl #builder_name {\n                #(#methods)*\n\n                pub fn build(mut self) -&gt; Result&lt;#name, &amp;'static str&gt; {\n                    Ok(#name {\n                        #(#assigns,)*\n                    })\n                }\n            }\n\n            /// 为使用 Builder 的原结构提供 builder() 方法，生成 Builder 结构\n            impl #name {\n                fn builder() -&gt; #builder_name {\n                    Default::default()\n                }\n            }\n        }\n    }\n\n    // 为 XXXBuilder 生成 Option&lt;T&gt; 字段\n    // 比如：executable: String -&gt; executable: Option&lt;String&gt;\n    fn gen_optionized_fields(&amp;self) -&gt; Vec&lt;TokenStream&gt; {\n        todo!();\n    }\n\n    // 为 XXXBuilder 生成处理函数\n    // 比如：methods: fn executable(mut self, v: impl Into&lt;String&gt;) -&gt; Self { self.executable = Some(v); self }\n    fn gen_methods(&amp;self) -&gt; Vec&lt;TokenStream&gt; {\n        todo!();\n    }\n\n    // 为 XXXBuilder 生成相应的赋值语句，把 XXXBuilder 每个字段赋值给 XXX 的字段\n    // 比如：#field_name: self.#field_name.take().ok_or(\" xxx need to be set!\")\n    fn gen_assigns(&amp;self) -&gt; Vec&lt;TokenStream&gt; {\n        todo!();\n    }\n}\n</code></pre><p>可以看到，<code>quote!</code> 包裹的代码，和上一讲在 template 中写的代码非常类似，只不过循环的地方使用了 quote! 内部的重复语法 <code>#(...)*</code>。</p><p>到目前为止，虽然我们的代码还不能运行，但完整的从 TokenStream 到 TokenStream 转换的骨架已经完成，剩下的只是实现细节而已，你可以试着自己实现。</p><h3>Step5：完整实现</h3><p>好，我们创建 src/builder.rs 文件（记得在 src/lib.rs 里引入），然后写入代码：</p><pre><code class=\"language-rust\">use proc_macro2::{Ident, TokenStream};\nuse quote::quote;\nuse syn::{\n    Data, DataStruct, DeriveInput, Field, Fields, FieldsNamed, GenericArgument, Path, Type,\n    TypePath,\n};\n\n/// 我们需要的描述一个字段的所有信息\nstruct Fd {\n    name: Ident,\n    ty: Type,\n    optional: bool,\n}\n\n/// 我们需要的描述一个 struct 的所有信息\npub struct BuilderContext {\n    name: Ident,\n    fields: Vec&lt;Fd&gt;,\n}\n\n/// 把一个 Field 转换成 Fd\nimpl From&lt;Field&gt; for Fd {\n    fn from(f: Field) -&gt; Self {\n        let (optional, ty) = get_option_inner(&amp;f.ty);\n        Self {\n            // 此时，我们拿到的是 NamedFields，所以 ident 必然存在\n            name: f.ident.unwrap(),\n            optional,\n            ty: ty.to_owned(),\n        }\n    }\n}\n\n/// 把 DeriveInput 转换成 BuilderContext\nimpl From&lt;DeriveInput&gt; for BuilderContext {\n    fn from(input: DeriveInput) -&gt; Self {\n        let name = input.ident;\n\n        let fields = if let Data::Struct(DataStruct {\n            fields: Fields::Named(FieldsNamed { named, .. }),\n            ..\n        }) = input.data\n        {\n            named\n        } else {\n            panic!(\"Unsupported data type\");\n        };\n\n        let fds = fields.into_iter().map(Fd::from).collect();\n        Self { name, fields: fds }\n    }\n}\n\nimpl BuilderContext {\n    pub fn render(&amp;self) -&gt; TokenStream {\n        let name = &amp;self.name;\n        // 生成 XXXBuilder 的 ident\n        let builder_name = Ident::new(&amp;format!(\"{}Builder\", name), name.span());\n\n        let optionized_fields = self.gen_optionized_fields();\n        let methods = self.gen_methods();\n        let assigns = self.gen_assigns();\n\n        quote! {\n            /// Builder 结构\n            #[derive(Debug, Default)]\n            struct #builder_name {\n                #(#optionized_fields,)*\n            }\n\n            /// Builder 结构每个字段赋值的方法，以及 build() 方法\n            impl #builder_name {\n                #(#methods)*\n\n                pub fn build(mut self) -&gt; Result&lt;#name, &amp;'static str&gt; {\n                    Ok(#name {\n                        #(#assigns,)*\n                    })\n                }\n            }\n\n            /// 为使用 Builder 的原结构提供 builder() 方法，生成 Builder 结构\n            impl #name {\n                fn builder() -&gt; #builder_name {\n                    Default::default()\n                }\n            }\n        }\n    }\n\n    // 为 XXXBuilder 生成 Option&lt;T&gt; 字段\n    // 比如：executable: String -&gt; executable: Option&lt;String&gt;\n    fn gen_optionized_fields(&amp;self) -&gt; Vec&lt;TokenStream&gt; {\n        self.fields\n            .iter()\n            .map(|Fd { name, ty, .. }| quote! { #name: std::option::Option&lt;#ty&gt; })\n            .collect()\n    }\n\n    // 为 XXXBuilder 生成处理函数\n    // 比如：methods: fn executable(mut self, v: impl Into&lt;String&gt;) -&gt; Self { self.executable = Some(v); self }\n    fn gen_methods(&amp;self) -&gt; Vec&lt;TokenStream&gt; {\n        self.fields\n            .iter()\n            .map(|Fd { name, ty, .. }| {\n                quote! {\n                    pub fn #name(mut self, v: impl Into&lt;#ty&gt;) -&gt; Self {\n                        self.#name = Some(v.into());\n                        self\n                    }\n                }\n            })\n            .collect()\n    }\n\n    // 为 XXXBuilder 生成相应的赋值语句，把 XXXBuilder 每个字段赋值给 XXX 的字段\n    // 比如：#field_name: self.#field_name.take().ok_or(\" xxx need to be set!\")\n    fn gen_assigns(&amp;self) -&gt; Vec&lt;TokenStream&gt; {\n        self.fields\n            .iter()\n            .map(|Fd { name, optional, .. }| {\n                if *optional {\n                    return quote! {\n                        #name: self.#name.take()\n                    };\n                }\n\n                quote! {\n                    #name: self.#name.take().ok_or(concat!(stringify!(#name), \" needs to be set!\"))?\n                }\n            })\n            .collect()\n    }\n}\n\n// 如果是 T = Option&lt;Inner&gt;，返回 (true, Inner)；否则返回 (false, T)\nfn get_option_inner(ty: &amp;Type) -&gt; (bool, &amp;Type) {\n    // 首先模式匹配出 segments\n    if let Type::Path(TypePath {\n        path: Path { segments, .. },\n        ..\n    }) = ty\n    {\n        if let Some(v) = segments.iter().next() {\n            if v.ident == \"Option\" {\n                // 如果 PathSegment 第一个是 Option，那么它内部应该是 AngleBracketed，比如 &lt;T&gt;\n                // 获取其第一个值，如果是 GenericArgument::Type，则返回\n                let t = match &amp;v.arguments {\n                    syn::PathArguments::AngleBracketed(a) =&gt; match a.args.iter().next() {\n                        Some(GenericArgument::Type(t)) =&gt; t,\n                        _ =&gt; panic!(\"Not sure what to do with other GenericArgument\"),\n                    },\n                    _ =&gt; panic!(\"Not sure what to do with other PathArguments\"),\n                };\n                return (true, t);\n            }\n        }\n    }\n    return (false, ty);\n}\n</code></pre><p>这段代码仔细阅读的话并不难理解，可能 <code>get_option_inner()</code> 拗口一些。你需要对着 DeriveInput 的 Debug 信息对应的部分比对着看，去推敲如何做模式匹配。比如：</p><pre><code class=\"language-rust\">ty: Path(\n    TypePath {\n        qself: None,\n        path: Path {\n            leading_colon: None,\n            segments: [\n                PathSegment {\n                    ident: Ident {\n                        ident: \"Option\",\n                        span: #0 bytes(201..207),\n                    },\n                    arguments: AngleBracketed(\n                        AngleBracketedGenericArguments {\n                            colon2_token: None,\n                            lt_token: Lt,\n                            args: [\n                                Type(\n                                    Path(\n                                        TypePath {\n                                            qself: None,\n                                            path: Path {\n                                                leading_colon: None,\n                                                segments: [\n                                                    PathSegment {\n                                                        ident: Ident {\n                                                            ident: \"String\",\n                                                            span: #0 bytes(208..214),\n                                                        },\n                                                        arguments: None,\n                                                    },\n                                                ],\n                                            },\n                                        },\n                                    ),\n                                ),\n                            ],\n                            gt_token: Gt,\n                        },\n                    ),\n                },\n            ],\n        },\n    },\n),\n</code></pre><p>这本身并不难，难的是心细以及足够的耐心。如果你对某个数据结构拿不准该怎么匹配，可以在 syn 的文档中查找这个数据结构，了解它的定义。</p><p>好，如果你理解了这个代码，我们就可以更新 src/lib.rs 里定义的 derive_builder 了：</p><pre><code class=\"language-rust\">#[proc_macro_derive(Builder)]\npub fn derive_builder(input: TokenStream) -&gt; TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n    builder::BuilderContext::from(input).render().into()\n}\n</code></pre><p>可以直接从 DeriveInput 中生成一个 BuilderContext，然后 render()。注意 quote 得到的是 proc_macro2::TokenStream，所以需要调用一下 into() 转换成 proc_macro::TokenStream。</p><p>在 examples/command.rs 中，更新 Command 的 derive 宏：</p><pre><code class=\"language-rust\">use macros::Builder;\n\n#[allow(dead_code)]\n#[derive(Debug, Builder)]\npub struct Command {\n    ...\n}\n</code></pre><p>运行之，你可以得到正确的结果。</p><h3>one more thing：支持 attributes</h3><p>很多时候，我们的派生宏可能还需要一些额外的 attributes 来提供更多信息，更好地指导代码的生成。比如 serde，你可以在数据结构中加入 #[serde(xxx)] attributes，控制 serde 序列化/反序列化的行为。</p><p>现在我们的 Builder 宏支持基本的功能，但用着还不那么特别方便，比如对于类型是 Vec<string> 的 args，如果我可以依次添加每个 arg，该多好？</string></p><p>在 proc-macro-workshop 里 <a href=\"https://github.com/dtolnay/proc-macro-workshop/blob/master/builder/tests/07-repeated-field.rs\">Builder 宏的第 7 个练习</a>中，就有这样一个需求：</p><pre><code class=\"language-rust\">#[derive(Builder)]\npub struct Command {\n    executable: String,\n    #[builder(each = \"arg\")]\n    args: Vec&lt;String&gt;,\n    #[builder(each = \"env\")]\n    env: Vec&lt;String&gt;,\n    current_dir: Option&lt;String&gt;,\n}\n\nfn main() {\n    let command = Command::builder()\n        .executable(\"cargo\".to_owned())\n        .arg(\"build\".to_owned())\n        .arg(\"--release\".to_owned())\n        .build()\n        .unwrap();\n\n    assert_eq!(command.executable, \"cargo\");\n    assert_eq!(command.args, vec![\"build\", \"--release\"]);\n}\n</code></pre><p>这里，如果字段定义了 builder attributes，并且提供了 each 参数，那么用户不断调用 arg 来依次添加参数。这样使用起来，直观多了。</p><p><strong>分析一下这个需求。想要支持这样的功能，首先要能够解析 attributes，然后要能够根据 each attribute 的内容生成对应的代码</strong>，比如这样：</p><pre><code class=\"language-rust\">pub fn arg(mut self, v: String) -&gt; Self {\n    let mut data = self.args.take().unwrap_or_default();\n    data.push(v);\n    self.args = Some(data);\n    self\n}\n</code></pre><p>syn 提供的 DeriveInput 并没有对 attributes 额外处理，所有的 attributes 被包裹在一个 TokenTree::Group 中。</p><p>我们可以用上一讲提到的方法，手工处理 TokenTree/TokenStream，不过这样太麻烦，社区里已经有一个非常棒的库叫 <a href=\"https://github.com/teddriggs/darling\">darling</a>，光是名字就听上去惹人喜爱，用起来更是让人爱不释手。我们就使用这个库，来为 Builder 宏添加对 attributes 的支持。</p><p>为了避免对之前的 Builder 宏的破坏，我们把 src/builder.rs 拷贝一份出来改名 src/builder_with_attr.rs，然后在 src/lib.rs 中引用它。</p><p>在 src/lib.rs 中，我们再创建一个 BuilderWithAttrs 的派生宏：</p><pre><code class=\"language-rust\">#[proc_macro_derive(BuilderWithAttr, attributes(builder))]\npub fn derive_builder_with_attr(input: TokenStream) -&gt; TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n    builder_with_attr::BuilderContext::from(input)\n        .render()\n        .into()\n}\n</code></pre><p>和之前不同的是，这里多了一个 attributes(builder) 属性，这是告诉编译器，请允许代码中出现的 <code>#[builder(...)]</code>，它是我这个宏认识并要处理的。</p><p>再创建一个 examples/command_with_attr.rs，把 workshop 中的代码粘进去并适当修改：</p><pre><code class=\"language-rust\">use macros::BuilderWithAttr;\n\n#[allow(dead_code)]\n#[derive(Debug, BuilderWithAttr)]\npub struct Command {\n    executable: String,\n    #[builder(each = \"arg\")]\n    args: Vec&lt;String&gt;,\n    #[builder(each = \"env\", default=\"vec![]\")]\n    env: Vec&lt;String&gt;,\n    current_dir: Option&lt;String&gt;,\n}\n\nfn main() {\n    let command = Command::builder()\n        .executable(\"cargo\".to_owned())\n        .arg(\"build\".to_owned())\n        .arg(\"--release\".to_owned())\n        .build()\n        .unwrap();\n\n    assert_eq!(command.executable, \"cargo\");\n    assert_eq!(command.args, vec![\"build\", \"--release\"]);\n    println!(\"{:?}\", command);\n}\n</code></pre><p>这里，我们不仅希望支持 each 属性，还支持 default —— 如果用户没有为这个域提供数据，就使用 default 对应的代码来初始化。</p><p>这个代码目前会报错，因为并未为 CommandBuilder 添加 arg 方法。接下来我们就要实现这个功能。</p><p>在 Cargo.toml 中，加入对 darling 的引用：</p><pre><code class=\"language-rust\">[dependencies]\ndarling = \"0.13\"\n</code></pre><p>然后，在 src/builder_with_attr.rs 中，添加用于捕获 attributes 的数据结构：</p><pre><code class=\"language-rust\">use darling::FromField;\n\n#[derive(Debug, Default, FromField)]\n#[darling(default, attributes(builder))]\nstruct Opts {\n    each: Option&lt;String&gt;,\n    default: Option&lt;String&gt;,\n}\n</code></pre><p>因为我们捕获的是 field 级别的 attributes，所以这个数据结构需要实现 <a href=\"https://docs.rs/darling/latest/darling/trait.FromField.html\">FromField</a> trait（通过 FromTrait 派生宏），并且告诉 darling 要从哪个 attributes 中捕获（这里是从 builder 中捕获）。</p><p>不过先需要修改一下 Fd，让它包括 Opts，并且在 From<t> 的实现中初始化 opts：</t></p><pre><code class=\"language-rust\">/// 我们需要的描述一个字段的所有信息\nstruct Fd {\n    name: Ident,\n    ty: Type,\n    optional: bool,\n    opts: Opts,\n}\n\n/// 把一个 Field 转换成 Fd\nimpl From&lt;Field&gt; for Fd {\n    fn from(f: Field) -&gt; Self {\n        let (optional, ty) = get_option_inner(&amp;f.ty);\n        // 从 Field 中读取 attributes 生成 Opts，如果没有使用缺省值\n        let opts = Opts::from_field(&amp;f).unwrap_or_default();\n        Self {\n            opts,\n            // 此时，我们拿到的是 NamedFields，所以 ident 必然存在\n            name: f.ident.unwrap(),\n            optional,\n            ty: ty.to_owned(),\n        }\n    }\n}\n</code></pre><p>好，现在 Fd 就包含 Opts 的信息了，我们可以利用这个信息来生成 methods 和 assigns。</p><p>接下来先看 gen_methods 怎么修改。如果 Fd 定义了 each attribute，且它是个 Vec 的话，我们就生成不一样的代码，否则的话，像之前那样生成代码。来看实现：</p><pre><code class=\"language-rust\">// 为 XXXBuilder 生成处理函数\n// 比如：methods: fn executable(mut self, v: impl Into&lt;String&gt;) -&gt; Self { self.executable = Some(v); self }\nfn gen_methods(&amp;self) -&gt; Vec&lt;TokenStream&gt; {\n    self.fields\n        .iter()\n        .map(|f| {\n            let name = &amp;f.name;\n            let ty = &amp;f.ty;\n            // 如果不是 Option 类型，且定义了 each attribute\n            if !f.optional &amp;&amp; f.opts.each.is_some() {\n                let each = Ident::new(f.opts.each.as_deref().unwrap(), name.span());\n                let (is_vec, ty) = get_vec_inner(ty);\n                if is_vec {\n                    return quote! {\n                        pub fn #each(mut self, v: impl Into&lt;#ty&gt;) -&gt; Self {\n                            let mut data = self.#name.take().unwrap_or_default();\n                            data.push(v.into());\n                            self.#name = Some(data);\n                            self\n                        }\n                    };\n                }\n            }\n            quote! {\n                pub fn #name(mut self, v: impl Into&lt;#ty&gt;) -&gt; Self {\n                    self.#name = Some(v.into());\n                    self\n                }\n            }\n        })\n        .collect()\n}\n</code></pre><p>这里，我们重构了一下 get_option_inner() 的代码，因为 get_vec_inner() 和它有相同的逻辑：</p><pre><code class=\"language-rust\">// 如果是 T = Option&lt;Inner&gt;，返回 (true, Inner)；否则返回 (false, T)\nfn get_option_inner(ty: &amp;Type) -&gt; (bool, &amp;Type) {\n    get_type_inner(ty, \"Option\")\n}\n\n// 如果是 T = Vec&lt;Inner&gt;，返回 (true, Inner)；否则返回 (false, T)\nfn get_vec_inner(ty: &amp;Type) -&gt; (bool, &amp;Type) {\n    get_type_inner(ty, \"Vec\")\n}\n\nfn get_type_inner&lt;'a&gt;(ty: &amp;'a Type, name: &amp;str) -&gt; (bool, &amp;'a Type) {\n    // 首先模式匹配出 segments\n    if let Type::Path(TypePath {\n        path: Path { segments, .. },\n        ..\n    }) = ty\n    {\n        if let Some(v) = segments.iter().next() {\n            if v.ident == name {\n                // 如果 PathSegment 第一个是 Option/Vec 等类型，那么它内部应该是 AngleBracketed，比如 &lt;T&gt;\n                // 获取其第一个值，如果是 GenericArgument::Type，则返回\n                let t = match &amp;v.arguments {\n                    syn::PathArguments::AngleBracketed(a) =&gt; match a.args.iter().next() {\n                        Some(GenericArgument::Type(t)) =&gt; t,\n                        _ =&gt; panic!(\"Not sure what to do with other GenericArgument\"),\n                    },\n                    _ =&gt; panic!(\"Not sure what to do with other PathArguments\"),\n                };\n                return (true, t);\n            }\n        }\n    }\n    return (false, ty);\n}\n</code></pre><p>最后，我们为 gen_assigns() 提供对 default attribute 的支持：</p><pre><code class=\"language-rust\">fn gen_assigns(&amp;self) -&gt; Vec&lt;TokenStream&gt; {\n    self.fields\n        .iter()\n        .map(|Fd { name, optional, opts, .. }| {\n            if *optional {\n                return quote! {\n                    #name: self.#name.take()\n                };\n            }\n\n            // 如果定义了 default，那么把 default 里的字符串转换成 TokenStream\n            // 使用 unwrap_or_else 在没有值的时候，使用缺省的结果\n            if let Some(default) = opts.default.as_ref() {\n                let ast: TokenStream = default.parse().unwrap();\n                return quote! {\n                    #name: self.#name.take().unwrap_or_else(|| #ast)\n                };\n            }\n\n            quote! {\n                #name: self.#name.take().ok_or(concat!(stringify!(#name), \" needs to be set!\"))?\n            }\n        })\n        .collect()\n}\n</code></pre><p>如果你完成了这些改动，运行 <code>cargo run --example command_with_attr</code> 就会得到正确的结果。完整的代码，可以去 GitHub <a href=\"https://github.com/tyrchen/geektime-rust/tree/master/47_48_macros\">repo</a> 上获取。</p><h2>小结</h2><p>这一讲我们使用 syn/quote 重写了 Builder 派生宏的功能。可以看到，使用 syn/quote 后，宏的开发变得简单很多，最后我们还用 darling 进一步提供了对 attributes 的支持。</p><p>虽然这两讲我们只做了派生宏和一个非常简单的函数宏，但是，如果你学会了最复杂的派生宏，那开发函数宏和属性宏也不在话下。另外，darling 对 attributes 的支持，同样也可以应用在属性宏中。</p><p>今天重写Builder中核心做的就是，我们定义了两个自己的 From&lt;T&gt; trait，把 DeriveInput 转换成了自己的数据结构，然后围绕着我们自己的数据结构，构建更多的功能来生成代码。所以，宏编程不过是一系列数据结构的转换而已，并不神秘，它就跟我们平日里写的代码一样，只不过它操作和输出的数据结构都是语法树。</p><p><strong>使用宏来生成代码虽然听上去很牛，写起来也很有成就感，但是切不可滥用</strong>。凡事都有两面，强大和灵活多变的对立面就是危险和难以捉摸。</p><p>因为虽然撰写宏并不困难，宏会为别人理解你的代码，使用你的代码带来额外的负担。由于宏会生成代码，大量使用宏会让你的代码在不知不觉中膨胀，也会导致二进制很大。另外，正如我们在使用中发现的那样，目前 IDE 对宏的支持还不够好，这也是大量使用宏的一个问题。我们看到像 <a href=\"https://github.com/Geal/nom\">nom</a> 这样的工具，一开始大量使用宏，后来也都逐渐用函数取代。</p><p>所以在开发的时候，要非常谨慎地构建宏。多问自己：我非用宏不可么？可以使用别的设计来避免使用宏么？同样是 Web 框架，rocket 使用宏做路由，axum 完全不使用宏。</p><p>就像 unsafe 一样，我们要把宏编程作为撰写代码最后的手段。<strong>当一个功能可以用函数表达时，不要用宏。不要过分迷信于编译时的处理，不要把它当成提高性能的手段</strong>。如果你发现某个设计似乎不得不使用宏，你需要质疑一下，自己设计上的选择是否正确。</p><h3>思考题</h3><p>学完了这两课，如果你还觉得不过瘾，可以继续完成 <a href=\"https://github.com/dtolnay/proc-macro-workshop\">proc-macro-workshop</a> 里Builder 以外的其它例子。这些例子你耐心地把它们全做一遍，一定会有很大的收获。</p><p>学习愉快，如果你觉得有收获，也欢迎你分享给你身边的朋友，邀他一起讨论。</p>","comments":[{"had_liked":false,"id":332320,"user_name":"胡小涵","can_delete":false,"product_type":"c1","uid":2004538,"ip_address":"","ucode":"2E750C65EC282C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/96/3a/e06f8367.jpg","comment_is_top":false,"comment_ctime":1643176135,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643176135","product_id":100085301,"comment_content":"感谢老师加餐！顶顶顶！","like_count":1}]}