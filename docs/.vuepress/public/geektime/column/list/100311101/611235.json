{"id":611235,"title":"10｜动态渲染组件：如何实现Vue的动态渲染组件？","content":"<p>你好，我是杨文坚。</p><p>前两节课，我们已经入门了Vue.js 3.x自研组件库的开发和组件库的主题方案设计，还了解了按钮组件这一基础组件的开发流程及其主题化实现。</p><p>组件库，核心是将不同类型的功能组件聚合起来，提供给业务前端开发者按需选择，用到实际前端页面上。接下来的几节课，我们主要会一步步开发不同类型的Vue.js 3.x的组件，打造属于自己的Vue.js 3.x企业级自研组件库。</p><p>今天，我们先学习组件库里常见的一种组件类型，<strong>动态渲染组件</strong>。</p><h2>什么是动态渲染组件？</h2><p>在平时工作中用Ant Design或者Element Plus等前端组件库时，相信你经常会用到对话框、消息提醒和侧边抽屉等组件，来做一些信息的动态显示和动态操作，这类组件都可以通过函数式的方式直接调用。</p><p>这类组件从功能上分类，一般被称为“反馈类型组件”。如果从技术实现方式上归类，就可以归纳为“动态渲染组件”。<strong>那我们如何从技术实现的角度，理解动态渲染组件呢？</strong></p><p>从字面意义可以看出来，动态渲染组件就是通过“动态”的方式来“渲染”组件，不需要像常规 Vue.js 3.x组件那样，把组件注册到模板里使用。</p><p>所以，动态渲染组件的两个技术特点就是：</p><ul>\n<li>以直接函数式地使用来执行渲染，使用者不需要写代码来挂载组件；</li>\n<li>组件内部实现了动态挂载和卸载节点的操作。</li>\n</ul><!-- [[[read_end]]] --><p>如果我们把这2个技术特点放在Vue.js 3.x的框架体系内来理解，你会发现：<strong>Vue.js 3.x 动态渲染组件在页面上是独立于“Vue.js 主应用”之外的渲染。</strong></p><p>因为，动态渲染组件，在项目应用里，只是调用组件的函数（或者方法），然后创建一个独立于“Vue.js 主应用”外的一个“Vue.js 副应用”，动态挂载（mount）在HTML动态创建的DOM上。如果要关闭动态渲染组件，就需要再次触发一个关闭函数（或者方法），把这个“Vue.js 的副应用”卸载（unmount），最后把动态创建的DOM也一并销毁回收。这样，就完成动态渲染组件从挂载到卸载的一个完整的生命周期。</p><p>那么，动态渲染组件一般可以实现组件库里的哪些功能组件？或者说，组件库的建设一般需要哪些动态渲染组件呢？</p><p>工作开发中高频用到的动态渲染组件有<strong>消息提醒组件（Message）<strong>和</strong>对话框组件(Dialog)</strong>。所以，接下来我们会围绕这两个组件动态渲染的技术实现方案展开。</p><p>不过，在实现Message和Dialog这两个动态渲染组件之前，我们首要的工作是知道实现动态组件前要准备什么。</p><h2>实现动态渲染组件需要做什么技术准备？</h2><p>组件库是提供给开发者使用的，除了功能，开发者最关心的当然就是组件的API（接口）使用方式，所以<strong>动态渲染组件API设计尤为重要</strong>。</p><p>我们前面说过，动态渲染组件是直接通过函数方法触发调用，所以我们首先要准备的就是对这个函数方法的API的设计。</p><p>需要关注的是，这里不仅仅要考虑技术层面的API设计，我们还需要考虑到组件库使用者的开发使用体验。我建议在设计函数方法的API的时候，以组件库的使用者视角作为出发点，换位思考一下，如果你作为组件库的使用者，使用一个函数方法来触发一个动态渲染组件时，是不是使用方式越简单越好，学习成本越低越好？</p><p>所以，我们在设计动态渲染组件的API时，<strong>使用步骤尽量少，使用代码尽量精简</strong>。</p><p>而动态渲染组件整个生命周期，最核心的就是“动态挂载”和“动态卸载”两个步骤，所以API的设计，可以直接围绕着“挂载”和“卸载”两个来设计，最简单的可以设计成如下代码：</p><pre><code class=\"language-typescript\">import { Module } from 'xxxx'\n\n// 动态组件挂载\nModule.open({&nbsp; /* 组件参数 */ });\n\n// 动态组件卸载\nModule.close();\n</code></pre><p>如果考虑到组件不是单例的，而是多实例共存的，可以这么设计API：</p><pre><code class=\"language-typescript\">import { Module } from 'xxxx'\n\n// 创建动态组件 mod1\nconst mod1 = Module.create({&nbsp; /* 组件参数 */ });\n// 挂载渲染 mod1\nmod1.open();\n// 卸载动态组件 mod1\nmod1.close();\n\n\n\n// 创建动态组件 mod2\nconst mod2 = Module.create({&nbsp; /* 组件参数 */ });\n// 挂载渲染 mod2\nmod2.open();\n// 卸载动态组件 mod2\nmod2.close();\n</code></pre><p>如果动态组件在其生命周期还需要添加一些节点，可以这么来设计：</p><pre><code class=\"language-typescript\">import { Module } from 'xxxx'\n\n// 创建动态组件 mod1\nconst mod1 = Module.create({  /* 组件参数 */ });\n// 挂载渲染 mod1\nmod1.open();\n// 更新组 mod1 件内容\nmod1.update({ /* 更新内容参数 */ })\n// 卸载动态组件 mod1\nmod1.close();\n</code></pre><p>完成了动态组件的函数方法API设计，接下来，我们学习Vue.js 3.x实现组件的动态挂载和卸载操作。</p><p>前面说了，Vue.js 3.x 动态渲染组件本质就是渲染一个独立的Vue.js 3.x的应用，只是独立于本身页面主应用存在，那么，组件渲染挂载的时候，就需要一个动态的挂载节点DOM，用Vue.js 3.x创建一个App挂载到这个动态节点DOM上面。</p><p>后续到组件生命周期结束时，也就是卸载动态渲染组件时，再用Vue.js 3.x卸载App的方法，把组件从DOM上卸载掉，同时把动态创建的DOM给销毁掉。</p><p>整个过程，我们可以用最简单的Vue.js 3.x代码实现：</p><pre><code class=\"language-typescript\">import { defineComponent, createApp, h } from 'vue';\n\n// 用 JSX 语法实现一个Vue.js 3.x的组件\nconst ModuleComponent = defineComponent({\n&nbsp; setup(props, context) {\n&nbsp; &nbsp; return () =&gt; {\n&nbsp; &nbsp; &nbsp; return (\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;div&gt;这是一个动态渲染的组件&lt;/div&gt;\n&nbsp; &nbsp; &nbsp; );\n&nbsp; &nbsp; };\n&nbsp; }\n});\n\n// 实现动态渲染组件的过程\n\nexport const createModule = () =&gt; {\n&nbsp; // 创建动态节点DOM\n\tconst dom = document.createElement('div');\n&nbsp; // 把 DOM 追加到页面 body标签里\n&nbsp; const body = document.querySelector('body') as HTMLBodyElement;\n&nbsp; const app = createApp({\n&nbsp; &nbsp; render() {\n&nbsp; &nbsp; &nbsp; return h(DialogComponent, {});\n&nbsp; &nbsp; }\n&nbsp; });\n&nbsp;\n\n&nbsp; // 返回当前组件的操作实例\n&nbsp; // 其中封装了挂载和卸载组件的方法\n&nbsp; return {\n&nbsp; &nbsp; open(): () =&gt; {\n&nbsp; &nbsp; &nbsp; // 把组件 ModuleComponent 作为一个独立应用挂载在 DOM 节点上\n&nbsp; &nbsp; &nbsp; app.mount(dom);\n&nbsp; &nbsp; },\n&nbsp; &nbsp; close: () =&gt; {\n&nbsp; &nbsp; &nbsp; // 卸载组件\n&nbsp; &nbsp; &nbsp; app.unmount();\n&nbsp; &nbsp; &nbsp; // 销毁动态节点\n&nbsp; &nbsp; &nbsp; dom.remove();\n&nbsp; &nbsp; }\n&nbsp; }\n}\n</code></pre><p>上面封装的一个最简单的动态渲染组件，可以这么使用：</p><pre><code class=\"language-typescript\">import { createModule } from './xxxx';\n\n// 创建和渲染组件\nconst mod = createModule();\n\n// 挂载渲染组件\nmod.open();\n\n// 卸载关闭组件\nmod.close();\n</code></pre><p>通过这些代码演示和注释，相信你可以一目了然地看到动态渲染组件一个完整的开发实现过程。</p><p>在这个例子里，我们通过一个 JSX语法实现的动态渲染组件，而JSX的语法比较灵活，在动态渲染组件的实现上有很大的发挥空间，我们还可以用JSX语法，把一个Vue.js 3.x的动态组件实现在一个独立的JS文件中，不需要额外新建Vue文件来书写组件实体。</p><p>那么问题来了，我们能不能用不同于JSX语法的另一种语法，也就是模板语法，来实现动态渲染组件呢？</p><p>答案是可以的。</p><h2>如何实现一个动态Message组件？</h2><p>实现动态Message组件前，你可以先看一下最终的功能效果：</p><p><img src=\"https://static001.geekbang.org/resource/image/a3/c8/a38e2f1a60daa1c57be8101dd393f4c8.gif?wh=599x316\" alt=\"图片\"></p><p>可以看出，Message组件主要功能是显示消息提示，在挂载渲染后的一段时间内自动关闭，所以，这个组件除了能实现API控制的挂载渲染和卸载关闭，也需要支持默认的自动关闭。</p><p>想实现的效果我们知道了，动态渲染组件的技术准备前面也都掌握了，接下来，我们就实现这个Message动态渲染组件。</p><p>主要分四步：</p><ul>\n<li>第一步，先用Vue.js 3.x模板语法实现Message的模板组件；</li>\n<li>第二步，封装open函数来控制挂载渲染这个模板语法的Message组件；</li>\n<li>第三步，封装close函数来控制卸载关闭这个组件；</li>\n<li>第四步，扩展open函数，内置一个定时器来控制延时自动关闭组件。</li>\n</ul><p>在进入正式开发前，我们先定义以下参数的TypeScript类型，如下所示：</p><pre><code class=\"language-typescript\">// ./types.ts\nexport type MessageType = 'info' | 'success' | 'warn' | 'error';\n\nexport interface MessageParams {\n  text: string;\n  type?: MessageType;\n  duration?: number;\n}\n\n</code></pre><p>进入第一步，也就是用Vue.js 3.x模板语法先实现Message的模板组件，实现代码如下所示：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div v-if=\"show\" :class=\"{ [baseClassName]: true, [typeClassName]: true }\"&gt;\n    &lt;div&gt;{{ props.text }}&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script lang=\"ts\" setup&gt;\nimport { onMounted, ref } from 'vue';\nimport { prefixName } from '../theme/index';\nimport type { MessageType } from './types';\n\nconst show = ref&lt;boolean&gt;(false);\n\nonMounted(() =&gt; {\n  show.value = true;\n});\n\nconst props = withDefaults(\n  defineProps&lt;{\n    text?: string;\n    type?: MessageType;\n  }&gt;(),\n  {\n    type: 'info'\n  }\n);\n\nconst closeMessage = () =&gt; {\n  show.value = false;\n};\n\ndefineExpose&lt;{\n  closeMessage: () =&gt; void;\n}&gt;({ closeMessage: closeMessage });\n\nconst baseClassName = `${prefixName}-message`;\nconst typeClassName = `${baseClassName}-${props.type}`;\n&lt;/script&gt;\n\n</code></pre><p>在上述代码中，我把Message组件的消息提醒划分成几种类型，用几种不同颜色来显示区别，具体实现方式是基于Less和CSS Variable，如果你有什么不懂，可以翻看上一节课的内容。</p><p>进入第二步来封装open函数，代码片段如下所示：</p><pre><code class=\"language-javascript\">import { createApp, h } from 'vue';\nimport MessageComponent from './message.vue';\nimport type { MessageParams } from './types';\n\nconst Message = {\n  // 封装open函数\n  open(params: MessageParams) {\n    const dom = document.createElement('div');\n    const body = document.querySelector('body') as HTMLBodyElement;\n    let duration: number | undefined = params.duration;\n    if (duration === undefined) {\n      duration = 3000;\n    }\n    body.appendChild(dom);\n    const msg = h(MessageComponent, {\n      text: params.text,\n      type: params.type\n    });\n    const app = createApp({\n      render() {\n        return msg;\n      }\n    });\n    // 挂载和渲染Message组件\n    app.mount(dom);\n\n    // 后续等待返回 close 函数\n  }\n};\n\nexport default Message;\n\n</code></pre><p>到了第三步，就是基于已有open函数来返回close函数，代码如下所示：</p><pre><code class=\"language-typescript\">import { createApp, h } from 'vue';\nimport MessageComponent from './message.vue';\nimport type { MessageParams } from './types';\n\nconst Message = {\n  open(params: MessageParams) {\n    // 这里省略open函数渲染Message组件的代码\n\n    // 封装内部关闭函数\n    const internalClose = () =&gt; {\n      msg.component?.exposed?.['closeMessage']?.();\n      app.unmount();\n      dom.remove();\n    };\n\n    let timer: number | null = null;\n    if (duration &gt; 0) {\n      timer = setTimeout(() =&gt; {\n        internalClose();\n      }, duration);\n    }\n    \n    // 最后返回可控制Message关闭的close函数\n    return {\n      close: () =&gt; {\n        if (timer) {\n          clearTimeout(timer);\n          timer = null;\n        }\n        internalClose();\n      }\n    };\n  }\n};\n\nexport default Message;\n</code></pre><p>最后，第四步封装定时器到open函数中来控制挂载渲染这个模板语法的Message组件，最终实现代码所示：</p><pre><code class=\"language-typescript\">import { createApp, h } from 'vue';\nimport MessageComponent from './message.vue';\nimport type { MessageParams } from './types';\n\nconst Message = {\n  open(params: MessageParams) {\n    const dom = document.createElement('div');\n    const body = document.querySelector('body') as HTMLBodyElement;\n    let duration: number | undefined = params.duration;\n    if (duration === undefined) {\n      duration = 3000;\n    }\n    body.appendChild(dom);\n    const msg = h(MessageComponent, {\n      text: params.text,\n      type: params.type\n    });\n    const app = createApp({\n      render() {\n        return msg;\n      }\n    });\n    app.mount(dom);\n\n    const internalClose = () =&gt; {\n      msg.component?.exposed?.['closeMessage']?.();\n      app.unmount();\n      dom.remove();\n    };\n\n    let timer: number | null = null;\n    if (duration &gt; 0) {\n      timer = setTimeout(() =&gt; {\n        internalClose();\n      }, duration);\n    }\n\n    return {\n      close: () =&gt; {\n        if (timer) {\n          clearTimeout(timer);\n          timer = null;\n        }\n        internalClose();\n      }\n    };\n  }\n};\n\nexport default Message;\n\n</code></pre><p>最终可以这么来使用：</p><pre><code class=\"language-typescript\">import Message from './message';\n\n// 自动关闭\nMessage.open({\n  text: '这是一个success类型的消息提醒组件，5秒后自动关闭',\n  type: 'success',\n  duration: 5000\n})\n\n\n\nconst msg = Message.open({\n  text: '这是一个success类型的消息提醒组件，不会自动关闭',\n  type: 'success',\n  duration: 0\n})\n// 如果要关闭，就执行 msg.close() 来关闭这个组件\n\n</code></pre><p>至此，我们就已经学会了用动态渲染组件开发思路，来实现一个消息提示的功能组件Message。</p><p>不过到这儿，还没有大功告成。我们要做一个企业级项目，当然要按照企业级的用户体验来要求技术实现。不知道你有没有发现，我实现的这个Message组件，在显示消息和关闭消息过程中很突兀，<strong>消息突然显示和消失，组件变化中间没有过渡，给人一种不友好的用户体验</strong>。</p><p>这时候我们就需要用到动画过渡的效果，来消除组件显示和消失的突兀感觉，那在Vue.js 3.x组件开发中，如何来实现组件的动画效果呢？</p><h2>动态渲染组件的动画效果实现？</h2><p>Vue.js 3.x官方对组件动画过渡效果实现提供了一个内置的组件&lt;transition&gt;，这个组件使用起来比较简单，有JavaScript和CSS3两种控制动画的方式，我们就选择CSS3这个比较简单的动画过渡方式来实现。</p><p>你可以先看一下最终的功能效果，如下动图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/26/9e/263e3d6d1ed11ab7668c54bd2bcb779e.gif?wh=599x316\" alt=\"图片\"></p><p>基于上述的Message组件，我们可以加入&lt;transition&gt;内置组件来控制动画过渡。Vue相关代码调整为：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;Transition :name=\"fadeClassName\"&gt;\n    &lt;div v-if=\"show\" :class=\"{ [baseClassName]: true, [typeClassName]: true }\"&gt;\n      &lt;div&gt;{{ props.text }}&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/Transition&gt;\n&lt;/template&gt;\n\n&lt;script lang=\"ts\" setup&gt;\nimport { onMounted, ref } from 'vue';\nimport { prefixName } from '../theme/index';\nimport type { MessageType } from './types';\n\nconst show = ref&lt;boolean&gt;(false);\n\nonMounted(() =&gt; {\n  show.value = true;\n});\n\nconst props = withDefaults(\n  defineProps&lt;{\n    text?: string;\n    type?: MessageType;\n  }&gt;(),\n  {\n    type: 'info'\n  }\n);\n\nconst closeMessage = () =&gt; {\n  show.value = false;\n};\n\ndefineExpose&lt;{\n  closeMessage: () =&gt; void;\n}&gt;({ closeMessage: closeMessage });\n\nconst baseClassName = `${prefixName}-message`;\nconst typeClassName = `${baseClassName}-${props.type}`;\nconst fadeClassName = `${baseClassName}-fade`;\n&lt;/script&gt;\n\n</code></pre><p>针对&lt;transition&gt;组件的CSS3动画过渡样式，在Less文件中补充样式代码如下：</p><pre><code class=\"language-less\">.@{message-name}-fade-enter-active,\n.@{message-name}-fade-leave-active {\n  transition: opacity 0.5s ease;\n}\n\n.@{message-name}-fade-enter-from,\n.@{message-name}-fade-leave-to {\n  opacity: 0;\n}\n</code></pre><p>Vue.js 3.x 内置动画效果组件&lt;transition&gt;，结合CSS3实现动画过渡，<strong>核心原理就是在运行过程中，自动检查目标组件是否使用了CSS的过渡动画样式</strong>。如果使用了，会在适当的组件变化过程中添加或者删除对应的样式的className。</p><p>在&lt;transition&gt;基于CSS3动画样式实现的动画过渡效果中，真正实现过渡的动画效果是CSS3动画样式，内置的&lt;transition&gt;组件只是帮助开发者更加方便和合理地把握动画的执行时机（如果你还想了解更多Vue.js 3.x 动画效果的实现，可以参阅<a href=\"https://cn.vuejs.org/guide/extras/animation.html\">官方文档</a>）。</p><h2>如何实现一个动态Dialog组件？</h2><p>现在，看我们实现的 Message组件，你会发现只是显示消息提醒，没有任何交互操作。那么，动态渲染组件实现的功能组件，有哪些是既可以显示消息，又可以交互操作的呢？</p><p>我们最经常遇到的就是Dialog组件，也就是对话框组件。接下来我们就用动态渲染组件的开发思路来开发一个对话框组件。</p><p>实现动态Dialog组件前，我还是先给你看一下最终的功能效果，如下动图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/9b/9d/9ba06fe485a85cafea2958f9eb423e9d.gif?wh=600x381\" alt=\"图片\"></p><p>看了这个动图，是不是觉得很眼熟？没错，就是我们在第4节课中，用JSX语法实现的那个对话框组件。</p><p>上次我们是从JSX语法角度来分析实现过程，这节课我们再从动态渲染组件的角度来讲解这个实现过程，具体步骤如下：</p><ul>\n<li>第一步，实现Dialog的实体组件，用JSX语法或模板语法都可以。这里，Dialog组件要用Emit方式注册好回调事件；</li>\n<li>第二步，封装createDialog函数来创建一个Dialog的实例。这个过程要注意配置好Dialog的回调函数等操作；</li>\n<li>第三步，封装close函数来控制卸载关闭这个组件。</li>\n</ul><p>具体实现代码也跟第4课实现的代码一致，我把它再贴出来了，你可以再看看。这个是JSX实现的Dialog实体组件：</p><pre><code class=\"language-typescript\">// ./dialog.tsx\nimport { defineComponent } from 'vue';\nimport { prefixName } from '../theme/index';\n\nexport const DialogComponent = defineComponent({\n  props: {\n    text: String\n  },\n  emits: ['onOk'],\n  setup(props, context) {\n    const { emit } = context;\n    const onOk = () =&gt; {\n      emit('onOk');\n    };\n    return () =&gt; {\n      return (\n        &lt;div class={`${prefixName}-dialog-mask`}&gt;\n          &lt;div class={`${prefixName}-dialog`}&gt;\n            &lt;div class={`${prefixName}-dialog-text`}&gt;{props.text}&lt;/div&gt;\n            &lt;div class={`${prefixName}-dialog-footer`}&gt;\n              &lt;button class={`${prefixName}-dialog-btn`} onClick={onOk}&gt;\n                确定\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      );\n    };\n  }\n});\n</code></pre><p>以下是封装了函数方法调用的动态渲染组件的方式：</p><pre><code class=\"language-typescript\">import { createApp, h } from 'vue';\nimport { DialogComponent } from './dialog';\n\nfunction createDialog(params: { text: string; onOk: () =&gt; void }) {\n  const dom = document.createElement('div');\n  const body = document.querySelector('body') as HTMLBodyElement;\n  body.appendChild(dom);\n  const app = createApp({\n    render() {\n      return h(DialogComponent, {\n        text: params.text,\n        onOnOk: params.onOk\n      });\n    }\n  });\n  app.mount(dom);\n\n  return {\n    close: () =&gt; {\n      app.unmount();\n      dom.remove();\n    }\n  };\n}\n\nconst Dialog: { createDialog: typeof createDialog } = {\n  createDialog\n};\n\nexport default Dialog;\n</code></pre><p>最后你会发现，Dialog动态渲染组件和Message动态渲染组件，实现流程是类似的，核心是要用函数方法来控制组件的“动态挂载”和“动态卸载”。</p><h2>总结</h2><p>这节课核心内容就是Vue.js 3.x 动态渲染组件的实现思路，我再总结一下具体的实现步骤：</p><ul>\n<li>第一步：设计动态渲染组件的使用函数方法的API，API越简洁越好，核心是要控制组件渲染的挂载和卸载的生命周期；</li>\n<li>第二步：基于Vue.js 3.x 实现动态渲染组件的原理，核心是要在页面上动态创建DOM，再用Vue.js 3.x创建一个独立应用来“承载”这个组件，挂载在这个动态DOM上面；</li>\n<li>第三步：关闭动态组件时，要卸载这个Vue.js 3.x的“独立应用”，卸载完再销毁这个动态DOM。</li>\n</ul><p>在实现Vue.js 3.x 动态渲染组件的时候，还有几点需要你多加注意：</p><ul>\n<li>在组件的挂载和卸载过程中，尽量用Vue.js 3.x的内置&lt;transition&gt;组件来实现动画过渡效果，提升用户体验，减少组件动态显示和消失的突兀感觉。</li>\n<li>动态组件在关闭后，注意要记得销毁组件挂载的动态DOM，释放没必要的内存占用，减少内存泄漏的风险。</li>\n</ul><h2>思考题</h2><p>Vue.js 3.x 动态渲染组件是通过创建一个新的Vue.js应用来渲染组件的，跟页面原有的Vue.js应用是互相独立的，那么如何实现这两个Vue.js 应用的数据通信呢？</p><p>欢迎在留言区分享你的想法，参与讨论，如果对今天的内容有疑问，也欢迎留言，下节课见。</p><h3><a href=\"https://github.com/FE-star/vue3-course/tree/main/chapter/10\">完整的代码在这里</a></h3>","neighbors":{"left":{"article_title":"09｜主题方案和基础组件：如何设计组件库的主题方案？","id":611229},"right":{"article_title":"11｜布局组件：如何实现自研组件库的布局方案？","id":611267}},"comments":[{"had_liked":false,"id":364727,"user_name":"初烬","can_delete":false,"product_type":"c1","uid":1507277,"ip_address":"陕西","ucode":"7ED4A301A7CC11","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/rUqhSN2OVg5aHw10Hxib61nGv1SXxD6zowFl27oSm9Y6g8grRpTxCxwk7qg14a1TtmpzMTM2y810MnibBhwn75Mg/132","comment_is_top":false,"comment_ctime":1671419485,"is_pvip":false,"replies":[{"id":134991,"content":"您好，Vue.js动态渲染组件有很多种实现方式，本课是用最简单的方式来实现，方便课程讲解。但又由于篇幅有限，不能把大部分动态渲染组件的实现方式都一一列举出来。\n如果你熟悉Teleport来实现动态渲染，那也是可以实现的，只不过要多学习和理解一个新的API。","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1678624431,"ip_address":"浙江","comment_id":364727,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"老师，你好问一下，这边为什么在挂载dom的时候选择createApp。而不是是用telport","like_count":1,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608721,"discussion_content":"您好，Vue.js动态渲染组件有很多种实现方式，本课是用最简单的方式来实现，方便课程讲解。但又由于篇幅有限，不能把大部分动态渲染组件的实现方式都一一列举出来。\n如果你熟悉Teleport来实现动态渲染，那也是可以实现的，只不过要多学习和理解一个新的API。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678624431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368893,"user_name":"刘大夫","can_delete":false,"product_type":"c1","uid":1707726,"ip_address":"北京","ucode":"B03DCF41E50ADF","user_header":"https://static001.geekbang.org/account/avatar/00/1a/0e/ce/1e02a513.jpg","comment_is_top":false,"comment_ctime":1676873808,"is_pvip":false,"replies":[{"id":134950,"content":"您好，你可以参考一下Vue.js的官方文档  https:&#47;&#47;v3-migration.vuejs.org&#47;breaking-changes&#47;listeners-removed.html  ","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1678523417,"ip_address":"浙江","comment_id":368893,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"前辈您好，想问一下，在 vue3 中，想实现 vue2 里动态组件 component 和 v-bind=&quot;$listeners&quot;  的功能该怎么做呢，我看文档，component 被划到了选项式 api 的范畴，那用组合式 api 的方式，该怎么去实现呀","like_count":0,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608566,"discussion_content":"您好，你可以参考一下Vue.js的官方文档  https://v3-migration.vuejs.org/breaking-changes/listeners-removed.html  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678523417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366651,"user_name":"Anne","can_delete":false,"product_type":"c1","uid":1232726,"ip_address":"江苏","ucode":"3BCA6E29CD5FA7","user_header":"https://static001.geekbang.org/account/avatar/00/12/cf/56/eb1e7efc.jpg","comment_is_top":false,"comment_ctime":1674013275,"is_pvip":false,"replies":[{"id":134964,"content":"您好，请问您指的是 “例如ant design vue组件库在主副应用的共用场景” 吗？\n\n如果是这种场景，可以考虑将“公共组件库”在编译配置中external出来，变成全局变量共用。","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1678527099,"ip_address":"浙江","comment_id":366651,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"有个问题请老师解惑，多个应用实例之间数据能否共享，如何共享？比如主应用引入ant design vue组件库，副应用如何共享使用？\n","like_count":0,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608584,"discussion_content":"您好，请问您指的是 “例如ant design vue组件库在主副应用的共用场景” 吗？\n\n如果是这种场景，可以考虑将“公共组件库”在编译配置中external出来，变成全局变量共用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678527099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365897,"user_name":"沧海一粟","can_delete":false,"product_type":"c1","uid":1888132,"ip_address":"广东","ucode":"BCE5E620210B84","user_header":"https://static001.geekbang.org/account/avatar/00/1c/cf/84/88a54107.jpg","comment_is_top":false,"comment_ctime":1673186269,"is_pvip":false,"replies":[{"id":134971,"content":"您好，创建应用实例是可以提供一个container去自定义挂载的DOM。本课中动态创建div挂载在body上只是方便内容讲解，不是绝对的解决方案，你也可以灵活设置一个container去挂载实例。","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1678611832,"ip_address":"浙江","comment_id":365897,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"在创建应用实例的时候为啥不直接使用要作为根组件的而是要多包一层组件","like_count":0,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608688,"discussion_content":"您好，创建应用实例是可以提供一个container去自定义挂载的DOM。本课中动态创建div挂载在body上只是方便内容讲解，不是绝对的解决方案，你也可以灵活设置一个container去挂载实例。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678611833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365250,"user_name":"珍爱学习账号","can_delete":false,"product_type":"c1","uid":3023043,"ip_address":"日本","ucode":"C58CA2A757AD7A","user_header":"","comment_is_top":false,"comment_ctime":1672300968,"is_pvip":false,"replies":[{"id":134975,"content":"您好，谢谢指正，这个案例和Dialog代码混在一起了。","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1678612559,"ip_address":"浙江","comment_id":365250,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"整个过程，我们可以用最简单的 Vue.js 3.x 代码实现：\n下面这段代码\nh(DialogComponent, {}); } });\n应该h(ModuleComponent, {}); } });\n搞混了。","like_count":0,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608692,"discussion_content":"您好，谢谢指正，这个案例和Dialog代码混在一起了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678612559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365093,"user_name":"文艺理科生","can_delete":false,"product_type":"c1","uid":1625271,"ip_address":"北京","ucode":"ECEBE56833156D","user_header":"https://static001.geekbang.org/account/avatar/00/18/cc/b7/c9ec5b8c.jpg","comment_is_top":false,"comment_ctime":1672102906,"is_pvip":false,"replies":[{"id":134980,"content":"您好，是的，很多成熟的组件库是封装了Popper组件来承载“浮层”的功能，然后再基于Popper组件来扩展Dialog等浮层相关组件。","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1678613771,"ip_address":"浙江","comment_id":365093,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"如果写一个成熟的弹窗组件是不太容易的，可以参考popper js，简单的一个组件，做了很多事情","like_count":0,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608697,"discussion_content":"您好，是的，很多成熟的组件库是封装了Popper组件来承载“浮层”的功能，然后再基于Popper组件来扩展Dialog等浮层相关组件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678613771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365061,"user_name":"ZR-rd","can_delete":false,"product_type":"c1","uid":2076199,"ip_address":"北京","ucode":"427E69255F30D8","user_header":"https://static001.geekbang.org/account/avatar/00/1f/ae/27/74828c37.jpg","comment_is_top":false,"comment_ctime":1672045675,"is_pvip":false,"replies":[{"id":133516,"content":"通过封装不同的入口就可以了","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1673771046,"ip_address":"浙江","comment_id":365061,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"请问下老师，Dialog 组件一般还可以通过声明组件的方式使用，通过 visible 属性控制显示，如何做到这两者都支持呢","like_count":0,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599752,"discussion_content":"通过封装不同的入口就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673771046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364629,"user_name":"癡癡的等你歸","can_delete":false,"product_type":"c1","uid":1334321,"ip_address":"浙江","ucode":"AF950FDE0C736C","user_header":"https://static001.geekbang.org/account/avatar/00/14/5c/31/d7b92b6b.jpg","comment_is_top":false,"comment_ctime":1671239871,"is_pvip":false,"replies":[{"id":134994,"content":"您好，这个技术角度也是可以实现的。","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1678624765,"ip_address":"浙江","comment_id":364629,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"数据通信我觉得应该是通过参数传入和方法传出，当成一个普通的组件一样使用吧。","like_count":0,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608724,"discussion_content":"您好，这个技术角度也是可以实现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678624766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394060,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1725686085,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100311101,"comment_content":"学习打卡","like_count":0},{"had_liked":false,"id":364685,"user_name":"WGH丶","can_delete":false,"product_type":"c1","uid":1922568,"ip_address":"陕西","ucode":"02E43256770C62","user_header":"https://static001.geekbang.org/account/avatar/00/1d/56/08/bd75f114.jpg","comment_is_top":false,"comment_ctime":1671335529,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"妙啊，我之前也搞过动态渲染组件，今天一看，很多考虑不周。学到很多，给作者打call~\n\n本期思考题：\n\n函数很容易实现相互通信，调用时可以通过函数参数传递信息。动态组件可以暴露一些回调函数来包装好数据，让调用组件获取即可。","like_count":0}]}