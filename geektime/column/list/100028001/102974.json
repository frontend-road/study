{"id":102974,"title":"16 | 多线程调优（下）：如何优化多线程上下文切换？","content":"<p>你好，我是刘超。</p><p>通过上一讲的讲解，相信你对上下文切换已经有了一定的了解了。如果是单个线程，在 CPU 调用之后，那么它基本上是不会被调度出去的。如果可运行的线程数远大于 CPU 数量，那么操作系统最终会将某个正在运行的线程调度出来，从而使其它线程能够使用 CPU ，这就会导致上下文切换。</p><p>还有，在多线程中如果使用了竞争锁，当线程由于等待竞争锁而被阻塞时，JVM 通常会将这个线程挂起，并允许它被交换出去。如果频繁地发生阻塞，CPU 密集型的程序就会发生更多的上下文切换。</p><p>那么问题来了，我们知道在某些场景下使用多线程是非常必要的，但多线程编程给系统带来了上下文切换，从而增加的性能开销也是实打实存在的。那么我们该如何优化多线程上下文切换呢？这就是我今天要和你分享的话题，我将重点介绍几种常见的优化方法。</p><h2>竞争锁优化</h2><p>大多数人在多线程编程中碰到性能问题，第一反应多是想到了锁。</p><p>多线程对锁资源的竞争会引起上下文切换，还有锁竞争导致的线程阻塞越多，上下文切换就越频繁，系统的性能开销也就越大。由此可见，<span class=\"orange\">在多线程编程中，锁其实不是性能开销的根源，竞争锁才是。</span></p><p>第11～13讲中我曾集中讲过锁优化，我们知道锁的优化归根结底就是减少竞争。这讲中我们就再来总结下锁优化的一些方式。</p><!-- [[[read_end]]] --><h3>1.减少锁的持有时间</h3><p>我们知道，锁的持有时间越长，就意味着有越多的线程在等待该竞争资源释放。如果是Synchronized同步锁资源，就不仅是带来线程间的上下文切换，还有可能会增加进程间的上下文切换。</p><p>在第12讲中，我曾分享过一些更具体的方法，例如，可以将一些与锁无关的代码移出同步代码块，尤其是那些开销较大的操作以及可能被阻塞的操作。</p><ul>\n<li>优化前</li>\n</ul><pre><code>public synchronized void mySyncMethod(){  \n        businesscode1();  \n        mutextMethod();  \n        businesscode2();\n    }\n</code></pre><ul>\n<li>优化后</li>\n</ul><pre><code>public void mySyncMethod(){  \n        businesscode1();  \n        synchronized(this)\n        {\n            mutextMethod();  \n        }\n        businesscode2();\n    }\n</code></pre><h3>2.降低锁的粒度</h3><p>同步锁可以保证对象的原子性，<span class=\"orange\">我们可以考虑将锁粒度拆分得更小一些，以此避免所有线程对一个锁资源的竞争过于激烈。</span>具体方式有以下两种：</p><ul>\n<li>锁分离</li>\n</ul><p>与传统锁不同的是，读写锁实现了锁分离，也就是说读写锁是由“读锁”和“写锁”两个锁实现的，其规则是可以共享读，但只有一个写。</p><p>这样做的好处是，在多线程读的时候，读读是不互斥的，读写是互斥的，写写是互斥的。而传统的独占锁在没有区分读写锁的时候，读写操作一般是：读读互斥、读写互斥、写写互斥。所以在读远大于写的多线程场景中，锁分离避免了在高并发读情况下的资源竞争，从而避免了上下文切换。</p><ul>\n<li>锁分段</li>\n</ul><p>我们在使用锁来保证集合或者大对象原子性时，可以考虑将锁对象进一步分解。例如，我之前讲过的 Java1.8 之前版本的 ConcurrentHashMap 就使用了锁分段。</p><h3>3.非阻塞乐观锁替代竞争锁</h3><p>volatile关键字的作用是保障可见性及有序性，volatile的读写操作不会导致上下文切换，因此开销比较小。 但是，volatile不能保证操作变量的原子性，因为没有锁的排他性。</p><p>而 CAS 是一个原子的 if-then-act 操作，<span class=\"orange\">CAS 是一个无锁算法实现，保障了对一个共享变量读写操作的一致性。</span>CAS 操作中有 3 个操作数，内存值 V、旧的预期值 A和要修改的新值 B，当且仅当 A 和 V 相同时，将 V 修改为 B，否则什么都不做，CAS 算法将不会导致上下文切换。Java 的 Atomic 包就使用了 CAS 算法来更新数据，就不需要额外加锁。</p><p>上面我们了解了如何从编码层面去优化竞争锁，那么除此之外，JVM内部其实也对Synchronized同步锁做了优化，我在12讲中有详细地讲解过，这里简单回顾一下。</p><p>在JDK1.6中，JVM将Synchronized同步锁分为了偏向锁、轻量级锁、自旋锁以及重量级锁，优化路径也是按照以上顺序进行。JIT 编译器在动态编译同步块的时候，也会通过锁消除、锁粗化的方式来优化该同步锁。</p><h2>wait/notify优化</h2><p>在 Java 中，我们可以通过配合调用 Object 对象的 wait()方法和 notify()方法或 notifyAll() 方法来实现线程间的通信。</p><p>在线程中调用 wait()方法，将阻塞等待其它线程的通知（其它线程调用notify()方法或notifyAll()方法），在线程中调用 notify()方法或 notifyAll()方法，将通知其它线程从 wait()方法处返回。</p><p>下面我们通过wait() / notify()来实现一个简单的生产者和消费者的案例，代码如下：</p><pre><code>public class WaitNotifyTest {\n    public static void main(String[] args) {\n        Vector&lt;Integer&gt; pool=new Vector&lt;Integer&gt;();\n        Producer producer=new Producer(pool, 10);\n        Consumer consumer=new Consumer(pool);\n        new Thread(producer).start();\n        new Thread(consumer).start();\n    }\n}\n\t/**\n\t * 生产者\n\t * @author admin\n\t *\n\t */\n\tclass Producer implements Runnable{\n\t    private Vector&lt;Integer&gt; pool;\n\t    private Integer size;\n\t    \n\t    public Producer(Vector&lt;Integer&gt;  pool, Integer size) {\n\t        this.pool = pool;\n\t        this.size = size;\n\t    }\n\t    \n\t    public void run() {\n\t        for(;;){\n\t            try {\n\t                System.out.println(&quot;生产一个商品 &quot;);\n\t                produce(1);\n\t            } catch (InterruptedException e) {\n\t                // TODO Auto-generated catch block\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t    }\n\t    private void produce(int i) throws InterruptedException{\n\t        while(pool.size()==size){\n\t            synchronized (pool) {\n\t                System.out.println(&quot;生产者等待消费者消费商品,当前商品数量为&quot;+pool.size());\n\t                pool.wait();//等待消费者消费\n\t            }\n\t        }\n\t        synchronized (pool) {\n\t            pool.add(i);\n\t            pool.notifyAll();//生产成功，通知消费者消费\n\t        }\n\t    }\n\t}\n\n\n\t/**\n\t * 消费者\n\t * @author admin\n\t *\n\t */\n\tclass Consumer implements Runnable{\n\t    private Vector&lt;Integer&gt;  pool;\n\t    public Consumer(Vector&lt;Integer&gt;  pool) {\n\t        this.pool = pool;\n\t    }\n\t    \n\t    public void run() {\n\t        for(;;){\n\t            try {\n\t                System.out.println(&quot;消费一个商品&quot;);\n\t                consume();\n\t            } catch (InterruptedException e) {\n\t                // TODO Auto-generated catch block\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t    }\n\t    \n\t    private void consume() throws InterruptedException{\n\t        synchronized (pool) {\n\t            while(pool.isEmpty()) {\n\t                System.out.println(&quot;消费者等待生产者生产商品,当前商品数量为&quot;+pool.size());\n\t                pool.wait();//等待生产者生产商品\n\t            }\n\t        }\n\t        synchronized (pool) {\n\t            pool.remove(0);\n\t            pool.notifyAll();//通知生产者生产商品\n\t            \n\t        }\n\t    }\n\n}\n</code></pre><h3>wait/notify的使用导致了较多的上下文切换</h3><p>结合以下图片，我们可以看到，在消费者第一次申请到锁之前，发现没有商品消费，此时会执行 Object.wait() 方法，这里会导致线程挂起，进入阻塞状态，这里为一次上下文切换。</p><p>当生产者获取到锁并执行notifyAll()之后，会唤醒处于阻塞状态的消费者线程，此时这里又发生了一次上下文切换。</p><p>被唤醒的等待线程在继续运行时，需要再次申请相应对象的内部锁，此时等待线程可能需要和其它新来的活跃线程争用内部锁，这也可能会导致上下文切换。</p><p>如果有多个消费者线程同时被阻塞，用notifyAll()方法，将会唤醒所有阻塞的线程。而某些商品依然没有库存，过早地唤醒这些没有库存的商品的消费线程，可能会导致线程再次进入阻塞状态，从而引起不必要的上下文切换。</p><p><img src=\"https://static001.geekbang.org/resource/image/60/0a/601517ef35af63a9e470b8531124bc0a.jpg?wh=1324*1210\" alt=\"\"></p><h3>优化wait/notify的使用，减少上下文切换</h3><p>首先，我们在多个不同消费场景中，可以使用 Object.notify() 替代 Object.notifyAll()。 因为Object.notify() 只会唤醒指定线程，不会过早地唤醒其它未满足需求的阻塞线程，所以可以减少相应的上下文切换。</p><p>其次，在生产者执行完 Object.notify() / notifyAll()唤醒其它线程之后，应该尽快地释放内部锁，以避免其它线程在唤醒之后长时间地持有锁处理业务操作，这样可以避免被唤醒的线程再次申请相应内部锁的时候等待锁的释放。</p><p>最后，为了避免长时间等待，我们常会使用Object.wait (long）设置等待超时时间，但线程无法区分其返回是由于等待超时还是被通知线程唤醒，从而导致线程再次尝试获取锁操作，增加了上下文切换。</p><p>这里我建议使用Lock锁结合Condition 接口替代Synchronized内部锁中的 wait / notify，实现等待／通知。这样做不仅可以解决上述的Object.wait(long) 无法区分的问题，还可以解决线程被过早唤醒的问题。</p><p>Condition 接口定义的 await 方法 、signal 方法和 signalAll 方法分别相当于 Object.wait()、 Object.notify()和 Object.notifyAll()。</p><h2>合理地设置线程池大小，避免创建过多线程</h2><p><span class=\"orange\">线程池的线程数量设置不宜过大，</span>因为一旦线程池的工作线程总数超过系统所拥有的处理器数量，就会导致过多的上下文切换。更多关于如何合理设置线程池数量的内容，我将在第18讲中详解。</p><p>还有一种情况就是，在有些创建线程池的方法里，线程数量设置不会直接暴露给我们。比如，用 Executors.newCachedThreadPool() 创建的线程池，该线程池会复用其内部空闲的线程来处理新提交的任务，如果没有，再创建新的线程（不受 MAX_VALUE 限制），这样的线程池如果碰到大量且耗时长的任务场景，就会创建非常多的工作线程，从而导致频繁的上下文切换。因此，这类线程池就只适合处理大量且耗时短的非阻塞任务。</p><h2>使用协程实现非阻塞等待</h2><p>相信很多人一听到协程（Coroutines），马上想到的就是Go语言。协程对于大部分 Java 程序员来说可能还有点陌生，但其在 Go 中的使用相对来说已经很成熟了。</p><p>协程是一种比线程更加轻量级的东西，相比于由操作系统内核来管理的进程和线程，<span class=\"orange\">协程则完全由程序本身所控制，也就是在用户态执行。</span>协程避免了像线程切换那样产生的上下文切换，在性能方面得到了很大的提升。协程在多线程业务上的运用，我会在第18讲中详述。</p><h2>减少Java虚拟机的垃圾回收</h2><p>我们在上一讲讲上下文切换的诱因时，曾提到过“垃圾回收会导致上下文切换”。</p><p>很多 JVM 垃圾回收器（serial收集器、ParNew收集器）在回收旧对象时，会产生内存碎片，从而需要进行内存整理，在这个过程中就需要移动存活的对象。而移动内存对象就意味着这些对象所在的内存地址会发生变化，因此在移动对象前需要暂停线程，在移动完成后需要再次唤醒该线程。因此减少 JVM 垃圾回收的频率可以有效地减少上下文切换。</p><h2>总结</h2><p>上下文切换是多线程编程性能消耗的原因之一，而竞争锁、线程间的通信以及过多地创建线程等多线程编程操作，都会给系统带来上下文切换。除此之外，I/O阻塞以及JVM的垃圾回收也会增加上下文切换。</p><p>总的来说，过于频繁的上下文切换会影响系统的性能，所以我们应该避免它。另外，<span class=\"orange\">我们还可以将上下文切换也作为系统的性能参考指标，并将该指标纳入到服务性能监控，防患于未然。</span></p><h2>思考题</h2><p>除了我总结中提到的线程间上下文切换的一些诱因，你还知道其它诱因吗？对应的优化方法又是什么？</p><p>期待在留言区看到你的分享。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。</p><p><img src=\"https://static001.geekbang.org/resource/image/bb/67/bbe343640d6b708832c4133ec53ed967.jpg?wh=1110*659\" alt=\"unpreview\"></p>","comments":[{"had_liked":false,"id":106953,"user_name":"Geek_1f1a07","can_delete":false,"product_type":"c1","uid":1292406,"ip_address":"","ucode":"9C42A5B796AEDA","user_header":"https://static001.geekbang.org/account/avatar/00/13/b8/76/6f0c39c2.jpg","comment_is_top":false,"comment_ctime":1561428575,"is_pvip":false,"replies":[{"id":"38848","content":"回答很好，赞一个。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561518983,"ip_address":"","comment_id":106953,"utype":1}],"discussion_count":1,"race_medal":0,"score":"229194695263","product_id":100028001,"comment_content":"Zed说的不对，首先，所有的锁，无论synchronize还是lock，如果发生竞争条件，都可能造成上下文切换，优化锁的目的是为了尽量降低发生锁竞争的概率，synchronize做的优化都是把竞争的可能消灭在前期的偏向锁，轻量级锁，把会造成上下文切换的“脏活”留在最后。lock的乐观锁大体思路也是一样的，不到万不得已，不会轻易调用park方法。但是本质上java目前都是利用内核线程，所以都会有上下文切换。除非使用协程的技术，这个以前有green thread，后来不用了，期待老师后面对协程的讲解。","like_count":54,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455299,"discussion_content":"回答很好，赞一个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561518983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135074,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1568996799,"is_pvip":false,"replies":[{"id":"51865","content":"volatile主要是用来保证共享变量额可见性，以及防止指令重排序，保证执行的有序性。<br><br>通过生成.class文件之后，反编译文件我们可以看到通过volatile修饰的共享变量，在写入操作的时候会多一个Lock前缀这样的指令，当操作系统执行时会由于这个指令，将当前处理器缓存的数据写回系统内存中，并通知其他处理器中的缓存失效。<br><br>所以volatile不会带来线程的挂起操作，不会导致上下文切换。<br><br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569052490,"ip_address":"","comment_id":135074,"utype":1}],"discussion_count":1,"race_medal":0,"score":"74583440831","product_id":100028001,"comment_content":"volitile的读写不会导致上下文切换，操作系统层面怎么理解呢","like_count":17,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468032,"discussion_content":"volatile主要是用来保证共享变量额可见性，以及防止指令重排序，保证执行的有序性。\n\n通过生成.class文件之后，反编译文件我们可以看到通过volatile修饰的共享变量，在写入操作的时候会多一个Lock前缀这样的指令，当操作系统执行时会由于这个指令，将当前处理器缓存的数据写回系统内存中，并通知其他处理器中的缓存失效。\n\n所以volatile不会带来线程的挂起操作，不会导致上下文切换。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569052490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106916,"user_name":"Zed","can_delete":false,"product_type":"c1","uid":1184951,"ip_address":"","ucode":"09947C76F55A46","user_header":"https://static001.geekbang.org/account/avatar/00/12/14/b7/bb6a1fd4.jpg","comment_is_top":false,"comment_ctime":1561424794,"is_pvip":false,"replies":[{"id":"38846","content":"回答很好。线程进入阻塞，两者都会发生进程上下文切换。Synchronized中阻塞线程无论何时去获取锁，都需要进入到内核态，而AQS中，阻塞线程再次获取锁时，是通过state以及CAS操作判断，只有没有竞争成功时，才会再次被挂起，这样可以尽量减少上下文切换。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561518114,"ip_address":"","comment_id":106916,"utype":1}],"discussion_count":1,"race_medal":0,"score":"65985934234","product_id":100028001,"comment_content":"回答趙衍同学<br><br>如你所说，synchronized主要是因为有用户态和内核态的交互所以能到进程级别。<br><br>而Lock是通过AQS的state状态来判断是否持有锁，整个过程都是在用户态或者说纯java实现。<br><br>最后lock.await()也是把当前线程放到当前条件变量的等待队列中并让出cpu。顺便提下，lock支持多条件变量。","like_count":15,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455280,"discussion_content":"回答很好。线程进入阻塞，两者都会发生进程上下文切换。Synchronized中阻塞线程无论何时去获取锁，都需要进入到内核态，而AQS中，阻塞线程再次获取锁时，是通过state以及CAS操作判断，只有没有竞争成功时，才会再次被挂起，这样可以尽量减少上下文切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561518114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107205,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1561479684,"is_pvip":false,"replies":[{"id":"38807","content":"notify()可以结合wait（long）方法使用，解决某些没有通知的线程被通知不到的问题","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561512320,"ip_address":"","comment_id":107205,"utype":1}],"discussion_count":3,"race_medal":0,"score":"53101087236","product_id":100028001,"comment_content":"我觉得有些人建议使用notifyall的原因是使用notify需要有十足的把握去确认哪条线程需要唤醒，因为一不留神就容易搞错，为了优化而优化最后事倍功半，所以大家才会使用notifyall一劳永逸，我其实挺认同老师的观点，老师，全部唤醒会导致更多的上下文切换，是否要优化这点，我觉得还是得看个人了吧😂","like_count":13,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455416,"discussion_content":"notify()可以结合wait（long）方法使用，解决某些没有通知的线程被通知不到的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561512320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1086568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/94/68/56794ea3.jpg","nickname":"Kian.Lee","note":"","ucode":"3FB08A00F2DFD7","race_medal":5,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3285,"discussion_content":"只是关注点不同而已，隔壁王宝令老师的并发编程专栏推荐的是尽量用notifyAll代替notify，主要考虑的是安全性，因为系统同一功能不同时期的代码可能是不一样，可能开发者不一样或依赖的三方库代码不一样，那么可能安全就是第一位的，毕竟有些变化是当前不可预测的。刘超老师说notity 代替notifyAll主要考虑的是性能优先，在他的情景下也是合理的。notifyAll也不是为了优化而优化😁，如何抉择还是要看自己的应用场景。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1564375485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006789,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg","nickname":"梁中华","note":"","ucode":"52FE40242CBAD0","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422,"discussion_content":"应该是只有要进入running的线程才需要把各种暂存的上线文信息调入吧，其他被notify的线程虽然被唤醒了，也只进入runnable状态, 并不会导致实质的上线文切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561542192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107121,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1561462918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48806103174","product_id":100028001,"comment_content":"老师请问一下在一段程序中除了工作线程之外还有很多守护线程, 这些线程加起来的数量必然比cup的数量会多很多, 那么为什么创建线程池的时候要参考CPU的数量呢, 为什么不把守护线程也考虑进去呢?","like_count":12},{"had_liked":false,"id":106847,"user_name":"你好旅行者","can_delete":false,"product_type":"c1","uid":1154101,"ip_address":"","ucode":"5C72A428DC28F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/35/9dc79371.jpg","comment_is_top":false,"comment_ctime":1561397753,"is_pvip":false,"replies":[{"id":"38845","content":"AQS挂起是通过LockSupport中的park进入阻塞状态，这个过程也是存在进程上下文切换的。但被阻塞的线程再次获取锁时，不会产生进程上下文切换，而synchronized阻塞的线程每次获取锁资源都要通过系统调用内核来完成，这样就比AQS阻塞的线程更消耗系统资源了。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561518004,"ip_address":"","comment_id":106847,"utype":1}],"discussion_count":2,"race_medal":0,"score":"44511070713","product_id":100028001,"comment_content":"老师好！在synchronized中，“挂起”这个动作是由JVM来实现的，获取不到锁的线程会被迫让出CPU，由于synchronized是基于操作系统的mutex机制，所以会产生进程的上下文切换。我想请问老师，在JDK的Lock中，或者AQS中，线程“挂起”这个动作又是怎么实现的呢？为什么不会产生进程级别的上下文切换呢？","like_count":10,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455252,"discussion_content":"AQS挂起是通过LockSupport中的park进入阻塞状态，这个过程也是存在进程上下文切换的。但被阻塞的线程再次获取锁时，不会产生进程上下文切换，而synchronized阻塞的线程每次获取锁资源都要通过系统调用内核来完成，这样就比AQS阻塞的线程更消耗系统资源了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561518004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2311463,"avatar":"https://static001.geekbang.org/account/avatar/00/23/45/27/4fbf8f6a.jpg","nickname":"luke Y","note":"","ucode":"111F98D367235B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369176,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618967789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164019,"user_name":"td901105","can_delete":false,"product_type":"c1","uid":1348830,"ip_address":"","ucode":"32D42A4F36FA02","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/SM4fwn9uFicXU8cQ1rNF2LQdKNbZI1FX1jmdwaE2MTrBawbugj4TQKjMKWG0sGbmqQickyARXZFS8NZtobvoWTHA/132","comment_is_top":false,"comment_ctime":1576846890,"is_pvip":false,"replies":[{"id":"62975","content":"一样会有，相对同步锁来说，只是减少了用户态和内核态的切换。Lock锁被阻塞的线程再次获取锁时，不会产生进程上下文切换，而synchronized阻塞的线程每次获取锁资源都要通过系统调用内核来完成。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1577187101,"ip_address":"","comment_id":164019,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23051683370","product_id":100028001,"comment_content":"老师,是不是使用Lock锁机制不会有用户态和内核态的切换?还是Lock本身锁机制是不涉及用户态到内核态的切换的,只是在未获取锁的时候需要使用内核态的方法比如park方法进行线程的挂起?","like_count":5,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478619,"discussion_content":"一样会有，相对同步锁来说，只是减少了用户态和内核态的切换。Lock锁被阻塞的线程再次获取锁时，不会产生进程上下文切换，而synchronized阻塞的线程每次获取锁资源都要通过系统调用内核来完成。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577187101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115825,"user_name":"K","can_delete":false,"product_type":"c1","uid":1118374,"ip_address":"","ucode":"69831D1EFC083C","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/a6/4d2c933e.jpg","comment_is_top":false,"comment_ctime":1563755547,"is_pvip":false,"replies":[{"id":"42713","content":"这里的vector是一个对象锁，锁的是一个代码块，并不是保证vector的线程安全。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563932840,"ip_address":"","comment_id":115825,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23038592027","product_id":100028001,"comment_content":"老师好，我有个特别简单的小问题不太明白。既然用了vector，为什么还要用synchronize锁起来啊，vector本身不就是线程安全的？谢谢老师回答。","like_count":5,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459301,"discussion_content":"这里的vector是一个对象锁，锁的是一个代码块，并不是保证vector的线程安全。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563932840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2664121,"avatar":"https://static001.geekbang.org/account/avatar/00/28/a6/b9/6bdaf8ce.jpg","nickname":"rich_li","note":"","ucode":"B82495DDC942DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405579,"discussion_content":"vector 只是保证自身的线程安全，而无法保证这整个代码块","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634605133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107936,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1561636249,"is_pvip":false,"replies":[{"id":"39187","content":"一个JVM在操作系统中只有一个进程，这里指的是进程中的某个运行的线程停止使用CPU，切换到内核获取CPU运行，而不是说停止JVM，然后运行内核。这里的切换是用户态使用CPU切换到了内核态使用CPU。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561691332,"ip_address":"","comment_id":107936,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23036472729","product_id":100028001,"comment_content":"老师请问一下, JVM在操作系统层面是一个进程还是多个进程, 如果是一个进程的话, 那synchronize和park()方法发生的是进程级别的状态切换的话是指操作系统不运行JVM了吗?","like_count":5,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455754,"discussion_content":"一个JVM在操作系统中只有一个进程，这里指的是进程中的某个运行的线程停止使用CPU，切换到内核获取CPU运行，而不是说停止JVM，然后运行内核。这里的切换是用户态使用CPU切换到了内核态使用CPU。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561691332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107145,"user_name":"皮皮","can_delete":false,"product_type":"c1","uid":1156624,"ip_address":"","ucode":"D692CFAA982137","user_header":"https://static001.geekbang.org/account/avatar/00/11/a6/10/3ff2e1a5.jpg","comment_is_top":false,"comment_ctime":1561467137,"is_pvip":true,"replies":[{"id":"38847","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561518531,"ip_address":"","comment_id":107145,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18741336321","product_id":100028001,"comment_content":"老师您好，一直有个疑问想请教，就是JDK1.5引入的lock锁底层实现也是调用了lockhelper的park和unpark方法，这个是否也涉及到系统的上下文切换，用户态和内核态的切换？","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455384,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561518531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109505,"user_name":"奇奇","can_delete":false,"product_type":"c1","uid":1399097,"ip_address":"","ucode":"BC86B0CB55E35A","user_header":"","comment_is_top":false,"comment_ctime":1562046814,"is_pvip":true,"replies":[{"id":"39772","content":"同学你好！后面有个锁，不会同时进去remove。如有疑问，可继续留言。","user_name":"编辑回复","user_name_real":"王冬青","uid":"1356014","ctime":1562116711,"ip_address":"","comment_id":109505,"utype":2}],"discussion_count":1,"race_medal":0,"score":"14446948702","product_id":100028001,"comment_content":"代码写错了<br>while(pool.isEmpty())不能放在同步代码块的外面<br>假设此时pool不为空容量为1，此时10个线程的pool.isEmpty都为false，此时全部跳出循环。<br>全部执行pool.remove(0) 错误","like_count":3,"discussions":[{"author":{"id":1356014,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b0/ee/d0871efd.jpg","nickname":"冬青","note":"","ucode":"14576781B499FB","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456442,"discussion_content":"同学你好！后面有个锁，不会同时进去remove。如有疑问，可继续留言。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562116711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106863,"user_name":"ヾ(◍°∇°◍)ﾉﾞ","can_delete":false,"product_type":"c1","uid":1044175,"ip_address":"","ucode":"89545632BDA56E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOBwR7MCVqwZbPA5RQ2mjUjd571jUXUcBCE7lY5vSMibWn8D5S4PzDZMaAhRPdnRBqYbVOBTJibhJg/132","comment_is_top":false,"comment_ctime":1561417919,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14446319807","product_id":100028001,"comment_content":"多个软件共同运行也有可能导致上下文切换，有些软件考虑使用绑定固定cpu核方式运行","like_count":3},{"had_liked":false,"id":107477,"user_name":"梁中华","can_delete":false,"product_type":"c1","uid":1006789,"ip_address":"","ucode":"52FE40242CBAD0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg","comment_is_top":false,"comment_ctime":1561542541,"is_pvip":true,"replies":[{"id":"39207","content":"年轻代是部分对象复制过程，是不会存在stop the world的发生。如果存在对象移动，使用对象的线程是会被挂起的，这个过程存在上下文切换。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561694279,"ip_address":"","comment_id":107477,"utype":1}],"discussion_count":2,"race_medal":1,"score":"10151477133","product_id":100028001,"comment_content":"原文：“而移动内存对象就意味着这些对象所在的内存地址会发生变化，因此在移动对象前需要暂停线程，在移动完成后需要再次唤醒该线程”。 这句话是不是不太严密？每次ygc都会导致年轻代内存地址变化，这也会导致暂停线程吗？如果是的话，那线程切换也太频繁了，似乎和事实不符啊。 ","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455526,"discussion_content":"年轻代是部分对象复制过程，是不会存在stop the world的发生。如果存在对象移动，使用对象的线程是会被挂起的，这个过程存在上下文切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561694279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2080531,"avatar":"","nickname":"Geek_315d30","note":"","ucode":"B24DD20A180027","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552029,"discussion_content":"老师，还是不明白啊，不管是对象移动还是复制，对象的地址都会发生变化，按照文中的说话，岂不是都会引起线程切换","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645238987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134655,"user_name":"Young","can_delete":false,"product_type":"c1","uid":1619635,"ip_address":"","ucode":"B6CD7E4CF3220D","user_header":"https://static001.geekbang.org/account/avatar/00/18/b6/b3/f626885f.jpg","comment_is_top":false,"comment_ctime":1568886900,"is_pvip":true,"replies":[{"id":"51648","content":"wait是在锁代码块里面，所以一旦超时，则会跳出该同步锁代码块","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568895107,"ip_address":"","comment_id":134655,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863854196","product_id":100028001,"comment_content":"请问老师，线程wait区分是由于等待超时重新运行为什么不需要再去重新获取锁呢，我的理解是，wait后锁被释放了，那线程重新恢复运行后无论什么情况下都应该先去获取锁","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467848,"discussion_content":"wait是在锁代码块里面，所以一旦超时，则会跳出该同步锁代码块","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568895107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132214,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568043660,"is_pvip":false,"replies":[{"id":"51139","content":"进程的上下文切换指的是用户态和内核态的相互切换，后续补上进程的上下文切换。 ","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568539773,"ip_address":"","comment_id":132214,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5863010956","product_id":100028001,"comment_content":"这节很不错，不过疑问还是有的<br>感觉老师没有完全讲清楚进程的上下文切换和线程的上下文切换？另外，老师对于什么是进程？什么是线程？他们之间的区别与联系也是没有讲的比较细致？这两个概念非常重要，不过能通俗易懂的讲明白的不多。另外，不管进程还是线程我认为若想被CPU执行，少不了要进入内核态。进进出出比较费劲但又不得不进，那就减少进进出出的次数，少进为妙，少进的方法就是少触发那些进进出出的条件。比如：减少锁持有时间，减少锁粒度，少触发锁竞争，减少FULL GC，减少IO阻塞，创建合适的线程数等等。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466824,"discussion_content":"进程的上下文切换指的是用户态和内核态的相互切换，后续补上进程的上下文切换。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568539773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":18072,"discussion_content":"你评论错章节了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569001012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107253,"user_name":"undifined","can_delete":false,"product_type":"c1","uid":1068920,"ip_address":"","ucode":"449CB4CD2DC089","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/78/c3d8ecb0.jpg","comment_is_top":false,"comment_ctime":1561508772,"is_pvip":false,"replies":[{"id":"38804","content":"notify()可以结合wait（long）方法使用，解决某些没有通知的线程被通知不到的问题","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561512160,"ip_address":"","comment_id":107253,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5856476068","product_id":100028001,"comment_content":"老师，在并发编程那个专栏第 6 讲中老师提到：notify() 是会随机地通知等待队列中的一个线程，而 notifyAll() 会通知等待队列中的所有线程；即使使用 notifyAll()，也只有一个线程能够进入临界区；但是 notify() 的风险在于可能导致某些线程永远不会被通知到；所以除非有特殊考虑，否则尽量使用notifyAll() <br><br>如果现在又考虑到锁，应该怎么做选择","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455439,"discussion_content":"notify()可以结合wait（long）方法使用，解决某些没有通知的线程被通知不到的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561512160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107026,"user_name":"欧星星","can_delete":false,"product_type":"c1","uid":1014347,"ip_address":"","ucode":"56365442E231A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4b/1a7b36ab.jpg","comment_is_top":false,"comment_ctime":1561440391,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5856407687","product_id":100028001,"comment_content":"sync在使用重量级锁的时候会有上下文切换，lock由于内部是Java实现，锁的等待是基于park来的，所以在lock中只会有线程切换带来的CPU上下文切换，没有锁竞争的上下文切换，比sync少一次CPU上下文切换","like_count":1},{"had_liked":false,"id":106936,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1561426336,"is_pvip":false,"replies":[{"id":"38849","content":"g1只是减少，不能避免哦。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561519018,"ip_address":"","comment_id":106936,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5856393632","product_id":100028001,"comment_content":"g1并行垃圾回收。不一定会上下文切换吧。至于上下文切换这个，java还有信号量的实现。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455290,"discussion_content":"g1只是减少，不能避免哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561519018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350884,"user_name":"杯莫停","can_delete":false,"product_type":"c1","uid":1759325,"ip_address":"","ucode":"4FA1D5CBBEF702","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","comment_is_top":false,"comment_ctime":1657278762,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657278762","product_id":100028001,"comment_content":"notify和notifyall各有各的好处，用notify有可能造成线程姬饥饿。","like_count":0},{"had_liked":false,"id":349218,"user_name":"keep_it_real","can_delete":false,"product_type":"c1","uid":2055554,"ip_address":"","ucode":"F5057CAF752FF3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5d/82/81b2ba91.jpg","comment_is_top":false,"comment_ctime":1655807197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655807197","product_id":100028001,"comment_content":"频繁IO就是诱因，频繁的数据库操作，各种拷贝，都是大量的上线文切换。","like_count":0},{"had_liked":false,"id":345716,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1652522009,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652522009","product_id":100028001,"comment_content":"争议点<br><br>文中说到Object.notify() 替代Object.notifyAll()。 因为 Object.notify() 只会唤醒指定线程，不会过早地唤醒其它未满足需求的阻塞线程，所以可以减少相应的上下文切换。<br><br>但是，Object.notify() 是会随机地通知等待队列中的一个线程，而 Object.notifyAll() 会通知等待队列中的所有线程。从感觉上来讲，应该是 notify() 更好一些，因为即便通知所有线程，也只有一个线程能够进入临界区。但那所谓的感觉往往都蕴藏着风险，实际上使用 notify() 也很有风险，它的风险在于可能导致某些线程永远不会被通知到（此观点来源于极客时间另一个专栏）。<br><br>希望老师解惑","like_count":0},{"had_liked":false,"id":313350,"user_name":"Jing","can_delete":false,"product_type":"c1","uid":2748637,"ip_address":"","ucode":"D06AC36B7DFC74","user_header":"https://static001.geekbang.org/account/avatar/00/29/f0/dd/62895468.jpg","comment_is_top":false,"comment_ctime":1632385675,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632385675","product_id":100028001,"comment_content":"vector可以换成ArrayList吗","like_count":0},{"had_liked":false,"id":241727,"user_name":"放不下荣华富贵","can_delete":false,"product_type":"c1","uid":2053679,"ip_address":"","ucode":"9FE29C22B9ABE3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/56/2f/4518f8e1.jpg","comment_is_top":false,"comment_ctime":1597402979,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597402979","product_id":100028001,"comment_content":"例子中，如果不是用 Vector ，而是arrayList，应该会出现并发问题的吧","like_count":0},{"had_liked":false,"id":240953,"user_name":"姚文龙","can_delete":false,"product_type":"c1","uid":1913434,"ip_address":"","ucode":"D36C9EC8EAFAAD","user_header":"","comment_is_top":false,"comment_ctime":1597131757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597131757","product_id":100028001,"comment_content":"notify()唤醒的指定线程如果发生异常，是不是会造成死锁呢？","like_count":0},{"had_liked":false,"id":237204,"user_name":"Gavin","can_delete":false,"product_type":"c1","uid":1616970,"ip_address":"","ucode":"A5735665E303FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2UXuSevhia94o9Eky4OfMuSictaldxcqpjGuvRCOcvjIIoVBAENLEZbv2lgwmwC8icK1ZrUcneNtiaeFBV8MT3uzNg/132","comment_is_top":false,"comment_ctime":1595738021,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595738021","product_id":100028001,"comment_content":"这个例子应该不需要使用线程安全的Vector，使用ArrayList就可以了吧！","like_count":0},{"had_liked":false,"id":211188,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1587911754,"is_pvip":false,"replies":[{"id":"78610","content":"阻塞线程再次获取锁时，是通过state以及CAS操作判断，只有没有竞争成功时，才会再次被挂起，这样可以尽量减少上下文切换。具体源码如下：<br>        final void lock() {<br>            if (compareAndSetState(0, 1))<br>                setExclusiveOwnerThread(Thread.currentThread());<br>            else<br>                acquire(1);<br>        }","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1587987848,"ip_address":"","comment_id":211188,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587911754","product_id":100028001,"comment_content":"老师在回复中说：AQS挂起是通过LockSupport中的park进入阻塞状态，这个过程也是存在进程上下文切换的。但被阻塞的线程再次获取锁时，不会产生进程上下文切换。<br>为什么再次获取锁时，不会产生上下文切换，代码里可以看出来吗？<br>","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493216,"discussion_content":"阻塞线程再次获取锁时，是通过state以及CAS操作判断，只有没有竞争成功时，才会再次被挂起，这样可以尽量减少上下文切换。具体源码如下：\n        final void lock() {\n            if (compareAndSetState(0, 1))\n                setExclusiveOwnerThread(Thread.currentThread());\n            else\n                acquire(1);\n        }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587987848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210427,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1587742813,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587742813","product_id":100028001,"comment_content":"调用notify()，可能会唤醒不该唤醒的线程，导致死锁吧。","like_count":0},{"had_liked":false,"id":210046,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1587656625,"is_pvip":false,"replies":[{"id":"78611","content":"指通过CAS获取到锁","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1587988171,"ip_address":"","comment_id":210046,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587656625","product_id":100028001,"comment_content":"在多线程中如果使用了竞争锁，当线程由于等待竞争锁而被阻塞时，JVM 通常会将这个锁挂起，并允许它被交换出去。如果频繁地发生阻塞，CPU 密集型的程序就会发生更多的上下文切换。这个被交换出去是什么意思?","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492925,"discussion_content":"指通过CAS获取到锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587988171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166227,"user_name":"阿杜","can_delete":false,"product_type":"c1","uid":1066705,"ip_address":"","ucode":"349D3572F5ABE7","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/d1/a1ddf49f.jpg","comment_is_top":false,"comment_ctime":1577418576,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577418576","product_id":100028001,"comment_content":"减少上下文切换：1）notify优化，减少notify访问，设置wait时间；2）线程数设置合理；3）减少jvm垃圾回收","like_count":0},{"had_liked":false,"id":137730,"user_name":"vivi","can_delete":false,"product_type":"c1","uid":1213764,"ip_address":"","ucode":"2F0005960F11F8","user_header":"https://wx.qlogo.cn/mmopen/vi_32/TaJVdWvc44qM6ABpA5KUHMGfje0OZ80pIib5AibrY23gf6DZWRibBGkTFI12Aumibga6tgQlM6wUHbBhz3beCk6UIg/132","comment_is_top":false,"comment_ctime":1569832528,"is_pvip":false,"replies":[{"id":"53042","content":"在事务内加，其实这种情况使用乐观锁来锁库存会性能好一些","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569977466,"ip_address":"","comment_id":137730,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569832528","product_id":100028001,"comment_content":"请问，那事物的开启和锁的持有时间该如何权衡？例如我方法里设计到三个不同表的插入更新操作，其中一个是库存表，是该把锁加在事物外面还是在事物中进行库存表的加锁操作","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469234,"discussion_content":"在事务内加，其实这种情况使用乐观锁来锁库存会性能好一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569977466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128615,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1566914313,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1566914313","product_id":100028001,"comment_content":"老师，如果将文中的例子的wait，notify，notifyAll，全部换成Condition的await，signal和signalAll方法。我试了一下，只要把synchronized换成lock锁就可以实现生产10个数据，然后消费10个数据。有两个问题请教您，望老师不吝指教<br>1 .就这个功能来说，直接一对一替换api，有什么需要注意的地方吗?我第一次使用Condition<br>2 .如果生产者await等待超时，再次获取锁的行为，需要怎么做呢?","like_count":0},{"had_liked":false,"id":115616,"user_name":"devin.ou","can_delete":false,"product_type":"c1","uid":1064942,"ip_address":"","ucode":"C9AE50AFC2C194","user_header":"https://static001.geekbang.org/account/avatar/00/10/3f/ee/5ed997a6.jpg","comment_is_top":false,"comment_ctime":1563676030,"is_pvip":false,"replies":[{"id":"43572","content":"你好 devin，在第29讲中讲到了具体的优化。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564452642,"ip_address":"","comment_id":115616,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563676030","product_id":100028001,"comment_content":"老师，能给出wait&#47;notify优发后的代码么","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459192,"discussion_content":"你好 devin，在第29讲中讲到了具体的优化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564452642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113500,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1563034412,"is_pvip":false,"replies":[{"id":"41377","content":"你好DemonLee同学，第一句是偏向锁、轻量级锁、自旋锁以及重量级锁；<br>第22讲中详细讲解了优化垃圾回收的内容，可以跳过去先了解下。<br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563092290,"ip_address":"","comment_id":113500,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1563034412","product_id":100028001,"comment_content":"1.  ‘’在 JDK1.6 中，JVM 将 Synchronized 同步锁分为了偏向锁、轻量级锁、偏向锁以及重量级锁，优化路径也是按照以上顺序进行。‘’<br> 这句话里面有两个偏向锁，后一个是不是“自旋锁”呀<br><br>2. 老师只说了减少垃圾回收频率可以减少上下文切换，没说如何减少回收频率。感觉不是个好问题，算了，我还是先去Google下找答案吧。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458250,"discussion_content":"你好DemonLee同学，第一句是偏向锁、轻量级锁、自旋锁以及重量级锁；\n第22讲中详细讲解了优化垃圾回收的内容，可以跳过去先了解下。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563092290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110111,"user_name":"旭东(Frank)","can_delete":false,"product_type":"c1","uid":1024486,"ip_address":"","ucode":"176FA629800062","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg","comment_is_top":false,"comment_ctime":1562197860,"is_pvip":false,"replies":[{"id":"39950","content":"包括了JDK1.6","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562208442,"ip_address":"","comment_id":110111,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562197860","product_id":100028001,"comment_content":"在 JDK1.6 中，JVM 将 Synchronized 同步锁分为了偏向锁、轻量级锁、偏向锁以及重量级锁，优化路径也是按照以上顺序进行。JIT 编译器在动态编译同步块的时候，也会通过锁消除、锁粗化的方式来优化该同步锁。<br><br>老师，这个只是JDK1.6的优化，还是1.6以后都是这么优化的？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456728,"discussion_content":"包括了JDK1.6","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562208442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109815,"user_name":"奇奇","can_delete":false,"product_type":"c1","uid":1399097,"ip_address":"","ucode":"BC86B0CB55E35A","user_header":"","comment_is_top":false,"comment_ctime":1562116789,"is_pvip":true,"replies":[{"id":"39959","content":"是的，这个循环应该放到锁里面。已修正，谢谢提醒。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562208970,"ip_address":"","comment_id":109815,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562116789","product_id":100028001,"comment_content":"不同时执行remive 但是也会进去执行remove(0)也是不符合语义的","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456586,"discussion_content":"是的，这个循环应该放到锁里面。已修正，谢谢提醒。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562208970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107055,"user_name":"拒绝","can_delete":false,"product_type":"c1","uid":1335155,"ip_address":"","ucode":"CB0264C4D3FE17","user_header":"https://static001.geekbang.org/account/avatar/00/14/5f/73/bb3dc468.jpg","comment_is_top":false,"comment_ctime":1561449159,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561449159","product_id":100028001,"comment_content":"使用notify会带来线程饥饿，该怎样避免？","like_count":0},{"had_liked":false,"id":106954,"user_name":"CRann","can_delete":false,"product_type":"c1","uid":1542500,"ip_address":"","ucode":"45D569C9778BDA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqWicx6gYmNqGYC8V9xo31w9hjsJrZB1fogG6ibBc0KObo2q3n1xndl6BcriahzHKnGvWy3sgCxVlH1w/132","comment_is_top":false,"comment_ctime":1561428792,"is_pvip":false,"replies":[{"id":"38854","content":"可以根据条件来唤醒，例如，当有合适的库存时，依次唤醒其他线程。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561521359,"ip_address":"","comment_id":106954,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561428792","product_id":100028001,"comment_content":"老师，请问一下如果有多个线程wait()的时候notify()怎么唤醒指定线程？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455300,"discussion_content":"可以根据条件来唤醒，例如，当有合适的库存时，依次唤醒其他线程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561521359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106901,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1561423693,"is_pvip":false,"replies":[{"id":"38842","content":"因为notify结合wait使用，可能会导致某些线程没有被唤醒，而处于一直等待状态。这个可以根据自己的具体业务来衡量使用哪一个。<br><br>在15讲中，有提到使用vmstat监测进程上下文切换，以及pidstat监测线程的上下文切换。<br><br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561516895,"ip_address":"","comment_id":106901,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1561423693","product_id":100028001,"comment_content":"怎样监控上下文切换？为什么有的并发书建议用notifyAll而不是notify？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455274,"discussion_content":"因为notify结合wait使用，可能会导致某些线程没有被唤醒，而处于一直等待状态。这个可以根据自己的具体业务来衡量使用哪一个。\n\n在15讲中，有提到使用vmstat监测进程上下文切换，以及pidstat监测线程的上下文切换。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561516895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1224367,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ae/af/985298a8.jpg","nickname":"Michelle","note":"","ucode":"82B82C067F98F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313,"discussion_content":"为什么有的并发书建议用notifyAll而不是notify？\n\n因为notify 是随机通知waitlist中的一个线程，notifyAll是通知waitlist中全部线程，所以有些线程会永远不被通知到。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561443480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}